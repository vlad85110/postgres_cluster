2023-08-01 17:01:33.775 +07 postmaster[295405] LOG:  starting PostgreSQL 13.2 on x86_64-pc-linux-gnu, compiled by gcc (Ubuntu 11.3.0-1ubuntu1~22.04.1) 11.3.0, 64-bit
2023-08-01 17:01:33.775 +07 postmaster[295405] LOG:  listening on Unix socket "/tmp/pg_regress-rSyWwD/.s.PGSQL.64466"
2023-08-01 17:01:33.776 +07 startup[295408] LOG:  database system was shut down at 2023-08-01 17:01:33 +07
2023-08-01 17:01:33.776 +07 postmaster[295405] LOG:  database system is ready to accept connections
2023-08-01 17:01:34.778 +07 checkpointer[295409] LOG:  checkpoint starting: immediate force wait flush-all
2023-08-01 17:01:34.779 +07 checkpointer[295409] LOG:  checkpoint complete: wrote 3 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.001 s, sync=0.001 s, total=0.001 s; sync files=0, longest=0.000 s, average=0.000 s; distance=1 kB, estimate=1 kB
2023-08-01 17:01:34.789 +07 checkpointer[295409] LOG:  checkpoint starting: immediate force wait
2023-08-01 17:01:34.789 +07 checkpointer[295409] LOG:  checkpoint complete: wrote 0 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.001 s, sync=0.001 s, total=0.001 s; sync files=0, longest=0.000 s, average=0.000 s; distance=0 kB, estimate=1 kB
2023-08-01 17:01:34.797 +07 client backend[295450] pg_regress/tablespace ERROR:  unrecognized parameter "some_nonexistent_parameter"
2023-08-01 17:01:34.797 +07 client backend[295450] pg_regress/tablespace STATEMENT:  CREATE TABLESPACE regress_tblspacewith LOCATION '/home/vlad/postgres_cluster/build/src/test/regress/testtablespace' WITH (some_nonexistent_parameter = true);
2023-08-01 17:01:34.798 +07 client backend[295450] pg_regress/tablespace ERROR:  unrecognized parameter "some_nonexistent_parameter"
2023-08-01 17:01:34.798 +07 client backend[295450] pg_regress/tablespace STATEMENT:  ALTER TABLESPACE regress_tblspace SET (some_nonexistent_parameter = true);
2023-08-01 17:01:34.798 +07 client backend[295450] pg_regress/tablespace ERROR:  RESET must not include values for parameters
2023-08-01 17:01:34.798 +07 client backend[295450] pg_regress/tablespace STATEMENT:  ALTER TABLESPACE regress_tblspace RESET (random_page_cost = 2.0);
2023-08-01 17:01:34.807 +07 client backend[295450] pg_regress/tablespace ERROR:  only shared relations can be placed in pg_global tablespace
2023-08-01 17:01:34.807 +07 client backend[295450] pg_regress/tablespace STATEMENT:  CREATE TABLE testschema.part_1 PARTITION OF testschema.part FOR VALUES IN (1);
2023-08-01 17:01:34.808 +07 client backend[295450] pg_regress/tablespace ERROR:  only shared relations can be placed in pg_global tablespace
2023-08-01 17:01:34.808 +07 client backend[295450] pg_regress/tablespace STATEMENT:  CREATE TABLE testschema.part_3 PARTITION OF testschema.part FOR VALUES IN (3);
2023-08-01 17:01:34.809 +07 client backend[295450] pg_regress/tablespace ERROR:  only shared relations can be placed in pg_global tablespace
2023-08-01 17:01:34.809 +07 client backend[295450] pg_regress/tablespace STATEMENT:  CREATE TABLE testschema.part_78 PARTITION OF testschema.part FOR VALUES IN (7, 8)
	  PARTITION BY LIST (a);
2023-08-01 17:01:34.826 +07 client backend[295450] pg_regress/tablespace ERROR:  cannot specify default tablespace for partitioned relations
2023-08-01 17:01:34.826 +07 client backend[295450] pg_regress/tablespace STATEMENT:  CREATE TABLE testschema.dflt (a int PRIMARY KEY) PARTITION BY LIST (a) TABLESPACE pg_default;
2023-08-01 17:01:34.826 +07 client backend[295450] pg_regress/tablespace ERROR:  cannot specify default tablespace for partitioned relations
2023-08-01 17:01:34.826 +07 client backend[295450] pg_regress/tablespace STATEMENT:  CREATE TABLE testschema.dflt (a int PRIMARY KEY USING INDEX TABLESPACE pg_default) PARTITION BY LIST (a);
2023-08-01 17:01:34.826 +07 client backend[295450] pg_regress/tablespace ERROR:  cannot specify default tablespace for partitioned relations
2023-08-01 17:01:34.826 +07 client backend[295450] pg_regress/tablespace STATEMENT:  CREATE TABLE testschema.dflt (a int PRIMARY KEY) PARTITION BY LIST (a) TABLESPACE regress_tblspace;
2023-08-01 17:01:34.826 +07 client backend[295450] pg_regress/tablespace ERROR:  cannot specify default tablespace for partitioned relations
2023-08-01 17:01:34.826 +07 client backend[295450] pg_regress/tablespace STATEMENT:  CREATE TABLE testschema.dflt (a int PRIMARY KEY USING INDEX TABLESPACE regress_tblspace) PARTITION BY LIST (a);
2023-08-01 17:01:34.914 +07 client backend[295450] pg_regress/tablespace ERROR:  only shared relations can be placed in pg_global tablespace
2023-08-01 17:01:34.914 +07 client backend[295450] pg_regress/tablespace STATEMENT:  ALTER INDEX testschema.part_a_idx SET TABLESPACE pg_global;
2023-08-01 17:01:34.914 +07 client backend[295450] pg_regress/tablespace ERROR:  duplicate key value violates unique constraint "anindex"
2023-08-01 17:01:34.914 +07 client backend[295450] pg_regress/tablespace DETAIL:  Key (column1)=(1) already exists.
2023-08-01 17:01:34.914 +07 client backend[295450] pg_regress/tablespace STATEMENT:  INSERT INTO testschema.atable VALUES(1);
2023-08-01 17:01:34.914 +07 client backend[295450] pg_regress/tablespace ERROR:  directory "/no/such/location" does not exist
2023-08-01 17:01:34.914 +07 client backend[295450] pg_regress/tablespace STATEMENT:  CREATE TABLESPACE regress_badspace LOCATION '/no/such/location';
2023-08-01 17:01:34.914 +07 client backend[295450] pg_regress/tablespace ERROR:  tablespace "regress_nosuchspace" does not exist
2023-08-01 17:01:34.914 +07 client backend[295450] pg_regress/tablespace STATEMENT:  CREATE TABLE bar (i int) TABLESPACE regress_nosuchspace;
2023-08-01 17:01:34.914 +07 client backend[295450] pg_regress/tablespace ERROR:  tablespace "regress_tblspace" cannot be dropped because some objects depend on it
2023-08-01 17:01:34.914 +07 client backend[295450] pg_regress/tablespace DETAIL:  tablespace for index testschema.part_a_idx
2023-08-01 17:01:34.914 +07 client backend[295450] pg_regress/tablespace STATEMENT:  DROP TABLESPACE regress_tblspace;
2023-08-01 17:01:34.915 +07 checkpointer[295409] LOG:  checkpoint starting: immediate force wait
2023-08-01 17:01:34.917 +07 checkpointer[295409] LOG:  checkpoint complete: wrote 84 buffers (0.5%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.002 s, sync=0.001 s, total=0.003 s; sync files=0, longest=0.000 s, average=0.000 s; distance=507 kB, estimate=507 kB
2023-08-01 17:01:34.917 +07 client backend[295450] pg_regress/tablespace ERROR:  tablespace "regress_tblspace" is not empty
2023-08-01 17:01:34.917 +07 client backend[295450] pg_regress/tablespace STATEMENT:  DROP TABLESPACE regress_tblspace;
2023-08-01 17:01:34.918 +07 client backend[295450] pg_regress/tablespace ERROR:  permission denied for tablespace regress_tblspace
2023-08-01 17:01:34.918 +07 client backend[295450] pg_regress/tablespace STATEMENT:  CREATE TABLE tablespace_table (i int) TABLESPACE regress_tblspace;
2023-08-01 17:01:34.921 +07 checkpointer[295409] LOG:  checkpoint starting: immediate force wait
2023-08-01 17:01:34.922 +07 checkpointer[295409] LOG:  checkpoint complete: wrote 36 buffers (0.2%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.001 s, sync=0.001 s, total=0.002 s; sync files=0, longest=0.000 s, average=0.000 s; distance=242 kB, estimate=481 kB
2023-08-01 17:01:34.929 +07 client backend[295472] pg_regress/boolean ERROR:  invalid input syntax for type boolean: "test" at character 13
2023-08-01 17:01:34.929 +07 client backend[295472] pg_regress/boolean STATEMENT:  SELECT bool 'test' AS error;
2023-08-01 17:01:34.930 +07 client backend[295472] pg_regress/boolean ERROR:  invalid input syntax for type boolean: "foo" at character 13
2023-08-01 17:01:34.930 +07 client backend[295472] pg_regress/boolean STATEMENT:  SELECT bool 'foo' AS error;
2023-08-01 17:01:34.930 +07 client backend[295472] pg_regress/boolean ERROR:  invalid input syntax for type boolean: "yeah" at character 13
2023-08-01 17:01:34.930 +07 client backend[295472] pg_regress/boolean STATEMENT:  SELECT bool 'yeah' AS error;
2023-08-01 17:01:34.930 +07 client backend[295472] pg_regress/boolean ERROR:  invalid input syntax for type boolean: "nay" at character 13
2023-08-01 17:01:34.930 +07 client backend[295472] pg_regress/boolean STATEMENT:  SELECT bool 'nay' AS error;
2023-08-01 17:01:34.930 +07 client backend[295472] pg_regress/boolean ERROR:  invalid input syntax for type boolean: "o" at character 13
2023-08-01 17:01:34.930 +07 client backend[295472] pg_regress/boolean STATEMENT:  SELECT bool 'o' AS error;
2023-08-01 17:01:34.930 +07 client backend[295472] pg_regress/boolean ERROR:  invalid input syntax for type boolean: "on_" at character 13
2023-08-01 17:01:34.930 +07 client backend[295472] pg_regress/boolean STATEMENT:  SELECT bool 'on_' AS error;
2023-08-01 17:01:34.930 +07 client backend[295472] pg_regress/boolean ERROR:  invalid input syntax for type boolean: "off_" at character 13
2023-08-01 17:01:34.930 +07 client backend[295472] pg_regress/boolean STATEMENT:  SELECT bool 'off_' AS error;
2023-08-01 17:01:34.930 +07 client backend[295472] pg_regress/boolean ERROR:  invalid input syntax for type boolean: "11" at character 13
2023-08-01 17:01:34.930 +07 client backend[295472] pg_regress/boolean STATEMENT:  SELECT bool '11' AS error;
2023-08-01 17:01:34.931 +07 client backend[295472] pg_regress/boolean ERROR:  invalid input syntax for type boolean: "000" at character 13
2023-08-01 17:01:34.931 +07 client backend[295472] pg_regress/boolean STATEMENT:  SELECT bool '000' AS error;
2023-08-01 17:01:34.931 +07 client backend[295472] pg_regress/boolean ERROR:  invalid input syntax for type boolean: "" at character 13
2023-08-01 17:01:34.931 +07 client backend[295472] pg_regress/boolean STATEMENT:  SELECT bool '' AS error;
2023-08-01 17:01:34.931 +07 client backend[295478] pg_regress/varchar ERROR:  value too long for type character varying(1)
2023-08-01 17:01:34.931 +07 client backend[295478] pg_regress/varchar STATEMENT:  INSERT INTO VARCHAR_TBL (f1) VALUES ('cd');
2023-08-01 17:01:34.932 +07 client backend[295479] pg_regress/int4 ERROR:  invalid input syntax for type integer: "34.5" at character 34
2023-08-01 17:01:34.932 +07 client backend[295479] pg_regress/int4 STATEMENT:  INSERT INTO INT4_TBL(f1) VALUES ('34.5');
2023-08-01 17:01:34.932 +07 client backend[295479] pg_regress/int4 ERROR:  value "1000000000000" is out of range for type integer at character 34
2023-08-01 17:01:34.932 +07 client backend[295479] pg_regress/int4 STATEMENT:  INSERT INTO INT4_TBL(f1) VALUES ('1000000000000');
2023-08-01 17:01:34.932 +07 client backend[295479] pg_regress/int4 ERROR:  invalid input syntax for type integer: "asdf" at character 34
2023-08-01 17:01:34.932 +07 client backend[295479] pg_regress/int4 STATEMENT:  INSERT INTO INT4_TBL(f1) VALUES ('asdf');
2023-08-01 17:01:34.932 +07 client backend[295479] pg_regress/int4 ERROR:  invalid input syntax for type integer: "     " at character 34
2023-08-01 17:01:34.932 +07 client backend[295479] pg_regress/int4 STATEMENT:  INSERT INTO INT4_TBL(f1) VALUES ('     ');
2023-08-01 17:01:34.932 +07 client backend[295472] pg_regress/boolean ERROR:  invalid input syntax for type boolean: "  tru e "
2023-08-01 17:01:34.932 +07 client backend[295472] pg_regress/boolean STATEMENT:  SELECT '  tru e '::text::boolean AS invalid;
2023-08-01 17:01:34.932 +07 client backend[295479] pg_regress/int4 ERROR:  invalid input syntax for type integer: "   asdf   " at character 34
2023-08-01 17:01:34.932 +07 client backend[295479] pg_regress/int4 STATEMENT:  INSERT INTO INT4_TBL(f1) VALUES ('   asdf   ');
2023-08-01 17:01:34.932 +07 client backend[295489] pg_regress/bit ERROR:  bit string length 2 does not match type bit(11)
2023-08-01 17:01:34.932 +07 client backend[295489] pg_regress/bit STATEMENT:  INSERT INTO BIT_TABLE VALUES (B'10');
2023-08-01 17:01:34.932 +07 client backend[295472] pg_regress/boolean ERROR:  invalid input syntax for type boolean: ""
2023-08-01 17:01:34.932 +07 client backend[295472] pg_regress/boolean STATEMENT:  SELECT ''::text::boolean AS invalid;
2023-08-01 17:01:34.932 +07 client backend[295479] pg_regress/int4 ERROR:  invalid input syntax for type integer: "- 1234" at character 34
2023-08-01 17:01:34.932 +07 client backend[295479] pg_regress/int4 STATEMENT:  INSERT INTO INT4_TBL(f1) VALUES ('- 1234');
2023-08-01 17:01:34.932 +07 client backend[295479] pg_regress/int4 ERROR:  invalid input syntax for type integer: "123       5" at character 34
2023-08-01 17:01:34.932 +07 client backend[295479] pg_regress/int4 STATEMENT:  INSERT INTO INT4_TBL(f1) VALUES ('123       5');
2023-08-01 17:01:34.932 +07 client backend[295479] pg_regress/int4 ERROR:  invalid input syntax for type integer: "" at character 34
2023-08-01 17:01:34.932 +07 client backend[295479] pg_regress/int4 STATEMENT:  INSERT INTO INT4_TBL(f1) VALUES ('');
2023-08-01 17:01:34.932 +07 client backend[295481] pg_regress/oid ERROR:  invalid input syntax for type oid: "" at character 33
2023-08-01 17:01:34.932 +07 client backend[295481] pg_regress/oid STATEMENT:  INSERT INTO OID_TBL(f1) VALUES ('');
2023-08-01 17:01:34.933 +07 client backend[295481] pg_regress/oid ERROR:  invalid input syntax for type oid: "    " at character 33
2023-08-01 17:01:34.933 +07 client backend[295481] pg_regress/oid STATEMENT:  INSERT INTO OID_TBL(f1) VALUES ('    ');
2023-08-01 17:01:34.933 +07 client backend[295489] pg_regress/bit ERROR:  bit string length 12 does not match type bit(11)
2023-08-01 17:01:34.933 +07 client backend[295489] pg_regress/bit STATEMENT:  INSERT INTO BIT_TABLE VALUES (B'101011111010');
2023-08-01 17:01:34.933 +07 client backend[295481] pg_regress/oid ERROR:  invalid input syntax for type oid: "asdfasd" at character 33
2023-08-01 17:01:34.933 +07 client backend[295481] pg_regress/oid STATEMENT:  INSERT INTO OID_TBL(f1) VALUES ('asdfasd');
2023-08-01 17:01:34.933 +07 client backend[295481] pg_regress/oid ERROR:  invalid input syntax for type oid: "99asdfasd" at character 33
2023-08-01 17:01:34.933 +07 client backend[295481] pg_regress/oid STATEMENT:  INSERT INTO OID_TBL(f1) VALUES ('99asdfasd');
2023-08-01 17:01:34.933 +07 client backend[295481] pg_regress/oid ERROR:  invalid input syntax for type oid: "5    d" at character 33
2023-08-01 17:01:34.933 +07 client backend[295481] pg_regress/oid STATEMENT:  INSERT INTO OID_TBL(f1) VALUES ('5    d');
2023-08-01 17:01:34.933 +07 client backend[295481] pg_regress/oid ERROR:  invalid input syntax for type oid: "    5d" at character 33
2023-08-01 17:01:34.933 +07 client backend[295481] pg_regress/oid STATEMENT:  INSERT INTO OID_TBL(f1) VALUES ('    5d');
2023-08-01 17:01:34.933 +07 client backend[295481] pg_regress/oid ERROR:  invalid input syntax for type oid: "5    5" at character 33
2023-08-01 17:01:34.933 +07 client backend[295481] pg_regress/oid STATEMENT:  INSERT INTO OID_TBL(f1) VALUES ('5    5');
2023-08-01 17:01:34.933 +07 client backend[295481] pg_regress/oid ERROR:  invalid input syntax for type oid: " - 500" at character 33
2023-08-01 17:01:34.933 +07 client backend[295481] pg_regress/oid STATEMENT:  INSERT INTO OID_TBL(f1) VALUES (' - 500');
2023-08-01 17:01:34.933 +07 client backend[295481] pg_regress/oid ERROR:  value "32958209582039852935" is out of range for type oid at character 33
2023-08-01 17:01:34.933 +07 client backend[295481] pg_regress/oid STATEMENT:  INSERT INTO OID_TBL(f1) VALUES ('32958209582039852935');
2023-08-01 17:01:34.933 +07 client backend[295481] pg_regress/oid ERROR:  value "-23582358720398502385" is out of range for type oid at character 33
2023-08-01 17:01:34.933 +07 client backend[295481] pg_regress/oid STATEMENT:  INSERT INTO OID_TBL(f1) VALUES ('-23582358720398502385');
2023-08-01 17:01:34.933 +07 client backend[295482] pg_regress/int8 ERROR:  invalid input syntax for type bigint: "      " at character 34
2023-08-01 17:01:34.933 +07 client backend[295482] pg_regress/int8 STATEMENT:  INSERT INTO INT8_TBL(q1) VALUES ('      ');
2023-08-01 17:01:34.934 +07 client backend[295482] pg_regress/int8 ERROR:  invalid input syntax for type bigint: "xxx" at character 34
2023-08-01 17:01:34.934 +07 client backend[295482] pg_regress/int8 STATEMENT:  INSERT INTO INT8_TBL(q1) VALUES ('xxx');
2023-08-01 17:01:34.934 +07 client backend[295482] pg_regress/int8 ERROR:  value "3908203590239580293850293850329485" is out of range for type bigint at character 34
2023-08-01 17:01:34.934 +07 client backend[295482] pg_regress/int8 STATEMENT:  INSERT INTO INT8_TBL(q1) VALUES ('3908203590239580293850293850329485');
2023-08-01 17:01:34.934 +07 client backend[295482] pg_regress/int8 ERROR:  value "-1204982019841029840928340329840934" is out of range for type bigint at character 34
2023-08-01 17:01:34.934 +07 client backend[295482] pg_regress/int8 STATEMENT:  INSERT INTO INT8_TBL(q1) VALUES ('-1204982019841029840928340329840934');
2023-08-01 17:01:34.934 +07 client backend[295489] pg_regress/bit ERROR:  bit string too long for type bit varying(11)
2023-08-01 17:01:34.934 +07 client backend[295489] pg_regress/bit STATEMENT:  INSERT INTO VARBIT_TABLE VALUES (B'101011111010');
2023-08-01 17:01:34.934 +07 client backend[295477] pg_regress/text ERROR:  function length(integer) does not exist at character 8
2023-08-01 17:01:34.934 +07 client backend[295477] pg_regress/text HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:34.934 +07 client backend[295477] pg_regress/text STATEMENT:  select length(42);
2023-08-01 17:01:34.934 +07 client backend[295482] pg_regress/int8 ERROR:  invalid input syntax for type bigint: "- 123" at character 34
2023-08-01 17:01:34.934 +07 client backend[295482] pg_regress/int8 STATEMENT:  INSERT INTO INT8_TBL(q1) VALUES ('- 123');
2023-08-01 17:01:34.934 +07 client backend[295482] pg_regress/int8 ERROR:  invalid input syntax for type bigint: "  345     5" at character 34
2023-08-01 17:01:34.934 +07 client backend[295482] pg_regress/int8 STATEMENT:  INSERT INTO INT8_TBL(q1) VALUES ('  345     5');
2023-08-01 17:01:34.934 +07 client backend[295482] pg_regress/int8 ERROR:  invalid input syntax for type bigint: "" at character 34
2023-08-01 17:01:34.934 +07 client backend[295482] pg_regress/int8 STATEMENT:  INSERT INTO INT8_TBL(q1) VALUES ('');
2023-08-01 17:01:34.934 +07 client backend[295477] pg_regress/text ERROR:  operator does not exist: integer || numeric at character 10
2023-08-01 17:01:34.934 +07 client backend[295477] pg_regress/text HINT:  No operator matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:34.934 +07 client backend[295477] pg_regress/text STATEMENT:  select 3 || 4.0;
2023-08-01 17:01:34.934 +07 client backend[295480] pg_regress/char ERROR:  value too long for type character(1)
2023-08-01 17:01:34.934 +07 client backend[295480] pg_regress/char STATEMENT:  INSERT INTO CHAR_TBL (f1) VALUES ('cd');
2023-08-01 17:01:34.935 +07 client backend[295487] pg_regress/rangetypes ERROR:  malformed range literal: "" at character 8
2023-08-01 17:01:34.935 +07 client backend[295487] pg_regress/rangetypes DETAIL:  Missing left parenthesis or bracket.
2023-08-01 17:01:34.935 +07 client backend[295487] pg_regress/rangetypes STATEMENT:  select ''::textrange;
2023-08-01 17:01:34.935 +07 client backend[295479] pg_regress/int4 ERROR:  integer out of range
2023-08-01 17:01:34.935 +07 client backend[295479] pg_regress/int4 STATEMENT:  SELECT '' AS five, i.f1, i.f1 * int2 '2' AS x FROM INT4_TBL i;
2023-08-01 17:01:34.935 +07 client backend[295487] pg_regress/rangetypes ERROR:  malformed range literal: "-[a,z)" at character 8
2023-08-01 17:01:34.935 +07 client backend[295487] pg_regress/rangetypes DETAIL:  Missing left parenthesis or bracket.
2023-08-01 17:01:34.935 +07 client backend[295487] pg_regress/rangetypes STATEMENT:  select '-[a,z)'::textrange;
2023-08-01 17:01:34.935 +07 client backend[295487] pg_regress/rangetypes ERROR:  malformed range literal: "[a,z) - " at character 8
2023-08-01 17:01:34.935 +07 client backend[295487] pg_regress/rangetypes DETAIL:  Junk after right parenthesis or bracket.
2023-08-01 17:01:34.935 +07 client backend[295487] pg_regress/rangetypes STATEMENT:  select '[a,z) - '::textrange;
2023-08-01 17:01:34.935 +07 client backend[295487] pg_regress/rangetypes ERROR:  malformed range literal: "(",a)" at character 8
2023-08-01 17:01:34.935 +07 client backend[295487] pg_regress/rangetypes DETAIL:  Unexpected end of input.
2023-08-01 17:01:34.935 +07 client backend[295487] pg_regress/rangetypes STATEMENT:  select '(",a)'::textrange;
2023-08-01 17:01:34.935 +07 client backend[295472] pg_regress/boolean ERROR:  invalid input syntax for type boolean: "XXX" at character 43
2023-08-01 17:01:34.935 +07 client backend[295472] pg_regress/boolean STATEMENT:  INSERT INTO BOOLTBL2 (f1)
	   VALUES (bool 'XXX');
2023-08-01 17:01:34.935 +07 client backend[295491] pg_regress/pg_lsn ERROR:  invalid input syntax for type pg_lsn: "G/0" at character 32
2023-08-01 17:01:34.935 +07 client backend[295491] pg_regress/pg_lsn STATEMENT:  INSERT INTO PG_LSN_TBL VALUES ('G/0');
2023-08-01 17:01:34.935 +07 client backend[295478] pg_regress/varchar ERROR:  value too long for type character varying(4)
2023-08-01 17:01:34.935 +07 client backend[295478] pg_regress/varchar STATEMENT:  INSERT INTO VARCHAR_TBL (f1) VALUES ('abcde');
2023-08-01 17:01:34.935 +07 client backend[295487] pg_regress/rangetypes ERROR:  malformed range literal: "(,,a)" at character 8
2023-08-01 17:01:34.935 +07 client backend[295487] pg_regress/rangetypes DETAIL:  Too many commas.
2023-08-01 17:01:34.935 +07 client backend[295487] pg_regress/rangetypes STATEMENT:  select '(,,a)'::textrange;
2023-08-01 17:01:34.935 +07 client backend[295491] pg_regress/pg_lsn ERROR:  invalid input syntax for type pg_lsn: "-1/0" at character 32
2023-08-01 17:01:34.935 +07 client backend[295491] pg_regress/pg_lsn STATEMENT:  INSERT INTO PG_LSN_TBL VALUES ('-1/0');
2023-08-01 17:01:34.935 +07 client backend[295487] pg_regress/rangetypes ERROR:  malformed range literal: "(),a)" at character 8
2023-08-01 17:01:34.935 +07 client backend[295487] pg_regress/rangetypes DETAIL:  Missing comma after lower bound.
2023-08-01 17:01:34.935 +07 client backend[295487] pg_regress/rangetypes STATEMENT:  select '(),a)'::textrange;
2023-08-01 17:01:34.935 +07 client backend[295491] pg_regress/pg_lsn ERROR:  invalid input syntax for type pg_lsn: " 0/12345678" at character 32
2023-08-01 17:01:34.935 +07 client backend[295491] pg_regress/pg_lsn STATEMENT:  INSERT INTO PG_LSN_TBL VALUES (' 0/12345678');
2023-08-01 17:01:34.935 +07 client backend[295491] pg_regress/pg_lsn ERROR:  invalid input syntax for type pg_lsn: "ABCD/" at character 32
2023-08-01 17:01:34.935 +07 client backend[295491] pg_regress/pg_lsn STATEMENT:  INSERT INTO PG_LSN_TBL VALUES ('ABCD/');
2023-08-01 17:01:34.935 +07 client backend[295487] pg_regress/rangetypes ERROR:  malformed range literal: "(a,))" at character 8
2023-08-01 17:01:34.935 +07 client backend[295487] pg_regress/rangetypes DETAIL:  Junk after right parenthesis or bracket.
2023-08-01 17:01:34.935 +07 client backend[295487] pg_regress/rangetypes STATEMENT:  select '(a,))'::textrange;
2023-08-01 17:01:34.935 +07 client backend[295479] pg_regress/int4 ERROR:  integer out of range
2023-08-01 17:01:34.935 +07 client backend[295479] pg_regress/int4 STATEMENT:  SELECT '' AS five, i.f1, i.f1 * int4 '2' AS x FROM INT4_TBL i;
2023-08-01 17:01:34.935 +07 client backend[295491] pg_regress/pg_lsn ERROR:  invalid input syntax for type pg_lsn: "/ABCD" at character 32
2023-08-01 17:01:34.935 +07 client backend[295491] pg_regress/pg_lsn STATEMENT:  INSERT INTO PG_LSN_TBL VALUES ('/ABCD');
2023-08-01 17:01:34.935 +07 client backend[295487] pg_regress/rangetypes ERROR:  malformed range literal: "(],a)" at character 8
2023-08-01 17:01:34.935 +07 client backend[295487] pg_regress/rangetypes DETAIL:  Missing comma after lower bound.
2023-08-01 17:01:34.935 +07 client backend[295487] pg_regress/rangetypes STATEMENT:  select '(],a)'::textrange;
2023-08-01 17:01:34.935 +07 client backend[295487] pg_regress/rangetypes ERROR:  malformed range literal: "(a,])" at character 8
2023-08-01 17:01:34.935 +07 client backend[295487] pg_regress/rangetypes DETAIL:  Junk after right parenthesis or bracket.
2023-08-01 17:01:34.935 +07 client backend[295487] pg_regress/rangetypes STATEMENT:  select '(a,])'::textrange;
2023-08-01 17:01:34.935 +07 client backend[295487] pg_regress/rangetypes ERROR:  range lower bound must be less than or equal to range upper bound at character 8
2023-08-01 17:01:34.935 +07 client backend[295487] pg_regress/rangetypes STATEMENT:  select '[z,a]'::textrange;
2023-08-01 17:01:34.935 +07 client backend[295479] pg_regress/int4 ERROR:  integer out of range
2023-08-01 17:01:34.935 +07 client backend[295479] pg_regress/int4 STATEMENT:  SELECT '' AS five, i.f1, i.f1 + int2 '2' AS x FROM INT4_TBL i;
2023-08-01 17:01:34.935 +07 client backend[295489] pg_regress/bit ERROR:  negative substring length not allowed
2023-08-01 17:01:34.935 +07 client backend[295489] pg_regress/bit STATEMENT:  SELECT SUBSTRING('01010101'::bit(8) FROM -10 FOR -2147483646) AS "error";
2023-08-01 17:01:34.935 +07 client backend[295489] pg_regress/bit ERROR:  negative substring length not allowed
2023-08-01 17:01:34.935 +07 client backend[295489] pg_regress/bit STATEMENT:  SELECT SUBSTRING('01010101'::varbit FROM -10 FOR -2147483646) AS "error";
2023-08-01 17:01:34.936 +07 client backend[295479] pg_regress/int4 ERROR:  integer out of range
2023-08-01 17:01:34.936 +07 client backend[295479] pg_regress/int4 STATEMENT:  SELECT '' AS five, i.f1, i.f1 + int4 '2' AS x FROM INT4_TBL i;
2023-08-01 17:01:34.936 +07 client backend[295479] pg_regress/int4 ERROR:  integer out of range
2023-08-01 17:01:34.936 +07 client backend[295479] pg_regress/int4 STATEMENT:  SELECT '' AS five, i.f1, i.f1 - int2 '2' AS x FROM INT4_TBL i;
2023-08-01 17:01:34.936 +07 client backend[295477] pg_regress/text ERROR:  VARIADIC argument must be an array at character 32
2023-08-01 17:01:34.936 +07 client backend[295477] pg_regress/text STATEMENT:  select concat_ws(',', variadic 10);
2023-08-01 17:01:34.936 +07 client backend[295479] pg_regress/int4 ERROR:  integer out of range
2023-08-01 17:01:34.936 +07 client backend[295479] pg_regress/int4 STATEMENT:  SELECT '' AS five, i.f1, i.f1 - int4 '2' AS x FROM INT4_TBL i;
2023-08-01 17:01:34.936 +07 client backend[295477] pg_regress/text ERROR:  too few arguments for format()
2023-08-01 17:01:34.936 +07 client backend[295477] pg_regress/text STATEMENT:  select format('Hello %s %s', 'World');
2023-08-01 17:01:34.936 +07 client backend[295477] pg_regress/text ERROR:  too few arguments for format()
2023-08-01 17:01:34.936 +07 client backend[295477] pg_regress/text STATEMENT:  select format('Hello %s');
2023-08-01 17:01:34.937 +07 client backend[295477] pg_regress/text ERROR:  unrecognized format() type specifier "x"
2023-08-01 17:01:34.937 +07 client backend[295477] pg_regress/text HINT:  For a single "%" use "%%".
2023-08-01 17:01:34.937 +07 client backend[295477] pg_regress/text STATEMENT:  select format('Hello %x', 20);
2023-08-01 17:01:34.937 +07 client backend[295475] pg_regress/int2 ERROR:  invalid input syntax for type smallint: "34.5" at character 34
2023-08-01 17:01:34.937 +07 client backend[295475] pg_regress/int2 STATEMENT:  INSERT INTO INT2_TBL(f1) VALUES ('34.5');
2023-08-01 17:01:34.937 +07 client backend[295480] pg_regress/char ERROR:  value too long for type character(4)
2023-08-01 17:01:34.937 +07 client backend[295480] pg_regress/char STATEMENT:  INSERT INTO CHAR_TBL (f1) VALUES ('abcde');
2023-08-01 17:01:34.937 +07 client backend[295475] pg_regress/int2 ERROR:  value "100000" is out of range for type smallint at character 34
2023-08-01 17:01:34.937 +07 client backend[295475] pg_regress/int2 STATEMENT:  INSERT INTO INT2_TBL(f1) VALUES ('100000');
2023-08-01 17:01:34.937 +07 client backend[295475] pg_regress/int2 ERROR:  invalid input syntax for type smallint: "asdf" at character 34
2023-08-01 17:01:34.937 +07 client backend[295475] pg_regress/int2 STATEMENT:  INSERT INTO INT2_TBL(f1) VALUES ('asdf');
2023-08-01 17:01:34.937 +07 client backend[295477] pg_regress/text ERROR:  null values cannot be formatted as an SQL identifier
2023-08-01 17:01:34.937 +07 client backend[295477] pg_regress/text STATEMENT:  select format('INSERT INTO %I VALUES(%L,%L)', NULL, 10, 'Hello');
2023-08-01 17:01:34.937 +07 client backend[295475] pg_regress/int2 ERROR:  invalid input syntax for type smallint: "    " at character 34
2023-08-01 17:01:34.937 +07 client backend[295475] pg_regress/int2 STATEMENT:  INSERT INTO INT2_TBL(f1) VALUES ('    ');
2023-08-01 17:01:34.937 +07 client backend[295475] pg_regress/int2 ERROR:  invalid input syntax for type smallint: "- 1234" at character 34
2023-08-01 17:01:34.937 +07 client backend[295475] pg_regress/int2 STATEMENT:  INSERT INTO INT2_TBL(f1) VALUES ('- 1234');
2023-08-01 17:01:34.937 +07 client backend[295475] pg_regress/int2 ERROR:  invalid input syntax for type smallint: "4 444" at character 34
2023-08-01 17:01:34.937 +07 client backend[295475] pg_regress/int2 STATEMENT:  INSERT INTO INT2_TBL(f1) VALUES ('4 444');
2023-08-01 17:01:34.937 +07 client backend[295475] pg_regress/int2 ERROR:  invalid input syntax for type smallint: "123 dt" at character 34
2023-08-01 17:01:34.937 +07 client backend[295475] pg_regress/int2 STATEMENT:  INSERT INTO INT2_TBL(f1) VALUES ('123 dt');
2023-08-01 17:01:34.937 +07 client backend[295477] pg_regress/text ERROR:  too few arguments for format()
2023-08-01 17:01:34.937 +07 client backend[295477] pg_regress/text STATEMENT:  select format('%1$s %4$s', 1, 2, 3);
2023-08-01 17:01:34.937 +07 client backend[295475] pg_regress/int2 ERROR:  invalid input syntax for type smallint: "" at character 34
2023-08-01 17:01:34.937 +07 client backend[295475] pg_regress/int2 STATEMENT:  INSERT INTO INT2_TBL(f1) VALUES ('');
2023-08-01 17:01:34.937 +07 client backend[295477] pg_regress/text ERROR:  too few arguments for format()
2023-08-01 17:01:34.937 +07 client backend[295477] pg_regress/text STATEMENT:  select format('%1$s %13$s', 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12);
2023-08-01 17:01:34.937 +07 client backend[295477] pg_regress/text ERROR:  format specifies argument 0, but arguments are numbered from 1
2023-08-01 17:01:34.937 +07 client backend[295477] pg_regress/text STATEMENT:  select format('%0$s', 'Hello');
2023-08-01 17:01:34.937 +07 client backend[295477] pg_regress/text ERROR:  format specifies argument 0, but arguments are numbered from 1
2023-08-01 17:01:34.937 +07 client backend[295477] pg_regress/text STATEMENT:  select format('%*0$s', 'Hello');
2023-08-01 17:01:34.937 +07 client backend[295477] pg_regress/text ERROR:  unterminated format() type specifier
2023-08-01 17:01:34.937 +07 client backend[295477] pg_regress/text HINT:  For a single "%" use "%%".
2023-08-01 17:01:34.937 +07 client backend[295477] pg_regress/text STATEMENT:  select format('%1$', 1);
2023-08-01 17:01:34.937 +07 client backend[295477] pg_regress/text ERROR:  unterminated format() type specifier
2023-08-01 17:01:34.937 +07 client backend[295477] pg_regress/text HINT:  For a single "%" use "%%".
2023-08-01 17:01:34.937 +07 client backend[295477] pg_regress/text STATEMENT:  select format('%1$1', 1);
2023-08-01 17:01:34.938 +07 client backend[295479] pg_regress/int4 ERROR:  integer out of range
2023-08-01 17:01:34.938 +07 client backend[295479] pg_regress/int4 STATEMENT:  SELECT (-2147483648)::int4 * (-1)::int4;
2023-08-01 17:01:34.938 +07 client backend[295479] pg_regress/int4 ERROR:  integer out of range
2023-08-01 17:01:34.938 +07 client backend[295479] pg_regress/int4 STATEMENT:  SELECT (-2147483648)::int4 / (-1)::int4;
2023-08-01 17:01:34.938 +07 client backend[295485] pg_regress/enum ERROR:  invalid input value for enum rainbow: "mauve" at character 8
2023-08-01 17:01:34.938 +07 client backend[295485] pg_regress/enum STATEMENT:  SELECT 'mauve'::rainbow;
2023-08-01 17:01:34.938 +07 client backend[295479] pg_regress/int4 ERROR:  integer out of range
2023-08-01 17:01:34.938 +07 client backend[295479] pg_regress/int4 STATEMENT:  SELECT (-2147483648)::int4 * (-1)::int2;
2023-08-01 17:01:34.938 +07 client backend[295479] pg_regress/int4 ERROR:  integer out of range
2023-08-01 17:01:34.938 +07 client backend[295479] pg_regress/int4 STATEMENT:  SELECT (-2147483648)::int4 / (-1)::int2;
2023-08-01 17:01:34.939 +07 client backend[295482] pg_regress/int8 ERROR:  bigint out of range
2023-08-01 17:01:34.939 +07 client backend[295482] pg_regress/int8 STATEMENT:  SELECT '' AS three, q1, q2, q1 * q2 AS multiply FROM INT8_TBL;
2023-08-01 17:01:34.939 +07 client backend[295479] pg_regress/int4 ERROR:  integer out of range
2023-08-01 17:01:34.939 +07 client backend[295479] pg_regress/int4 STATEMENT:  SELECT gcd((-2147483648)::int4, 0::int4);
2023-08-01 17:01:34.939 +07 client backend[295479] pg_regress/int4 ERROR:  integer out of range
2023-08-01 17:01:34.939 +07 client backend[295479] pg_regress/int4 STATEMENT:  SELECT gcd((-2147483648)::int4, (-2147483648)::int4);
2023-08-01 17:01:34.939 +07 client backend[295475] pg_regress/int2 ERROR:  smallint out of range
2023-08-01 17:01:34.939 +07 client backend[295475] pg_regress/int2 STATEMENT:  SELECT '' AS five, i.f1, i.f1 * int2 '2' AS x FROM INT2_TBL i;
2023-08-01 17:01:34.939 +07 client backend[295479] pg_regress/int4 ERROR:  integer out of range
2023-08-01 17:01:34.939 +07 client backend[295479] pg_regress/int4 STATEMENT:  SELECT lcm((-2147483648)::int4, 1::int4);
2023-08-01 17:01:34.939 +07 client backend[295479] pg_regress/int4 ERROR:  integer out of range
2023-08-01 17:01:34.939 +07 client backend[295479] pg_regress/int4 STATEMENT:  SELECT lcm(2147483647::int4, 2147483646::int4);
2023-08-01 17:01:34.940 +07 client backend[295475] pg_regress/int2 ERROR:  smallint out of range
2023-08-01 17:01:34.940 +07 client backend[295475] pg_regress/int2 STATEMENT:  SELECT '' AS five, i.f1, i.f1 + int2 '2' AS x FROM INT2_TBL i;
2023-08-01 17:01:34.940 +07 client backend[295475] pg_regress/int2 ERROR:  smallint out of range
2023-08-01 17:01:34.940 +07 client backend[295475] pg_regress/int2 STATEMENT:  SELECT '' AS five, i.f1, i.f1 - int2 '2' AS x FROM INT2_TBL i;
2023-08-01 17:01:34.940 +07 client backend[295485] pg_regress/enum ERROR:  invalid enum label "plutoplutoplutoplutoplutoplutoplutoplutoplutoplutoplutoplutoplutopluto"
2023-08-01 17:01:34.940 +07 client backend[295485] pg_regress/enum DETAIL:  Labels must be 63 characters or less.
2023-08-01 17:01:34.940 +07 client backend[295485] pg_regress/enum STATEMENT:  ALTER TYPE planets ADD VALUE
	  'plutoplutoplutoplutoplutoplutoplutoplutoplutoplutoplutoplutoplutopluto';
2023-08-01 17:01:34.940 +07 client backend[295485] pg_regress/enum ERROR:  "zeus" is not an existing enum label
2023-08-01 17:01:34.940 +07 client backend[295485] pg_regress/enum STATEMENT:  ALTER TYPE planets ADD VALUE 'pluto' AFTER 'zeus';
2023-08-01 17:01:34.940 +07 client backend[295485] pg_regress/enum ERROR:  enum label "mercury" already exists
2023-08-01 17:01:34.940 +07 client backend[295485] pg_regress/enum STATEMENT:  ALTER TYPE planets ADD VALUE 'mercury';
2023-08-01 17:01:34.941 +07 client backend[295475] pg_regress/int2 ERROR:  smallint out of range
2023-08-01 17:01:34.941 +07 client backend[295475] pg_regress/int2 STATEMENT:  SELECT (-32768)::int2 * (-1)::int2;
2023-08-01 17:01:34.941 +07 client backend[295475] pg_regress/int2 ERROR:  smallint out of range
2023-08-01 17:01:34.941 +07 client backend[295475] pg_regress/int2 STATEMENT:  SELECT (-32768)::int2 / (-1)::int2;
2023-08-01 17:01:34.942 +07 client backend[295488] pg_regress/uuid ERROR:  invalid input syntax for type uuid: "11111111-1111-1111-1111-111111111111F" at character 38
2023-08-01 17:01:34.942 +07 client backend[295488] pg_regress/uuid STATEMENT:  INSERT INTO guid1(guid_field) VALUES('11111111-1111-1111-1111-111111111111F');
2023-08-01 17:01:34.942 +07 client backend[295488] pg_regress/uuid ERROR:  invalid input syntax for type uuid: "{11111111-1111-1111-1111-11111111111}" at character 38
2023-08-01 17:01:34.942 +07 client backend[295488] pg_regress/uuid STATEMENT:  INSERT INTO guid1(guid_field) VALUES('{11111111-1111-1111-1111-11111111111}');
2023-08-01 17:01:34.942 +07 client backend[295488] pg_regress/uuid ERROR:  invalid input syntax for type uuid: "111-11111-1111-1111-1111-111111111111" at character 38
2023-08-01 17:01:34.942 +07 client backend[295488] pg_regress/uuid STATEMENT:  INSERT INTO guid1(guid_field) VALUES('111-11111-1111-1111-1111-111111111111');
2023-08-01 17:01:34.942 +07 client backend[295488] pg_regress/uuid ERROR:  invalid input syntax for type uuid: "{22222222-2222-2222-2222-222222222222 " at character 38
2023-08-01 17:01:34.942 +07 client backend[295488] pg_regress/uuid STATEMENT:  INSERT INTO guid1(guid_field) VALUES('{22222222-2222-2222-2222-222222222222 ');
2023-08-01 17:01:34.942 +07 client backend[295488] pg_regress/uuid ERROR:  invalid input syntax for type uuid: "11111111-1111-1111-G111-111111111111" at character 38
2023-08-01 17:01:34.942 +07 client backend[295488] pg_regress/uuid STATEMENT:  INSERT INTO guid1(guid_field) VALUES('11111111-1111-1111-G111-111111111111');
2023-08-01 17:01:34.942 +07 client backend[295488] pg_regress/uuid ERROR:  invalid input syntax for type uuid: "11+11111-1111-1111-1111-111111111111" at character 38
2023-08-01 17:01:34.942 +07 client backend[295488] pg_regress/uuid STATEMENT:  INSERT INTO guid1(guid_field) VALUES('11+11111-1111-1111-1111-111111111111');
2023-08-01 17:01:34.943 +07 client backend[295489] pg_regress/bit ERROR:  cannot AND bit strings of different sizes
2023-08-01 17:01:34.943 +07 client backend[295489] pg_regress/bit STATEMENT:  select B'001' & B'10';
2023-08-01 17:01:34.943 +07 client backend[295489] pg_regress/bit ERROR:  cannot OR bit strings of different sizes
2023-08-01 17:01:34.943 +07 client backend[295489] pg_regress/bit STATEMENT:  select B'0111' | B'011';
2023-08-01 17:01:34.943 +07 client backend[295489] pg_regress/bit ERROR:  cannot XOR bit strings of different sizes
2023-08-01 17:01:34.943 +07 client backend[295489] pg_regress/bit STATEMENT:  select B'0010' # B'011101';
2023-08-01 17:01:34.943 +07 client backend[295482] pg_regress/int8 ERROR:  value "-9223372036854775809" is out of range for type bigint at character 8
2023-08-01 17:01:34.943 +07 client backend[295482] pg_regress/int8 STATEMENT:  select '-9223372036854775809'::int8;
2023-08-01 17:01:34.944 +07 client backend[295482] pg_regress/int8 ERROR:  value "9223372036854775808" is out of range for type bigint at character 8
2023-08-01 17:01:34.944 +07 client backend[295482] pg_regress/int8 STATEMENT:  select '9223372036854775808'::int8;
2023-08-01 17:01:34.944 +07 client backend[295482] pg_regress/int8 ERROR:  bigint out of range
2023-08-01 17:01:34.944 +07 client backend[295482] pg_regress/int8 STATEMENT:  select -('-9223372036854775808'::int8);
2023-08-01 17:01:34.944 +07 client backend[295482] pg_regress/int8 ERROR:  bigint out of range
2023-08-01 17:01:34.944 +07 client backend[295482] pg_regress/int8 STATEMENT:  select '9223372036854775800'::int8 + '9223372036854775800'::int8;
2023-08-01 17:01:34.944 +07 client backend[295482] pg_regress/int8 ERROR:  bigint out of range
2023-08-01 17:01:34.944 +07 client backend[295482] pg_regress/int8 STATEMENT:  select '-9223372036854775800'::int8 + '-9223372036854775800'::int8;
2023-08-01 17:01:34.944 +07 client backend[295482] pg_regress/int8 ERROR:  bigint out of range
2023-08-01 17:01:34.944 +07 client backend[295482] pg_regress/int8 STATEMENT:  select '9223372036854775800'::int8 - '-9223372036854775800'::int8;
2023-08-01 17:01:34.944 +07 client backend[295482] pg_regress/int8 ERROR:  bigint out of range
2023-08-01 17:01:34.944 +07 client backend[295482] pg_regress/int8 STATEMENT:  select '-9223372036854775800'::int8 - '9223372036854775800'::int8;
2023-08-01 17:01:34.944 +07 client backend[295482] pg_regress/int8 ERROR:  bigint out of range
2023-08-01 17:01:34.944 +07 client backend[295482] pg_regress/int8 STATEMENT:  select '9223372036854775800'::int8 * '9223372036854775800'::int8;
2023-08-01 17:01:34.944 +07 client backend[295482] pg_regress/int8 ERROR:  division by zero
2023-08-01 17:01:34.944 +07 client backend[295482] pg_regress/int8 STATEMENT:  select '9223372036854775800'::int8 / '0'::int8;
2023-08-01 17:01:34.944 +07 client backend[295482] pg_regress/int8 ERROR:  division by zero
2023-08-01 17:01:34.944 +07 client backend[295482] pg_regress/int8 STATEMENT:  select '9223372036854775800'::int8 % '0'::int8;
2023-08-01 17:01:34.944 +07 client backend[295482] pg_regress/int8 ERROR:  bigint out of range
2023-08-01 17:01:34.944 +07 client backend[295482] pg_regress/int8 STATEMENT:  select abs('-9223372036854775808'::int8);
2023-08-01 17:01:34.944 +07 client backend[295482] pg_regress/int8 ERROR:  bigint out of range
2023-08-01 17:01:34.944 +07 client backend[295482] pg_regress/int8 STATEMENT:  select '9223372036854775800'::int8 + '100'::int4;
2023-08-01 17:01:34.944 +07 client backend[295482] pg_regress/int8 ERROR:  bigint out of range
2023-08-01 17:01:34.944 +07 client backend[295482] pg_regress/int8 STATEMENT:  select '-9223372036854775800'::int8 - '100'::int4;
2023-08-01 17:01:34.944 +07 client backend[295482] pg_regress/int8 ERROR:  bigint out of range
2023-08-01 17:01:34.944 +07 client backend[295482] pg_regress/int8 STATEMENT:  select '9223372036854775800'::int8 * '100'::int4;
2023-08-01 17:01:34.944 +07 client backend[295482] pg_regress/int8 ERROR:  bigint out of range
2023-08-01 17:01:34.944 +07 client backend[295482] pg_regress/int8 STATEMENT:  select '100'::int4 + '9223372036854775800'::int8;
2023-08-01 17:01:34.944 +07 client backend[295482] pg_regress/int8 ERROR:  bigint out of range
2023-08-01 17:01:34.944 +07 client backend[295482] pg_regress/int8 STATEMENT:  select '-100'::int4 - '9223372036854775800'::int8;
2023-08-01 17:01:34.945 +07 client backend[295482] pg_regress/int8 ERROR:  bigint out of range
2023-08-01 17:01:34.945 +07 client backend[295482] pg_regress/int8 STATEMENT:  select '100'::int4 * '9223372036854775800'::int8;
2023-08-01 17:01:34.945 +07 client backend[295482] pg_regress/int8 ERROR:  bigint out of range
2023-08-01 17:01:34.945 +07 client backend[295482] pg_regress/int8 STATEMENT:  select '9223372036854775800'::int8 + '100'::int2;
2023-08-01 17:01:34.945 +07 client backend[295476] pg_regress/name ERROR:  string is not a valid identifier: "foo.boo[]"
2023-08-01 17:01:34.945 +07 client backend[295476] pg_regress/name STATEMENT:  SELECT parse_ident('foo.boo[]');
2023-08-01 17:01:34.945 +07 client backend[295482] pg_regress/int8 ERROR:  bigint out of range
2023-08-01 17:01:34.945 +07 client backend[295482] pg_regress/int8 STATEMENT:  select '-9223372036854775800'::int8 - '100'::int2;
2023-08-01 17:01:34.945 +07 client backend[295482] pg_regress/int8 ERROR:  bigint out of range
2023-08-01 17:01:34.945 +07 client backend[295482] pg_regress/int8 STATEMENT:  select '9223372036854775800'::int8 * '100'::int2;
2023-08-01 17:01:34.945 +07 client backend[295482] pg_regress/int8 ERROR:  division by zero
2023-08-01 17:01:34.945 +07 client backend[295482] pg_regress/int8 STATEMENT:  select '-9223372036854775808'::int8 / '0'::int2;
2023-08-01 17:01:34.945 +07 client backend[295476] pg_regress/name ERROR:  string is not a valid identifier: " "
2023-08-01 17:01:34.945 +07 client backend[295476] pg_regress/name STATEMENT:  SELECT parse_ident(' ');
2023-08-01 17:01:34.945 +07 client backend[295482] pg_regress/int8 ERROR:  bigint out of range
2023-08-01 17:01:34.945 +07 client backend[295482] pg_regress/int8 STATEMENT:  select '100'::int2 + '9223372036854775800'::int8;
2023-08-01 17:01:34.945 +07 client backend[295476] pg_regress/name ERROR:  string is not a valid identifier: " .aaa"
2023-08-01 17:01:34.945 +07 client backend[295476] pg_regress/name DETAIL:  No valid identifier before ".".
2023-08-01 17:01:34.945 +07 client backend[295476] pg_regress/name STATEMENT:  SELECT parse_ident(' .aaa');
2023-08-01 17:01:34.945 +07 client backend[295476] pg_regress/name ERROR:  string is not a valid identifier: " aaa . "
2023-08-01 17:01:34.945 +07 client backend[295476] pg_regress/name DETAIL:  No valid identifier after ".".
2023-08-01 17:01:34.945 +07 client backend[295476] pg_regress/name STATEMENT:  SELECT parse_ident(' aaa . ');
2023-08-01 17:01:34.945 +07 client backend[295482] pg_regress/int8 ERROR:  bigint out of range
2023-08-01 17:01:34.945 +07 client backend[295482] pg_regress/int8 STATEMENT:  select '-100'::int2 - '9223372036854775800'::int8;
2023-08-01 17:01:34.945 +07 client backend[295476] pg_regress/name ERROR:  string is not a valid identifier: "aaa.a%b"
2023-08-01 17:01:34.945 +07 client backend[295476] pg_regress/name STATEMENT:  SELECT parse_ident('aaa.a%b');
2023-08-01 17:01:34.945 +07 client backend[295482] pg_regress/int8 ERROR:  bigint out of range
2023-08-01 17:01:34.945 +07 client backend[295482] pg_regress/int8 STATEMENT:  select '100'::int2 * '9223372036854775800'::int8;
2023-08-01 17:01:34.945 +07 client backend[295476] pg_regress/name ERROR:  string is not a valid identifier: "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
2023-08-01 17:01:34.945 +07 client backend[295476] pg_regress/name STATEMENT:  SELECT parse_ident(E'X\rXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX');
2023-08-01 17:01:34.945 +07 client backend[295482] pg_regress/int8 ERROR:  division by zero
2023-08-01 17:01:34.945 +07 client backend[295482] pg_regress/int8 STATEMENT:  select '100'::int2 / '0'::int8;
2023-08-01 17:01:34.945 +07 client backend[295488] pg_regress/uuid ERROR:  duplicate key value violates unique constraint "guid1_unique_btree"
2023-08-01 17:01:34.945 +07 client backend[295488] pg_regress/uuid DETAIL:  Key (guid_field)=(11111111-1111-1111-1111-111111111111) already exists.
2023-08-01 17:01:34.945 +07 client backend[295488] pg_regress/uuid STATEMENT:  INSERT INTO guid1(guid_field) VALUES('11111111-1111-1111-1111-111111111111');
2023-08-01 17:01:34.945 +07 client backend[295487] pg_regress/rangetypes ERROR:  range lower bound must be less than or equal to range upper bound
2023-08-01 17:01:34.945 +07 client backend[295487] pg_regress/rangetypes STATEMENT:  select numrange(2.0, 1.0);
2023-08-01 17:01:34.945 +07 client backend[295482] pg_regress/int8 ERROR:  integer out of range
2023-08-01 17:01:34.945 +07 client backend[295482] pg_regress/int8 STATEMENT:  SELECT CAST(q1 AS int4) FROM int8_tbl WHERE q2 <> 456;
2023-08-01 17:01:34.945 +07 client backend[295482] pg_regress/int8 ERROR:  smallint out of range
2023-08-01 17:01:34.945 +07 client backend[295482] pg_regress/int8 STATEMENT:  SELECT CAST(q1 AS int2) FROM int8_tbl WHERE q2 <> 456;
2023-08-01 17:01:34.945 +07 client backend[295476] pg_regress/name ERROR:  string is not a valid identifier: ""c".X XXXXXXXXXX"
2023-08-01 17:01:34.945 +07 client backend[295476] pg_regress/name STATEMENT:  SELECT parse_ident(E'"c".X XXXX\002XXXXXX');
2023-08-01 17:01:34.946 +07 client backend[295476] pg_regress/name ERROR:  string is not a valid identifier: "1020"
2023-08-01 17:01:34.946 +07 client backend[295476] pg_regress/name STATEMENT:  SELECT parse_ident('1020');
2023-08-01 17:01:34.946 +07 client backend[295476] pg_regress/name ERROR:  string is not a valid identifier: "10.20"
2023-08-01 17:01:34.946 +07 client backend[295476] pg_regress/name STATEMENT:  SELECT parse_ident('10.20');
2023-08-01 17:01:34.946 +07 client backend[295476] pg_regress/name ERROR:  string is not a valid identifier: "."
2023-08-01 17:01:34.946 +07 client backend[295476] pg_regress/name DETAIL:  No valid identifier before ".".
2023-08-01 17:01:34.946 +07 client backend[295476] pg_regress/name STATEMENT:  SELECT parse_ident('.');
2023-08-01 17:01:34.946 +07 client backend[295476] pg_regress/name ERROR:  string is not a valid identifier: ".1020"
2023-08-01 17:01:34.946 +07 client backend[295476] pg_regress/name DETAIL:  No valid identifier before ".".
2023-08-01 17:01:34.946 +07 client backend[295476] pg_regress/name STATEMENT:  SELECT parse_ident('.1020');
2023-08-01 17:01:34.946 +07 client backend[295476] pg_regress/name ERROR:  string is not a valid identifier: "xxx.1020"
2023-08-01 17:01:34.946 +07 client backend[295476] pg_regress/name DETAIL:  No valid identifier after ".".
2023-08-01 17:01:34.946 +07 client backend[295476] pg_regress/name STATEMENT:  SELECT parse_ident('xxx.1020');
2023-08-01 17:01:34.946 +07 client backend[295482] pg_regress/int8 ERROR:  bigint out of range
2023-08-01 17:01:34.946 +07 client backend[295482] pg_regress/int8 STATEMENT:  SELECT CAST('922337203685477580700.0'::float8 AS int8);
2023-08-01 17:01:34.946 +07 client backend[295482] pg_regress/int8 ERROR:  OID out of range
2023-08-01 17:01:34.946 +07 client backend[295482] pg_regress/int8 STATEMENT:  SELECT CAST(q1 AS oid) FROM INT8_TBL;
2023-08-01 17:01:34.947 +07 client backend[295482] pg_regress/int8 ERROR:  step size cannot equal zero
2023-08-01 17:01:34.947 +07 client backend[295482] pg_regress/int8 STATEMENT:  SELECT * FROM generate_series('+4567890123456789'::int8, '+4567890123456799'::int8, 0);
2023-08-01 17:01:34.947 +07 client backend[295483] pg_regress/money ERROR:  value "123456789012345678" is out of range for type money at character 8
2023-08-01 17:01:34.947 +07 client backend[295483] pg_regress/money STATEMENT:  SELECT '123456789012345678'::money;
2023-08-01 17:01:34.947 +07 client backend[295483] pg_regress/money ERROR:  value "9223372036854775807" is out of range for type money at character 8
2023-08-01 17:01:34.947 +07 client backend[295483] pg_regress/money STATEMENT:  SELECT '9223372036854775807'::money;
2023-08-01 17:01:34.947 +07 client backend[295482] pg_regress/int8 ERROR:  bigint out of range
2023-08-01 17:01:34.947 +07 client backend[295482] pg_regress/int8 STATEMENT:  SELECT (-9223372036854775808)::int8 * (-1)::int8;
2023-08-01 17:01:34.947 +07 client backend[295483] pg_regress/money ERROR:  value "-123456789012345678" is out of range for type money at character 8
2023-08-01 17:01:34.947 +07 client backend[295483] pg_regress/money STATEMENT:  SELECT '-123456789012345678'::money;
2023-08-01 17:01:34.947 +07 client backend[295482] pg_regress/int8 ERROR:  bigint out of range
2023-08-01 17:01:34.947 +07 client backend[295482] pg_regress/int8 STATEMENT:  SELECT (-9223372036854775808)::int8 / (-1)::int8;
2023-08-01 17:01:34.947 +07 client backend[295483] pg_regress/money ERROR:  value "-9223372036854775808" is out of range for type money at character 8
2023-08-01 17:01:34.947 +07 client backend[295483] pg_regress/money STATEMENT:  SELECT '-9223372036854775808'::money;
2023-08-01 17:01:34.948 +07 client backend[295482] pg_regress/int8 ERROR:  bigint out of range
2023-08-01 17:01:34.948 +07 client backend[295482] pg_regress/int8 STATEMENT:  SELECT (-9223372036854775808)::int8 * (-1)::int4;
2023-08-01 17:01:34.948 +07 client backend[295484] pg_regress/float4 ERROR:  "10e70" is out of range for type real at character 36
2023-08-01 17:01:34.948 +07 client backend[295484] pg_regress/float4 STATEMENT:  INSERT INTO FLOAT4_TBL(f1) VALUES ('10e70');
2023-08-01 17:01:34.948 +07 client backend[295482] pg_regress/int8 ERROR:  bigint out of range
2023-08-01 17:01:34.948 +07 client backend[295482] pg_regress/int8 STATEMENT:  SELECT (-9223372036854775808)::int8 / (-1)::int4;
2023-08-01 17:01:34.948 +07 client backend[295484] pg_regress/float4 ERROR:  "-10e70" is out of range for type real at character 36
2023-08-01 17:01:34.948 +07 client backend[295484] pg_regress/float4 STATEMENT:  INSERT INTO FLOAT4_TBL(f1) VALUES ('-10e70');
2023-08-01 17:01:34.948 +07 client backend[295484] pg_regress/float4 ERROR:  "10e-70" is out of range for type real at character 36
2023-08-01 17:01:34.948 +07 client backend[295484] pg_regress/float4 STATEMENT:  INSERT INTO FLOAT4_TBL(f1) VALUES ('10e-70');
2023-08-01 17:01:34.948 +07 client backend[295484] pg_regress/float4 ERROR:  "-10e-70" is out of range for type real at character 36
2023-08-01 17:01:34.948 +07 client backend[295484] pg_regress/float4 STATEMENT:  INSERT INTO FLOAT4_TBL(f1) VALUES ('-10e-70');
2023-08-01 17:01:34.948 +07 client backend[295482] pg_regress/int8 ERROR:  bigint out of range
2023-08-01 17:01:34.948 +07 client backend[295482] pg_regress/int8 STATEMENT:  SELECT (-9223372036854775808)::int8 * (-1)::int2;
2023-08-01 17:01:34.948 +07 client backend[295483] pg_regress/money ERROR:  value "-92233720368547758.09" is out of range for type money at character 8
2023-08-01 17:01:34.948 +07 client backend[295483] pg_regress/money STATEMENT:  SELECT '-92233720368547758.09'::money;
2023-08-01 17:01:34.948 +07 client backend[295482] pg_regress/int8 ERROR:  bigint out of range
2023-08-01 17:01:34.948 +07 client backend[295482] pg_regress/int8 STATEMENT:  SELECT (-9223372036854775808)::int8 / (-1)::int2;
2023-08-01 17:01:34.948 +07 client backend[295484] pg_regress/float4 ERROR:  value out of range: overflow
2023-08-01 17:01:34.948 +07 client backend[295484] pg_regress/float4 STATEMENT:  INSERT INTO FLOAT4_TBL(f1) VALUES ('10e70'::float8);
2023-08-01 17:01:34.948 +07 client backend[295483] pg_regress/money ERROR:  value "92233720368547758.08" is out of range for type money at character 8
2023-08-01 17:01:34.948 +07 client backend[295483] pg_regress/money STATEMENT:  SELECT '92233720368547758.08'::money;
2023-08-01 17:01:34.948 +07 client backend[295487] pg_regress/rangetypes ERROR:  result of range union would not be contiguous
2023-08-01 17:01:34.948 +07 client backend[295487] pg_regress/rangetypes STATEMENT:  select numrange(1.0, 2.0) + numrange(2.5, 3.0);
2023-08-01 17:01:34.948 +07 client backend[295484] pg_regress/float4 ERROR:  value out of range: overflow
2023-08-01 17:01:34.948 +07 client backend[295484] pg_regress/float4 STATEMENT:  INSERT INTO FLOAT4_TBL(f1) VALUES ('-10e70'::float8);
2023-08-01 17:01:34.948 +07 client backend[295483] pg_regress/money ERROR:  value "-92233720368547758.085" is out of range for type money at character 8
2023-08-01 17:01:34.948 +07 client backend[295483] pg_regress/money STATEMENT:  SELECT '-92233720368547758.085'::money;
2023-08-01 17:01:34.948 +07 client backend[295484] pg_regress/float4 ERROR:  value out of range: underflow
2023-08-01 17:01:34.948 +07 client backend[295484] pg_regress/float4 STATEMENT:  INSERT INTO FLOAT4_TBL(f1) VALUES ('10e-70'::float8);
2023-08-01 17:01:34.948 +07 client backend[295483] pg_regress/money ERROR:  value "92233720368547758.075" is out of range for type money at character 8
2023-08-01 17:01:34.948 +07 client backend[295483] pg_regress/money STATEMENT:  SELECT '92233720368547758.075'::money;
2023-08-01 17:01:34.948 +07 client backend[295484] pg_regress/float4 ERROR:  value out of range: underflow
2023-08-01 17:01:34.948 +07 client backend[295484] pg_regress/float4 STATEMENT:  INSERT INTO FLOAT4_TBL(f1) VALUES ('-10e-70'::float8);
2023-08-01 17:01:34.948 +07 client backend[295484] pg_regress/float4 ERROR:  "10e400" is out of range for type real at character 36
2023-08-01 17:01:34.948 +07 client backend[295484] pg_regress/float4 STATEMENT:  INSERT INTO FLOAT4_TBL(f1) VALUES ('10e400');
2023-08-01 17:01:34.948 +07 client backend[295484] pg_regress/float4 ERROR:  "-10e400" is out of range for type real at character 36
2023-08-01 17:01:34.948 +07 client backend[295484] pg_regress/float4 STATEMENT:  INSERT INTO FLOAT4_TBL(f1) VALUES ('-10e400');
2023-08-01 17:01:34.948 +07 client backend[295484] pg_regress/float4 ERROR:  "10e-400" is out of range for type real at character 36
2023-08-01 17:01:34.948 +07 client backend[295484] pg_regress/float4 STATEMENT:  INSERT INTO FLOAT4_TBL(f1) VALUES ('10e-400');
2023-08-01 17:01:34.948 +07 client backend[295484] pg_regress/float4 ERROR:  "-10e-400" is out of range for type real at character 36
2023-08-01 17:01:34.948 +07 client backend[295484] pg_regress/float4 STATEMENT:  INSERT INTO FLOAT4_TBL(f1) VALUES ('-10e-400');
2023-08-01 17:01:34.948 +07 client backend[295484] pg_regress/float4 ERROR:  invalid input syntax for type real: "" at character 36
2023-08-01 17:01:34.948 +07 client backend[295484] pg_regress/float4 STATEMENT:  INSERT INTO FLOAT4_TBL(f1) VALUES ('');
2023-08-01 17:01:34.948 +07 client backend[295484] pg_regress/float4 ERROR:  invalid input syntax for type real: "       " at character 36
2023-08-01 17:01:34.948 +07 client backend[295484] pg_regress/float4 STATEMENT:  INSERT INTO FLOAT4_TBL(f1) VALUES ('       ');
2023-08-01 17:01:34.948 +07 client backend[295484] pg_regress/float4 ERROR:  invalid input syntax for type real: "xyz" at character 36
2023-08-01 17:01:34.948 +07 client backend[295484] pg_regress/float4 STATEMENT:  INSERT INTO FLOAT4_TBL(f1) VALUES ('xyz');
2023-08-01 17:01:34.948 +07 client backend[295493] pg_regress/txid ERROR:  invalid input syntax for type pg_snapshot: "31:12:" at character 8
2023-08-01 17:01:34.948 +07 client backend[295493] pg_regress/txid STATEMENT:  select '31:12:'::txid_snapshot;
2023-08-01 17:01:34.948 +07 client backend[295484] pg_regress/float4 ERROR:  invalid input syntax for type real: "5.0.0" at character 36
2023-08-01 17:01:34.948 +07 client backend[295484] pg_regress/float4 STATEMENT:  INSERT INTO FLOAT4_TBL(f1) VALUES ('5.0.0');
2023-08-01 17:01:34.948 +07 client backend[295493] pg_regress/txid ERROR:  invalid input syntax for type pg_snapshot: "0:1:" at character 8
2023-08-01 17:01:34.948 +07 client backend[295493] pg_regress/txid STATEMENT:  select '0:1:'::txid_snapshot;
2023-08-01 17:01:34.948 +07 client backend[295484] pg_regress/float4 ERROR:  invalid input syntax for type real: "5 . 0" at character 36
2023-08-01 17:01:34.948 +07 client backend[295484] pg_regress/float4 STATEMENT:  INSERT INTO FLOAT4_TBL(f1) VALUES ('5 . 0');
2023-08-01 17:01:34.949 +07 client backend[295493] pg_regress/txid ERROR:  invalid input syntax for type pg_snapshot: "12:13:0" at character 8
2023-08-01 17:01:34.949 +07 client backend[295493] pg_regress/txid STATEMENT:  select '12:13:0'::txid_snapshot;
2023-08-01 17:01:34.949 +07 client backend[295484] pg_regress/float4 ERROR:  invalid input syntax for type real: "5.   0" at character 36
2023-08-01 17:01:34.949 +07 client backend[295484] pg_regress/float4 STATEMENT:  INSERT INTO FLOAT4_TBL(f1) VALUES ('5.   0');
2023-08-01 17:01:34.949 +07 client backend[295493] pg_regress/txid ERROR:  invalid input syntax for type pg_snapshot: "12:16:14,13" at character 8
2023-08-01 17:01:34.949 +07 client backend[295493] pg_regress/txid STATEMENT:  select '12:16:14,13'::txid_snapshot;
2023-08-01 17:01:34.949 +07 client backend[295484] pg_regress/float4 ERROR:  invalid input syntax for type real: "     - 3.0" at character 36
2023-08-01 17:01:34.949 +07 client backend[295484] pg_regress/float4 STATEMENT:  INSERT INTO FLOAT4_TBL(f1) VALUES ('     - 3.0');
2023-08-01 17:01:34.949 +07 client backend[295484] pg_regress/float4 ERROR:  invalid input syntax for type real: "123            5" at character 36
2023-08-01 17:01:34.949 +07 client backend[295484] pg_regress/float4 STATEMENT:  INSERT INTO FLOAT4_TBL(f1) VALUES ('123            5');
2023-08-01 17:01:34.949 +07 client backend[295482] pg_regress/int8 ERROR:  bigint out of range
2023-08-01 17:01:34.949 +07 client backend[295482] pg_regress/int8 STATEMENT:  SELECT gcd((-9223372036854775808)::int8, 0::int8);
2023-08-01 17:01:34.949 +07 client backend[295482] pg_regress/int8 ERROR:  bigint out of range
2023-08-01 17:01:34.949 +07 client backend[295482] pg_regress/int8 STATEMENT:  SELECT gcd((-9223372036854775808)::int8, (-9223372036854775808)::int8);
2023-08-01 17:01:34.949 +07 client backend[295484] pg_regress/float4 ERROR:  invalid input syntax for type real: "N A N" at character 8
2023-08-01 17:01:34.949 +07 client backend[295484] pg_regress/float4 STATEMENT:  SELECT 'N A N'::float4;
2023-08-01 17:01:34.949 +07 client backend[295484] pg_regress/float4 ERROR:  invalid input syntax for type real: "NaN x" at character 8
2023-08-01 17:01:34.949 +07 client backend[295484] pg_regress/float4 STATEMENT:  SELECT 'NaN x'::float4;
2023-08-01 17:01:34.949 +07 client backend[295484] pg_regress/float4 ERROR:  invalid input syntax for type real: " INFINITY    x" at character 8
2023-08-01 17:01:34.949 +07 client backend[295484] pg_regress/float4 STATEMENT:  SELECT ' INFINITY    x'::float4;
2023-08-01 17:01:34.949 +07 client backend[295482] pg_regress/int8 ERROR:  bigint out of range
2023-08-01 17:01:34.949 +07 client backend[295482] pg_regress/int8 STATEMENT:  SELECT lcm((-9223372036854775808)::int8, 1::int8);
2023-08-01 17:01:34.949 +07 client backend[295482] pg_regress/int8 ERROR:  bigint out of range
2023-08-01 17:01:34.949 +07 client backend[295482] pg_regress/int8 STATEMENT:  SELECT lcm(9223372036854775807::int8, 9223372036854775806::int8);
2023-08-01 17:01:34.951 +07 client backend[295489] pg_regress/bit ERROR:  bit index 16 out of valid range (0..15)
2023-08-01 17:01:34.951 +07 client backend[295489] pg_regress/bit STATEMENT:  SELECT set_bit(B'0101011000100100', 16, 1);
2023-08-01 17:01:34.951 +07 client backend[295484] pg_regress/float4 ERROR:  division by zero
2023-08-01 17:01:34.951 +07 client backend[295484] pg_regress/float4 STATEMENT:  SELECT '' AS bad, f.f1 / '0.0' from FLOAT4_TBL f;
2023-08-01 17:01:34.952 +07 client backend[295493] pg_regress/txid ERROR:  invalid input syntax for type pg_snapshot: "1:9223372036854775808:3" at character 22
2023-08-01 17:01:34.952 +07 client backend[295493] pg_regress/txid STATEMENT:  SELECT txid_snapshot '1:9223372036854775808:3';
2023-08-01 17:01:34.952 +07 client backend[295484] pg_regress/float4 ERROR:  smallint out of range
2023-08-01 17:01:34.952 +07 client backend[295484] pg_regress/float4 STATEMENT:  SELECT '32767.6'::float4::int2;
2023-08-01 17:01:34.952 +07 client backend[295485] pg_regress/enum ERROR:  value for domain rgb violates check constraint "rgb_check"
2023-08-01 17:01:34.952 +07 client backend[295485] pg_regress/enum STATEMENT:  SELECT 'purple'::rgb;
2023-08-01 17:01:34.952 +07 client backend[295484] pg_regress/float4 ERROR:  smallint out of range
2023-08-01 17:01:34.952 +07 client backend[295484] pg_regress/float4 STATEMENT:  SELECT '-32768.6'::float4::int2;
2023-08-01 17:01:34.952 +07 client backend[295485] pg_regress/enum ERROR:  value for domain rgb violates check constraint "rgb_check"
2023-08-01 17:01:34.952 +07 client backend[295485] pg_regress/enum STATEMENT:  SELECT 'purple'::rainbow::rgb;
2023-08-01 17:01:34.952 +07 client backend[295484] pg_regress/float4 ERROR:  integer out of range
2023-08-01 17:01:34.952 +07 client backend[295484] pg_regress/float4 STATEMENT:  SELECT '2147483647'::float4::int4;
2023-08-01 17:01:34.953 +07 client backend[295484] pg_regress/float4 ERROR:  integer out of range
2023-08-01 17:01:34.953 +07 client backend[295484] pg_regress/float4 STATEMENT:  SELECT '-2147483900'::float4::int4;
2023-08-01 17:01:34.953 +07 client backend[295484] pg_regress/float4 ERROR:  bigint out of range
2023-08-01 17:01:34.953 +07 client backend[295484] pg_regress/float4 STATEMENT:  SELECT '9223372036854775807'::float4::int8;
2023-08-01 17:01:34.953 +07 client backend[295486] pg_regress/float8 ERROR:  "10e400" is out of range for type double precision at character 8
2023-08-01 17:01:34.953 +07 client backend[295486] pg_regress/float8 STATEMENT:  SELECT '10e400'::float8;
2023-08-01 17:01:34.953 +07 client backend[295484] pg_regress/float4 ERROR:  bigint out of range
2023-08-01 17:01:34.953 +07 client backend[295484] pg_regress/float4 STATEMENT:  SELECT '-9223380000000000000'::float4::int8;
2023-08-01 17:01:34.953 +07 client backend[295486] pg_regress/float8 ERROR:  "-10e400" is out of range for type double precision at character 8
2023-08-01 17:01:34.953 +07 client backend[295486] pg_regress/float8 STATEMENT:  SELECT '-10e400'::float8;
2023-08-01 17:01:34.953 +07 client backend[295486] pg_regress/float8 ERROR:  "10e-400" is out of range for type double precision at character 8
2023-08-01 17:01:34.953 +07 client backend[295486] pg_regress/float8 STATEMENT:  SELECT '10e-400'::float8;
2023-08-01 17:01:34.953 +07 client backend[295486] pg_regress/float8 ERROR:  "-10e-400" is out of range for type double precision at character 8
2023-08-01 17:01:34.953 +07 client backend[295486] pg_regress/float8 STATEMENT:  SELECT '-10e-400'::float8;
2023-08-01 17:01:34.953 +07 client backend[295486] pg_regress/float8 ERROR:  invalid input syntax for type double precision: "" at character 36
2023-08-01 17:01:34.953 +07 client backend[295486] pg_regress/float8 STATEMENT:  INSERT INTO FLOAT8_TBL(f1) VALUES ('');
2023-08-01 17:01:34.953 +07 client backend[295486] pg_regress/float8 ERROR:  invalid input syntax for type double precision: "     " at character 36
2023-08-01 17:01:34.953 +07 client backend[295486] pg_regress/float8 STATEMENT:  INSERT INTO FLOAT8_TBL(f1) VALUES ('     ');
2023-08-01 17:01:34.953 +07 client backend[295486] pg_regress/float8 ERROR:  invalid input syntax for type double precision: "xyz" at character 36
2023-08-01 17:01:34.953 +07 client backend[295486] pg_regress/float8 STATEMENT:  INSERT INTO FLOAT8_TBL(f1) VALUES ('xyz');
2023-08-01 17:01:34.954 +07 client backend[295486] pg_regress/float8 ERROR:  invalid input syntax for type double precision: "5.0.0" at character 36
2023-08-01 17:01:34.954 +07 client backend[295486] pg_regress/float8 STATEMENT:  INSERT INTO FLOAT8_TBL(f1) VALUES ('5.0.0');
2023-08-01 17:01:34.954 +07 client backend[295486] pg_regress/float8 ERROR:  invalid input syntax for type double precision: "5 . 0" at character 36
2023-08-01 17:01:34.954 +07 client backend[295486] pg_regress/float8 STATEMENT:  INSERT INTO FLOAT8_TBL(f1) VALUES ('5 . 0');
2023-08-01 17:01:34.954 +07 client backend[295486] pg_regress/float8 ERROR:  invalid input syntax for type double precision: "5.   0" at character 36
2023-08-01 17:01:34.954 +07 client backend[295486] pg_regress/float8 STATEMENT:  INSERT INTO FLOAT8_TBL(f1) VALUES ('5.   0');
2023-08-01 17:01:34.954 +07 client backend[295486] pg_regress/float8 ERROR:  invalid input syntax for type double precision: "    - 3" at character 36
2023-08-01 17:01:34.954 +07 client backend[295486] pg_regress/float8 STATEMENT:  INSERT INTO FLOAT8_TBL(f1) VALUES ('    - 3');
2023-08-01 17:01:34.954 +07 client backend[295486] pg_regress/float8 ERROR:  invalid input syntax for type double precision: "123           5" at character 36
2023-08-01 17:01:34.954 +07 client backend[295486] pg_regress/float8 STATEMENT:  INSERT INTO FLOAT8_TBL(f1) VALUES ('123           5');
2023-08-01 17:01:34.954 +07 client backend[295486] pg_regress/float8 ERROR:  invalid input syntax for type double precision: "N A N" at character 8
2023-08-01 17:01:34.954 +07 client backend[295486] pg_regress/float8 STATEMENT:  SELECT 'N A N'::float8;
2023-08-01 17:01:34.954 +07 client backend[295486] pg_regress/float8 ERROR:  invalid input syntax for type double precision: "NaN x" at character 8
2023-08-01 17:01:34.954 +07 client backend[295486] pg_regress/float8 STATEMENT:  SELECT 'NaN x'::float8;
2023-08-01 17:01:34.954 +07 client backend[295486] pg_regress/float8 ERROR:  invalid input syntax for type double precision: " INFINITY    x" at character 8
2023-08-01 17:01:34.954 +07 client backend[295486] pg_regress/float8 STATEMENT:  SELECT ' INFINITY    x'::float8;
2023-08-01 17:01:34.955 +07 client backend[295490] pg_regress/regproc ERROR:  operator does not exist: ||// at character 16
2023-08-01 17:01:34.955 +07 client backend[295490] pg_regress/regproc STATEMENT:  SELECT regoper('||//');
2023-08-01 17:01:34.955 +07 client backend[295490] pg_regress/regproc ERROR:  operator does not exist: ++(int4,int4) at character 20
2023-08-01 17:01:34.955 +07 client backend[295490] pg_regress/regproc STATEMENT:  SELECT regoperator('++(int4,int4)');
2023-08-01 17:01:34.955 +07 client backend[295490] pg_regress/regproc ERROR:  function "know" does not exist at character 16
2023-08-01 17:01:34.955 +07 client backend[295490] pg_regress/regproc STATEMENT:  SELECT regproc('know');
2023-08-01 17:01:34.955 +07 client backend[295490] pg_regress/regproc ERROR:  function "absinthe(numeric)" does not exist at character 21
2023-08-01 17:01:34.955 +07 client backend[295490] pg_regress/regproc STATEMENT:  SELECT regprocedure('absinthe(numeric)');
2023-08-01 17:01:34.955 +07 client backend[295490] pg_regress/regproc ERROR:  relation "pg_classes" does not exist at character 17
2023-08-01 17:01:34.955 +07 client backend[295490] pg_regress/regproc STATEMENT:  SELECT regclass('pg_classes');
2023-08-01 17:01:34.955 +07 client backend[295490] pg_regress/regproc ERROR:  type "int3" does not exist at character 16
2023-08-01 17:01:34.955 +07 client backend[295490] pg_regress/regproc STATEMENT:  SELECT regtype('int3');
2023-08-01 17:01:34.955 +07 client backend[295490] pg_regress/regproc ERROR:  schema "ng_catalog" does not exist at character 16
2023-08-01 17:01:34.955 +07 client backend[295490] pg_regress/regproc STATEMENT:  SELECT regoper('ng_catalog.||/');
2023-08-01 17:01:34.955 +07 client backend[295490] pg_regress/regproc ERROR:  operator does not exist: ng_catalog.+(int4,int4) at character 20
2023-08-01 17:01:34.955 +07 client backend[295490] pg_regress/regproc STATEMENT:  SELECT regoperator('ng_catalog.+(int4,int4)');
2023-08-01 17:01:34.955 +07 client backend[295490] pg_regress/regproc ERROR:  schema "ng_catalog" does not exist at character 16
2023-08-01 17:01:34.955 +07 client backend[295490] pg_regress/regproc STATEMENT:  SELECT regproc('ng_catalog.now');
2023-08-01 17:01:34.956 +07 client backend[295490] pg_regress/regproc ERROR:  schema "ng_catalog" does not exist at character 21
2023-08-01 17:01:34.956 +07 client backend[295490] pg_regress/regproc STATEMENT:  SELECT regprocedure('ng_catalog.abs(numeric)');
2023-08-01 17:01:34.956 +07 client backend[295490] pg_regress/regproc ERROR:  schema "ng_catalog" does not exist at character 17
2023-08-01 17:01:34.956 +07 client backend[295490] pg_regress/regproc STATEMENT:  SELECT regclass('ng_catalog.pg_class');
2023-08-01 17:01:34.956 +07 client backend[295490] pg_regress/regproc ERROR:  schema "ng_catalog" does not exist at character 16
2023-08-01 17:01:34.956 +07 client backend[295490] pg_regress/regproc STATEMENT:  SELECT regtype('ng_catalog.int4');
2023-08-01 17:01:34.956 +07 client backend[295490] pg_regress/regproc ERROR:  schema "ng_catalog" does not exist at character 21
2023-08-01 17:01:34.956 +07 client backend[295490] pg_regress/regproc STATEMENT:  SELECT regcollation('ng_catalog."POSIX"');
2023-08-01 17:01:34.956 +07 client backend[295490] pg_regress/regproc ERROR:  role "regress_regrole_test" does not exist at character 16
2023-08-01 17:01:34.956 +07 client backend[295490] pg_regress/regproc STATEMENT:  SELECT regrole('regress_regrole_test');
2023-08-01 17:01:34.956 +07 client backend[295490] pg_regress/regproc ERROR:  role "regress_regrole_test" does not exist at character 16
2023-08-01 17:01:34.956 +07 client backend[295490] pg_regress/regproc STATEMENT:  SELECT regrole('"regress_regrole_test"');
2023-08-01 17:01:34.956 +07 client backend[295490] pg_regress/regproc ERROR:  role "nonexistent" does not exist at character 16
2023-08-01 17:01:34.956 +07 client backend[295490] pg_regress/regproc STATEMENT:  SELECT regrole('Nonexistent');
2023-08-01 17:01:34.956 +07 client backend[295490] pg_regress/regproc ERROR:  role "Nonexistent" does not exist at character 16
2023-08-01 17:01:34.956 +07 client backend[295490] pg_regress/regproc STATEMENT:  SELECT regrole('"Nonexistent"');
2023-08-01 17:01:34.956 +07 client backend[295490] pg_regress/regproc ERROR:  invalid name syntax at character 16
2023-08-01 17:01:34.956 +07 client backend[295490] pg_regress/regproc STATEMENT:  SELECT regrole('foo.bar');
2023-08-01 17:01:34.956 +07 client backend[295490] pg_regress/regproc ERROR:  schema "nonexistent" does not exist at character 21
2023-08-01 17:01:34.956 +07 client backend[295490] pg_regress/regproc STATEMENT:  SELECT regnamespace('Nonexistent');
2023-08-01 17:01:34.956 +07 client backend[295490] pg_regress/regproc ERROR:  schema "Nonexistent" does not exist at character 21
2023-08-01 17:01:34.956 +07 client backend[295490] pg_regress/regproc STATEMENT:  SELECT regnamespace('"Nonexistent"');
2023-08-01 17:01:34.956 +07 client backend[295490] pg_regress/regproc ERROR:  invalid name syntax at character 21
2023-08-01 17:01:34.956 +07 client backend[295490] pg_regress/regproc STATEMENT:  SELECT regnamespace('foo.bar');
2023-08-01 17:01:34.958 +07 client backend[295490] pg_regress/regproc ERROR:  invalid name syntax
2023-08-01 17:01:34.958 +07 client backend[295490] pg_regress/regproc STATEMENT:  SELECT to_regrole('foo.bar');
2023-08-01 17:01:34.958 +07 client backend[295490] pg_regress/regproc ERROR:  invalid name syntax
2023-08-01 17:01:34.958 +07 client backend[295490] pg_regress/regproc STATEMENT:  SELECT to_regrole('foo.bar');
2023-08-01 17:01:34.958 +07 client backend[295485] pg_regress/enum ERROR:  insert or update on table "enumtest_child" violates foreign key constraint "enumtest_child_parent_fkey"
2023-08-01 17:01:34.958 +07 client backend[295485] pg_regress/enum DETAIL:  Key (parent)=(blue) is not present in table "enumtest_parent".
2023-08-01 17:01:34.958 +07 client backend[295485] pg_regress/enum STATEMENT:  INSERT INTO enumtest_child VALUES ('blue');
2023-08-01 17:01:34.958 +07 client backend[295490] pg_regress/regproc ERROR:  invalid name syntax
2023-08-01 17:01:34.958 +07 client backend[295490] pg_regress/regproc STATEMENT:  SELECT to_regnamespace('foo.bar');
2023-08-01 17:01:34.958 +07 client backend[295485] pg_regress/enum ERROR:  update or delete on table "enumtest_parent" violates foreign key constraint "enumtest_child_parent_fkey" on table "enumtest_child"
2023-08-01 17:01:34.958 +07 client backend[295485] pg_regress/enum DETAIL:  Key (id)=(red) is still referenced from table "enumtest_child".
2023-08-01 17:01:34.958 +07 client backend[295485] pg_regress/enum STATEMENT:  DELETE FROM enumtest_parent;
2023-08-01 17:01:34.959 +07 client backend[295485] pg_regress/enum ERROR:  foreign key constraint "enumtest_bogus_child_parent_fkey" cannot be implemented
2023-08-01 17:01:34.959 +07 client backend[295485] pg_regress/enum DETAIL:  Key columns "parent" and "id" are of incompatible types: bogus and rainbow.
2023-08-01 17:01:34.959 +07 client backend[295485] pg_regress/enum STATEMENT:  CREATE TABLE enumtest_bogus_child(parent bogus REFERENCES enumtest_parent);
2023-08-01 17:01:34.960 +07 client backend[295486] pg_regress/float8 ERROR:  value out of range: overflow
2023-08-01 17:01:34.960 +07 client backend[295486] pg_regress/float8 STATEMENT:  SELECT '' AS bad, f.f1 * '1e200' from FLOAT8_TBL f;
2023-08-01 17:01:34.960 +07 client backend[295486] pg_regress/float8 ERROR:  value out of range: overflow
2023-08-01 17:01:34.960 +07 client backend[295486] pg_regress/float8 STATEMENT:  SELECT '' AS bad, f.f1 ^ '1e200' from FLOAT8_TBL f;
2023-08-01 17:01:34.960 +07 client backend[295485] pg_regress/enum ERROR:  "red" is not an existing enum label
2023-08-01 17:01:34.960 +07 client backend[295485] pg_regress/enum STATEMENT:  ALTER TYPE rainbow RENAME VALUE 'red' TO 'crimson';
2023-08-01 17:01:34.960 +07 client backend[295485] pg_regress/enum ERROR:  enum label "green" already exists
2023-08-01 17:01:34.960 +07 client backend[295485] pg_regress/enum STATEMENT:  ALTER TYPE rainbow RENAME VALUE 'blue' TO 'green';
2023-08-01 17:01:34.960 +07 client backend[295486] pg_regress/float8 ERROR:  cannot take logarithm of zero
2023-08-01 17:01:34.960 +07 client backend[295486] pg_regress/float8 STATEMENT:  SELECT '' AS bad, ln(f.f1) from FLOAT8_TBL f where f.f1 = '0.0' ;
2023-08-01 17:01:34.960 +07 client backend[295486] pg_regress/float8 ERROR:  cannot take logarithm of a negative number
2023-08-01 17:01:34.960 +07 client backend[295486] pg_regress/float8 STATEMENT:  SELECT '' AS bad, ln(f.f1) from FLOAT8_TBL f where f.f1 < '0.0' ;
2023-08-01 17:01:34.960 +07 client backend[295486] pg_regress/float8 ERROR:  value out of range: underflow
2023-08-01 17:01:34.960 +07 client backend[295486] pg_regress/float8 STATEMENT:  SELECT '' AS bad, exp(f.f1) from FLOAT8_TBL f;
2023-08-01 17:01:34.960 +07 client backend[295486] pg_regress/float8 ERROR:  division by zero
2023-08-01 17:01:34.960 +07 client backend[295486] pg_regress/float8 STATEMENT:  SELECT '' AS bad, f.f1 / '0.0' from FLOAT8_TBL f;
2023-08-01 17:01:34.960 +07 client backend[295485] pg_regress/enum ERROR:  unsafe use of new value "new" of enum type bogus at character 8
2023-08-01 17:01:34.960 +07 client backend[295485] pg_regress/enum HINT:  New enum values must be committed before they can be used.
2023-08-01 17:01:34.960 +07 client backend[295485] pg_regress/enum STATEMENT:  SELECT 'new'::bogus;
2023-08-01 17:01:34.961 +07 client backend[295485] pg_regress/enum ERROR:  unsafe use of new value "new" of enum type bogus
2023-08-01 17:01:34.961 +07 client backend[295485] pg_regress/enum HINT:  New enum values must be committed before they can be used.
2023-08-01 17:01:34.961 +07 client backend[295485] pg_regress/enum STATEMENT:  SELECT enum_last(null::bogus);
2023-08-01 17:01:34.961 +07 client backend[295485] pg_regress/enum ERROR:  unsafe use of new value "new" of enum type bogus
2023-08-01 17:01:34.961 +07 client backend[295485] pg_regress/enum HINT:  New enum values must be committed before they can be used.
2023-08-01 17:01:34.961 +07 client backend[295485] pg_regress/enum STATEMENT:  SELECT enum_range(null::bogus);
2023-08-01 17:01:34.961 +07 client backend[295485] pg_regress/enum ERROR:  unsafe use of new value "bad" of enum type bogon at character 8
2023-08-01 17:01:34.961 +07 client backend[295485] pg_regress/enum HINT:  New enum values must be committed before they can be used.
2023-08-01 17:01:34.961 +07 client backend[295485] pg_regress/enum STATEMENT:  SELECT 'bad'::bogon;
2023-08-01 17:01:34.962 +07 client backend[295486] pg_regress/float8 ERROR:  input is out of range
2023-08-01 17:01:34.962 +07 client backend[295486] pg_regress/float8 STATEMENT:  SELECT acosh(float8 '-infinity');
2023-08-01 17:01:34.962 +07 client backend[295486] pg_regress/float8 ERROR:  input is out of range
2023-08-01 17:01:34.962 +07 client backend[295486] pg_regress/float8 STATEMENT:  SELECT atanh(float8 'infinity');
2023-08-01 17:01:34.962 +07 client backend[295486] pg_regress/float8 ERROR:  input is out of range
2023-08-01 17:01:34.962 +07 client backend[295486] pg_regress/float8 STATEMENT:  SELECT atanh(float8 '-infinity');
2023-08-01 17:01:34.962 +07 client backend[295486] pg_regress/float8 ERROR:  "10e400" is out of range for type double precision at character 36
2023-08-01 17:01:34.962 +07 client backend[295486] pg_regress/float8 STATEMENT:  INSERT INTO FLOAT8_TBL(f1) VALUES ('10e400');
2023-08-01 17:01:34.962 +07 client backend[295486] pg_regress/float8 ERROR:  "-10e400" is out of range for type double precision at character 36
2023-08-01 17:01:34.962 +07 client backend[295486] pg_regress/float8 STATEMENT:  INSERT INTO FLOAT8_TBL(f1) VALUES ('-10e400');
2023-08-01 17:01:34.962 +07 client backend[295486] pg_regress/float8 ERROR:  "10e-400" is out of range for type double precision at character 36
2023-08-01 17:01:34.962 +07 client backend[295486] pg_regress/float8 STATEMENT:  INSERT INTO FLOAT8_TBL(f1) VALUES ('10e-400');
2023-08-01 17:01:34.962 +07 client backend[295486] pg_regress/float8 ERROR:  "-10e-400" is out of range for type double precision at character 36
2023-08-01 17:01:34.962 +07 client backend[295486] pg_regress/float8 STATEMENT:  INSERT INTO FLOAT8_TBL(f1) VALUES ('-10e-400');
2023-08-01 17:01:34.963 +07 client backend[295486] pg_regress/float8 ERROR:  smallint out of range
2023-08-01 17:01:34.963 +07 client backend[295486] pg_regress/float8 STATEMENT:  SELECT '32767.6'::float8::int2;
2023-08-01 17:01:34.963 +07 client backend[295486] pg_regress/float8 ERROR:  smallint out of range
2023-08-01 17:01:34.963 +07 client backend[295486] pg_regress/float8 STATEMENT:  SELECT '-32768.6'::float8::int2;
2023-08-01 17:01:34.963 +07 client backend[295486] pg_regress/float8 ERROR:  integer out of range
2023-08-01 17:01:34.963 +07 client backend[295486] pg_regress/float8 STATEMENT:  SELECT '2147483647.6'::float8::int4;
2023-08-01 17:01:34.963 +07 client backend[295486] pg_regress/float8 ERROR:  integer out of range
2023-08-01 17:01:34.963 +07 client backend[295486] pg_regress/float8 STATEMENT:  SELECT '-2147483648.6'::float8::int4;
2023-08-01 17:01:34.963 +07 client backend[295485] pg_regress/enum ERROR:  unsafe use of new value "bad" of enum type bogon
2023-08-01 17:01:34.963 +07 client backend[295485] pg_regress/enum HINT:  New enum values must be committed before they can be used.
2023-08-01 17:01:34.963 +07 client backend[295485] pg_regress/enum STATEMENT:  select enum_range(null::bogon);
2023-08-01 17:01:34.963 +07 client backend[295486] pg_regress/float8 ERROR:  bigint out of range
2023-08-01 17:01:34.963 +07 client backend[295486] pg_regress/float8 STATEMENT:  SELECT '9223372036854775807'::float8::int8;
2023-08-01 17:01:34.963 +07 client backend[295486] pg_regress/float8 ERROR:  bigint out of range
2023-08-01 17:01:34.963 +07 client backend[295486] pg_regress/float8 STATEMENT:  SELECT '-9223372036854780000'::float8::int8;
2023-08-01 17:01:35.003 +07 client backend[295492] pg_regress/numeric ERROR:  numeric field overflow
2023-08-01 17:01:35.003 +07 client backend[295492] pg_regress/numeric DETAIL:  A field with precision 4, scale 4 must round to an absolute value less than 1.
2023-08-01 17:01:35.003 +07 client backend[295492] pg_regress/numeric STATEMENT:  INSERT INTO fract_only VALUES (3, '1.0');
2023-08-01 17:01:35.003 +07 client backend[295492] pg_regress/numeric ERROR:  numeric field overflow
2023-08-01 17:01:35.003 +07 client backend[295492] pg_regress/numeric DETAIL:  A field with precision 4, scale 4 must round to an absolute value less than 1.
2023-08-01 17:01:35.003 +07 client backend[295492] pg_regress/numeric STATEMENT:  INSERT INTO fract_only VALUES (6, '0.99995');
2023-08-01 17:01:35.004 +07 client backend[295492] pg_regress/numeric ERROR:  cannot convert infinity to numeric
2023-08-01 17:01:35.004 +07 client backend[295492] pg_regress/numeric STATEMENT:  SELECT 'Infinity'::float8::numeric;
2023-08-01 17:01:35.004 +07 client backend[295492] pg_regress/numeric ERROR:  cannot convert infinity to numeric
2023-08-01 17:01:35.004 +07 client backend[295492] pg_regress/numeric STATEMENT:  SELECT '-Infinity'::float8::numeric;
2023-08-01 17:01:35.004 +07 client backend[295492] pg_regress/numeric ERROR:  cannot convert infinity to numeric
2023-08-01 17:01:35.004 +07 client backend[295492] pg_regress/numeric STATEMENT:  SELECT 'Infinity'::float4::numeric;
2023-08-01 17:01:35.004 +07 client backend[295492] pg_regress/numeric ERROR:  cannot convert infinity to numeric
2023-08-01 17:01:35.004 +07 client backend[295492] pg_regress/numeric STATEMENT:  SELECT '-Infinity'::float4::numeric;
2023-08-01 17:01:35.007 +07 client backend[295492] pg_regress/numeric ERROR:  count must be greater than zero
2023-08-01 17:01:35.007 +07 client backend[295492] pg_regress/numeric STATEMENT:  SELECT width_bucket(5.0, 3.0, 4.0, 0);
2023-08-01 17:01:35.007 +07 client backend[295492] pg_regress/numeric ERROR:  count must be greater than zero
2023-08-01 17:01:35.007 +07 client backend[295492] pg_regress/numeric STATEMENT:  SELECT width_bucket(5.0, 3.0, 4.0, -5);
2023-08-01 17:01:35.007 +07 client backend[295492] pg_regress/numeric ERROR:  lower bound cannot equal upper bound
2023-08-01 17:01:35.007 +07 client backend[295492] pg_regress/numeric STATEMENT:  SELECT width_bucket(3.5, 3.0, 3.0, 888);
2023-08-01 17:01:35.007 +07 client backend[295492] pg_regress/numeric ERROR:  count must be greater than zero
2023-08-01 17:01:35.007 +07 client backend[295492] pg_regress/numeric STATEMENT:  SELECT width_bucket(5.0::float8, 3.0::float8, 4.0::float8, 0);
2023-08-01 17:01:35.007 +07 client backend[295492] pg_regress/numeric ERROR:  count must be greater than zero
2023-08-01 17:01:35.007 +07 client backend[295492] pg_regress/numeric STATEMENT:  SELECT width_bucket(5.0::float8, 3.0::float8, 4.0::float8, -5);
2023-08-01 17:01:35.007 +07 client backend[295492] pg_regress/numeric ERROR:  lower bound cannot equal upper bound
2023-08-01 17:01:35.007 +07 client backend[295492] pg_regress/numeric STATEMENT:  SELECT width_bucket(3.5::float8, 3.0::float8, 3.0::float8, 888);
2023-08-01 17:01:35.007 +07 client backend[295492] pg_regress/numeric ERROR:  operand, lower bound, and upper bound cannot be NaN
2023-08-01 17:01:35.007 +07 client backend[295492] pg_regress/numeric STATEMENT:  SELECT width_bucket('NaN', 3.0, 4.0, 888);
2023-08-01 17:01:35.007 +07 client backend[295492] pg_regress/numeric ERROR:  operand, lower bound, and upper bound cannot be NaN
2023-08-01 17:01:35.007 +07 client backend[295492] pg_regress/numeric STATEMENT:  SELECT width_bucket(0::float8, 'NaN', 4.0::float8, 888);
2023-08-01 17:01:35.008 +07 client backend[295492] pg_regress/numeric ERROR:  lower and upper bounds must be finite
2023-08-01 17:01:35.008 +07 client backend[295492] pg_regress/numeric STATEMENT:  SELECT width_bucket(0.0::float8, 'Infinity'::float8, 5, 10);
2023-08-01 17:01:35.008 +07 client backend[295492] pg_regress/numeric ERROR:  lower and upper bounds must be finite
2023-08-01 17:01:35.008 +07 client backend[295492] pg_regress/numeric STATEMENT:  SELECT width_bucket(0.0::float8, 5, '-Infinity'::float8, 20);
2023-08-01 17:01:35.015 +07 client backend[295492] pg_regress/numeric ERROR:  invalid input syntax for type numeric: "     " at character 40
2023-08-01 17:01:35.015 +07 client backend[295492] pg_regress/numeric STATEMENT:  INSERT INTO num_input_test(n1) VALUES ('     ');
2023-08-01 17:01:35.015 +07 client backend[295492] pg_regress/numeric ERROR:  invalid input syntax for type numeric: "   1234   %" at character 40
2023-08-01 17:01:35.015 +07 client backend[295492] pg_regress/numeric STATEMENT:  INSERT INTO num_input_test(n1) VALUES ('   1234   %');
2023-08-01 17:01:35.015 +07 client backend[295492] pg_regress/numeric ERROR:  invalid input syntax for type numeric: "xyz" at character 40
2023-08-01 17:01:35.015 +07 client backend[295492] pg_regress/numeric STATEMENT:  INSERT INTO num_input_test(n1) VALUES ('xyz');
2023-08-01 17:01:35.015 +07 client backend[295492] pg_regress/numeric ERROR:  invalid input syntax for type numeric: "- 1234" at character 40
2023-08-01 17:01:35.015 +07 client backend[295492] pg_regress/numeric STATEMENT:  INSERT INTO num_input_test(n1) VALUES ('- 1234');
2023-08-01 17:01:35.015 +07 client backend[295492] pg_regress/numeric ERROR:  invalid input syntax for type numeric: "5 . 0" at character 40
2023-08-01 17:01:35.015 +07 client backend[295492] pg_regress/numeric STATEMENT:  INSERT INTO num_input_test(n1) VALUES ('5 . 0');
2023-08-01 17:01:35.015 +07 client backend[295492] pg_regress/numeric ERROR:  invalid input syntax for type numeric: "5. 0   " at character 40
2023-08-01 17:01:35.015 +07 client backend[295492] pg_regress/numeric STATEMENT:  INSERT INTO num_input_test(n1) VALUES ('5. 0   ');
2023-08-01 17:01:35.015 +07 client backend[295492] pg_regress/numeric ERROR:  invalid input syntax for type numeric: "" at character 40
2023-08-01 17:01:35.015 +07 client backend[295492] pg_regress/numeric STATEMENT:  INSERT INTO num_input_test(n1) VALUES ('');
2023-08-01 17:01:35.015 +07 client backend[295492] pg_regress/numeric ERROR:  invalid input syntax for type numeric: " N aN " at character 40
2023-08-01 17:01:35.015 +07 client backend[295492] pg_regress/numeric STATEMENT:  INSERT INTO num_input_test(n1) VALUES (' N aN ');
2023-08-01 17:01:35.017 +07 client backend[295492] pg_regress/numeric ERROR:  value overflows numeric format
2023-08-01 17:01:35.017 +07 client backend[295492] pg_regress/numeric STATEMENT:  select 10.0 ^ 2147483647 as overflows;
2023-08-01 17:01:35.017 +07 client backend[295492] pg_regress/numeric ERROR:  value overflows numeric format
2023-08-01 17:01:35.017 +07 client backend[295492] pg_regress/numeric STATEMENT:  select 117743296169.0 ^ 1000000000 as overflows;
2023-08-01 17:01:35.018 +07 client backend[295492] pg_regress/numeric ERROR:  zero raised to a negative power is undefined
2023-08-01 17:01:35.018 +07 client backend[295492] pg_regress/numeric STATEMENT:  select 0.0 ^ (-12.34);
2023-08-01 17:01:35.018 +07 client backend[295492] pg_regress/numeric ERROR:  a negative number raised to a non-integer power yields a complex result
2023-08-01 17:01:35.018 +07 client backend[295492] pg_regress/numeric STATEMENT:  select (-12.34) ^ 1.2;
2023-08-01 17:01:35.020 +07 client backend[295492] pg_regress/numeric ERROR:  step size cannot equal zero
2023-08-01 17:01:35.020 +07 client backend[295492] pg_regress/numeric STATEMENT:  select * from generate_series(-100::numeric, 100::numeric, 0::numeric);
2023-08-01 17:01:35.020 +07 client backend[295492] pg_regress/numeric ERROR:  step size cannot be NaN
2023-08-01 17:01:35.020 +07 client backend[295492] pg_regress/numeric STATEMENT:  select * from generate_series(-100::numeric, 100::numeric, 'nan'::numeric);
2023-08-01 17:01:35.020 +07 client backend[295492] pg_regress/numeric ERROR:  start value cannot be NaN
2023-08-01 17:01:35.020 +07 client backend[295492] pg_regress/numeric STATEMENT:  select * from generate_series('nan'::numeric, 100::numeric, 10::numeric);
2023-08-01 17:01:35.020 +07 client backend[295492] pg_regress/numeric ERROR:  stop value cannot be NaN
2023-08-01 17:01:35.020 +07 client backend[295492] pg_regress/numeric STATEMENT:  select * from generate_series(0::numeric, 'nan'::numeric, 10::numeric);
2023-08-01 17:01:35.021 +07 client backend[295492] pg_regress/numeric ERROR:  cannot take logarithm of a negative number
2023-08-01 17:01:35.021 +07 client backend[295492] pg_regress/numeric STATEMENT:  select ln(-12.34);
2023-08-01 17:01:35.021 +07 client backend[295492] pg_regress/numeric ERROR:  cannot take logarithm of zero
2023-08-01 17:01:35.021 +07 client backend[295492] pg_regress/numeric STATEMENT:  select ln(0.0);
2023-08-01 17:01:35.022 +07 client backend[295492] pg_regress/numeric ERROR:  cannot take logarithm of a negative number
2023-08-01 17:01:35.022 +07 client backend[295492] pg_regress/numeric CONTEXT:  SQL function "log" statement 1
2023-08-01 17:01:35.022 +07 client backend[295492] pg_regress/numeric STATEMENT:  select log(-12.34);
2023-08-01 17:01:35.022 +07 client backend[295492] pg_regress/numeric ERROR:  cannot take logarithm of zero
2023-08-01 17:01:35.022 +07 client backend[295492] pg_regress/numeric CONTEXT:  SQL function "log" statement 1
2023-08-01 17:01:35.022 +07 client backend[295492] pg_regress/numeric STATEMENT:  select log(0.0);
2023-08-01 17:01:35.023 +07 client backend[295492] pg_regress/numeric ERROR:  cannot take logarithm of a negative number
2023-08-01 17:01:35.023 +07 client backend[295492] pg_regress/numeric STATEMENT:  select log(-12.34, 56.78);
2023-08-01 17:01:35.023 +07 client backend[295492] pg_regress/numeric ERROR:  cannot take logarithm of a negative number
2023-08-01 17:01:35.023 +07 client backend[295492] pg_regress/numeric STATEMENT:  select log(-12.34, -56.78);
2023-08-01 17:01:35.023 +07 client backend[295492] pg_regress/numeric ERROR:  cannot take logarithm of a negative number
2023-08-01 17:01:35.023 +07 client backend[295492] pg_regress/numeric STATEMENT:  select log(12.34, -56.78);
2023-08-01 17:01:35.023 +07 client backend[295492] pg_regress/numeric ERROR:  cannot take logarithm of zero
2023-08-01 17:01:35.023 +07 client backend[295492] pg_regress/numeric STATEMENT:  select log(0.0, 12.34);
2023-08-01 17:01:35.023 +07 client backend[295492] pg_regress/numeric ERROR:  cannot take logarithm of zero
2023-08-01 17:01:35.023 +07 client backend[295492] pg_regress/numeric STATEMENT:  select log(12.34, 0.0);
2023-08-01 17:01:35.023 +07 client backend[295492] pg_regress/numeric ERROR:  division by zero
2023-08-01 17:01:35.023 +07 client backend[295492] pg_regress/numeric STATEMENT:  select log(1.0, 12.34);
2023-08-01 17:01:35.044 +07 client backend[295492] pg_regress/numeric LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295492.0", size 1400000
2023-08-01 17:01:35.044 +07 client backend[295492] pg_regress/numeric STATEMENT:  SELECT SUM(9999::numeric) FROM generate_series(1, 100000);
2023-08-01 17:01:35.063 +07 client backend[295492] pg_regress/numeric LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295492.1", size 1400000
2023-08-01 17:01:35.063 +07 client backend[295492] pg_regress/numeric STATEMENT:  SELECT SUM((-9999)::numeric) FROM generate_series(1, 100000);
2023-08-01 17:01:35.065 +07 client backend[295492] pg_regress/numeric ERROR:  value overflows numeric format
2023-08-01 17:01:35.065 +07 client backend[295492] pg_regress/numeric STATEMENT:  SELECT lcm(9999 * (10::numeric)^131068 + (10::numeric^131068 - 1), 2);
2023-08-01 17:01:35.093 +07 client backend[295487] pg_regress/rangetypes ERROR:  conflicting key value violates exclusion constraint "test_range_excl_room_during_excl"
2023-08-01 17:01:35.093 +07 client backend[295487] pg_regress/rangetypes DETAIL:  Key (room, during)=([123,124), ["Sat Jan 02 10:10:00 2010","Sat Jan 02 11:00:00 2010")) conflicts with existing key (room, during)=([123,124), ["Sat Jan 02 10:00:00 2010","Sat Jan 02 11:00:00 2010")).
2023-08-01 17:01:35.093 +07 client backend[295487] pg_regress/rangetypes STATEMENT:  insert into test_range_excl
	  values(int4range(123, 123, '[]'), int4range(3, 3, '[]'), '[2010-01-02 10:10, 2010-01-02 11:00)');
2023-08-01 17:01:35.093 +07 client backend[295487] pg_regress/rangetypes ERROR:  conflicting key value violates exclusion constraint "test_range_excl_speaker_during_excl"
2023-08-01 17:01:35.093 +07 client backend[295487] pg_regress/rangetypes DETAIL:  Key (speaker, during)=([1,2), ["Sat Jan 02 10:10:00 2010","Sat Jan 02 11:00:00 2010")) conflicts with existing key (speaker, during)=([1,2), ["Sat Jan 02 10:00:00 2010","Sat Jan 02 11:00:00 2010")).
2023-08-01 17:01:35.093 +07 client backend[295487] pg_regress/rangetypes STATEMENT:  insert into test_range_excl
	  values(int4range(125, 125, '[]'), int4range(1, 1, '[]'), '[2010-01-02 10:10, 2010-01-02 11:00)');
2023-08-01 17:01:35.094 +07 client backend[295487] pg_regress/rangetypes ERROR:  range lower bound must be less than or equal to range upper bound at character 8
2023-08-01 17:01:35.094 +07 client backend[295487] pg_regress/rangetypes STATEMENT:  select '[2010-01-01 01:00:00 -08, 2010-01-01 02:00:00 -05)'::tstzrange;
2023-08-01 17:01:35.094 +07 client backend[295487] pg_regress/rangetypes ERROR:  function float4mi(double precision, double precision) does not exist
2023-08-01 17:01:35.094 +07 client backend[295487] pg_regress/rangetypes STATEMENT:  create type float8range as range (subtype=float8, subtype_diff=float4mi);
2023-08-01 17:01:35.096 +07 client backend[295487] pg_regress/rangetypes ERROR:  cannot drop type mydomain because other objects depend on it
2023-08-01 17:01:35.096 +07 client backend[295487] pg_regress/rangetypes DETAIL:  type mydomainrange depends on type mydomain
2023-08-01 17:01:35.096 +07 client backend[295487] pg_regress/rangetypes HINT:  Use DROP ... CASCADE to drop the dependent objects too.
2023-08-01 17:01:35.096 +07 client backend[295487] pg_regress/rangetypes STATEMENT:  drop domain mydomain;
2023-08-01 17:01:35.097 +07 client backend[295487] pg_regress/rangetypes ERROR:  value for domain restrictedrange violates check constraint "restrictedrange_check"
2023-08-01 17:01:35.097 +07 client backend[295487] pg_regress/rangetypes STATEMENT:  select '[4,50)'::restrictedrange @> 7;
2023-08-01 17:01:35.098 +07 client backend[295487] pg_regress/rangetypes ERROR:  range lower bound must be less than or equal to range upper bound
2023-08-01 17:01:35.098 +07 client backend[295487] pg_regress/rangetypes STATEMENT:  select textrange1('a','Z') @> 'b'::text;
2023-08-01 17:01:35.099 +07 client backend[295487] pg_regress/rangetypes ERROR:  function anyarray_anyrange_func(integer[], numrange) does not exist at character 8
2023-08-01 17:01:35.099 +07 client backend[295487] pg_regress/rangetypes HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:35.099 +07 client backend[295487] pg_regress/rangetypes STATEMENT:  select anyarray_anyrange_func(ARRAY[1,2], numrange(10,20));
2023-08-01 17:01:35.099 +07 client backend[295487] pg_regress/rangetypes ERROR:  cannot determine result data type
2023-08-01 17:01:35.099 +07 client backend[295487] pg_regress/rangetypes DETAIL:  A result of type anyrange requires at least one input of type anyrange.
2023-08-01 17:01:35.099 +07 client backend[295487] pg_regress/rangetypes STATEMENT:  create function bogus_func(anyelement)
	  returns anyrange as 'select int4range(1,10)' language sql;
2023-08-01 17:01:35.099 +07 client backend[295487] pg_regress/rangetypes ERROR:  cannot determine result data type
2023-08-01 17:01:35.099 +07 client backend[295487] pg_regress/rangetypes DETAIL:  A result of type anyrange requires at least one input of type anyrange.
2023-08-01 17:01:35.099 +07 client backend[295487] pg_regress/rangetypes STATEMENT:  create function bogus_func(int)
	  returns anyrange as 'select int4range(1,10)' language sql;
2023-08-01 17:01:35.100 +07 client backend[295487] pg_regress/rangetypes ERROR:  function rangetypes_sql(numrange, integer[]) does not exist at character 8
2023-08-01 17:01:35.100 +07 client backend[295487] pg_regress/rangetypes HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:35.100 +07 client backend[295487] pg_regress/rangetypes STATEMENT:  select rangetypes_sql(numrange(1,10), ARRAY[2,20]);
2023-08-01 17:01:35.100 +07 client backend[295487] pg_regress/rangetypes ERROR:  function anycompatiblearray_anycompatiblerange_func(numeric[], int4range) does not exist at character 8
2023-08-01 17:01:35.100 +07 client backend[295487] pg_regress/rangetypes HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:35.100 +07 client backend[295487] pg_regress/rangetypes STATEMENT:  select anycompatiblearray_anycompatiblerange_func(ARRAY[1.1,2], int4range(10,20));
2023-08-01 17:01:35.100 +07 client backend[295487] pg_regress/rangetypes ERROR:  cannot determine result data type
2023-08-01 17:01:35.100 +07 client backend[295487] pg_regress/rangetypes DETAIL:  A result of type anycompatiblerange requires at least one input of type anycompatiblerange.
2023-08-01 17:01:35.100 +07 client backend[295487] pg_regress/rangetypes STATEMENT:  create function bogus_func(anycompatible)
	  returns anycompatiblerange as 'select int4range(1,10)' language sql;
2023-08-01 17:01:35.102 +07 client backend[295487] pg_regress/rangetypes ERROR:  range lower bound must be less than or equal to range upper bound
2023-08-01 17:01:35.102 +07 client backend[295487] pg_regress/rangetypes STATEMENT:  select arrayrange(ARRAY[2,1], ARRAY[1,2]);
2023-08-01 17:01:35.103 +07 client backend[295487] pg_regress/rangetypes ERROR:  composite type two_ints cannot be made a member of itself
2023-08-01 17:01:35.103 +07 client backend[295487] pg_regress/rangetypes STATEMENT:  alter type two_ints add attribute c two_ints_range;
2023-08-01 17:01:35.105 +07 client backend[295487] pg_regress/rangetypes ERROR:  cannot determine result data type
2023-08-01 17:01:35.105 +07 client backend[295487] pg_regress/rangetypes DETAIL:  A result of type anyrange requires at least one input of type anyrange.
2023-08-01 17:01:35.105 +07 client backend[295487] pg_regress/rangetypes STATEMENT:  create function outparam_fail(i anyelement, out r anyrange, out t text)
	  as $$ select '[1,10]', 'foo' $$ language sql;
2023-08-01 17:01:35.105 +07 client backend[295487] pg_regress/rangetypes ERROR:  cannot determine result data type
2023-08-01 17:01:35.105 +07 client backend[295487] pg_regress/rangetypes DETAIL:  A result of type anyrange requires at least one input of type anyrange.
2023-08-01 17:01:35.105 +07 client backend[295487] pg_regress/rangetypes STATEMENT:  create function inoutparam_fail(inout i anyelement, out r anyrange)
	  as $$ select $1, '[1,10]' $$ language sql;
2023-08-01 17:01:35.105 +07 client backend[295487] pg_regress/rangetypes ERROR:  cannot determine result data type
2023-08-01 17:01:35.105 +07 client backend[295487] pg_regress/rangetypes DETAIL:  A result of type anyrange requires at least one input of type anyrange.
2023-08-01 17:01:35.105 +07 client backend[295487] pg_regress/rangetypes STATEMENT:  create function table_fail(i anyelement) returns table(i anyelement, r anyrange)
	  as $$ select $1, '[1,10]' $$ language sql;
2023-08-01 17:01:35.130 +07 client backend[295560] pg_regress/lseg ERROR:  invalid input syntax for type lseg: "(3asdf,2 ,3,4r2)" at character 30
2023-08-01 17:01:35.130 +07 client backend[295560] pg_regress/lseg STATEMENT:  INSERT INTO LSEG_TBL VALUES ('(3asdf,2 ,3,4r2)');
2023-08-01 17:01:35.130 +07 client backend[295560] pg_regress/lseg ERROR:  invalid input syntax for type lseg: "[1,2,3, 4" at character 30
2023-08-01 17:01:35.130 +07 client backend[295560] pg_regress/lseg STATEMENT:  INSERT INTO LSEG_TBL VALUES ('[1,2,3, 4');
2023-08-01 17:01:35.130 +07 client backend[295560] pg_regress/lseg ERROR:  invalid input syntax for type lseg: "[(,2),(3,4)]" at character 30
2023-08-01 17:01:35.130 +07 client backend[295560] pg_regress/lseg STATEMENT:  INSERT INTO LSEG_TBL VALUES ('[(,2),(3,4)]');
2023-08-01 17:01:35.130 +07 client backend[295560] pg_regress/lseg ERROR:  invalid input syntax for type lseg: "[(1,2),(3,4)" at character 30
2023-08-01 17:01:35.130 +07 client backend[295560] pg_regress/lseg STATEMENT:  INSERT INTO LSEG_TBL VALUES ('[(1,2),(3,4)');
2023-08-01 17:01:35.130 +07 client backend[295567] pg_regress/inet ERROR:  table "inet_tbl" does not exist
2023-08-01 17:01:35.130 +07 client backend[295567] pg_regress/inet STATEMENT:  DROP TABLE INET_TBL;
2023-08-01 17:01:35.130 +07 client backend[295562] pg_regress/strings ERROR:  syntax error at or near "' - third line'" at character 75
2023-08-01 17:01:35.130 +07 client backend[295562] pg_regress/strings STATEMENT:  SELECT 'first line'
	' - next line' /* this comment is not allowed here */
	' - third line'
		AS "Illegal comment within continuation";
2023-08-01 17:01:35.131 +07 client backend[295564] pg_regress/path ERROR:  invalid input syntax for type path: "[]" at character 30
2023-08-01 17:01:35.131 +07 client backend[295564] pg_regress/path STATEMENT:  INSERT INTO PATH_TBL VALUES ('[]');
2023-08-01 17:01:35.131 +07 client backend[295564] pg_regress/path ERROR:  invalid input syntax for type path: "[(,2),(3,4)]" at character 30
2023-08-01 17:01:35.131 +07 client backend[295564] pg_regress/path STATEMENT:  INSERT INTO PATH_TBL VALUES ('[(,2),(3,4)]');
2023-08-01 17:01:35.131 +07 client backend[295564] pg_regress/path ERROR:  invalid input syntax for type path: "[(1,2),(3,4)" at character 30
2023-08-01 17:01:35.131 +07 client backend[295564] pg_regress/path STATEMENT:  INSERT INTO PATH_TBL VALUES ('[(1,2),(3,4)');
2023-08-01 17:01:35.131 +07 client backend[295564] pg_regress/path ERROR:  invalid input syntax for type path: "(1,2,3,4" at character 30
2023-08-01 17:01:35.131 +07 client backend[295564] pg_regress/path STATEMENT:  INSERT INTO PATH_TBL VALUES ('(1,2,3,4');
2023-08-01 17:01:35.131 +07 client backend[295564] pg_regress/path ERROR:  invalid input syntax for type path: "(1,2),(3,4)]" at character 30
2023-08-01 17:01:35.131 +07 client backend[295564] pg_regress/path STATEMENT:  INSERT INTO PATH_TBL VALUES ('(1,2),(3,4)]');
2023-08-01 17:01:35.132 +07 client backend[295565] pg_regress/polygon ERROR:  invalid input syntax for type polygon: "0.0" at character 37
2023-08-01 17:01:35.132 +07 client backend[295565] pg_regress/polygon STATEMENT:  INSERT INTO POLYGON_TBL(f1) VALUES ('0.0');
2023-08-01 17:01:35.132 +07 client backend[295561] pg_regress/line ERROR:  invalid input syntax for type line: "{}" at character 30
2023-08-01 17:01:35.132 +07 client backend[295561] pg_regress/line STATEMENT:  INSERT INTO LINE_TBL VALUES ('{}');
2023-08-01 17:01:35.132 +07 client backend[295566] pg_regress/macaddr ERROR:  invalid input syntax for type macaddr: "0800:2b01:0203" at character 37
2023-08-01 17:01:35.132 +07 client backend[295566] pg_regress/macaddr STATEMENT:  INSERT INTO macaddr_data VALUES (8, '0800:2b01:0203');
2023-08-01 17:01:35.132 +07 client backend[295561] pg_regress/line ERROR:  invalid input syntax for type line: "{0" at character 30
2023-08-01 17:01:35.132 +07 client backend[295561] pg_regress/line STATEMENT:  INSERT INTO LINE_TBL VALUES ('{0');
2023-08-01 17:01:35.132 +07 client backend[295566] pg_regress/macaddr ERROR:  invalid input syntax for type macaddr: "not even close" at character 37
2023-08-01 17:01:35.132 +07 client backend[295566] pg_regress/macaddr STATEMENT:  INSERT INTO macaddr_data VALUES (9, 'not even close');
2023-08-01 17:01:35.132 +07 client backend[295561] pg_regress/line ERROR:  invalid input syntax for type line: "{0,0}" at character 30
2023-08-01 17:01:35.132 +07 client backend[295561] pg_regress/line STATEMENT:  INSERT INTO LINE_TBL VALUES ('{0,0}');
2023-08-01 17:01:35.132 +07 client backend[295561] pg_regress/line ERROR:  invalid input syntax for type line: "{0,0,1" at character 30
2023-08-01 17:01:35.132 +07 client backend[295561] pg_regress/line STATEMENT:  INSERT INTO LINE_TBL VALUES ('{0,0,1');
2023-08-01 17:01:35.132 +07 client backend[295561] pg_regress/line ERROR:  invalid line specification: A and B cannot both be zero at character 30
2023-08-01 17:01:35.132 +07 client backend[295561] pg_regress/line STATEMENT:  INSERT INTO LINE_TBL VALUES ('{0,0,1}');
2023-08-01 17:01:35.132 +07 client backend[295561] pg_regress/line ERROR:  invalid input syntax for type line: "{0,0,1} x" at character 30
2023-08-01 17:01:35.132 +07 client backend[295561] pg_regress/line STATEMENT:  INSERT INTO LINE_TBL VALUES ('{0,0,1} x');
2023-08-01 17:01:35.132 +07 client backend[295561] pg_regress/line ERROR:  invalid input syntax for type line: "(3asdf,2 ,3,4r2)" at character 30
2023-08-01 17:01:35.132 +07 client backend[295561] pg_regress/line STATEMENT:  INSERT INTO LINE_TBL VALUES ('(3asdf,2 ,3,4r2)');
2023-08-01 17:01:35.132 +07 client backend[295565] pg_regress/polygon ERROR:  invalid input syntax for type polygon: "(0.0 0.0" at character 37
2023-08-01 17:01:35.132 +07 client backend[295565] pg_regress/polygon STATEMENT:  INSERT INTO POLYGON_TBL(f1) VALUES ('(0.0 0.0');
2023-08-01 17:01:35.133 +07 client backend[295561] pg_regress/line ERROR:  invalid input syntax for type line: "[1,2,3, 4" at character 30
2023-08-01 17:01:35.133 +07 client backend[295561] pg_regress/line STATEMENT:  INSERT INTO LINE_TBL VALUES ('[1,2,3, 4');
2023-08-01 17:01:35.133 +07 client backend[295561] pg_regress/line ERROR:  invalid input syntax for type line: "[(,2),(3,4)]" at character 30
2023-08-01 17:01:35.133 +07 client backend[295561] pg_regress/line STATEMENT:  INSERT INTO LINE_TBL VALUES ('[(,2),(3,4)]');
2023-08-01 17:01:35.133 +07 client backend[295561] pg_regress/line ERROR:  invalid input syntax for type line: "[(1,2),(3,4)" at character 30
2023-08-01 17:01:35.133 +07 client backend[295561] pg_regress/line STATEMENT:  INSERT INTO LINE_TBL VALUES ('[(1,2),(3,4)');
2023-08-01 17:01:35.133 +07 client backend[295561] pg_regress/line ERROR:  invalid line specification: must be two distinct points at character 30
2023-08-01 17:01:35.133 +07 client backend[295561] pg_regress/line STATEMENT:  INSERT INTO LINE_TBL VALUES ('[(1,2),(1,2)]');
2023-08-01 17:01:35.133 +07 client backend[295561] pg_regress/line ERROR:  invalid line specification: must be two distinct points
2023-08-01 17:01:35.133 +07 client backend[295561] pg_regress/line STATEMENT:  INSERT INTO LINE_TBL VALUES (line(point '(1,0)', point '(1,0)'));
2023-08-01 17:01:35.133 +07 client backend[295565] pg_regress/polygon ERROR:  invalid input syntax for type polygon: "(0,1,2)" at character 37
2023-08-01 17:01:35.133 +07 client backend[295565] pg_regress/polygon STATEMENT:  INSERT INTO POLYGON_TBL(f1) VALUES ('(0,1,2)');
2023-08-01 17:01:35.133 +07 client backend[295565] pg_regress/polygon ERROR:  invalid input syntax for type polygon: "(0,1,2,3" at character 37
2023-08-01 17:01:35.133 +07 client backend[295565] pg_regress/polygon STATEMENT:  INSERT INTO POLYGON_TBL(f1) VALUES ('(0,1,2,3');
2023-08-01 17:01:35.133 +07 client backend[295565] pg_regress/polygon ERROR:  invalid input syntax for type polygon: "asdf" at character 37
2023-08-01 17:01:35.133 +07 client backend[295565] pg_regress/polygon STATEMENT:  INSERT INTO POLYGON_TBL(f1) VALUES ('asdf');
2023-08-01 17:01:35.134 +07 client backend[295577] pg_regress/xid ERROR:  operator does not exist: xid < xid at character 17
2023-08-01 17:01:35.134 +07 client backend[295577] pg_regress/xid HINT:  No operator matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:35.134 +07 client backend[295577] pg_regress/xid STATEMENT:  select '1'::xid < '2'::xid;
2023-08-01 17:01:35.134 +07 client backend[295577] pg_regress/xid ERROR:  operator does not exist: xid <= xid at character 17
2023-08-01 17:01:35.134 +07 client backend[295577] pg_regress/xid HINT:  No operator matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:35.134 +07 client backend[295577] pg_regress/xid STATEMENT:  select '1'::xid <= '2'::xid;
2023-08-01 17:01:35.134 +07 client backend[295577] pg_regress/xid ERROR:  operator does not exist: xid > xid at character 17
2023-08-01 17:01:35.134 +07 client backend[295577] pg_regress/xid HINT:  No operator matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:35.134 +07 client backend[295577] pg_regress/xid STATEMENT:  select '1'::xid > '2'::xid;
2023-08-01 17:01:35.134 +07 client backend[295577] pg_regress/xid ERROR:  operator does not exist: xid >= xid at character 17
2023-08-01 17:01:35.134 +07 client backend[295577] pg_regress/xid HINT:  No operator matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:35.134 +07 client backend[295577] pg_regress/xid STATEMENT:  select '1'::xid >= '2'::xid;
2023-08-01 17:01:35.134 +07 client backend[295563] pg_regress/box ERROR:  invalid input syntax for type box: "(2.3, 4.5)" at character 34
2023-08-01 17:01:35.134 +07 client backend[295563] pg_regress/box STATEMENT:  INSERT INTO BOX_TBL (f1) VALUES ('(2.3, 4.5)');
2023-08-01 17:01:35.135 +07 client backend[295563] pg_regress/box ERROR:  invalid input syntax for type box: "[1, 2, 3, 4)" at character 34
2023-08-01 17:01:35.135 +07 client backend[295563] pg_regress/box STATEMENT:  INSERT INTO BOX_TBL (f1) VALUES ('[1, 2, 3, 4)');
2023-08-01 17:01:35.135 +07 client backend[295563] pg_regress/box ERROR:  invalid input syntax for type box: "(1, 2, 3, 4]" at character 34
2023-08-01 17:01:35.135 +07 client backend[295563] pg_regress/box STATEMENT:  INSERT INTO BOX_TBL (f1) VALUES ('(1, 2, 3, 4]');
2023-08-01 17:01:35.135 +07 client backend[295563] pg_regress/box ERROR:  invalid input syntax for type box: "(1, 2, 3, 4) x" at character 34
2023-08-01 17:01:35.135 +07 client backend[295563] pg_regress/box STATEMENT:  INSERT INTO BOX_TBL (f1) VALUES ('(1, 2, 3, 4) x');
2023-08-01 17:01:35.135 +07 client backend[295563] pg_regress/box ERROR:  invalid input syntax for type box: "asdfasdf(ad" at character 34
2023-08-01 17:01:35.135 +07 client backend[295563] pg_regress/box STATEMENT:  INSERT INTO BOX_TBL (f1) VALUES ('asdfasdf(ad');
2023-08-01 17:01:35.137 +07 client backend[295558] pg_regress/point ERROR:  invalid input syntax for type point: "asdfasdf" at character 35
2023-08-01 17:01:35.137 +07 client backend[295558] pg_regress/point STATEMENT:  INSERT INTO POINT_TBL(f1) VALUES ('asdfasdf');
2023-08-01 17:01:35.137 +07 client backend[295558] pg_regress/point ERROR:  invalid input syntax for type point: "(10.0 10.0)" at character 35
2023-08-01 17:01:35.137 +07 client backend[295558] pg_regress/point STATEMENT:  INSERT INTO POINT_TBL(f1) VALUES ('(10.0 10.0)');
2023-08-01 17:01:35.137 +07 client backend[295558] pg_regress/point ERROR:  invalid input syntax for type point: "(10.0, 10.0) x" at character 35
2023-08-01 17:01:35.137 +07 client backend[295558] pg_regress/point STATEMENT:  INSERT INTO POINT_TBL(f1) VALUES ('(10.0, 10.0) x');
2023-08-01 17:01:35.137 +07 client backend[295558] pg_regress/point ERROR:  invalid input syntax for type point: "(10.0,10.0" at character 35
2023-08-01 17:01:35.137 +07 client backend[295558] pg_regress/point STATEMENT:  INSERT INTO POINT_TBL(f1) VALUES ('(10.0,10.0');
2023-08-01 17:01:35.137 +07 client backend[295558] pg_regress/point ERROR:  "1e+500" is out of range for type double precision at character 35
2023-08-01 17:01:35.137 +07 client backend[295558] pg_regress/point STATEMENT:  INSERT INTO POINT_TBL(f1) VALUES ('(10.0, 1e+500)');
2023-08-01 17:01:35.138 +07 client backend[295562] pg_regress/strings ERROR:  invalid Unicode escape at character 18
2023-08-01 17:01:35.138 +07 client backend[295562] pg_regress/strings HINT:  Unicode escapes must be \XXXX or \+XXXXXX.
2023-08-01 17:01:35.138 +07 client backend[295562] pg_regress/strings STATEMENT:  SELECT U&'wrong: \061';
2023-08-01 17:01:35.138 +07 client backend[295577] pg_regress/xid ERROR:  invalid input syntax for type pg_snapshot: "31:12:" at character 8
2023-08-01 17:01:35.138 +07 client backend[295577] pg_regress/xid STATEMENT:  select '31:12:'::pg_snapshot;
2023-08-01 17:01:35.138 +07 client backend[295562] pg_regress/strings ERROR:  invalid Unicode escape at character 18
2023-08-01 17:01:35.138 +07 client backend[295562] pg_regress/strings HINT:  Unicode escapes must be \XXXX or \+XXXXXX.
2023-08-01 17:01:35.138 +07 client backend[295562] pg_regress/strings STATEMENT:  SELECT U&'wrong: \+0061';
2023-08-01 17:01:35.138 +07 client backend[295577] pg_regress/xid ERROR:  invalid input syntax for type pg_snapshot: "0:1:" at character 8
2023-08-01 17:01:35.138 +07 client backend[295577] pg_regress/xid STATEMENT:  select '0:1:'::pg_snapshot;
2023-08-01 17:01:35.138 +07 client backend[295570] pg_regress/interval ERROR:  invalid input syntax for type interval: "badly formatted interval" at character 39
2023-08-01 17:01:35.138 +07 client backend[295570] pg_regress/interval STATEMENT:  INSERT INTO INTERVAL_TBL (f1) VALUES ('badly formatted interval');
2023-08-01 17:01:35.138 +07 client backend[295577] pg_regress/xid ERROR:  invalid input syntax for type pg_snapshot: "12:13:0" at character 8
2023-08-01 17:01:35.138 +07 client backend[295577] pg_regress/xid STATEMENT:  select '12:13:0'::pg_snapshot;
2023-08-01 17:01:35.138 +07 client backend[295570] pg_regress/interval ERROR:  invalid input syntax for type interval: "@ 30 eons ago" at character 39
2023-08-01 17:01:35.138 +07 client backend[295570] pg_regress/interval STATEMENT:  INSERT INTO INTERVAL_TBL (f1) VALUES ('@ 30 eons ago');
2023-08-01 17:01:35.138 +07 client backend[295577] pg_regress/xid ERROR:  invalid input syntax for type pg_snapshot: "12:16:14,13" at character 8
2023-08-01 17:01:35.138 +07 client backend[295577] pg_regress/xid STATEMENT:  select '12:16:14,13'::pg_snapshot;
2023-08-01 17:01:35.138 +07 client backend[295562] pg_regress/strings ERROR:  UESCAPE must be followed by a simple string literal at or near "+" at character 33
2023-08-01 17:01:35.138 +07 client backend[295562] pg_regress/strings STATEMENT:  SELECT U&'wrong: +0061' UESCAPE +;
2023-08-01 17:01:35.139 +07 client backend[295562] pg_regress/strings ERROR:  invalid Unicode escape character at or near "'+'" at character 33
2023-08-01 17:01:35.139 +07 client backend[295562] pg_regress/strings STATEMENT:  SELECT U&'wrong: +0061' UESCAPE '+';
2023-08-01 17:01:35.139 +07 client backend[295562] pg_regress/strings ERROR:  invalid Unicode surrogate pair at character 23
2023-08-01 17:01:35.139 +07 client backend[295562] pg_regress/strings STATEMENT:  SELECT U&'wrong: \db99';
2023-08-01 17:01:35.139 +07 client backend[295562] pg_regress/strings ERROR:  invalid Unicode surrogate pair at character 23
2023-08-01 17:01:35.139 +07 client backend[295562] pg_regress/strings STATEMENT:  SELECT U&'wrong: \db99xy';
2023-08-01 17:01:35.140 +07 client backend[295562] pg_regress/strings ERROR:  invalid Unicode surrogate pair at character 23
2023-08-01 17:01:35.140 +07 client backend[295562] pg_regress/strings STATEMENT:  SELECT U&'wrong: \db99\\';
2023-08-01 17:01:35.140 +07 client backend[295572] pg_regress/circle ERROR:  invalid input syntax for type circle: "<(-100,0),-100>" at character 32
2023-08-01 17:01:35.140 +07 client backend[295572] pg_regress/circle STATEMENT:  INSERT INTO CIRCLE_TBL VALUES ('<(-100,0),-100>');
2023-08-01 17:01:35.140 +07 client backend[295562] pg_regress/strings ERROR:  invalid Unicode surrogate pair at character 23
2023-08-01 17:01:35.140 +07 client backend[295562] pg_regress/strings STATEMENT:  SELECT U&'wrong: \db99\0061';
2023-08-01 17:01:35.140 +07 client backend[295562] pg_regress/strings ERROR:  invalid Unicode surrogate pair at character 26
2023-08-01 17:01:35.140 +07 client backend[295562] pg_regress/strings STATEMENT:  SELECT U&'wrong: \+00db99\+000061';
2023-08-01 17:01:35.140 +07 client backend[295572] pg_regress/circle ERROR:  invalid input syntax for type circle: "<(100,200),10" at character 32
2023-08-01 17:01:35.140 +07 client backend[295572] pg_regress/circle STATEMENT:  INSERT INTO CIRCLE_TBL VALUES ('<(100,200),10');
2023-08-01 17:01:35.140 +07 client backend[295562] pg_regress/strings ERROR:  invalid Unicode escape value at character 18
2023-08-01 17:01:35.140 +07 client backend[295562] pg_regress/strings STATEMENT:  SELECT U&'wrong: \+2FFFFF';
2023-08-01 17:01:35.140 +07 client backend[295572] pg_regress/circle ERROR:  invalid input syntax for type circle: "<(100,200),10> x" at character 32
2023-08-01 17:01:35.140 +07 client backend[295572] pg_regress/circle STATEMENT:  INSERT INTO CIRCLE_TBL VALUES ('<(100,200),10> x');
2023-08-01 17:01:35.141 +07 client backend[295572] pg_regress/circle ERROR:  invalid input syntax for type circle: "1abc,3,5" at character 32
2023-08-01 17:01:35.141 +07 client backend[295572] pg_regress/circle STATEMENT:  INSERT INTO CIRCLE_TBL VALUES ('1abc,3,5');
2023-08-01 17:01:35.141 +07 client backend[295562] pg_regress/strings ERROR:  invalid Unicode escape at character 17
2023-08-01 17:01:35.141 +07 client backend[295562] pg_regress/strings HINT:  Unicode escapes must be \uXXXX or \UXXXXXXXX.
2023-08-01 17:01:35.141 +07 client backend[295562] pg_regress/strings STATEMENT:  SELECT E'wrong: \u061';
2023-08-01 17:01:35.141 +07 client backend[295562] pg_regress/strings ERROR:  invalid Unicode escape at character 17
2023-08-01 17:01:35.141 +07 client backend[295562] pg_regress/strings HINT:  Unicode escapes must be \uXXXX or \UXXXXXXXX.
2023-08-01 17:01:35.141 +07 client backend[295562] pg_regress/strings STATEMENT:  SELECT E'wrong: \U0061';
2023-08-01 17:01:35.141 +07 client backend[295562] pg_regress/strings ERROR:  invalid Unicode surrogate pair at or near "'" at character 23
2023-08-01 17:01:35.141 +07 client backend[295562] pg_regress/strings STATEMENT:  SELECT E'wrong: \udb99';
2023-08-01 17:01:35.141 +07 client backend[295562] pg_regress/strings ERROR:  invalid Unicode surrogate pair at or near "x" at character 23
2023-08-01 17:01:35.141 +07 client backend[295562] pg_regress/strings STATEMENT:  SELECT E'wrong: \udb99xy';
2023-08-01 17:01:35.141 +07 client backend[295572] pg_regress/circle ERROR:  invalid input syntax for type circle: "(3,(1,2),3)" at character 32
2023-08-01 17:01:35.141 +07 client backend[295572] pg_regress/circle STATEMENT:  INSERT INTO CIRCLE_TBL VALUES ('(3,(1,2),3)');
2023-08-01 17:01:35.141 +07 client backend[295562] pg_regress/strings ERROR:  invalid Unicode surrogate pair at or near "\" at character 23
2023-08-01 17:01:35.141 +07 client backend[295562] pg_regress/strings STATEMENT:  SELECT E'wrong: \udb99\\';
2023-08-01 17:01:35.141 +07 client backend[295562] pg_regress/strings ERROR:  invalid Unicode surrogate pair at or near "\u0061" at character 23
2023-08-01 17:01:35.141 +07 client backend[295562] pg_regress/strings STATEMENT:  SELECT E'wrong: \udb99\u0061';
2023-08-01 17:01:35.141 +07 client backend[295562] pg_regress/strings ERROR:  invalid Unicode surrogate pair at or near "\U00000061" at character 27
2023-08-01 17:01:35.141 +07 client backend[295562] pg_regress/strings STATEMENT:  SELECT E'wrong: \U0000db99\U00000061';
2023-08-01 17:01:35.142 +07 client backend[295576] pg_regress/date ERROR:  date/time field value out of range: "1997-02-29" at character 30
2023-08-01 17:01:35.142 +07 client backend[295576] pg_regress/date STATEMENT:  INSERT INTO DATE_TBL VALUES ('1997-02-29');
2023-08-01 17:01:35.142 +07 client backend[295577] pg_regress/xid ERROR:  invalid input syntax for type pg_snapshot: "1:9223372036854775808:3" at character 20
2023-08-01 17:01:35.142 +07 client backend[295577] pg_regress/xid STATEMENT:  SELECT pg_snapshot '1:9223372036854775808:3';
2023-08-01 17:01:35.142 +07 client backend[295562] pg_regress/strings ERROR:  invalid Unicode escape value at or near "\U002FFFFF" at character 17
2023-08-01 17:01:35.142 +07 client backend[295562] pg_regress/strings STATEMENT:  SELECT E'wrong: \U002FFFFF';
2023-08-01 17:01:35.143 +07 client backend[295562] pg_regress/strings ERROR:  unsafe use of string constant with Unicode escapes at character 8
2023-08-01 17:01:35.143 +07 client backend[295562] pg_regress/strings DETAIL:  String constants with Unicode escapes cannot be used when standard_conforming_strings is off.
2023-08-01 17:01:35.143 +07 client backend[295562] pg_regress/strings STATEMENT:  SELECT U&'d\0061t\+000061' AS U&"d\0061t\+000061";
2023-08-01 17:01:35.143 +07 client backend[295570] pg_regress/interval ERROR:  interval field value out of range: "2147483648 days" at character 42
2023-08-01 17:01:35.143 +07 client backend[295570] pg_regress/interval STATEMENT:  INSERT INTO INTERVAL_TBL_OF (f1) VALUES ('2147483648 days');
2023-08-01 17:01:35.143 +07 client backend[295571] pg_regress/macaddr8 ERROR:  invalid input syntax for type macaddr8: "123    08:00:2b:01:02:03" at character 8
2023-08-01 17:01:35.143 +07 client backend[295571] pg_regress/macaddr8 STATEMENT:  SELECT '123    08:00:2b:01:02:03'::macaddr8;
2023-08-01 17:01:35.143 +07 client backend[295562] pg_regress/strings ERROR:  unsafe use of string constant with Unicode escapes at character 8
2023-08-01 17:01:35.143 +07 client backend[295562] pg_regress/strings DETAIL:  String constants with Unicode escapes cannot be used when standard_conforming_strings is off.
2023-08-01 17:01:35.143 +07 client backend[295562] pg_regress/strings STATEMENT:  SELECT U&'d!0061t\+000061' UESCAPE '!' AS U&"d*0061t\+000061" UESCAPE '*';
2023-08-01 17:01:35.143 +07 client backend[295570] pg_regress/interval ERROR:  interval field value out of range: "-2147483649 days" at character 42
2023-08-01 17:01:35.143 +07 client backend[295570] pg_regress/interval STATEMENT:  INSERT INTO INTERVAL_TBL_OF (f1) VALUES ('-2147483649 days');
2023-08-01 17:01:35.143 +07 client backend[295562] pg_regress/strings ERROR:  unsafe use of string constant with Unicode escapes at character 8
2023-08-01 17:01:35.143 +07 client backend[295562] pg_regress/strings DETAIL:  String constants with Unicode escapes cannot be used when standard_conforming_strings is off.
2023-08-01 17:01:35.143 +07 client backend[295562] pg_regress/strings STATEMENT:  SELECT U&' \' UESCAPE '!' AS "tricky";
2023-08-01 17:01:35.143 +07 client backend[295570] pg_regress/interval ERROR:  interval out of range at character 42
2023-08-01 17:01:35.143 +07 client backend[295570] pg_regress/interval STATEMENT:  INSERT INTO INTERVAL_TBL_OF (f1) VALUES ('2147483647 years');
2023-08-01 17:01:35.143 +07 client backend[295570] pg_regress/interval ERROR:  interval out of range at character 42
2023-08-01 17:01:35.143 +07 client backend[295570] pg_regress/interval STATEMENT:  INSERT INTO INTERVAL_TBL_OF (f1) VALUES ('-2147483648 years');
2023-08-01 17:01:35.143 +07 client backend[295562] pg_regress/strings ERROR:  unsafe use of string constant with Unicode escapes at character 8
2023-08-01 17:01:35.143 +07 client backend[295562] pg_regress/strings DETAIL:  String constants with Unicode escapes cannot be used when standard_conforming_strings is off.
2023-08-01 17:01:35.143 +07 client backend[295562] pg_regress/strings STATEMENT:  SELECT U&'wrong: \061';
2023-08-01 17:01:35.143 +07 client backend[295571] pg_regress/macaddr8 ERROR:  invalid input syntax for type macaddr8: "08:00:2b:01:02:03  123" at character 8
2023-08-01 17:01:35.143 +07 client backend[295571] pg_regress/macaddr8 STATEMENT:  SELECT '08:00:2b:01:02:03  123'::macaddr8;
2023-08-01 17:01:35.143 +07 client backend[295570] pg_regress/interval ERROR:  interval out of range
2023-08-01 17:01:35.143 +07 client backend[295570] pg_regress/interval STATEMENT:  select extract(epoch from '256 microseconds'::interval * (2^55)::float8);
2023-08-01 17:01:35.143 +07 client backend[295576] pg_regress/date ERROR:  date/time field value out of range: "1/8/1999" at character 13
2023-08-01 17:01:35.143 +07 client backend[295576] pg_regress/date HINT:  Perhaps you need a different "datestyle" setting.
2023-08-01 17:01:35.143 +07 client backend[295576] pg_regress/date STATEMENT:  SELECT date '1/8/1999';
2023-08-01 17:01:35.143 +07 client backend[295576] pg_regress/date ERROR:  date/time field value out of range: "1/18/1999" at character 13
2023-08-01 17:01:35.143 +07 client backend[295576] pg_regress/date HINT:  Perhaps you need a different "datestyle" setting.
2023-08-01 17:01:35.143 +07 client backend[295576] pg_regress/date STATEMENT:  SELECT date '1/18/1999';
2023-08-01 17:01:35.143 +07 client backend[295562] pg_regress/strings ERROR:  unsafe use of string constant with Unicode escapes at character 8
2023-08-01 17:01:35.143 +07 client backend[295562] pg_regress/strings DETAIL:  String constants with Unicode escapes cannot be used when standard_conforming_strings is off.
2023-08-01 17:01:35.143 +07 client backend[295562] pg_regress/strings STATEMENT:  SELECT U&'wrong: \+0061';
2023-08-01 17:01:35.143 +07 client backend[295576] pg_regress/date ERROR:  date/time field value out of range: "18/1/1999" at character 13
2023-08-01 17:01:35.143 +07 client backend[295576] pg_regress/date HINT:  Perhaps you need a different "datestyle" setting.
2023-08-01 17:01:35.143 +07 client backend[295576] pg_regress/date STATEMENT:  SELECT date '18/1/1999';
2023-08-01 17:01:35.143 +07 client backend[295569] pg_regress/time ERROR:  invalid input syntax for type time: "15:36:39 America/New_York" at character 30
2023-08-01 17:01:35.143 +07 client backend[295569] pg_regress/time STATEMENT:  INSERT INTO TIME_TBL VALUES ('15:36:39 America/New_York');
2023-08-01 17:01:35.144 +07 client backend[295562] pg_regress/strings ERROR:  unsafe use of string constant with Unicode escapes at character 8
2023-08-01 17:01:35.144 +07 client backend[295562] pg_regress/strings DETAIL:  String constants with Unicode escapes cannot be used when standard_conforming_strings is off.
2023-08-01 17:01:35.144 +07 client backend[295562] pg_regress/strings STATEMENT:  SELECT U&'wrong: +0061' UESCAPE '+';
2023-08-01 17:01:35.144 +07 client backend[295568] pg_regress/timetz ERROR:  invalid input syntax for type time with time zone: "15:36:39 America/New_York" at character 32
2023-08-01 17:01:35.144 +07 client backend[295568] pg_regress/timetz STATEMENT:  INSERT INTO TIMETZ_TBL VALUES ('15:36:39 America/New_York');
2023-08-01 17:01:35.144 +07 client backend[295576] pg_regress/date ERROR:  date/time field value out of range: "January 8, 99 BC" at character 13
2023-08-01 17:01:35.144 +07 client backend[295576] pg_regress/date HINT:  Perhaps you need a different "datestyle" setting.
2023-08-01 17:01:35.144 +07 client backend[295576] pg_regress/date STATEMENT:  SELECT date 'January 8, 99 BC';
2023-08-01 17:01:35.144 +07 client backend[295576] pg_regress/date ERROR:  date/time field value out of range: "08-Jan-99" at character 13
2023-08-01 17:01:35.144 +07 client backend[295576] pg_regress/date HINT:  Perhaps you need a different "datestyle" setting.
2023-08-01 17:01:35.144 +07 client backend[295576] pg_regress/date STATEMENT:  SELECT date '08-Jan-99';
2023-08-01 17:01:35.144 +07 client backend[295571] pg_regress/macaddr8 ERROR:  invalid input syntax for type macaddr8: "123    08:00:2b:01:02:03:04:05" at character 8
2023-08-01 17:01:35.144 +07 client backend[295571] pg_regress/macaddr8 STATEMENT:  SELECT '123    08:00:2b:01:02:03:04:05'::macaddr8;
2023-08-01 17:01:35.144 +07 client backend[295576] pg_regress/date ERROR:  date/time field value out of range: "Jan-08-99" at character 13
2023-08-01 17:01:35.144 +07 client backend[295576] pg_regress/date HINT:  Perhaps you need a different "datestyle" setting.
2023-08-01 17:01:35.144 +07 client backend[295576] pg_regress/date STATEMENT:  SELECT date 'Jan-08-99';
2023-08-01 17:01:35.144 +07 client backend[295567] pg_regress/inet ERROR:  invalid cidr value: "192.168.1.2/30" at character 37
2023-08-01 17:01:35.144 +07 client backend[295567] pg_regress/inet DETAIL:  Value has bits set to right of mask.
2023-08-01 17:01:35.144 +07 client backend[295567] pg_regress/inet STATEMENT:  INSERT INTO INET_TBL (c, i) VALUES ('192.168.1.2/30', '192.168.1.226');
2023-08-01 17:01:35.144 +07 client backend[295568] pg_regress/timetz ERROR:  invalid input syntax for type time with time zone: "15:36:39 m2" at character 32
2023-08-01 17:01:35.144 +07 client backend[295568] pg_regress/timetz STATEMENT:  INSERT INTO TIMETZ_TBL VALUES ('15:36:39 m2');
2023-08-01 17:01:35.144 +07 client backend[295576] pg_regress/date ERROR:  invalid input syntax for type date: "99-08-Jan" at character 13
2023-08-01 17:01:35.144 +07 client backend[295576] pg_regress/date STATEMENT:  SELECT date '99-08-Jan';
2023-08-01 17:01:35.144 +07 client backend[295567] pg_regress/inet ERROR:  invalid input syntax for type cidr: "1234::1234::1234" at character 37
2023-08-01 17:01:35.144 +07 client backend[295567] pg_regress/inet STATEMENT:  INSERT INTO INET_TBL (c, i) VALUES ('1234::1234::1234', '::1.2.3.4');
2023-08-01 17:01:35.144 +07 client backend[295576] pg_regress/date ERROR:  invalid input syntax for type date: "1999-08-Jan" at character 13
2023-08-01 17:01:35.144 +07 client backend[295576] pg_regress/date STATEMENT:  SELECT date '1999-08-Jan';
2023-08-01 17:01:35.144 +07 client backend[295567] pg_regress/inet ERROR:  invalid cidr value: "192.168.1.2/30" at character 42
2023-08-01 17:01:35.144 +07 client backend[295567] pg_regress/inet DETAIL:  Value has bits set to right of mask.
2023-08-01 17:01:35.144 +07 client backend[295567] pg_regress/inet STATEMENT:  INSERT INTO INET_TBL (c, i) VALUES (cidr('192.168.1.2/30'), '192.168.1.226');
2023-08-01 17:01:35.145 +07 client backend[295567] pg_regress/inet ERROR:  invalid cidr value: "ffff:ffff:ffff:ffff::/24" at character 42
2023-08-01 17:01:35.145 +07 client backend[295567] pg_regress/inet DETAIL:  Value has bits set to right of mask.
2023-08-01 17:01:35.145 +07 client backend[295567] pg_regress/inet STATEMENT:  INSERT INTO INET_TBL (c, i) VALUES (cidr('ffff:ffff:ffff:ffff::/24'), '::192.168.1.226');
2023-08-01 17:01:35.145 +07 client backend[295576] pg_regress/date ERROR:  date/time field value out of range: "08 Jan 99" at character 13
2023-08-01 17:01:35.145 +07 client backend[295576] pg_regress/date HINT:  Perhaps you need a different "datestyle" setting.
2023-08-01 17:01:35.145 +07 client backend[295576] pg_regress/date STATEMENT:  SELECT date '08 Jan 99';
2023-08-01 17:01:35.145 +07 client backend[295571] pg_regress/macaddr8 ERROR:  invalid input syntax for type macaddr8: "08:00:2b:01:02:03:04:05  123" at character 8
2023-08-01 17:01:35.145 +07 client backend[295571] pg_regress/macaddr8 STATEMENT:  SELECT '08:00:2b:01:02:03:04:05  123'::macaddr8;
2023-08-01 17:01:35.145 +07 client backend[295562] pg_regress/strings ERROR:  invalid hexadecimal data: odd number of digits at character 8
2023-08-01 17:01:35.145 +07 client backend[295562] pg_regress/strings STATEMENT:  SELECT E'\\xDeAdBeE'::bytea;
2023-08-01 17:01:35.145 +07 client backend[295576] pg_regress/date ERROR:  date/time field value out of range: "Jan 08 99" at character 13
2023-08-01 17:01:35.145 +07 client backend[295576] pg_regress/date HINT:  Perhaps you need a different "datestyle" setting.
2023-08-01 17:01:35.145 +07 client backend[295576] pg_regress/date STATEMENT:  SELECT date 'Jan 08 99';
2023-08-01 17:01:35.145 +07 client backend[295576] pg_regress/date ERROR:  date/time field value out of range: "08-01-99" at character 13
2023-08-01 17:01:35.145 +07 client backend[295576] pg_regress/date HINT:  Perhaps you need a different "datestyle" setting.
2023-08-01 17:01:35.145 +07 client backend[295576] pg_regress/date STATEMENT:  SELECT date '08-01-99';
2023-08-01 17:01:35.145 +07 client backend[295576] pg_regress/date ERROR:  date/time field value out of range: "08-01-1999" at character 13
2023-08-01 17:01:35.145 +07 client backend[295576] pg_regress/date HINT:  Perhaps you need a different "datestyle" setting.
2023-08-01 17:01:35.145 +07 client backend[295576] pg_regress/date STATEMENT:  SELECT date '08-01-1999';
2023-08-01 17:01:35.145 +07 client backend[295576] pg_regress/date ERROR:  date/time field value out of range: "01-08-99" at character 13
2023-08-01 17:01:35.145 +07 client backend[295576] pg_regress/date HINT:  Perhaps you need a different "datestyle" setting.
2023-08-01 17:01:35.145 +07 client backend[295576] pg_regress/date STATEMENT:  SELECT date '01-08-99';
2023-08-01 17:01:35.145 +07 client backend[295576] pg_regress/date ERROR:  date/time field value out of range: "01-08-1999" at character 13
2023-08-01 17:01:35.145 +07 client backend[295576] pg_regress/date HINT:  Perhaps you need a different "datestyle" setting.
2023-08-01 17:01:35.145 +07 client backend[295576] pg_regress/date STATEMENT:  SELECT date '01-08-1999';
2023-08-01 17:01:35.145 +07 client backend[295562] pg_regress/strings ERROR:  invalid hexadecimal digit: "x" at character 8
2023-08-01 17:01:35.145 +07 client backend[295562] pg_regress/strings STATEMENT:  SELECT E'\\xDeAdBeEx'::bytea;
2023-08-01 17:01:35.145 +07 client backend[295568] pg_regress/timetz ERROR:  invalid input syntax for type time with time zone: "15:36:39 MSK m2" at character 32
2023-08-01 17:01:35.145 +07 client backend[295568] pg_regress/timetz STATEMENT:  INSERT INTO TIMETZ_TBL VALUES ('15:36:39 MSK m2');
2023-08-01 17:01:35.146 +07 client backend[295576] pg_regress/date ERROR:  date/time field value out of range: "08 01 99" at character 13
2023-08-01 17:01:35.146 +07 client backend[295576] pg_regress/date HINT:  Perhaps you need a different "datestyle" setting.
2023-08-01 17:01:35.146 +07 client backend[295576] pg_regress/date STATEMENT:  SELECT date '08 01 99';
2023-08-01 17:01:35.146 +07 client backend[295576] pg_regress/date ERROR:  date/time field value out of range: "08 01 1999" at character 13
2023-08-01 17:01:35.146 +07 client backend[295576] pg_regress/date HINT:  Perhaps you need a different "datestyle" setting.
2023-08-01 17:01:35.146 +07 client backend[295576] pg_regress/date STATEMENT:  SELECT date '08 01 1999';
2023-08-01 17:01:35.146 +07 client backend[295576] pg_regress/date ERROR:  date/time field value out of range: "01 08 99" at character 13
2023-08-01 17:01:35.146 +07 client backend[295576] pg_regress/date HINT:  Perhaps you need a different "datestyle" setting.
2023-08-01 17:01:35.146 +07 client backend[295576] pg_regress/date STATEMENT:  SELECT date '01 08 99';
2023-08-01 17:01:35.146 +07 client backend[295576] pg_regress/date ERROR:  date/time field value out of range: "01 08 1999" at character 13
2023-08-01 17:01:35.146 +07 client backend[295576] pg_regress/date HINT:  Perhaps you need a different "datestyle" setting.
2023-08-01 17:01:35.146 +07 client backend[295576] pg_regress/date STATEMENT:  SELECT date '01 08 1999';
2023-08-01 17:01:35.146 +07 client backend[295576] pg_regress/date ERROR:  date/time field value out of range: "1/18/1999" at character 13
2023-08-01 17:01:35.146 +07 client backend[295576] pg_regress/date HINT:  Perhaps you need a different "datestyle" setting.
2023-08-01 17:01:35.146 +07 client backend[295576] pg_regress/date STATEMENT:  SELECT date '1/18/1999';
2023-08-01 17:01:35.147 +07 client backend[295562] pg_regress/strings ERROR:  invalid input syntax for type bytea at character 8
2023-08-01 17:01:35.147 +07 client backend[295562] pg_regress/strings STATEMENT:  SELECT E'De\\678dBeEf'::bytea;
2023-08-01 17:01:35.147 +07 client backend[295576] pg_regress/date ERROR:  date/time field value out of range: "99-Jan-08" at character 13
2023-08-01 17:01:35.147 +07 client backend[295576] pg_regress/date HINT:  Perhaps you need a different "datestyle" setting.
2023-08-01 17:01:35.147 +07 client backend[295576] pg_regress/date STATEMENT:  SELECT date '99-Jan-08';
2023-08-01 17:01:35.147 +07 client backend[295576] pg_regress/date ERROR:  invalid input syntax for type date: "99-08-Jan" at character 13
2023-08-01 17:01:35.147 +07 client backend[295576] pg_regress/date STATEMENT:  SELECT date '99-08-Jan';
2023-08-01 17:01:35.147 +07 client backend[295576] pg_regress/date ERROR:  invalid input syntax for type date: "1999-08-Jan" at character 13
2023-08-01 17:01:35.147 +07 client backend[295576] pg_regress/date STATEMENT:  SELECT date '1999-08-Jan';
2023-08-01 17:01:35.147 +07 client backend[295576] pg_regress/date ERROR:  date/time field value out of range: "99 Jan 08" at character 13
2023-08-01 17:01:35.147 +07 client backend[295576] pg_regress/date HINT:  Perhaps you need a different "datestyle" setting.
2023-08-01 17:01:35.147 +07 client backend[295576] pg_regress/date STATEMENT:  SELECT date '99 Jan 08';
2023-08-01 17:01:35.148 +07 client backend[295576] pg_regress/date ERROR:  invalid input syntax for type date: "99 08 Jan" at character 13
2023-08-01 17:01:35.148 +07 client backend[295576] pg_regress/date STATEMENT:  SELECT date '99 08 Jan';
2023-08-01 17:01:35.148 +07 client backend[295576] pg_regress/date ERROR:  date/time field value out of range: "99-01-08" at character 13
2023-08-01 17:01:35.148 +07 client backend[295576] pg_regress/date HINT:  Perhaps you need a different "datestyle" setting.
2023-08-01 17:01:35.148 +07 client backend[295576] pg_regress/date STATEMENT:  SELECT date '99-01-08';
2023-08-01 17:01:35.148 +07 client backend[295569] pg_regress/time ERROR:  date/time field value out of range: "24:00:00.01" at character 8
2023-08-01 17:01:35.148 +07 client backend[295569] pg_regress/time STATEMENT:  SELECT '24:00:00.01'::time;
2023-08-01 17:01:35.148 +07 client backend[295569] pg_regress/time ERROR:  date/time field value out of range: "23:59:60.01" at character 8
2023-08-01 17:01:35.148 +07 client backend[295569] pg_regress/time STATEMENT:  SELECT '23:59:60.01'::time;
2023-08-01 17:01:35.148 +07 client backend[295569] pg_regress/time ERROR:  date/time field value out of range: "24:01:00" at character 8
2023-08-01 17:01:35.148 +07 client backend[295569] pg_regress/time STATEMENT:  SELECT '24:01:00'::time;
2023-08-01 17:01:35.148 +07 client backend[295570] pg_regress/interval ERROR:  invalid input syntax for type interval: "1 second 2 seconds" at character 8
2023-08-01 17:01:35.148 +07 client backend[295570] pg_regress/interval STATEMENT:  SELECT '1 second 2 seconds'::interval;
2023-08-01 17:01:35.148 +07 client backend[295570] pg_regress/interval ERROR:  invalid input syntax for type interval: "10 milliseconds 20 milliseconds" at character 8
2023-08-01 17:01:35.148 +07 client backend[295570] pg_regress/interval STATEMENT:  SELECT '10 milliseconds 20 milliseconds'::interval;
2023-08-01 17:01:35.148 +07 client backend[295570] pg_regress/interval ERROR:  invalid input syntax for type interval: "5.5 seconds 3 milliseconds" at character 8
2023-08-01 17:01:35.148 +07 client backend[295570] pg_regress/interval STATEMENT:  SELECT '5.5 seconds 3 milliseconds'::interval;
2023-08-01 17:01:35.148 +07 client backend[295576] pg_regress/date ERROR:  date/time field value out of range: "99-08-01" at character 13
2023-08-01 17:01:35.148 +07 client backend[295576] pg_regress/date HINT:  Perhaps you need a different "datestyle" setting.
2023-08-01 17:01:35.148 +07 client backend[295576] pg_regress/date STATEMENT:  SELECT date '99-08-01';
2023-08-01 17:01:35.148 +07 client backend[295570] pg_regress/interval ERROR:  invalid input syntax for type interval: "1:20:05 5 microseconds" at character 8
2023-08-01 17:01:35.148 +07 client backend[295570] pg_regress/interval STATEMENT:  SELECT '1:20:05 5 microseconds'::interval;
2023-08-01 17:01:35.149 +07 client backend[295570] pg_regress/interval ERROR:  invalid input syntax for type interval: "1 day 1 day" at character 8
2023-08-01 17:01:35.149 +07 client backend[295570] pg_regress/interval STATEMENT:  SELECT '1 day 1 day'::interval;
2023-08-01 17:01:35.149 +07 client backend[295569] pg_regress/time ERROR:  date/time field value out of range: "25:00:00" at character 8
2023-08-01 17:01:35.149 +07 client backend[295569] pg_regress/time STATEMENT:  SELECT '25:00:00'::time;
2023-08-01 17:01:35.149 +07 client backend[295576] pg_regress/date ERROR:  date/time field value out of range: "99 01 08" at character 13
2023-08-01 17:01:35.149 +07 client backend[295576] pg_regress/date HINT:  Perhaps you need a different "datestyle" setting.
2023-08-01 17:01:35.149 +07 client backend[295576] pg_regress/date STATEMENT:  SELECT date '99 01 08';
2023-08-01 17:01:35.149 +07 client backend[295569] pg_regress/time ERROR:  operator is not unique: time without time zone + time without time zone at character 11
2023-08-01 17:01:35.149 +07 client backend[295569] pg_regress/time HINT:  Could not choose a best candidate operator. You might need to add explicit type casts.
2023-08-01 17:01:35.149 +07 client backend[295569] pg_regress/time STATEMENT:  SELECT f1 + time '00:01' AS "Illegal" FROM TIME_TBL;
2023-08-01 17:01:35.150 +07 client backend[295576] pg_regress/date ERROR:  date/time field value out of range: "99 08 01" at character 13
2023-08-01 17:01:35.150 +07 client backend[295576] pg_regress/date HINT:  Perhaps you need a different "datestyle" setting.
2023-08-01 17:01:35.150 +07 client backend[295576] pg_regress/date STATEMENT:  SELECT date '99 08 01';
2023-08-01 17:01:35.150 +07 client backend[295570] pg_regress/interval ERROR:  invalid input syntax for type interval: "1 2" at character 17
2023-08-01 17:01:35.150 +07 client backend[295570] pg_regress/interval STATEMENT:  SELECT interval '1 2' day to minute;
2023-08-01 17:01:35.150 +07 client backend[295570] pg_regress/interval ERROR:  invalid input syntax for type interval: "1 2" at character 17
2023-08-01 17:01:35.150 +07 client backend[295570] pg_regress/interval STATEMENT:  SELECT interval '1 2' day to second;
2023-08-01 17:01:35.150 +07 client backend[295570] pg_regress/interval ERROR:  invalid input syntax for type interval: "1 2" at character 17
2023-08-01 17:01:35.150 +07 client backend[295570] pg_regress/interval STATEMENT:  SELECT interval '1 2' hour to minute;
2023-08-01 17:01:35.150 +07 client backend[295570] pg_regress/interval ERROR:  invalid input syntax for type interval: "1 2" at character 17
2023-08-01 17:01:35.150 +07 client backend[295570] pg_regress/interval STATEMENT:  SELECT interval '1 2' hour to second;
2023-08-01 17:01:35.150 +07 client backend[295576] pg_regress/date ERROR:  date/time field value out of range: "18/1/1999" at character 13
2023-08-01 17:01:35.150 +07 client backend[295576] pg_regress/date HINT:  Perhaps you need a different "datestyle" setting.
2023-08-01 17:01:35.150 +07 client backend[295576] pg_regress/date STATEMENT:  SELECT date '18/1/1999';
2023-08-01 17:01:35.151 +07 client backend[295570] pg_regress/interval ERROR:  invalid input syntax for type interval: "1 2" at character 17
2023-08-01 17:01:35.151 +07 client backend[295570] pg_regress/interval STATEMENT:  SELECT interval '1 2' minute to second;
2023-08-01 17:01:35.151 +07 client backend[295571] pg_regress/macaddr8 ERROR:  invalid input syntax for type macaddr8: "08:00:2b:01:02:03:04:05:06:07" at character 8
2023-08-01 17:01:35.151 +07 client backend[295571] pg_regress/macaddr8 STATEMENT:  SELECT '08:00:2b:01:02:03:04:05:06:07'::macaddr8;
2023-08-01 17:01:35.151 +07 client backend[295571] pg_regress/macaddr8 ERROR:  invalid input syntax for type macaddr8: "08-00-2b-01-02-03-04-05-06-07" at character 8
2023-08-01 17:01:35.151 +07 client backend[295571] pg_regress/macaddr8 STATEMENT:  SELECT '08-00-2b-01-02-03-04-05-06-07'::macaddr8;
2023-08-01 17:01:35.151 +07 client backend[295571] pg_regress/macaddr8 ERROR:  invalid input syntax for type macaddr8: "08002b:01020304050607" at character 8
2023-08-01 17:01:35.151 +07 client backend[295571] pg_regress/macaddr8 STATEMENT:  SELECT '08002b:01020304050607'::macaddr8;
2023-08-01 17:01:35.151 +07 client backend[295571] pg_regress/macaddr8 ERROR:  invalid input syntax for type macaddr8: "08002b01020304050607" at character 8
2023-08-01 17:01:35.151 +07 client backend[295571] pg_regress/macaddr8 STATEMENT:  SELECT '08002b01020304050607'::macaddr8;
2023-08-01 17:01:35.151 +07 client backend[295571] pg_regress/macaddr8 ERROR:  invalid input syntax for type macaddr8: "0z002b0102030405" at character 8
2023-08-01 17:01:35.151 +07 client backend[295571] pg_regress/macaddr8 STATEMENT:  SELECT '0z002b0102030405'::macaddr8;
2023-08-01 17:01:35.151 +07 client backend[295568] pg_regress/timetz ERROR:  date/time field value out of range: "24:00:00.01 PDT" at character 8
2023-08-01 17:01:35.151 +07 client backend[295568] pg_regress/timetz STATEMENT:  SELECT '24:00:00.01 PDT'::timetz;
2023-08-01 17:01:35.151 +07 client backend[295571] pg_regress/macaddr8 ERROR:  invalid input syntax for type macaddr8: "08002b010203xyza" at character 8
2023-08-01 17:01:35.151 +07 client backend[295571] pg_regress/macaddr8 STATEMENT:  SELECT '08002b010203xyza'::macaddr8;
2023-08-01 17:01:35.151 +07 client backend[295571] pg_regress/macaddr8 ERROR:  invalid input syntax for type macaddr8: "08:00-2b:01:02:03:04:05" at character 8
2023-08-01 17:01:35.151 +07 client backend[295571] pg_regress/macaddr8 STATEMENT:  SELECT '08:00-2b:01:02:03:04:05'::macaddr8;
2023-08-01 17:01:35.151 +07 client backend[295570] pg_regress/interval ERROR:  invalid input syntax for type interval: "123 11" at character 17
2023-08-01 17:01:35.151 +07 client backend[295570] pg_regress/interval STATEMENT:  SELECT interval '123 11' day;
2023-08-01 17:01:35.151 +07 client backend[295571] pg_regress/macaddr8 ERROR:  invalid input syntax for type macaddr8: "08:00-2b:01:02:03:04:05" at character 8
2023-08-01 17:01:35.151 +07 client backend[295571] pg_regress/macaddr8 STATEMENT:  SELECT '08:00-2b:01:02:03:04:05'::macaddr8;
2023-08-01 17:01:35.151 +07 client backend[295576] pg_regress/date ERROR:  date/time field value out of range: "99-Jan-08" at character 13
2023-08-01 17:01:35.151 +07 client backend[295576] pg_regress/date HINT:  Perhaps you need a different "datestyle" setting.
2023-08-01 17:01:35.151 +07 client backend[295576] pg_regress/date STATEMENT:  SELECT date '99-Jan-08';
2023-08-01 17:01:35.151 +07 client backend[295570] pg_regress/interval ERROR:  invalid input syntax for type interval: "123 11" at character 17
2023-08-01 17:01:35.151 +07 client backend[295570] pg_regress/interval STATEMENT:  SELECT interval '123 11';
2023-08-01 17:01:35.151 +07 client backend[295571] pg_regress/macaddr8 ERROR:  invalid input syntax for type macaddr8: "08:00:2b:01.02:03:04:05" at character 8
2023-08-01 17:01:35.151 +07 client backend[295571] pg_regress/macaddr8 STATEMENT:  SELECT '08:00:2b:01.02:03:04:05'::macaddr8;
2023-08-01 17:01:35.151 +07 client backend[295570] pg_regress/interval ERROR:  invalid input syntax for type interval: "123 2:03 -2:04" at character 17
2023-08-01 17:01:35.151 +07 client backend[295570] pg_regress/interval STATEMENT:  SELECT interval '123 2:03 -2:04';
2023-08-01 17:01:35.151 +07 client backend[295571] pg_regress/macaddr8 ERROR:  invalid input syntax for type macaddr8: "08:00:2b:01.02:03:04:05" at character 8
2023-08-01 17:01:35.151 +07 client backend[295571] pg_regress/macaddr8 STATEMENT:  SELECT '08:00:2b:01.02:03:04:05'::macaddr8;
2023-08-01 17:01:35.151 +07 client backend[295568] pg_regress/timetz ERROR:  date/time field value out of range: "23:59:60.01 PDT" at character 8
2023-08-01 17:01:35.151 +07 client backend[295568] pg_regress/timetz STATEMENT:  SELECT '23:59:60.01 PDT'::timetz;
2023-08-01 17:01:35.151 +07 client backend[295568] pg_regress/timetz ERROR:  date/time field value out of range: "24:01:00 PDT" at character 8
2023-08-01 17:01:35.151 +07 client backend[295568] pg_regress/timetz STATEMENT:  SELECT '24:01:00 PDT'::timetz;
2023-08-01 17:01:35.152 +07 client backend[295568] pg_regress/timetz ERROR:  date/time field value out of range: "25:00:00 PDT" at character 8
2023-08-01 17:01:35.152 +07 client backend[295568] pg_regress/timetz STATEMENT:  SELECT '25:00:00 PDT'::timetz;
2023-08-01 17:01:35.152 +07 client backend[295570] pg_regress/interval ERROR:  invalid input syntax for type interval: "1 2.345" at character 17
2023-08-01 17:01:35.152 +07 client backend[295570] pg_regress/interval STATEMENT:  SELECT interval '1 2.345' day to second(2);
2023-08-01 17:01:35.152 +07 client backend[295576] pg_regress/date ERROR:  invalid input syntax for type date: "99-08-Jan" at character 13
2023-08-01 17:01:35.152 +07 client backend[295576] pg_regress/date STATEMENT:  SELECT date '99-08-Jan';
2023-08-01 17:01:35.152 +07 client backend[295576] pg_regress/date ERROR:  invalid input syntax for type date: "1999-08-Jan" at character 13
2023-08-01 17:01:35.152 +07 client backend[295576] pg_regress/date STATEMENT:  SELECT date '1999-08-Jan';
2023-08-01 17:01:35.152 +07 client backend[295576] pg_regress/date ERROR:  invalid input syntax for type date: "99 Jan 08" at character 13
2023-08-01 17:01:35.152 +07 client backend[295576] pg_regress/date STATEMENT:  SELECT date '99 Jan 08';
2023-08-01 17:01:35.152 +07 client backend[295570] pg_regress/interval ERROR:  invalid input syntax for type interval: "1 2.345" at character 17
2023-08-01 17:01:35.152 +07 client backend[295570] pg_regress/interval STATEMENT:  SELECT interval '1 2.345' hour to second(2);
2023-08-01 17:01:35.152 +07 client backend[295568] pg_regress/timetz ERROR:  operator does not exist: time with time zone + time with time zone at character 11
2023-08-01 17:01:35.152 +07 client backend[295568] pg_regress/timetz HINT:  No operator matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:35.152 +07 client backend[295568] pg_regress/timetz STATEMENT:  SELECT f1 + time with time zone '00:01' AS "Illegal" FROM TIMETZ_TBL;
2023-08-01 17:01:35.152 +07 client backend[295570] pg_regress/interval ERROR:  invalid input syntax for type interval: "1 2.3456" at character 17
2023-08-01 17:01:35.152 +07 client backend[295570] pg_regress/interval STATEMENT:  SELECT interval '1 2.3456' minute to second(2);
2023-08-01 17:01:35.152 +07 client backend[295576] pg_regress/date ERROR:  invalid input syntax for type date: "99 08 Jan" at character 13
2023-08-01 17:01:35.152 +07 client backend[295576] pg_regress/date STATEMENT:  SELECT date '99 08 Jan';
2023-08-01 17:01:35.152 +07 client backend[295576] pg_regress/date ERROR:  date/time field value out of range: "99-01-08" at character 13
2023-08-01 17:01:35.152 +07 client backend[295576] pg_regress/date HINT:  Perhaps you need a different "datestyle" setting.
2023-08-01 17:01:35.152 +07 client backend[295576] pg_regress/date STATEMENT:  SELECT date '99-01-08';
2023-08-01 17:01:35.153 +07 client backend[295576] pg_regress/date ERROR:  date/time field value out of range: "99-08-01" at character 13
2023-08-01 17:01:35.153 +07 client backend[295576] pg_regress/date HINT:  Perhaps you need a different "datestyle" setting.
2023-08-01 17:01:35.153 +07 client backend[295576] pg_regress/date STATEMENT:  SELECT date '99-08-01';
2023-08-01 17:01:35.153 +07 client backend[295576] pg_regress/date ERROR:  date/time field value out of range: "99 01 08" at character 13
2023-08-01 17:01:35.153 +07 client backend[295576] pg_regress/date HINT:  Perhaps you need a different "datestyle" setting.
2023-08-01 17:01:35.153 +07 client backend[295576] pg_regress/date STATEMENT:  SELECT date '99 01 08';
2023-08-01 17:01:35.153 +07 client backend[295562] pg_regress/strings ERROR:  negative substring length not allowed
2023-08-01 17:01:35.153 +07 client backend[295562] pg_regress/strings STATEMENT:  SELECT SUBSTRING('string' FROM -10 FOR -2147483646) AS "error";
2023-08-01 17:01:35.153 +07 client backend[295571] pg_regress/macaddr8 ERROR:  invalid input syntax for type macaddr8: "not even close" at character 38
2023-08-01 17:01:35.153 +07 client backend[295571] pg_regress/macaddr8 STATEMENT:  INSERT INTO macaddr8_data VALUES (9, 'not even close');
2023-08-01 17:01:35.154 +07 client backend[295576] pg_regress/date ERROR:  date/time field value out of range: "99 08 01" at character 13
2023-08-01 17:01:35.154 +07 client backend[295576] pg_regress/date HINT:  Perhaps you need a different "datestyle" setting.
2023-08-01 17:01:35.154 +07 client backend[295576] pg_regress/date STATEMENT:  SELECT date '99 08 01';
2023-08-01 17:01:35.154 +07 client backend[295576] pg_regress/date ERROR:  date out of range: "4714-11-23 BC" at character 13
2023-08-01 17:01:35.154 +07 client backend[295576] pg_regress/date STATEMENT:  SELECT date '4714-11-23 BC';
2023-08-01 17:01:35.154 +07 client backend[295576] pg_regress/date ERROR:  date out of range: "5874898-01-01" at character 13
2023-08-01 17:01:35.154 +07 client backend[295576] pg_regress/date STATEMENT:  SELECT date '5874898-01-01';
2023-08-01 17:01:35.155 +07 client backend[295570] pg_regress/interval ERROR:  integer out of range
2023-08-01 17:01:35.155 +07 client backend[295570] pg_regress/interval STATEMENT:  select make_interval(years := 'inf'::float::int);
2023-08-01 17:01:35.155 +07 client backend[295570] pg_regress/interval ERROR:  integer out of range
2023-08-01 17:01:35.155 +07 client backend[295570] pg_regress/interval STATEMENT:  select make_interval(months := 'NaN'::float::int);
2023-08-01 17:01:35.155 +07 client backend[295570] pg_regress/interval ERROR:  interval out of range
2023-08-01 17:01:35.155 +07 client backend[295570] pg_regress/interval STATEMENT:  select make_interval(secs := 'inf');
2023-08-01 17:01:35.155 +07 client backend[295570] pg_regress/interval ERROR:  interval out of range
2023-08-01 17:01:35.155 +07 client backend[295570] pg_regress/interval STATEMENT:  select make_interval(secs := 'NaN');
2023-08-01 17:01:35.155 +07 client backend[295562] pg_regress/strings ERROR:  SQL regular expression may not contain more than two escape-double-quote separators
2023-08-01 17:01:35.155 +07 client backend[295562] pg_regress/strings CONTEXT:  SQL function "substring" statement 1
2023-08-01 17:01:35.155 +07 client backend[295562] pg_regress/strings STATEMENT:  SELECT SUBSTRING('abcdefg' FROM 'a*#"%#"g*#"x' FOR '#') AS "error";
2023-08-01 17:01:35.157 +07 client backend[295562] pg_regress/strings ERROR:  invalid escape string
2023-08-01 17:01:35.157 +07 client backend[295562] pg_regress/strings HINT:  Escape string must be empty or one character.
2023-08-01 17:01:35.157 +07 client backend[295562] pg_regress/strings STATEMENT:  SELECT 'abcdefg' SIMILAR TO '_bcd#%' ESCAPE '##' AS error;
2023-08-01 17:01:35.158 +07 client backend[295562] pg_regress/strings ERROR:  invalid regular expression option: "z"
2023-08-01 17:01:35.158 +07 client backend[295562] pg_regress/strings STATEMENT:  SELECT regexp_replace('AAA aaa', 'A+', 'Z', 'z');
2023-08-01 17:01:35.158 +07 client backend[295567] pg_regress/inet ERROR:  result is out of range
2023-08-01 17:01:35.158 +07 client backend[295567] pg_regress/inet STATEMENT:  SELECT '127.0.0.1'::inet + 10000000000;
2023-08-01 17:01:35.158 +07 client backend[295567] pg_regress/inet ERROR:  result is out of range
2023-08-01 17:01:35.158 +07 client backend[295567] pg_regress/inet STATEMENT:  SELECT '127.0.0.1'::inet - 10000000000;
2023-08-01 17:01:35.159 +07 client backend[295567] pg_regress/inet ERROR:  result is out of range
2023-08-01 17:01:35.159 +07 client backend[295567] pg_regress/inet STATEMENT:  SELECT '126::1'::inet - '127::2'::inet;
2023-08-01 17:01:35.159 +07 client backend[295567] pg_regress/inet ERROR:  result is out of range
2023-08-01 17:01:35.159 +07 client backend[295567] pg_regress/inet STATEMENT:  SELECT '127::1'::inet - '126::2'::inet;
2023-08-01 17:01:35.159 +07 client backend[295567] pg_regress/inet ERROR:  cannot merge addresses from different families
2023-08-01 17:01:35.159 +07 client backend[295567] pg_regress/inet STATEMENT:  SELECT inet_merge(c, i) FROM INET_TBL;
2023-08-01 17:01:35.160 +07 client backend[295562] pg_regress/strings ERROR:  invalid regular expression option: "z"
2023-08-01 17:01:35.160 +07 client backend[295562] pg_regress/strings STATEMENT:  SELECT regexp_matches('foobarbequebaz', $re$(bar)(beque)$re$, 'gz');
2023-08-01 17:01:35.160 +07 client backend[295562] pg_regress/strings ERROR:  invalid regular expression: parentheses () not balanced
2023-08-01 17:01:35.160 +07 client backend[295562] pg_regress/strings STATEMENT:  SELECT regexp_matches('foobarbequebaz', $re$(barbeque$re$);
2023-08-01 17:01:35.160 +07 client backend[295562] pg_regress/strings ERROR:  invalid regular expression: invalid repetition count(s)
2023-08-01 17:01:35.160 +07 client backend[295562] pg_regress/strings STATEMENT:  SELECT regexp_matches('foobarbequebaz', $re$(bar)(beque){2,1}$re$);
2023-08-01 17:01:35.162 +07 client backend[295562] pg_regress/strings ERROR:  invalid regular expression option: "z"
2023-08-01 17:01:35.162 +07 client backend[295562] pg_regress/strings STATEMENT:  SELECT foo, length(foo) FROM regexp_split_to_table('thE QUick bROWn FOx jUMPs ovEr The lazy dOG', 'e', 'zippy') AS foo;
2023-08-01 17:01:35.162 +07 client backend[295562] pg_regress/strings ERROR:  invalid regular expression option: "z"
2023-08-01 17:01:35.162 +07 client backend[295562] pg_regress/strings STATEMENT:  SELECT regexp_split_to_array('thE QUick bROWn FOx jUMPs ovEr The lazy dOG', 'e', 'iz');
2023-08-01 17:01:35.162 +07 client backend[295562] pg_regress/strings ERROR:  regexp_split_to_table() does not support the "global" option
2023-08-01 17:01:35.162 +07 client backend[295562] pg_regress/strings STATEMENT:  SELECT foo, length(foo) FROM regexp_split_to_table('thE QUick bROWn FOx jUMPs ovEr The lazy dOG', 'e', 'g') AS foo;
2023-08-01 17:01:35.162 +07 client backend[295562] pg_regress/strings ERROR:  regexp_split_to_array() does not support the "global" option
2023-08-01 17:01:35.162 +07 client backend[295562] pg_regress/strings STATEMENT:  SELECT regexp_split_to_array('thE QUick bROWn FOx jUMPs ovEr The lazy dOG', 'e', 'g');
2023-08-01 17:01:35.163 +07 client backend[295576] pg_regress/date ERROR:  timestamp units "microsec" not recognized
2023-08-01 17:01:35.163 +07 client backend[295576] pg_regress/date CONTEXT:  SQL function "date_part" statement 1
2023-08-01 17:01:35.163 +07 client backend[295576] pg_regress/date STATEMENT:  SELECT EXTRACT(MICROSEC  FROM DATE 'infinity');
2023-08-01 17:01:35.163 +07 client backend[295576] pg_regress/date ERROR:  date field value out of range: 2013-02-30
2023-08-01 17:01:35.163 +07 client backend[295576] pg_regress/date STATEMENT:  select make_date(2013, 2, 30);
2023-08-01 17:01:35.163 +07 client backend[295576] pg_regress/date ERROR:  date field value out of range: 2013-13-01
2023-08-01 17:01:35.163 +07 client backend[295576] pg_regress/date STATEMENT:  select make_date(2013, 13, 1);
2023-08-01 17:01:35.163 +07 client backend[295576] pg_regress/date ERROR:  date field value out of range: 2013-11--1
2023-08-01 17:01:35.163 +07 client backend[295576] pg_regress/date STATEMENT:  select make_date(2013, 11, -1);
2023-08-01 17:01:35.163 +07 client backend[295576] pg_regress/date ERROR:  time field value out of range: 10:55:100.1
2023-08-01 17:01:35.163 +07 client backend[295576] pg_regress/date STATEMENT:  select make_time(10, 55, 100.1);
2023-08-01 17:01:35.164 +07 client backend[295576] pg_regress/date ERROR:  time field value out of range: 24:00:2.1
2023-08-01 17:01:35.164 +07 client backend[295576] pg_regress/date STATEMENT:  select make_time(24, 0, 2.1);
2023-08-01 17:01:35.165 +07 client backend[295574] pg_regress/tstypes ERROR:  lexeme array may not contain nulls
2023-08-01 17:01:35.165 +07 client backend[295574] pg_regress/tstypes STATEMENT:  SELECT ts_delete('base hidden rebel spaceship strike'::tsvector, ARRAY['spaceship','leya','rebel', NULL]);
2023-08-01 17:01:35.165 +07 client backend[295574] pg_regress/tstypes ERROR:  lexeme array may not contain nulls
2023-08-01 17:01:35.165 +07 client backend[295574] pg_regress/tstypes STATEMENT:  SELECT array_to_tsvector(ARRAY['base','hidden','rebel','spaceship', NULL]);
2023-08-01 17:01:35.166 +07 client backend[295574] pg_regress/tstypes ERROR:  lexeme array may not contain nulls
2023-08-01 17:01:35.166 +07 client backend[295574] pg_regress/tstypes STATEMENT:  SELECT setweight('a asd w:5,6,12B,13A zxc'::tsvector, 'c', ARRAY['a', 'zxc', NULL]);
2023-08-01 17:01:35.166 +07 client backend[295574] pg_regress/tstypes ERROR:  weight array may not contain nulls
2023-08-01 17:01:35.166 +07 client backend[295574] pg_regress/tstypes STATEMENT:  SELECT ts_filter('base hidden rebel spaceship strike'::tsvector, '{a,b,NULL}');
2023-08-01 17:01:35.178 +07 client backend[295562] pg_regress/strings ERROR:  negative substring length not allowed
2023-08-01 17:01:35.178 +07 client backend[295562] pg_regress/strings STATEMENT:  SELECT substr(f1, 5, -1) from toasttest;
2023-08-01 17:01:35.192 +07 client backend[295562] pg_regress/strings ERROR:  negative substring length not allowed
2023-08-01 17:01:35.192 +07 client backend[295562] pg_regress/strings STATEMENT:  SELECT substr(f1, 5, -1) from toasttest;
2023-08-01 17:01:35.207 +07 client backend[295562] pg_regress/strings ERROR:  field position must be greater than zero
2023-08-01 17:01:35.207 +07 client backend[295562] pg_regress/strings STATEMENT:  select split_part('joeuser@mydatabase','@',0) AS "an error";
2023-08-01 17:01:35.209 +07 client backend[295562] pg_regress/strings ERROR:  index 99 out of valid range, 0..71
2023-08-01 17:01:35.209 +07 client backend[295562] pg_regress/strings STATEMENT:  SELECT get_bit('\x1234567890abcdef00'::bytea, 99);
2023-08-01 17:01:35.209 +07 client backend[295562] pg_regress/strings ERROR:  index 99 out of valid range, 0..71
2023-08-01 17:01:35.209 +07 client backend[295562] pg_regress/strings STATEMENT:  SELECT set_bit('\x1234567890abcdef00'::bytea, 99, 0);
2023-08-01 17:01:35.210 +07 client backend[295562] pg_regress/strings ERROR:  index 99 out of valid range, 0..8
2023-08-01 17:01:35.210 +07 client backend[295562] pg_regress/strings STATEMENT:  SELECT get_byte('\x1234567890abcdef00'::bytea, 99);
2023-08-01 17:01:35.210 +07 client backend[295562] pg_regress/strings ERROR:  index 99 out of valid range, 0..8
2023-08-01 17:01:35.210 +07 client backend[295562] pg_regress/strings STATEMENT:  SELECT set_byte('\x1234567890abcdef00'::bytea, 99, 11);
2023-08-01 17:01:35.210 +07 client backend[295562] pg_regress/strings WARNING:  nonstandard use of \\ in a string literal at character 8
2023-08-01 17:01:35.210 +07 client backend[295562] pg_regress/strings HINT:  Use the escape string syntax for backslashes, e.g., E'\\'.
2023-08-01 17:01:35.210 +07 client backend[295562] pg_regress/strings WARNING:  nonstandard use of \\ in a string literal at character 24
2023-08-01 17:01:35.210 +07 client backend[295562] pg_regress/strings HINT:  Use the escape string syntax for backslashes, e.g., E'\\'.
2023-08-01 17:01:35.210 +07 client backend[295562] pg_regress/strings WARNING:  nonstandard use of \\ in a string literal at character 42
2023-08-01 17:01:35.210 +07 client backend[295562] pg_regress/strings HINT:  Use the escape string syntax for backslashes, e.g., E'\\'.
2023-08-01 17:01:35.210 +07 client backend[295562] pg_regress/strings WARNING:  nonstandard use of \\ in a string literal at character 62
2023-08-01 17:01:35.210 +07 client backend[295562] pg_regress/strings HINT:  Use the escape string syntax for backslashes, e.g., E'\\'.
2023-08-01 17:01:35.210 +07 client backend[295562] pg_regress/strings WARNING:  nonstandard use of \\ in a string literal at character 80
2023-08-01 17:01:35.210 +07 client backend[295562] pg_regress/strings HINT:  Use the escape string syntax for backslashes, e.g., E'\\'.
2023-08-01 17:01:35.210 +07 client backend[295562] pg_regress/strings WARNING:  nonstandard use of \\ in a string literal at character 98
2023-08-01 17:01:35.210 +07 client backend[295562] pg_regress/strings HINT:  Use the escape string syntax for backslashes, e.g., E'\\'.
2023-08-01 17:01:35.212 +07 client backend[295562] pg_regress/strings ERROR:  null character not permitted
2023-08-01 17:01:35.212 +07 client backend[295562] pg_regress/strings STATEMENT:  SELECT chr(0);
2023-08-01 17:01:35.212 +07 client backend[295562] pg_regress/strings ERROR:  negative substring length not allowed
2023-08-01 17:01:35.212 +07 client backend[295562] pg_regress/strings STATEMENT:  SELECT SUBSTRING('string'::bytea FROM -10 FOR -2147483646) AS "error";
2023-08-01 17:01:35.450 +07 client backend[295573] pg_regress/timestamptz ERROR:  time zone "america/does_not_exist" not recognized at character 37
2023-08-01 17:01:35.450 +07 client backend[295573] pg_regress/timestamptz STATEMENT:  INSERT INTO TIMESTAMPTZ_TBL VALUES ('19970710 173201 America/Does_not_exist');
2023-08-01 17:01:35.450 +07 client backend[295573] pg_regress/timestamptz ERROR:  time zone "America/Does_not_exist" not recognized
2023-08-01 17:01:35.450 +07 client backend[295573] pg_regress/timestamptz STATEMENT:  SELECT '19970710 173201' AT TIME ZONE 'America/Does_not_exist';
2023-08-01 17:01:35.451 +07 client backend[295575] pg_regress/timestamp ERROR:  time zone "america/does_not_exist" not recognized at character 35
2023-08-01 17:01:35.451 +07 client backend[295575] pg_regress/timestamp STATEMENT:  INSERT INTO TIMESTAMP_TBL VALUES ('19970710 173201 America/Does_not_exist');
2023-08-01 17:01:35.453 +07 client backend[295573] pg_regress/timestamptz ERROR:  date/time field value out of range: "Feb 29 17:32:01 1997" at character 37
2023-08-01 17:01:35.453 +07 client backend[295573] pg_regress/timestamptz STATEMENT:  INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 29 17:32:01 1997');
2023-08-01 17:01:35.453 +07 client backend[295575] pg_regress/timestamp ERROR:  date/time field value out of range: "Feb 29 17:32:01 1997" at character 35
2023-08-01 17:01:35.453 +07 client backend[295575] pg_regress/timestamp STATEMENT:  INSERT INTO TIMESTAMP_TBL VALUES ('Feb 29 17:32:01 1997');
2023-08-01 17:01:35.453 +07 client backend[295573] pg_regress/timestamptz ERROR:  time zone displacement out of range: "Feb 16 17:32:01 -0097" at character 37
2023-08-01 17:01:35.453 +07 client backend[295573] pg_regress/timestamptz STATEMENT:  INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 16 17:32:01 -0097');
2023-08-01 17:01:35.453 +07 client backend[295573] pg_regress/timestamptz ERROR:  timestamp out of range: "Feb 16 17:32:01 5097 BC" at character 37
2023-08-01 17:01:35.453 +07 client backend[295573] pg_regress/timestamptz STATEMENT:  INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 16 17:32:01 5097 BC');
2023-08-01 17:01:35.454 +07 client backend[295575] pg_regress/timestamp ERROR:  time zone displacement out of range: "Feb 16 17:32:01 -0097" at character 35
2023-08-01 17:01:35.454 +07 client backend[295575] pg_regress/timestamp STATEMENT:  INSERT INTO TIMESTAMP_TBL VALUES ('Feb 16 17:32:01 -0097');
2023-08-01 17:01:35.454 +07 client backend[295575] pg_regress/timestamp ERROR:  timestamp out of range: "Feb 16 17:32:01 5097 BC" at character 35
2023-08-01 17:01:35.454 +07 client backend[295575] pg_regress/timestamp STATEMENT:  INSERT INTO TIMESTAMP_TBL VALUES ('Feb 16 17:32:01 5097 BC');
2023-08-01 17:01:35.454 +07 client backend[295575] pg_regress/timestamp ERROR:  timestamp out of range: "4714-11-23 23:59:59 BC" at character 8
2023-08-01 17:01:35.454 +07 client backend[295575] pg_regress/timestamp STATEMENT:  SELECT '4714-11-23 23:59:59 BC'::timestamp;
2023-08-01 17:01:35.454 +07 client backend[295573] pg_regress/timestamptz ERROR:  timestamp out of range: "4714-11-23 23:59:59+00 BC" at character 8
2023-08-01 17:01:35.454 +07 client backend[295573] pg_regress/timestamptz STATEMENT:  SELECT '4714-11-23 23:59:59+00 BC'::timestamptz;
2023-08-01 17:01:35.469 +07 client backend[295573] pg_regress/timestamptz ERROR:  invalid input syntax for type numeric time zone: "2"
2023-08-01 17:01:35.469 +07 client backend[295573] pg_regress/timestamptz HINT:  Numeric time zones must have "-" or "+" as first character.
2023-08-01 17:01:35.469 +07 client backend[295573] pg_regress/timestamptz STATEMENT:  SELECT make_timestamptz(1973, 07, 15, 08, 15, 55.33, '2');
2023-08-01 17:01:35.469 +07 client backend[295573] pg_regress/timestamptz ERROR:  numeric time zone "+16" out of range
2023-08-01 17:01:35.469 +07 client backend[295573] pg_regress/timestamptz STATEMENT:  SELECT make_timestamptz(2014, 12, 10, 10, 10, 10, '+16');
2023-08-01 17:01:35.469 +07 client backend[295573] pg_regress/timestamptz ERROR:  numeric time zone "-16" out of range
2023-08-01 17:01:35.469 +07 client backend[295573] pg_regress/timestamptz STATEMENT:  SELECT make_timestamptz(2014, 12, 10, 10, 10, 10, '-16');
2023-08-01 17:01:35.471 +07 client backend[295573] pg_regress/timestamptz ERROR:  time zone "Nehwon/Lankhmar" not recognized
2023-08-01 17:01:35.471 +07 client backend[295573] pg_regress/timestamptz STATEMENT:  SELECT make_timestamptz(1910, 12, 24, 0, 0, 0, 'Nehwon/Lankhmar');
2023-08-01 17:01:35.475 +07 client backend[295573] pg_regress/timestamptz ERROR:  timestamp cannot be NaN
2023-08-01 17:01:35.475 +07 client backend[295573] pg_regress/timestamptz STATEMENT:  SELECT to_timestamp('NaN'::float);
2023-08-01 17:01:35.501 +07 client backend[295636] pg_regress/unicode ERROR:  invalid normalization form: def
2023-08-01 17:01:35.501 +07 client backend[295636] pg_regress/unicode STATEMENT:  SELECT "normalize"('abc', 'def');
2023-08-01 17:01:35.502 +07 client backend[295636] pg_regress/unicode ERROR:  invalid normalization form: def
2023-08-01 17:01:35.502 +07 client backend[295636] pg_regress/unicode STATEMENT:  SELECT is_normalized('abc', 'def');
2023-08-01 17:01:35.502 +07 client backend[295628] pg_regress/horology ERROR:  date/time field value out of range: "27/12/2001 04:05:06.789-08" at character 33
2023-08-01 17:01:35.502 +07 client backend[295628] pg_regress/horology HINT:  Perhaps you need a different "datestyle" setting.
2023-08-01 17:01:35.502 +07 client backend[295628] pg_regress/horology STATEMENT:  SELECT timestamp with time zone '27/12/2001 04:05:06.789-08';
2023-08-01 17:01:35.504 +07 client backend[295630] pg_regress/regex ERROR:  regexp_match() does not support the "global" option
2023-08-01 17:01:35.504 +07 client backend[295630] pg_regress/regex HINT:  Use the regexp_matches function instead.
2023-08-01 17:01:35.504 +07 client backend[295630] pg_regress/regex STATEMENT:  select regexp_match('abc', 'Bd', 'ig');
2023-08-01 17:01:35.507 +07 client backend[295629] pg_regress/geometry ERROR:  value out of range: underflow
2023-08-01 17:01:35.507 +07 client backend[295629] pg_regress/geometry STATEMENT:  SELECT p1.f1, p2.f1, p1.f1 * p2.f1 FROM POINT_TBL p1, POINT_TBL p2 WHERE p1.f1[0] < 1;
2023-08-01 17:01:35.508 +07 client backend[295628] pg_regress/horology ERROR:  operator does not exist: date - time with time zone at character 26
2023-08-01 17:01:35.508 +07 client backend[295628] pg_regress/horology HINT:  No operator matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:35.508 +07 client backend[295628] pg_regress/horology STATEMENT:  SELECT date '1991-02-03' - time with time zone '04:05:06 UTC' AS "Subtract Time UTC";
2023-08-01 17:01:35.509 +07 client backend[295629] pg_regress/geometry ERROR:  value out of range: overflow
2023-08-01 17:01:35.509 +07 client backend[295629] pg_regress/geometry STATEMENT:  SELECT p1.f1, p2.f1, p1.f1 / p2.f1 FROM POINT_TBL p1, POINT_TBL p2 WHERE p2.f1[0] > 1000;
2023-08-01 17:01:35.509 +07 client backend[295629] pg_regress/geometry ERROR:  division by zero
2023-08-01 17:01:35.509 +07 client backend[295629] pg_regress/geometry STATEMENT:  SELECT p1.f1, p2.f1, p1.f1 / p2.f1 FROM POINT_TBL p1, POINT_TBL p2 WHERE p2.f1 ~= '(0,0)'::point;
2023-08-01 17:01:35.517 +07 client backend[295628] pg_regress/horology ERROR:  cannot cast type time with time zone to interval at character 8
2023-08-01 17:01:35.517 +07 client backend[295628] pg_regress/horology STATEMENT:  SELECT CAST(time with time zone '01:02-08' AS interval) AS "+00:01";
2023-08-01 17:01:35.517 +07 client backend[295628] pg_regress/horology ERROR:  cannot cast type interval to time with time zone at character 8
2023-08-01 17:01:35.517 +07 client backend[295628] pg_regress/horology STATEMENT:  SELECT CAST(interval '02:03' AS time with time zone) AS "02:03:00-08";
2023-08-01 17:01:35.520 +07 client backend[295629] pg_regress/geometry ERROR:  function "dist_lb" not implemented
2023-08-01 17:01:35.520 +07 client backend[295629] pg_regress/geometry STATEMENT:  SELECT l.s, b.f1, l.s <-> b.f1 FROM LINE_TBL l, BOX_TBL b;
2023-08-01 17:01:35.520 +07 client backend[295629] pg_regress/geometry ERROR:  function "dist_bl" not implemented
2023-08-01 17:01:35.520 +07 client backend[295629] pg_regress/geometry STATEMENT:  SELECT l.s, b.f1, b.f1 <-> l.s FROM LINE_TBL l, BOX_TBL b;
2023-08-01 17:01:35.522 +07 client backend[295629] pg_regress/geometry ERROR:  function "close_lb" not implemented
2023-08-01 17:01:35.522 +07 client backend[295629] pg_regress/geometry STATEMENT:  SELECT l.s, b.f1, l.s ## b.f1 FROM LINE_TBL l, BOX_TBL b;
2023-08-01 17:01:35.523 +07 client backend[295629] pg_regress/geometry ERROR:  operator does not exist: lseg # point at character 36
2023-08-01 17:01:35.523 +07 client backend[295629] pg_regress/geometry HINT:  No operator matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:35.523 +07 client backend[295629] pg_regress/geometry STATEMENT:  SELECT '' AS count, p.f1, l.s, l.s # p.f1 AS intersection
	   FROM LSEG_TBL l, POINT_TBL p;
2023-08-01 17:01:35.528 +07 client backend[295628] pg_regress/horology ERROR:  date out of range for timestamp
2023-08-01 17:01:35.528 +07 client backend[295628] pg_regress/horology STATEMENT:  SELECT '2202020-10-05'::date::timestamp;
2023-08-01 17:01:35.528 +07 client backend[295628] pg_regress/horology ERROR:  date out of range for timestamp
2023-08-01 17:01:35.528 +07 client backend[295628] pg_regress/horology STATEMENT:  SELECT '2202020-10-05'::date::timestamptz;
2023-08-01 17:01:35.529 +07 client backend[295629] pg_regress/geometry ERROR:  function "close_sl" not implemented
2023-08-01 17:01:35.529 +07 client backend[295629] pg_regress/geometry STATEMENT:  SELECT l.s, l1.s, l.s ## l1.s FROM LSEG_TBL l, LINE_TBL l1;
2023-08-01 17:01:35.529 +07 client backend[295628] pg_regress/horology ERROR:  date out of range for timestamp
2023-08-01 17:01:35.529 +07 client backend[295628] pg_regress/horology STATEMENT:  SELECT '4714-11-24 BC'::date::timestamptz;
2023-08-01 17:01:35.532 +07 client backend[295628] pg_regress/horology ERROR:  invalid value "/Feb/16" for "Mon"
2023-08-01 17:01:35.532 +07 client backend[295628] pg_regress/horology DETAIL:  The given value did not match any of the allowed values for this field.
2023-08-01 17:01:35.532 +07 client backend[295628] pg_regress/horology STATEMENT:  SELECT to_timestamp('97/Feb/16', 'YYMonDD');
2023-08-01 17:01:35.534 +07 client backend[295629] pg_regress/geometry ERROR:  function "path_center" not implemented
2023-08-01 17:01:35.534 +07 client backend[295629] pg_regress/geometry STATEMENT:  SELECT f1, @@ f1 FROM PATH_TBL;
2023-08-01 17:01:35.534 +07 client backend[295629] pg_regress/geometry ERROR:  open path cannot be converted to polygon
2023-08-01 17:01:35.534 +07 client backend[295629] pg_regress/geometry STATEMENT:  SELECT f1, f1::polygon FROM PATH_TBL WHERE isopen(f1);
2023-08-01 17:01:35.535 +07 client backend[295628] pg_regress/horology ERROR:  formatting field "TZ" is only supported in to_char
2023-08-01 17:01:35.535 +07 client backend[295628] pg_regress/horology STATEMENT:  SELECT to_timestamp('2011-12-18 11:38 PST', 'YYYY-MM-DD HH12:MI TZ');
2023-08-01 17:01:35.536 +07 client backend[295628] pg_regress/horology ERROR:  date/time field value out of range: "2018-11-02 12:34:56.123456789"
2023-08-01 17:01:35.536 +07 client backend[295628] pg_regress/horology STATEMENT:  SELECT i, to_timestamp('2018-11-02 12:34:56.123456789', 'YYYY-MM-DD HH24:MI:SS.FF' || i) FROM generate_series(1, 6) i;
2023-08-01 17:01:35.538 +07 client backend[295628] pg_regress/horology ERROR:  invalid value "+" for "MON"
2023-08-01 17:01:35.538 +07 client backend[295628] pg_regress/horology DETAIL:  The given value did not match any of the allowed values for this field.
2023-08-01 17:01:35.538 +07 client backend[295628] pg_regress/horology STATEMENT:  SELECT to_timestamp('2000 + + JUN', 'YYYY  MON');
2023-08-01 17:01:35.538 +07 client backend[295628] pg_regress/horology ERROR:  invalid value "x1" for "MM"
2023-08-01 17:01:35.538 +07 client backend[295628] pg_regress/horology DETAIL:  Value must be an integer.
2023-08-01 17:01:35.538 +07 client backend[295628] pg_regress/horology STATEMENT:  SELECT to_date('2011 x12 x18', 'YYYYxMMxDD');
2023-08-01 17:01:35.538 +07 client backend[295628] pg_regress/horology ERROR:  invalid combination of date conventions
2023-08-01 17:01:35.538 +07 client backend[295628] pg_regress/horology HINT:  Do not mix Gregorian and ISO week date conventions in a formatting template.
2023-08-01 17:01:35.538 +07 client backend[295628] pg_regress/horology STATEMENT:  SELECT to_timestamp('2005527', 'YYYYIWID');
2023-08-01 17:01:35.539 +07 client backend[295628] pg_regress/horology ERROR:  source string too short for "MM" formatting field
2023-08-01 17:01:35.539 +07 client backend[295628] pg_regress/horology DETAIL:  Field requires 2 characters, but only 1 remain.
2023-08-01 17:01:35.539 +07 client backend[295628] pg_regress/horology HINT:  If your source string is not fixed-width, try using the "FM" modifier.
2023-08-01 17:01:35.539 +07 client backend[295628] pg_regress/horology STATEMENT:  SELECT to_timestamp('19971', 'YYYYMMDD');
2023-08-01 17:01:35.539 +07 client backend[295628] pg_regress/horology ERROR:  invalid value "1)" for "MM"
2023-08-01 17:01:35.539 +07 client backend[295628] pg_regress/horology DETAIL:  Field requires 2 characters, but only 1 could be parsed.
2023-08-01 17:01:35.539 +07 client backend[295628] pg_regress/horology HINT:  If your source string is not fixed-width, try using the "FM" modifier.
2023-08-01 17:01:35.539 +07 client backend[295628] pg_regress/horology STATEMENT:  SELECT to_timestamp('19971)24', 'YYYYMMDD');
2023-08-01 17:01:35.539 +07 client backend[295628] pg_regress/horology ERROR:  invalid value "da" for "DD"
2023-08-01 17:01:35.539 +07 client backend[295628] pg_regress/horology DETAIL:  Value must be an integer.
2023-08-01 17:01:35.539 +07 client backend[295628] pg_regress/horology STATEMENT:  SELECT to_timestamp('Friday 1-January-1999', 'DY DD MON YYYY');
2023-08-01 17:01:35.539 +07 client backend[295628] pg_regress/horology ERROR:  invalid value "uary" for "YYYY"
2023-08-01 17:01:35.539 +07 client backend[295628] pg_regress/horology DETAIL:  Value must be an integer.
2023-08-01 17:01:35.539 +07 client backend[295628] pg_regress/horology STATEMENT:  SELECT to_timestamp('Fri 1-January-1999', 'DY DD MON YYYY');
2023-08-01 17:01:35.539 +07 client backend[295628] pg_regress/horology ERROR:  conflicting values for "Mon" field in formatting string
2023-08-01 17:01:35.539 +07 client backend[295628] pg_regress/horology DETAIL:  This value contradicts a previous setting for the same field type.
2023-08-01 17:01:35.539 +07 client backend[295628] pg_regress/horology STATEMENT:  SELECT to_timestamp('1997-11-Jan-16', 'YYYY-MM-Mon-DD');
2023-08-01 17:01:35.539 +07 client backend[295628] pg_regress/horology ERROR:  invalid value "xy" for "DD"
2023-08-01 17:01:35.539 +07 client backend[295628] pg_regress/horology DETAIL:  Value must be an integer.
2023-08-01 17:01:35.539 +07 client backend[295628] pg_regress/horology STATEMENT:  SELECT to_timestamp('199711xy', 'YYYYMMDD');
2023-08-01 17:01:35.539 +07 client backend[295628] pg_regress/horology ERROR:  value for "YYYY" in source string is out of range
2023-08-01 17:01:35.539 +07 client backend[295628] pg_regress/horology DETAIL:  Value must be in the range -2147483648 to 2147483647.
2023-08-01 17:01:35.539 +07 client backend[295628] pg_regress/horology STATEMENT:  SELECT to_timestamp('10000000000', 'FMYYYY');
2023-08-01 17:01:35.539 +07 client backend[295628] pg_regress/horology ERROR:  date/time field value out of range: "2016-06-13 25:00:00"
2023-08-01 17:01:35.539 +07 client backend[295628] pg_regress/horology STATEMENT:  SELECT to_timestamp('2016-06-13 25:00:00', 'YYYY-MM-DD HH24:MI:SS');
2023-08-01 17:01:35.539 +07 client backend[295628] pg_regress/horology ERROR:  date/time field value out of range: "2016-06-13 15:60:00"
2023-08-01 17:01:35.539 +07 client backend[295628] pg_regress/horology STATEMENT:  SELECT to_timestamp('2016-06-13 15:60:00', 'YYYY-MM-DD HH24:MI:SS');
2023-08-01 17:01:35.539 +07 client backend[295628] pg_regress/horology ERROR:  date/time field value out of range: "2016-06-13 15:50:60"
2023-08-01 17:01:35.539 +07 client backend[295628] pg_regress/horology STATEMENT:  SELECT to_timestamp('2016-06-13 15:50:60', 'YYYY-MM-DD HH24:MI:SS');
2023-08-01 17:01:35.539 +07 client backend[295628] pg_regress/horology ERROR:  hour "15" is invalid for the 12-hour clock
2023-08-01 17:01:35.539 +07 client backend[295628] pg_regress/horology HINT:  Use the 24-hour clock, or give an hour between 1 and 12.
2023-08-01 17:01:35.539 +07 client backend[295628] pg_regress/horology STATEMENT:  SELECT to_timestamp('2016-06-13 15:50:55', 'YYYY-MM-DD HH:MI:SS');
2023-08-01 17:01:35.539 +07 client backend[295628] pg_regress/horology ERROR:  date/time field value out of range: "2016-13-01 15:50:55"
2023-08-01 17:01:35.539 +07 client backend[295628] pg_regress/horology STATEMENT:  SELECT to_timestamp('2016-13-01 15:50:55', 'YYYY-MM-DD HH24:MI:SS');
2023-08-01 17:01:35.539 +07 client backend[295628] pg_regress/horology ERROR:  date/time field value out of range: "2016-02-30 15:50:55"
2023-08-01 17:01:35.539 +07 client backend[295628] pg_regress/horology STATEMENT:  SELECT to_timestamp('2016-02-30 15:50:55', 'YYYY-MM-DD HH24:MI:SS');
2023-08-01 17:01:35.539 +07 client backend[295628] pg_regress/horology ERROR:  date/time field value out of range: "2015-02-29 15:50:55"
2023-08-01 17:01:35.539 +07 client backend[295628] pg_regress/horology STATEMENT:  SELECT to_timestamp('2015-02-29 15:50:55', 'YYYY-MM-DD HH24:MI:SS');
2023-08-01 17:01:35.539 +07 client backend[295628] pg_regress/horology ERROR:  date/time field value out of range: "2015-02-11 86400"
2023-08-01 17:01:35.539 +07 client backend[295628] pg_regress/horology STATEMENT:  SELECT to_timestamp('2015-02-11 86400', 'YYYY-MM-DD SSSS');
2023-08-01 17:01:35.540 +07 client backend[295628] pg_regress/horology ERROR:  date/time field value out of range: "2015-02-11 86400"
2023-08-01 17:01:35.540 +07 client backend[295628] pg_regress/horology STATEMENT:  SELECT to_timestamp('2015-02-11 86400', 'YYYY-MM-DD SSSSS');
2023-08-01 17:01:35.540 +07 client backend[295628] pg_regress/horology ERROR:  date/time field value out of range: "2016-13-10"
2023-08-01 17:01:35.540 +07 client backend[295628] pg_regress/horology STATEMENT:  SELECT to_date('2016-13-10', 'YYYY-MM-DD');
2023-08-01 17:01:35.540 +07 client backend[295628] pg_regress/horology ERROR:  date/time field value out of range: "2016-02-30"
2023-08-01 17:01:35.540 +07 client backend[295628] pg_regress/horology STATEMENT:  SELECT to_date('2016-02-30', 'YYYY-MM-DD');
2023-08-01 17:01:35.540 +07 client backend[295628] pg_regress/horology ERROR:  date/time field value out of range: "2015-02-29"
2023-08-01 17:01:35.540 +07 client backend[295628] pg_regress/horology STATEMENT:  SELECT to_date('2015-02-29', 'YYYY-MM-DD');
2023-08-01 17:01:35.540 +07 client backend[295629] pg_regress/geometry ERROR:  division by zero
2023-08-01 17:01:35.540 +07 client backend[295629] pg_regress/geometry STATEMENT:  SELECT p.f1, p1.f1, p.f1 / p1.f1 FROM PATH_TBL p, POINT_TBL p1 WHERE p1.f1 ~= '(0,0)'::point;
2023-08-01 17:01:35.540 +07 client backend[295628] pg_regress/horology ERROR:  date/time field value out of range: "2015 366"
2023-08-01 17:01:35.540 +07 client backend[295628] pg_regress/horology STATEMENT:  SELECT to_date('2015 366', 'YYYY DDD');
2023-08-01 17:01:35.540 +07 client backend[295628] pg_regress/horology ERROR:  date/time field value out of range: "2016 367"
2023-08-01 17:01:35.540 +07 client backend[295628] pg_regress/horology STATEMENT:  SELECT to_date('2016 367', 'YYYY DDD');
2023-08-01 17:01:35.547 +07 client backend[295629] pg_regress/geometry ERROR:  function "poly_distance" not implemented
2023-08-01 17:01:35.547 +07 client backend[295629] pg_regress/geometry STATEMENT:  SELECT p1.f1, p2.f1, p1.f1 <-> p2.f1 FROM POLYGON_TBL p1, POLYGON_TBL p2;
2023-08-01 17:01:35.549 +07 client backend[295629] pg_regress/geometry ERROR:  must request at least 2 points
2023-08-01 17:01:35.549 +07 client backend[295629] pg_regress/geometry STATEMENT:  SELECT f1, polygon(1, f1) FROM CIRCLE_TBL WHERE f1 >= '<(0,0),1>';
2023-08-01 17:01:35.549 +07 client backend[295629] pg_regress/geometry ERROR:  cannot convert circle with radius zero to polygon
2023-08-01 17:01:35.549 +07 client backend[295629] pg_regress/geometry STATEMENT:  SELECT f1, polygon(10, f1) FROM CIRCLE_TBL WHERE f1 < '<(0,0),1>';
2023-08-01 17:01:35.556 +07 client backend[295629] pg_regress/geometry ERROR:  value out of range: overflow
2023-08-01 17:01:35.556 +07 client backend[295629] pg_regress/geometry STATEMENT:  SELECT c.f1, p.f1, c.f1 / p.f1 FROM CIRCLE_TBL c, POINT_TBL p WHERE p.f1[0] > 1000;
2023-08-01 17:01:35.556 +07 client backend[295629] pg_regress/geometry ERROR:  division by zero
2023-08-01 17:01:35.556 +07 client backend[295629] pg_regress/geometry STATEMENT:  SELECT c.f1, p.f1, c.f1 / p.f1 FROM CIRCLE_TBL c, POINT_TBL p WHERE p.f1 ~= '(0,0)'::point;
2023-08-01 17:01:35.682 +07 client backend[295630] pg_regress/regex ERROR:  invalid regular expression: regular expression is too complex
2023-08-01 17:01:35.682 +07 client backend[295630] pg_regress/regex STATEMENT:  select 'x' ~ repeat('x*y*z*', 1000);
2023-08-01 17:01:35.684 +07 client backend[295630] pg_regress/regex ERROR:  invalid regular expression: invalid backreference number
2023-08-01 17:01:35.684 +07 client backend[295630] pg_regress/regex STATEMENT:  select 'xyz' ~ 'x(\w)(?=\1)';
2023-08-01 17:01:35.684 +07 client backend[295630] pg_regress/regex ERROR:  invalid regular expression: invalid backreference number
2023-08-01 17:01:35.684 +07 client backend[295630] pg_regress/regex STATEMENT:  select 'xyz' ~ 'x(\w)(?=(\1))';
2023-08-01 17:01:35.684 +07 client backend[295630] pg_regress/regex ERROR:  invalid regular expression: invalid escape \ sequence
2023-08-01 17:01:35.684 +07 client backend[295630] pg_regress/regex STATEMENT:  select 'a' ~ '\x7fffffff';
2023-08-01 17:01:35.713 +07 client backend[295659] pg_regress/create_function_1 ERROR:  return type mismatch in function declared to return integer
2023-08-01 17:01:35.713 +07 client backend[295659] pg_regress/create_function_1 DETAIL:  Actual return type is text.
2023-08-01 17:01:35.713 +07 client backend[295659] pg_regress/create_function_1 CONTEXT:  SQL function "test1"
2023-08-01 17:01:35.713 +07 client backend[295659] pg_regress/create_function_1 STATEMENT:  CREATE FUNCTION test1 (int) RETURNS int LANGUAGE SQL
	    AS 'SELECT ''not an integer'';';
2023-08-01 17:01:35.713 +07 client backend[295659] pg_regress/create_function_1 ERROR:  syntax error at or near "not" at character 62
2023-08-01 17:01:35.713 +07 client backend[295659] pg_regress/create_function_1 STATEMENT:  CREATE FUNCTION test1 (int) RETURNS int LANGUAGE SQL
	    AS 'not even SQL';
2023-08-01 17:01:35.713 +07 client backend[295659] pg_regress/create_function_1 ERROR:  return type mismatch in function declared to return integer
2023-08-01 17:01:35.713 +07 client backend[295659] pg_regress/create_function_1 DETAIL:  Final statement must return exactly one column.
2023-08-01 17:01:35.713 +07 client backend[295659] pg_regress/create_function_1 CONTEXT:  SQL function "test1"
2023-08-01 17:01:35.713 +07 client backend[295659] pg_regress/create_function_1 STATEMENT:  CREATE FUNCTION test1 (int) RETURNS int LANGUAGE SQL
	    AS 'SELECT 1, 2, 3;';
2023-08-01 17:01:35.713 +07 client backend[295659] pg_regress/create_function_1 ERROR:  there is no parameter $2 at character 69
2023-08-01 17:01:35.713 +07 client backend[295659] pg_regress/create_function_1 STATEMENT:  CREATE FUNCTION test1 (int) RETURNS int LANGUAGE SQL
	    AS 'SELECT $2;';
2023-08-01 17:01:35.713 +07 client backend[295659] pg_regress/create_function_1 ERROR:  only one AS item needed for language "sql"
2023-08-01 17:01:35.713 +07 client backend[295659] pg_regress/create_function_1 STATEMENT:  CREATE FUNCTION test1 (int) RETURNS int LANGUAGE SQL
	    AS 'a', 'b';
2023-08-01 17:01:35.713 +07 client backend[295659] pg_regress/create_function_1 ERROR:  could not access file "nosuchfile": No such file or directory
2023-08-01 17:01:35.713 +07 client backend[295659] pg_regress/create_function_1 STATEMENT:  CREATE FUNCTION test1 (int) RETURNS int LANGUAGE C
	    AS 'nosuchfile';
2023-08-01 17:01:35.714 +07 client backend[295659] pg_regress/create_function_1 ERROR:  could not find function "nosuchsymbol" in file "/home/vlad/postgres_cluster/build/src/test/regress/regress.so"
2023-08-01 17:01:35.714 +07 client backend[295659] pg_regress/create_function_1 STATEMENT:  CREATE FUNCTION test1 (int) RETURNS int LANGUAGE C
	    AS '/home/vlad/postgres_cluster/build/src/test/regress/regress.so', 'nosuchsymbol';
2023-08-01 17:01:35.714 +07 client backend[295659] pg_regress/create_function_1 ERROR:  there is no built-in function named "nosuch"
2023-08-01 17:01:35.714 +07 client backend[295659] pg_regress/create_function_1 STATEMENT:  CREATE FUNCTION test1 (int) RETURNS int LANGUAGE internal
	    AS 'nosuch';
2023-08-01 17:01:35.717 +07 client backend[295663] pg_regress/create_type ERROR:  type "shell" already exists
2023-08-01 17:01:35.717 +07 client backend[295663] pg_regress/create_type STATEMENT:  CREATE TYPE shell;
2023-08-01 17:01:35.718 +07 client backend[295663] pg_regress/create_type ERROR:  type "shell" does not exist
2023-08-01 17:01:35.718 +07 client backend[295663] pg_regress/create_type STATEMENT:  DROP TYPE shell;
2023-08-01 17:01:35.720 +07 client backend[295663] pg_regress/create_type WARNING:  type attribute "Internallength" not recognized at character 27
2023-08-01 17:01:35.720 +07 client backend[295663] pg_regress/create_type WARNING:  type attribute "Input" not recognized at character 50
2023-08-01 17:01:35.720 +07 client backend[295663] pg_regress/create_type WARNING:  type attribute "Output" not recognized at character 71
2023-08-01 17:01:35.720 +07 client backend[295663] pg_regress/create_type WARNING:  type attribute "Alignment" not recognized at character 94
2023-08-01 17:01:35.720 +07 client backend[295663] pg_regress/create_type WARNING:  type attribute "Default" not recognized at character 115
2023-08-01 17:01:35.720 +07 client backend[295663] pg_regress/create_type WARNING:  type attribute "Passedbyvalue" not recognized at character 132
2023-08-01 17:01:35.720 +07 client backend[295663] pg_regress/create_type ERROR:  type input function must be specified
2023-08-01 17:01:35.720 +07 client backend[295663] pg_regress/create_type STATEMENT:  CREATE TYPE bogus_type (
		"Internallength" = 4,
		"Input" = int42_in,
		"Output" = int42_out,
		"Alignment" = int4,
		"Default" = 42,
		"Passedbyvalue"
	);
2023-08-01 17:01:35.720 +07 client backend[295663] pg_regress/create_type ERROR:  type input function array_in must return type bogus_type
2023-08-01 17:01:35.720 +07 client backend[295663] pg_regress/create_type STATEMENT:  CREATE TYPE bogus_type (INPUT = array_in,
	    OUTPUT = array_out,
	    ELEMENT = int,
	    INTERNALLENGTH = 32);
2023-08-01 17:01:35.720 +07 client backend[295663] pg_regress/create_type ERROR:  type "bogus_type" does not exist
2023-08-01 17:01:35.720 +07 client backend[295663] pg_regress/create_type HINT:  Create the type as a shell type, then create its I/O functions, then do a full CREATE TYPE.
2023-08-01 17:01:35.720 +07 client backend[295663] pg_regress/create_type STATEMENT:  CREATE TYPE bogus_type (INPUT = array_in,
	    OUTPUT = array_out,
	    ELEMENT = int,
	    INTERNALLENGTH = 32);
2023-08-01 17:01:35.720 +07 client backend[295663] pg_regress/create_type ERROR:  type "bad" does not exist
2023-08-01 17:01:35.720 +07 client backend[295663] pg_regress/create_type STATEMENT:  COMMENT ON TYPE bad IS 'bad comment';
2023-08-01 17:01:35.720 +07 client backend[295663] pg_regress/create_type ERROR:  column "nope" of relation "default_test_row" does not exist
2023-08-01 17:01:35.720 +07 client backend[295663] pg_regress/create_type STATEMENT:  COMMENT ON COLUMN default_test_row.nope IS 'bad comment';
2023-08-01 17:01:35.721 +07 client backend[295663] pg_regress/create_type ERROR:  type "text_w_default" already exists
2023-08-01 17:01:35.721 +07 client backend[295663] pg_regress/create_type STATEMENT:  CREATE TYPE text_w_default;
2023-08-01 17:01:35.722 +07 client backend[295663] pg_regress/create_type ERROR:  cannot drop function base_fn_in(cstring) because other objects depend on it
2023-08-01 17:01:35.722 +07 client backend[295663] pg_regress/create_type DETAIL:  type base_type depends on function base_fn_in(cstring)
	function base_fn_out(base_type) depends on type base_type
2023-08-01 17:01:35.722 +07 client backend[295663] pg_regress/create_type HINT:  Use DROP ... CASCADE to drop the dependent objects too.
2023-08-01 17:01:35.722 +07 client backend[295663] pg_regress/create_type STATEMENT:  DROP FUNCTION base_fn_in(cstring);
2023-08-01 17:01:35.722 +07 client backend[295663] pg_regress/create_type ERROR:  cannot drop function base_fn_out(base_type) because other objects depend on it
2023-08-01 17:01:35.722 +07 client backend[295663] pg_regress/create_type DETAIL:  type base_type depends on function base_fn_out(base_type)
	function base_fn_in(cstring) depends on type base_type
2023-08-01 17:01:35.722 +07 client backend[295663] pg_regress/create_type HINT:  Use DROP ... CASCADE to drop the dependent objects too.
2023-08-01 17:01:35.722 +07 client backend[295663] pg_regress/create_type STATEMENT:  DROP FUNCTION base_fn_out(base_type);
2023-08-01 17:01:35.722 +07 client backend[295663] pg_regress/create_type ERROR:  cannot drop type base_type because other objects depend on it
2023-08-01 17:01:35.722 +07 client backend[295663] pg_regress/create_type DETAIL:  function base_fn_in(cstring) depends on type base_type
	function base_fn_out(base_type) depends on type base_type
2023-08-01 17:01:35.722 +07 client backend[295663] pg_regress/create_type HINT:  Use DROP ... CASCADE to drop the dependent objects too.
2023-08-01 17:01:35.722 +07 client backend[295663] pg_regress/create_type STATEMENT:  DROP TYPE base_type;
2023-08-01 17:01:35.722 +07 client backend[295663] pg_regress/create_type ERROR:  invalid NUMERIC type modifier at character 30
2023-08-01 17:01:35.722 +07 client backend[295663] pg_regress/create_type STATEMENT:  CREATE TEMP TABLE mytab (foo widget(42,13,7));
2023-08-01 17:01:35.724 +07 client backend[295663] pg_regress/create_type ERROR:  type "myvarchar" is only a shell
2023-08-01 17:01:35.724 +07 client backend[295663] pg_regress/create_type STATEMENT:  ALTER TYPE myvarchar SET (storage = extended);
2023-08-01 17:01:35.724 +07 client backend[295663] pg_regress/create_type ERROR:  cannot change type's storage to PLAIN
2023-08-01 17:01:35.724 +07 client backend[295663] pg_regress/create_type STATEMENT:  ALTER TYPE myvarchar SET (storage = plain);
2023-08-01 17:01:35.725 +07 client backend[295663] pg_regress/create_type ERROR:  cannot drop function myvarcharsend(myvarchar) because other objects depend on it
2023-08-01 17:01:35.725 +07 client backend[295663] pg_regress/create_type DETAIL:  type myvarchar depends on function myvarcharsend(myvarchar)
	function myvarcharin(cstring,oid,integer) depends on type myvarchar
	function myvarcharout(myvarchar) depends on type myvarchar
	function myvarcharrecv(internal,oid,integer) depends on type myvarchar
	type myvarchardom depends on function myvarcharsend(myvarchar)
2023-08-01 17:01:35.725 +07 client backend[295663] pg_regress/create_type HINT:  Use DROP ... CASCADE to drop the dependent objects too.
2023-08-01 17:01:35.725 +07 client backend[295663] pg_regress/create_type STATEMENT:  DROP FUNCTION myvarcharsend(myvarchar);
2023-08-01 17:01:35.725 +07 client backend[295663] pg_regress/create_type ERROR:  cannot drop type myvarchar because other objects depend on it
2023-08-01 17:01:35.725 +07 client backend[295663] pg_regress/create_type DETAIL:  function myvarcharin(cstring,oid,integer) depends on type myvarchar
	function myvarcharout(myvarchar) depends on type myvarchar
	function myvarcharsend(myvarchar) depends on type myvarchar
	function myvarcharrecv(internal,oid,integer) depends on type myvarchar
	type myvarchardom depends on type myvarchar
2023-08-01 17:01:35.725 +07 client backend[295663] pg_regress/create_type HINT:  Use DROP ... CASCADE to drop the dependent objects too.
2023-08-01 17:01:35.725 +07 client backend[295663] pg_regress/create_type STATEMENT:  DROP TYPE myvarchar;
2023-08-01 17:01:35.745 +07 client backend[295667] pg_regress/create_table ERROR:  column "u" has pseudo-type unknown
2023-08-01 17:01:35.745 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE unknowntab (
		u unknown    
	);
2023-08-01 17:01:35.745 +07 client backend[295667] pg_regress/create_table ERROR:  column "u" has pseudo-type unknown
2023-08-01 17:01:35.745 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TYPE unknown_comptype AS (
		u unknown    
	);
2023-08-01 17:01:35.746 +07 client backend[295667] pg_regress/create_table ERROR:  unrecognized parameter "Fillfactor"
2023-08-01 17:01:35.746 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE tas_case WITH ("Fillfactor" = 10) AS SELECT 1 a;
2023-08-01 17:01:35.749 +07 client backend[295667] pg_regress/create_table ERROR:  only temporary relations may be created in temporary schemas at character 23
2023-08-01 17:01:35.749 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE UNLOGGED TABLE pg_temp.unlogged3 (a int primary key);
2023-08-01 17:01:35.751 +07 client backend[295667] pg_regress/create_table ERROR:  cannot create temporary relation in non-temporary schema at character 19
2023-08-01 17:01:35.751 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TEMP TABLE public.temp_to_perm (a int primary key);
2023-08-01 17:01:35.752 +07 client backend[295667] pg_regress/create_table ERROR:  relation "as_select1" already exists
2023-08-01 17:01:35.752 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE as_select1 AS SELECT * FROM pg_class WHERE relkind = 'r';
2023-08-01 17:01:35.753 +07 client backend[295667] pg_regress/create_table ERROR:  relation "as_select1" already exists
2023-08-01 17:01:35.753 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE as_select1 AS EXECUTE select1;
2023-08-01 17:01:35.772 +07 client backend[295667] pg_regress/create_table ERROR:  syntax error at or near "OIDS" at character 29
2023-08-01 17:01:35.772 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE withoid() WITH OIDS;
2023-08-01 17:01:35.772 +07 client backend[295667] pg_regress/create_table ERROR:  tables declared WITH OIDS are not supported
2023-08-01 17:01:35.772 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE withoid() WITH (oids);
2023-08-01 17:01:35.772 +07 client backend[295667] pg_regress/create_table ERROR:  tables declared WITH OIDS are not supported
2023-08-01 17:01:35.772 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE withoid() WITH (oids = true);
2023-08-01 17:01:35.773 +07 client backend[295667] pg_regress/create_table ERROR:  cannot use column reference in DEFAULT expression at character 51
2023-08-01 17:01:35.773 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE default_expr_column (id int DEFAULT (id));
2023-08-01 17:01:35.773 +07 client backend[295667] pg_regress/create_table ERROR:  cannot use column reference in DEFAULT expression at character 51
2023-08-01 17:01:35.773 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE default_expr_column (id int DEFAULT (bar.id));
2023-08-01 17:01:35.773 +07 client backend[295667] pg_regress/create_table ERROR:  cannot use column reference in DEFAULT expression at character 59
2023-08-01 17:01:35.773 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE default_expr_agg_column (id int DEFAULT (avg(id)));
2023-08-01 17:01:35.774 +07 client backend[295667] pg_regress/create_table ERROR:  cannot use column reference in DEFAULT expression at character 58
2023-08-01 17:01:35.774 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE default_expr_non_column (a int DEFAULT (avg(non_existent)));
2023-08-01 17:01:35.774 +07 client backend[295667] pg_regress/create_table ERROR:  aggregate functions are not allowed in DEFAULT expressions at character 47
2023-08-01 17:01:35.774 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE default_expr_agg (a int DEFAULT (avg(1)));
2023-08-01 17:01:35.774 +07 client backend[295667] pg_regress/create_table ERROR:  cannot use subquery in DEFAULT expression at character 46
2023-08-01 17:01:35.774 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE default_expr_agg (a int DEFAULT (select 1));
2023-08-01 17:01:35.775 +07 client backend[295667] pg_regress/create_table ERROR:  set-returning functions are not allowed in DEFAULT expressions at character 47
2023-08-01 17:01:35.775 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE default_expr_agg (a int DEFAULT (generate_series(1,3)));
2023-08-01 17:01:35.777 +07 client backend[295667] pg_regress/create_table ERROR:  cannot create partitioned table as inheritance child
2023-08-01 17:01:35.777 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE partitioned (
		a int
	) INHERITS (some_table) PARTITION BY LIST (a);
2023-08-01 17:01:35.777 +07 client backend[295667] pg_regress/create_table ERROR:  cannot use "list" partition strategy with more than one column
2023-08-01 17:01:35.777 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE partitioned (
		a1 int,
		a2 int
	) PARTITION BY LIST (a1, a2);
2023-08-01 17:01:35.777 +07 client backend[295667] pg_regress/create_table ERROR:  exclusion constraints are not supported on partitioned tables at character 37
2023-08-01 17:01:35.777 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE partitioned (
		a int,
		EXCLUDE USING gist (a WITH &&)
	) PARTITION BY RANGE (a);
2023-08-01 17:01:35.777 +07 client backend[295667] pg_regress/create_table ERROR:  set-returning functions are not allowed in partition key expressions
2023-08-01 17:01:35.777 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE partitioned (
		a int
	) PARTITION BY RANGE (retset(a));
2023-08-01 17:01:35.778 +07 client backend[295667] pg_regress/create_table ERROR:  aggregate functions are not allowed in partition key expressions
2023-08-01 17:01:35.778 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE partitioned (
		a int
	) PARTITION BY RANGE ((avg(a)));
2023-08-01 17:01:35.778 +07 client backend[295667] pg_regress/create_table ERROR:  window functions are not allowed in partition key expressions
2023-08-01 17:01:35.778 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE partitioned (
		a int,
		b int
	) PARTITION BY RANGE ((avg(a) OVER (PARTITION BY b)));
2023-08-01 17:01:35.778 +07 client backend[295667] pg_regress/create_table ERROR:  cannot use subquery in partition key expression
2023-08-01 17:01:35.778 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE partitioned (
		a int
	) PARTITION BY LIST ((a LIKE (SELECT 1)));
2023-08-01 17:01:35.778 +07 client backend[295667] pg_regress/create_table ERROR:  cannot use constant expression as partition key
2023-08-01 17:01:35.778 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE partitioned (
		a int
	) PARTITION BY RANGE ((42));
2023-08-01 17:01:35.779 +07 client backend[295667] pg_regress/create_table ERROR:  cannot use constant expression as partition key
2023-08-01 17:01:35.779 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE partitioned (
		a int
	) PARTITION BY RANGE (const_func());
2023-08-01 17:01:35.779 +07 client backend[295667] pg_regress/create_table ERROR:  unrecognized partitioning strategy "magic"
2023-08-01 17:01:35.779 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE partitioned (
	    a int
	) PARTITION BY MAGIC (a);
2023-08-01 17:01:35.779 +07 client backend[295667] pg_regress/create_table ERROR:  column "b" named in partition key does not exist at character 57
2023-08-01 17:01:35.779 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE partitioned (
		a int
	) PARTITION BY RANGE (b);
2023-08-01 17:01:35.780 +07 client backend[295667] pg_regress/create_table ERROR:  cannot use system column "xmin" in partition key at character 57
2023-08-01 17:01:35.780 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE partitioned (
		a int
	) PARTITION BY RANGE (xmin);
2023-08-01 17:01:35.780 +07 client backend[295667] pg_regress/create_table ERROR:  partition key column 1 has pseudo-type record
2023-08-01 17:01:35.780 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE partitioned (
		a int,
		b int
	) PARTITION BY RANGE (((a, b)));
2023-08-01 17:01:35.780 +07 client backend[295667] pg_regress/create_table ERROR:  partition key column 2 has pseudo-type unknown
2023-08-01 17:01:35.780 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE partitioned (
		a int,
		b int
	) PARTITION BY RANGE (a, ('unknown'));
2023-08-01 17:01:35.780 +07 client backend[295667] pg_regress/create_table ERROR:  functions in partition key expression must be marked IMMUTABLE
2023-08-01 17:01:35.780 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE partitioned (
		a int
	) PARTITION BY RANGE (immut_func(a));
2023-08-01 17:01:35.781 +07 client backend[295667] pg_regress/create_table ERROR:  data type point has no default operator class for access method "btree"
2023-08-01 17:01:35.781 +07 client backend[295667] pg_regress/create_table HINT:  You must specify a btree operator class or define a default btree operator class for the data type.
2023-08-01 17:01:35.781 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE partitioned (
		a point
	) PARTITION BY LIST (a);
2023-08-01 17:01:35.781 +07 client backend[295667] pg_regress/create_table ERROR:  operator class "point_ops" does not exist for access method "btree"
2023-08-01 17:01:35.781 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE partitioned (
		a point
	) PARTITION BY LIST (a point_ops);
2023-08-01 17:01:35.781 +07 client backend[295667] pg_regress/create_table ERROR:  data type point has no default operator class for access method "btree"
2023-08-01 17:01:35.781 +07 client backend[295667] pg_regress/create_table HINT:  You must specify a btree operator class or define a default btree operator class for the data type.
2023-08-01 17:01:35.781 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE partitioned (
		a point
	) PARTITION BY RANGE (a);
2023-08-01 17:01:35.782 +07 client backend[295667] pg_regress/create_table ERROR:  operator class "point_ops" does not exist for access method "btree"
2023-08-01 17:01:35.782 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE partitioned (
		a point
	) PARTITION BY RANGE (a point_ops);
2023-08-01 17:01:35.782 +07 client backend[295667] pg_regress/create_table ERROR:  cannot add NO INHERIT constraint to partitioned table "partitioned"
2023-08-01 17:01:35.782 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE partitioned (
		a int,
		CONSTRAINT check_a CHECK (a > 0) NO INHERIT
	) PARTITION BY RANGE (a);
2023-08-01 17:01:35.783 +07 client backend[295667] pg_regress/create_table ERROR:  cannot drop function plusone(integer) because other objects depend on it
2023-08-01 17:01:35.783 +07 client backend[295667] pg_regress/create_table DETAIL:  table partitioned depends on function plusone(integer)
2023-08-01 17:01:35.783 +07 client backend[295667] pg_regress/create_table HINT:  Use DROP ... CASCADE to drop the dependent objects too.
2023-08-01 17:01:35.783 +07 client backend[295667] pg_regress/create_table STATEMENT:  DROP FUNCTION plusone(int);
2023-08-01 17:01:35.783 +07 client backend[295667] pg_regress/create_table ERROR:  cannot inherit from partitioned table "partitioned2"
2023-08-01 17:01:35.783 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE fail () INHERITS (partitioned2);
2023-08-01 17:01:35.789 +07 client backend[295667] pg_regress/create_table ERROR:  no partition of relation "partitioned2" found for row
2023-08-01 17:01:35.789 +07 client backend[295667] pg_regress/create_table DETAIL:  Partition key of the failing row contains ((a + 1), substr(b, 1, 5)) = (2, hello).
2023-08-01 17:01:35.789 +07 client backend[295667] pg_regress/create_table STATEMENT:  INSERT INTO partitioned2 VALUES (1, 'hello');
2023-08-01 17:01:35.799 +07 client backend[295667] pg_regress/create_table ERROR:  cannot drop column "a" because it is part of the partition key of relation "partitioned"
2023-08-01 17:01:35.799 +07 client backend[295667] pg_regress/create_table STATEMENT:  alter table partitioned drop column a;
2023-08-01 17:01:35.799 +07 client backend[295667] pg_regress/create_table ERROR:  cannot drop type intdom1 because other objects depend on it
2023-08-01 17:01:35.799 +07 client backend[295667] pg_regress/create_table DETAIL:  table partitioned depends on type intdom1
2023-08-01 17:01:35.799 +07 client backend[295667] pg_regress/create_table HINT:  Use DROP ... CASCADE to drop the dependent objects too.
2023-08-01 17:01:35.799 +07 client backend[295667] pg_regress/create_table STATEMENT:  drop domain intdom1;
2023-08-01 17:01:35.799 +07 client backend[295667] pg_regress/create_table ERROR:  relation "partitioned" does not exist at character 7
2023-08-01 17:01:35.799 +07 client backend[295667] pg_regress/create_table STATEMENT:  table partitioned;
2023-08-01 17:01:35.800 +07 client backend[295667] pg_regress/create_table ERROR:  cannot drop column "a" because it is part of the partition key of relation "partitioned"
2023-08-01 17:01:35.800 +07 client backend[295667] pg_regress/create_table STATEMENT:  alter table partitioned drop column a;
2023-08-01 17:01:35.800 +07 client backend[295667] pg_regress/create_table ERROR:  cannot drop type intdom1 because other objects depend on it
2023-08-01 17:01:35.800 +07 client backend[295667] pg_regress/create_table DETAIL:  table partitioned depends on type intdom1
2023-08-01 17:01:35.800 +07 client backend[295667] pg_regress/create_table HINT:  Use DROP ... CASCADE to drop the dependent objects too.
2023-08-01 17:01:35.800 +07 client backend[295667] pg_regress/create_table STATEMENT:  drop domain intdom1;
2023-08-01 17:01:35.800 +07 client backend[295667] pg_regress/create_table ERROR:  relation "partitioned" does not exist at character 7
2023-08-01 17:01:35.800 +07 client backend[295667] pg_regress/create_table STATEMENT:  table partitioned;
2023-08-01 17:01:35.805 +07 client backend[295667] pg_regress/create_table ERROR:  cannot use column reference in partition bound expression at character 75
2023-08-01 17:01:35.805 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (somename);
2023-08-01 17:01:35.805 +07 client backend[295667] pg_regress/create_table ERROR:  cannot use column reference in partition bound expression at character 75
2023-08-01 17:01:35.805 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (somename.somename);
2023-08-01 17:01:35.805 +07 client backend[295667] pg_regress/create_table ERROR:  cannot use column reference in partition bound expression at character 75
2023-08-01 17:01:35.805 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (a);
2023-08-01 17:01:35.806 +07 client backend[295667] pg_regress/create_table ERROR:  cannot use column reference in partition bound expression at character 79
2023-08-01 17:01:35.806 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (sum(a));
2023-08-01 17:01:35.806 +07 client backend[295667] pg_regress/create_table ERROR:  cannot use column reference in partition bound expression at character 79
2023-08-01 17:01:35.806 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (sum(somename));
2023-08-01 17:01:35.806 +07 client backend[295667] pg_regress/create_table ERROR:  aggregate functions are not allowed in partition bound at character 75
2023-08-01 17:01:35.806 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (sum(1));
2023-08-01 17:01:35.807 +07 client backend[295667] pg_regress/create_table ERROR:  cannot use subquery in partition bound at character 75
2023-08-01 17:01:35.807 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN ((select 1));
2023-08-01 17:01:35.807 +07 client backend[295667] pg_regress/create_table ERROR:  set-returning functions are not allowed in partition bound at character 75
2023-08-01 17:01:35.807 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (generate_series(4, 6));
2023-08-01 17:01:35.808 +07 client backend[295667] pg_regress/create_table ERROR:  collations are not supported by type integer
2023-08-01 17:01:35.808 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN ('1' collate "POSIX");
2023-08-01 17:01:35.808 +07 client backend[295667] pg_regress/create_table ERROR:  collations are not supported by type integer at character 81
2023-08-01 17:01:35.808 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN ((1+1) collate "POSIX");
2023-08-01 17:01:35.808 +07 client backend[295667] pg_regress/create_table ERROR:  syntax error at or near ")" at character 64
2023-08-01 17:01:35.808 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE fail_part PARTITION OF list_parted FOR VALUES IN ();
2023-08-01 17:01:35.808 +07 client backend[295667] pg_regress/create_table ERROR:  invalid bound specification for a list partition at character 60
2023-08-01 17:01:35.808 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE fail_part PARTITION OF list_parted FOR VALUES FROM (1) TO (2);
2023-08-01 17:01:35.809 +07 client backend[295667] pg_regress/create_table ERROR:  invalid bound specification for a list partition at character 60
2023-08-01 17:01:35.809 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE fail_part PARTITION OF list_parted FOR VALUES WITH (MODULUS 10, REMAINDER 1);
2023-08-01 17:01:35.809 +07 client backend[295667] pg_regress/create_table ERROR:  partition "fail_default_part" conflicts with existing default partition "part_default"
2023-08-01 17:01:35.809 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE fail_default_part PARTITION OF list_parted DEFAULT;
2023-08-01 17:01:35.810 +07 client backend[295667] pg_regress/create_table ERROR:  specified value cannot be cast to type boolean for column "a" at character 59
2023-08-01 17:01:35.810 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE bools_true PARTITION OF bools FOR VALUES IN (1);
2023-08-01 17:01:35.813 +07 client backend[295667] pg_regress/create_table ERROR:  partition "bigintp_10_2" would overlap partition "bigintp_10"
2023-08-01 17:01:35.813 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE bigintp_10_2 PARTITION OF bigintp FOR VALUES IN ('10');
2023-08-01 17:01:35.815 +07 client backend[295667] pg_regress/create_table ERROR:  cannot use column reference in partition bound expression at character 80
2023-08-01 17:01:35.815 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted
	  FOR VALUES FROM (somename) TO ('2019-01-01');
2023-08-01 17:01:35.815 +07 client backend[295667] pg_regress/create_table ERROR:  cannot use column reference in partition bound expression at character 80
2023-08-01 17:01:35.815 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted
	  FOR VALUES FROM (somename.somename) TO ('2019-01-01');
2023-08-01 17:01:35.815 +07 client backend[295667] pg_regress/create_table ERROR:  cannot use column reference in partition bound expression at character 80
2023-08-01 17:01:35.815 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted
	  FOR VALUES FROM (a) TO ('2019-01-01');
2023-08-01 17:01:35.816 +07 client backend[295667] pg_regress/create_table ERROR:  cannot use column reference in partition bound expression at character 84
2023-08-01 17:01:35.816 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted
	  FOR VALUES FROM (max(a)) TO ('2019-01-01');
2023-08-01 17:01:35.816 +07 client backend[295667] pg_regress/create_table ERROR:  cannot use column reference in partition bound expression at character 84
2023-08-01 17:01:35.816 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted
	  FOR VALUES FROM (max(somename)) TO ('2019-01-01');
2023-08-01 17:01:35.816 +07 client backend[295667] pg_regress/create_table ERROR:  aggregate functions are not allowed in partition bound at character 80
2023-08-01 17:01:35.816 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted
	  FOR VALUES FROM (max('2019-02-01'::date)) TO ('2019-01-01');
2023-08-01 17:01:35.817 +07 client backend[295667] pg_regress/create_table ERROR:  cannot use subquery in partition bound at character 80
2023-08-01 17:01:35.817 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted
	  FOR VALUES FROM ((select 1)) TO ('2019-01-01');
2023-08-01 17:01:35.817 +07 client backend[295667] pg_regress/create_table ERROR:  set-returning functions are not allowed in partition bound at character 80
2023-08-01 17:01:35.817 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted
	  FOR VALUES FROM (generate_series(1, 3)) TO ('2019-01-01');
2023-08-01 17:01:35.817 +07 client backend[295667] pg_regress/create_table ERROR:  invalid bound specification for a range partition at character 61
2023-08-01 17:01:35.817 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE fail_part PARTITION OF range_parted FOR VALUES IN ('a');
2023-08-01 17:01:35.818 +07 client backend[295667] pg_regress/create_table ERROR:  invalid bound specification for a range partition at character 61
2023-08-01 17:01:35.818 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE fail_part PARTITION OF range_parted FOR VALUES WITH (MODULUS 10, REMAINDER 1);
2023-08-01 17:01:35.818 +07 client backend[295667] pg_regress/create_table ERROR:  FROM must specify exactly one value per partitioning column
2023-08-01 17:01:35.818 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE fail_part PARTITION OF range_parted FOR VALUES FROM ('a', 1) TO ('z');
2023-08-01 17:01:35.818 +07 client backend[295667] pg_regress/create_table ERROR:  TO must specify exactly one value per partitioning column
2023-08-01 17:01:35.818 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE fail_part PARTITION OF range_parted FOR VALUES FROM ('a') TO ('z', 1);
2023-08-01 17:01:35.819 +07 client backend[295667] pg_regress/create_table ERROR:  cannot specify NULL in range bound
2023-08-01 17:01:35.819 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE fail_part PARTITION OF range_parted FOR VALUES FROM (null) TO (maxvalue);
2023-08-01 17:01:35.819 +07 client backend[295667] pg_regress/create_table ERROR:  invalid bound specification for a range partition at character 61
2023-08-01 17:01:35.819 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE fail_part PARTITION OF range_parted FOR VALUES WITH (MODULUS 10, REMAINDER 1);
2023-08-01 17:01:35.821 +07 client backend[295667] pg_regress/create_table ERROR:  every hash partition modulus must be a factor of the next larger modulus
2023-08-01 17:01:35.821 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE fail_part PARTITION OF hash_parted FOR VALUES WITH (MODULUS 25, REMAINDER 3);
2023-08-01 17:01:35.821 +07 client backend[295667] pg_regress/create_table ERROR:  every hash partition modulus must be a factor of the next larger modulus
2023-08-01 17:01:35.821 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE fail_part PARTITION OF hash_parted FOR VALUES WITH (MODULUS 150, REMAINDER 3);
2023-08-01 17:01:35.821 +07 client backend[295667] pg_regress/create_table ERROR:  invalid bound specification for a hash partition at character 60
2023-08-01 17:01:35.821 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE fail_part PARTITION OF hash_parted FOR VALUES FROM ('a', 1) TO ('z');
2023-08-01 17:01:35.822 +07 client backend[295667] pg_regress/create_table ERROR:  invalid bound specification for a hash partition at character 60
2023-08-01 17:01:35.822 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE fail_part PARTITION OF hash_parted FOR VALUES IN (1000);
2023-08-01 17:01:35.822 +07 client backend[295667] pg_regress/create_table ERROR:  a hash-partitioned table may not have a default partition
2023-08-01 17:01:35.822 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE fail_default_part PARTITION OF hash_parted DEFAULT;
2023-08-01 17:01:35.823 +07 client backend[295667] pg_regress/create_table ERROR:  "unparted" is not partitioned
2023-08-01 17:01:35.823 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE fail_part PARTITION OF unparted FOR VALUES IN ('a');
2023-08-01 17:01:35.823 +07 client backend[295667] pg_regress/create_table ERROR:  "unparted" is not partitioned
2023-08-01 17:01:35.823 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE fail_part PARTITION OF unparted FOR VALUES WITH (MODULUS 2, REMAINDER 1);
2023-08-01 17:01:35.824 +07 client backend[295667] pg_regress/create_table ERROR:  cannot create a permanent relation as partition of temporary relation "temp_parted"
2023-08-01 17:01:35.824 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE fail_part PARTITION OF temp_parted FOR VALUES IN ('a');
2023-08-01 17:01:35.827 +07 client backend[295667] pg_regress/create_table ERROR:  partition "fail_part" would overlap partition "part_null_z"
2023-08-01 17:01:35.827 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE fail_part PARTITION OF list_parted2 FOR VALUES IN (null);
2023-08-01 17:01:35.827 +07 client backend[295667] pg_regress/create_table ERROR:  partition "fail_part" would overlap partition "part_ab"
2023-08-01 17:01:35.827 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE fail_part PARTITION OF list_parted2 FOR VALUES IN ('b', 'c');
2023-08-01 17:01:35.828 +07 client backend[295667] pg_regress/create_table ERROR:  updated partition constraint for default partition "list_parted2_def" would be violated by some row
2023-08-01 17:01:35.828 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE fail_part PARTITION OF list_parted2 FOR VALUES IN ('W', 'X', 'Y');
2023-08-01 17:01:35.829 +07 client backend[295667] pg_regress/create_table ERROR:  empty range bound specified for partition "fail_part"
2023-08-01 17:01:35.829 +07 client backend[295667] pg_regress/create_table DETAIL:  Specified lower bound (1) is greater than or equal to upper bound (0).
2023-08-01 17:01:35.829 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (1) TO (0);
2023-08-01 17:01:35.829 +07 client backend[295667] pg_regress/create_table ERROR:  empty range bound specified for partition "fail_part"
2023-08-01 17:01:35.829 +07 client backend[295667] pg_regress/create_table DETAIL:  Specified lower bound (1) is greater than or equal to upper bound (1).
2023-08-01 17:01:35.829 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (1) TO (1);
2023-08-01 17:01:35.830 +07 client backend[295667] pg_regress/create_table ERROR:  partition "fail_part" would overlap partition "part0"
2023-08-01 17:01:35.830 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (minvalue) TO (2);
2023-08-01 17:01:35.830 +07 client backend[295667] pg_regress/create_table ERROR:  partition "fail_part" would overlap partition "part1"
2023-08-01 17:01:35.830 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (9) TO (maxvalue);
2023-08-01 17:01:35.832 +07 client backend[295667] pg_regress/create_table ERROR:  partition "fail_part" would overlap partition "part2"
2023-08-01 17:01:35.832 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (10) TO (30);
2023-08-01 17:01:35.832 +07 client backend[295667] pg_regress/create_table ERROR:  partition "fail_part" would overlap partition "part2"
2023-08-01 17:01:35.832 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (10) TO (50);
2023-08-01 17:01:35.833 +07 client backend[295667] pg_regress/create_table ERROR:  partition "fail_default_part" conflicts with existing default partition "range2_default"
2023-08-01 17:01:35.833 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE fail_default_part PARTITION OF range_parted2 DEFAULT;
2023-08-01 17:01:35.833 +07 client backend[295667] pg_regress/create_table ERROR:  updated partition constraint for default partition "range2_default" would be violated by some row
2023-08-01 17:01:35.833 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (80) TO (90);
2023-08-01 17:01:35.835 +07 client backend[295667] pg_regress/create_table ERROR:  partition "fail_part" would overlap partition "part00"
2023-08-01 17:01:35.835 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE fail_part PARTITION OF range_parted3 FOR VALUES FROM (0, minvalue) TO (0, 1);
2023-08-01 17:01:35.836 +07 client backend[295667] pg_regress/create_table ERROR:  partition "fail_part" would overlap partition "part12"
2023-08-01 17:01:35.836 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE fail_part PARTITION OF range_parted3 FOR VALUES FROM (1, 10) TO (1, 20);
2023-08-01 17:01:35.837 +07 client backend[295667] pg_regress/create_table ERROR:  partition "fail_part" would overlap partition "part10"
2023-08-01 17:01:35.837 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE fail_part PARTITION OF range_parted3 FOR VALUES FROM (1, minvalue) TO (1, maxvalue);
2023-08-01 17:01:35.841 +07 client backend[295667] pg_regress/create_table ERROR:  partition "fail_part" would overlap partition "h2part_4"
2023-08-01 17:01:35.841 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE fail_part PARTITION OF hash_parted2 FOR VALUES WITH (MODULUS 2, REMAINDER 1);
2023-08-01 17:01:35.841 +07 client backend[295667] pg_regress/create_table ERROR:  modulus for hash partition must be a positive integer
2023-08-01 17:01:35.841 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE fail_part PARTITION OF hash_parted2 FOR VALUES WITH (MODULUS 0, REMAINDER 1);
2023-08-01 17:01:35.842 +07 client backend[295667] pg_regress/create_table ERROR:  remainder for hash partition must be less than modulus
2023-08-01 17:01:35.842 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE fail_part PARTITION OF hash_parted2 FOR VALUES WITH (MODULUS 8, REMAINDER 8);
2023-08-01 17:01:35.843 +07 client backend[295667] pg_regress/create_table ERROR:  column "b" specified more than once
2023-08-01 17:01:35.843 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE part_b PARTITION OF parted (
		b NOT NULL,
		b DEFAULT 1,
		b CHECK (b >= 0),
		CONSTRAINT check_a CHECK (length(a) > 0)
	) FOR VALUES IN ('b');
2023-08-01 17:01:35.845 +07 client backend[295667] pg_regress/create_table ERROR:  cannot drop inherited constraint "check_a" of relation "part_b"
2023-08-01 17:01:35.845 +07 client backend[295667] pg_regress/create_table STATEMENT:  ALTER TABLE part_b DROP CONSTRAINT check_a;
2023-08-01 17:01:35.845 +07 client backend[295667] pg_regress/create_table ERROR:  cannot drop inherited constraint "check_b" of relation "part_b"
2023-08-01 17:01:35.845 +07 client backend[295667] pg_regress/create_table STATEMENT:  ALTER TABLE part_b DROP CONSTRAINT check_b;
2023-08-01 17:01:35.846 +07 client backend[295667] pg_regress/create_table ERROR:  column "c" named in partition key does not exist at character 98
2023-08-01 17:01:35.846 +07 client backend[295667] pg_regress/create_table STATEMENT:  CREATE TABLE fail_part_col_not_found PARTITION OF parted FOR VALUES IN ('c') PARTITION BY RANGE (c);
2023-08-01 17:01:35.848 +07 client backend[295667] pg_regress/create_table ERROR:  null value in column "b" of relation "parted_notnull_inh_test1" violates not-null constraint
2023-08-01 17:01:35.848 +07 client backend[295667] pg_regress/create_table DETAIL:  Failing row contains (1, null).
2023-08-01 17:01:35.848 +07 client backend[295667] pg_regress/create_table STATEMENT:  insert into parted_notnull_inh_test (b) values (null);
2023-08-01 17:01:35.857 +07 client backend[295667] pg_regress/create_table ERROR:  collation of partition bound value for column "a" does not match partition key collation "POSIX" at character 80
2023-08-01 17:01:35.857 +07 client backend[295667] pg_regress/create_table STATEMENT:  create table test_part_coll partition of test_part_coll_posix for values from ('a' collate "C") to ('g');
2023-08-01 17:01:35.859 +07 client backend[295667] pg_regress/create_table ERROR:  collation of partition bound value for column "a" does not match partition key collation "POSIX" at character 90
2023-08-01 17:01:35.859 +07 client backend[295667] pg_regress/create_table STATEMENT:  create table test_part_coll_cast partition of test_part_coll_posix for values from (name 'm' collate "C") to ('s');
2023-08-01 17:01:35.904 +07 client backend[295667] pg_regress/create_table ERROR:  cannot create a permanent relation as partition of temporary relation "temp_parted"
2023-08-01 17:01:35.904 +07 client backend[295667] pg_regress/create_table STATEMENT:  create table perm_part partition of temp_parted default;
2023-08-01 17:01:35.904 +07 client backend[295667] pg_regress/create_table ERROR:  cannot create a temporary relation as partition of permanent relation "perm_parted"
2023-08-01 17:01:35.904 +07 client backend[295667] pg_regress/create_table STATEMENT:  create temp table temp_part partition of perm_parted default;
2023-08-01 17:01:35.906 +07 client backend[295667] pg_regress/create_table ERROR:  cannot CREATE TABLE .. PARTITION OF "tab_part_create" because it is being used by active queries in this session
2023-08-01 17:01:35.906 +07 client backend[295667] pg_regress/create_table CONTEXT:  SQL statement "create table tab_part_create_1 partition of tab_part_create for values in (1)"
	PL/pgSQL function func_part_create() line 3 at EXECUTE
2023-08-01 17:01:35.906 +07 client backend[295667] pg_regress/create_table STATEMENT:  insert into tab_part_create values (1);
2023-08-01 17:01:35.910 +07 client backend[295667] pg_regress/create_table ERROR:  updated partition constraint for default partition "defcheck_def" would be violated by some row
2023-08-01 17:01:35.910 +07 client backend[295667] pg_regress/create_table STATEMENT:  create table defcheck_0 partition of defcheck for values in (0);
2023-08-01 17:01:35.933 +07 client backend[295681] pg_regress/insert ERROR:  null value in column "col2" of relation "inserttest" violates not-null constraint
2023-08-01 17:01:35.933 +07 client backend[295681] pg_regress/insert DETAIL:  Failing row contains (null, null, testing).
2023-08-01 17:01:35.933 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into inserttest (col1, col2, col3) values (DEFAULT, DEFAULT, DEFAULT);
2023-08-01 17:01:35.933 +07 client backend[295680] pg_regress/insert_conflict ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
2023-08-01 17:01:35.933 +07 client backend[295680] pg_regress/insert_conflict STATEMENT:  explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (key) do nothing;
2023-08-01 17:01:35.933 +07 client backend[295680] pg_regress/insert_conflict ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
2023-08-01 17:01:35.933 +07 client backend[295680] pg_regress/insert_conflict STATEMENT:  explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (fruit) do nothing;
2023-08-01 17:01:35.934 +07 client backend[295681] pg_regress/insert ERROR:  INSERT has more target columns than expressions at character 37
2023-08-01 17:01:35.934 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into inserttest (col1, col2, col3) values (DEFAULT, DEFAULT);
2023-08-01 17:01:35.934 +07 client backend[295681] pg_regress/insert ERROR:  INSERT has more target columns than expressions at character 37
2023-08-01 17:01:35.934 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into inserttest (col1, col2, col3) values (1, 2);
2023-08-01 17:01:35.934 +07 client backend[295683] pg_regress/copydml ERROR:  COPY query must have a RETURNING clause
2023-08-01 17:01:35.934 +07 client backend[295683] pg_regress/copydml STATEMENT:  copy (insert into copydml_test default values) to stdout;
2023-08-01 17:01:35.934 +07 client backend[295681] pg_regress/insert ERROR:  INSERT has more expressions than target columns at character 42
2023-08-01 17:01:35.934 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into inserttest (col1) values (1, 2);
2023-08-01 17:01:35.934 +07 client backend[295683] pg_regress/copydml ERROR:  COPY query must have a RETURNING clause
2023-08-01 17:01:35.934 +07 client backend[295683] pg_regress/copydml STATEMENT:  copy (update copydml_test set t = 'g') to stdout;
2023-08-01 17:01:35.934 +07 client backend[295681] pg_regress/insert ERROR:  INSERT has more expressions than target columns at character 48
2023-08-01 17:01:35.934 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into inserttest (col1) values (DEFAULT, DEFAULT);
2023-08-01 17:01:35.934 +07 client backend[295683] pg_regress/copydml ERROR:  COPY query must have a RETURNING clause
2023-08-01 17:01:35.934 +07 client backend[295683] pg_regress/copydml STATEMENT:  copy (delete from copydml_test) to stdout;
2023-08-01 17:01:35.935 +07 client backend[295683] pg_regress/copydml ERROR:  DO INSTEAD NOTHING rules are not supported for COPY
2023-08-01 17:01:35.935 +07 client backend[295683] pg_regress/copydml STATEMENT:  copy (insert into copydml_test default values) to stdout;
2023-08-01 17:01:35.935 +07 client backend[295683] pg_regress/copydml ERROR:  DO ALSO rules are not supported for the COPY
2023-08-01 17:01:35.935 +07 client backend[295683] pg_regress/copydml STATEMENT:  copy (insert into copydml_test default values) to stdout;
2023-08-01 17:01:35.936 +07 client backend[295683] pg_regress/copydml ERROR:  multi-statement DO INSTEAD rules are not supported for COPY
2023-08-01 17:01:35.936 +07 client backend[295683] pg_regress/copydml STATEMENT:  copy (insert into copydml_test default values) to stdout;
2023-08-01 17:01:35.936 +07 client backend[295683] pg_regress/copydml ERROR:  conditional DO INSTEAD rules are not supported for COPY
2023-08-01 17:01:35.936 +07 client backend[295683] pg_regress/copydml STATEMENT:  copy (insert into copydml_test default values) to stdout;
2023-08-01 17:01:35.936 +07 client backend[295683] pg_regress/copydml ERROR:  DO INSTEAD NOTHING rules are not supported for COPY
2023-08-01 17:01:35.936 +07 client backend[295683] pg_regress/copydml STATEMENT:  copy (update copydml_test set t = 'f') to stdout;
2023-08-01 17:01:35.937 +07 client backend[295683] pg_regress/copydml ERROR:  DO ALSO rules are not supported for the COPY
2023-08-01 17:01:35.937 +07 client backend[295683] pg_regress/copydml STATEMENT:  copy (update copydml_test set t = 'f') to stdout;
2023-08-01 17:01:35.937 +07 client backend[295683] pg_regress/copydml ERROR:  multi-statement DO INSTEAD rules are not supported for COPY
2023-08-01 17:01:35.937 +07 client backend[295683] pg_regress/copydml STATEMENT:  copy (update copydml_test set t = 'f') to stdout;
2023-08-01 17:01:35.937 +07 client backend[295682] pg_regress/copyselect ERROR:  cannot copy from view "v_test1"
2023-08-01 17:01:35.937 +07 client backend[295682] pg_regress/copyselect HINT:  Try the COPY (SELECT ...) TO variant.
2023-08-01 17:01:35.937 +07 client backend[295682] pg_regress/copyselect STATEMENT:  copy v_test1 to stdout;
2023-08-01 17:01:35.937 +07 client backend[295680] pg_regress/insert_conflict ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
2023-08-01 17:01:35.937 +07 client backend[295680] pg_regress/insert_conflict STATEMENT:  explain (costs off) insert into insertconflicttest values(0, 'Crowberry') on conflict (lower(fruit) text_pattern_ops, upper(fruit) collate "C") do nothing;
2023-08-01 17:01:35.937 +07 client backend[295683] pg_regress/copydml ERROR:  conditional DO INSTEAD rules are not supported for COPY
2023-08-01 17:01:35.937 +07 client backend[295683] pg_regress/copydml STATEMENT:  copy (update copydml_test set t = 'f') to stdout;
2023-08-01 17:01:35.937 +07 client backend[295682] pg_regress/copyselect ERROR:  COPY (SELECT INTO) is not supported
2023-08-01 17:01:35.937 +07 client backend[295682] pg_regress/copyselect STATEMENT:  copy (select t into temp test3 from test1 where id=3) to stdout;
2023-08-01 17:01:35.937 +07 client backend[295682] pg_regress/copyselect ERROR:  syntax error at or near "from" at character 28
2023-08-01 17:01:35.937 +07 client backend[295682] pg_regress/copyselect STATEMENT:  copy (select * from test1) from stdin;
2023-08-01 17:01:35.938 +07 client backend[295682] pg_regress/copyselect ERROR:  syntax error at or near "(" at character 28
2023-08-01 17:01:35.938 +07 client backend[295682] pg_regress/copyselect STATEMENT:  copy (select * from test1) (t,id) to stdout;
2023-08-01 17:01:35.938 +07 client backend[295683] pg_regress/copydml ERROR:  DO INSTEAD NOTHING rules are not supported for COPY
2023-08-01 17:01:35.938 +07 client backend[295683] pg_regress/copydml STATEMENT:  copy (delete from copydml_test) to stdout;
2023-08-01 17:01:35.938 +07 client backend[295683] pg_regress/copydml ERROR:  DO ALSO rules are not supported for the COPY
2023-08-01 17:01:35.938 +07 client backend[295683] pg_regress/copydml STATEMENT:  copy (delete from copydml_test) to stdout;
2023-08-01 17:01:35.938 +07 client backend[295683] pg_regress/copydml ERROR:  multi-statement DO INSTEAD rules are not supported for COPY
2023-08-01 17:01:35.938 +07 client backend[295683] pg_regress/copydml STATEMENT:  copy (delete from copydml_test) to stdout;
2023-08-01 17:01:35.938 +07 client backend[295681] pg_regress/insert ERROR:  cannot set an array element to DEFAULT at character 32
2023-08-01 17:01:35.938 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into inserttest (f2[1], f2[2]) values (1,default);
2023-08-01 17:01:35.939 +07 client backend[295680] pg_regress/insert_conflict ERROR:  ON CONFLICT DO UPDATE requires inference specification or constraint name at character 52
2023-08-01 17:01:35.939 +07 client backend[295680] pg_regress/insert_conflict HINT:  For example, ON CONFLICT (column_name).
2023-08-01 17:01:35.939 +07 client backend[295680] pg_regress/insert_conflict STATEMENT:  insert into insertconflicttest values (1, 'Apple') on conflict do update set fruit = excluded.fruit;
2023-08-01 17:01:35.939 +07 client backend[295683] pg_regress/copydml ERROR:  conditional DO INSTEAD rules are not supported for COPY
2023-08-01 17:01:35.939 +07 client backend[295683] pg_regress/copydml STATEMENT:  copy (delete from copydml_test) to stdout;
2023-08-01 17:01:35.939 +07 client backend[295682] pg_regress/copyselect ERROR:  cannot copy from view "v_test1"
2023-08-01 17:01:35.939 +07 client backend[295682] pg_regress/copyselect HINT:  Try the COPY (SELECT ...) TO variant.
2023-08-01 17:01:35.939 +07 client backend[295682] pg_regress/copyselect STATEMENT:  COPY  v_test1 TO STDOUT 
2023-08-01 17:01:35.939 +07 client backend[295681] pg_regress/insert ERROR:  cannot set a subfield to DEFAULT at character 33
2023-08-01 17:01:35.939 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into inserttest (f3.if1, f3.if2) values (1,default);
2023-08-01 17:01:35.939 +07 client backend[295680] pg_regress/insert_conflict ERROR:  invalid reference to FROM-clause entry for table "excluded" at character 117
2023-08-01 17:01:35.939 +07 client backend[295680] pg_regress/insert_conflict HINT:  There is an entry for table "excluded", but it cannot be referenced from this part of the query.
2023-08-01 17:01:35.939 +07 client backend[295680] pg_regress/insert_conflict STATEMENT:  insert into insertconflicttest values (1, 'Apple') on conflict (key) do update set fruit = excluded.fruit RETURNING excluded.fruit;
2023-08-01 17:01:35.939 +07 client backend[295680] pg_regress/insert_conflict ERROR:  column "keyy" does not exist at character 64
2023-08-01 17:01:35.939 +07 client backend[295680] pg_regress/insert_conflict HINT:  Perhaps you meant to reference the column "insertconflicttest.key".
2023-08-01 17:01:35.939 +07 client backend[295680] pg_regress/insert_conflict STATEMENT:  insert into insertconflicttest values (1, 'Apple') on conflict (keyy) do update set fruit = excluded.fruit;
2023-08-01 17:01:35.939 +07 client backend[295680] pg_regress/insert_conflict ERROR:  column excluded.fruitt does not exist at character 92
2023-08-01 17:01:35.939 +07 client backend[295680] pg_regress/insert_conflict HINT:  Perhaps you meant to reference the column "excluded.fruit".
2023-08-01 17:01:35.939 +07 client backend[295680] pg_regress/insert_conflict STATEMENT:  insert into insertconflicttest values (1, 'Apple') on conflict (key) do update set fruit = excluded.fruitt;
2023-08-01 17:01:35.939 +07 client backend[295680] pg_regress/insert_conflict ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
2023-08-01 17:01:35.939 +07 client backend[295680] pg_regress/insert_conflict STATEMENT:  insert into insertconflicttest values (3, 'Kiwi') on conflict (key, fruit) do update set fruit = excluded.fruit;
2023-08-01 17:01:35.939 +07 client backend[295680] pg_regress/insert_conflict ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
2023-08-01 17:01:35.939 +07 client backend[295680] pg_regress/insert_conflict STATEMENT:  insert into insertconflicttest values (4, 'Mango') on conflict (fruit, key) do update set fruit = excluded.fruit;
2023-08-01 17:01:35.939 +07 client backend[295680] pg_regress/insert_conflict ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
2023-08-01 17:01:35.939 +07 client backend[295680] pg_regress/insert_conflict STATEMENT:  insert into insertconflicttest values (5, 'Lemon') on conflict (fruit) do update set fruit = excluded.fruit;
2023-08-01 17:01:35.939 +07 client backend[295680] pg_regress/insert_conflict ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
2023-08-01 17:01:35.939 +07 client backend[295680] pg_regress/insert_conflict STATEMENT:  insert into insertconflicttest values (6, 'Passionfruit') on conflict (lower(fruit)) do update set fruit = excluded.fruit;
2023-08-01 17:01:35.940 +07 client backend[295680] pg_regress/insert_conflict ERROR:  invalid reference to FROM-clause entry for table "insertconflicttest" at character 106
2023-08-01 17:01:35.940 +07 client backend[295680] pg_regress/insert_conflict HINT:  Perhaps you meant to reference the table alias "ict".
2023-08-01 17:01:35.940 +07 client backend[295680] pg_regress/insert_conflict STATEMENT:  insert into insertconflicttest AS ict values (6, 'Passionfruit') on conflict (key) do update set fruit = insertconflicttest.fruit;
2023-08-01 17:01:35.941 +07 client backend[295680] pg_regress/insert_conflict ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
2023-08-01 17:01:35.941 +07 client backend[295680] pg_regress/insert_conflict STATEMENT:  insert into insertconflicttest values (9, 'Banana') on conflict (key) do update set fruit = excluded.fruit;
2023-08-01 17:01:35.941 +07 client backend[295682] pg_regress/copyselect ERROR:  division by zero
2023-08-01 17:01:35.941 +07 client backend[295682] pg_regress/copyselect STATEMENT:  copy (select 1) to stdout; select 1/0;
2023-08-01 17:01:35.941 +07 client backend[295680] pg_regress/insert_conflict ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
2023-08-01 17:01:35.941 +07 client backend[295680] pg_regress/insert_conflict STATEMENT:  insert into insertconflicttest values (10, 'Blueberry') on conflict (key, key, key) do update set fruit = excluded.fruit;
2023-08-01 17:01:35.942 +07 client backend[295682] pg_regress/copyselect ERROR:  division by zero
2023-08-01 17:01:35.942 +07 client backend[295682] pg_regress/copyselect STATEMENT:  select 1/0; copy (select 1) to stdout;
2023-08-01 17:01:35.942 +07 client backend[295680] pg_regress/insert_conflict ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
2023-08-01 17:01:35.942 +07 client backend[295680] pg_regress/insert_conflict STATEMENT:  insert into insertconflicttest values (11, 'Cherry') on conflict (key, lower(fruit)) do update set fruit = excluded.fruit;
2023-08-01 17:01:35.942 +07 client backend[295680] pg_regress/insert_conflict ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
2023-08-01 17:01:35.942 +07 client backend[295680] pg_regress/insert_conflict STATEMENT:  insert into insertconflicttest values (12, 'Date') on conflict (lower(fruit), key) do update set fruit = excluded.fruit;
2023-08-01 17:01:35.943 +07 client backend[295680] pg_regress/insert_conflict ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
2023-08-01 17:01:35.943 +07 client backend[295680] pg_regress/insert_conflict STATEMENT:  insert into insertconflicttest values (13, 'Grape') on conflict (key, fruit) do update set fruit = excluded.fruit;
2023-08-01 17:01:35.943 +07 client backend[295680] pg_regress/insert_conflict ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
2023-08-01 17:01:35.943 +07 client backend[295680] pg_regress/insert_conflict STATEMENT:  insert into insertconflicttest values (14, 'Raisin') on conflict (fruit, key) do update set fruit = excluded.fruit;
2023-08-01 17:01:35.943 +07 client backend[295680] pg_regress/insert_conflict ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
2023-08-01 17:01:35.943 +07 client backend[295680] pg_regress/insert_conflict STATEMENT:  insert into insertconflicttest values (15, 'Cranberry') on conflict (key) do update set fruit = excluded.fruit;
2023-08-01 17:01:35.943 +07 client backend[295680] pg_regress/insert_conflict ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
2023-08-01 17:01:35.943 +07 client backend[295680] pg_regress/insert_conflict STATEMENT:  insert into insertconflicttest values (16, 'Melon') on conflict (key, key, key) do update set fruit = excluded.fruit;
2023-08-01 17:01:35.943 +07 client backend[295680] pg_regress/insert_conflict ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
2023-08-01 17:01:35.943 +07 client backend[295680] pg_regress/insert_conflict STATEMENT:  insert into insertconflicttest values (17, 'Mulberry') on conflict (key, lower(fruit)) do update set fruit = excluded.fruit;
2023-08-01 17:01:35.943 +07 client backend[295680] pg_regress/insert_conflict ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
2023-08-01 17:01:35.943 +07 client backend[295680] pg_regress/insert_conflict STATEMENT:  insert into insertconflicttest values (18, 'Pineapple') on conflict (lower(fruit), key) do update set fruit = excluded.fruit;
2023-08-01 17:01:35.945 +07 client backend[295680] pg_regress/insert_conflict ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
2023-08-01 17:01:35.945 +07 client backend[295680] pg_regress/insert_conflict STATEMENT:  insert into insertconflicttest values (22, 'Apricot') on conflict (upper(fruit)) do update set fruit = excluded.fruit;
2023-08-01 17:01:35.945 +07 client backend[295680] pg_regress/insert_conflict ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
2023-08-01 17:01:35.945 +07 client backend[295680] pg_regress/insert_conflict STATEMENT:  insert into insertconflicttest values (23, 'Blackberry') on conflict (fruit) do update set fruit = excluded.fruit;
2023-08-01 17:01:35.946 +07 client backend[295680] pg_regress/insert_conflict ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
2023-08-01 17:01:35.946 +07 client backend[295680] pg_regress/insert_conflict STATEMENT:  insert into insertconflicttest values (27, 'Prune') on conflict (key, upper(fruit)) do update set fruit = excluded.fruit;
2023-08-01 17:01:35.946 +07 client backend[295680] pg_regress/insert_conflict ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
2023-08-01 17:01:35.946 +07 client backend[295680] pg_regress/insert_conflict STATEMENT:  insert into insertconflicttest values (28, 'Redcurrant') on conflict (fruit, key) do update set fruit = excluded.fruit;
2023-08-01 17:01:35.946 +07 client backend[295680] pg_regress/insert_conflict ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
2023-08-01 17:01:35.946 +07 client backend[295680] pg_regress/insert_conflict STATEMENT:  insert into insertconflicttest values (29, 'Nectarine') on conflict (key) do update set fruit = excluded.fruit;
2023-08-01 17:01:35.948 +07 client backend[295680] pg_regress/insert_conflict ERROR:  duplicate key value violates unique constraint "fruit_index"
2023-08-01 17:01:35.948 +07 client backend[295680] pg_regress/insert_conflict DETAIL:  Key (fruit)=(Peach) already exists.
2023-08-01 17:01:35.948 +07 client backend[295680] pg_regress/insert_conflict STATEMENT:  insert into insertconflicttest values (26, 'Peach') on conflict (key) do update set fruit = excluded.fruit;
2023-08-01 17:01:35.949 +07 client backend[295680] pg_regress/insert_conflict ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
2023-08-01 17:01:35.949 +07 client backend[295680] pg_regress/insert_conflict STATEMENT:  insert into insertconflicttest values (23, 'Blackberry') on conflict (key) do update set fruit = excluded.fruit;
2023-08-01 17:01:35.949 +07 client backend[295680] pg_regress/insert_conflict ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
2023-08-01 17:01:35.949 +07 client backend[295680] pg_regress/insert_conflict STATEMENT:  insert into insertconflicttest values (23, 'Blackberry') on conflict (key) where fruit like '%berry' or fruit = 'consequential' do nothing;
2023-08-01 17:01:35.949 +07 client backend[295680] pg_regress/insert_conflict ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
2023-08-01 17:01:35.949 +07 client backend[295680] pg_regress/insert_conflict STATEMENT:  insert into insertconflicttest values (23, 'Blackberry') on conflict (fruit) where fruit like '%berry' do update set fruit = excluded.fruit;
2023-08-01 17:01:35.951 +07 client backend[295681] pg_regress/insert ERROR:  no partition of relation "range_parted" found for row
2023-08-01 17:01:35.951 +07 client backend[295681] pg_regress/insert DETAIL:  Partition key of the failing row contains (a, (b + 0)) = (a, 11).
2023-08-01 17:01:35.951 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into range_parted values ('a', 11);
2023-08-01 17:01:35.953 +07 client backend[295680] pg_regress/insert_conflict ERROR:  column excluded.ctid does not exist at character 82
2023-08-01 17:01:35.953 +07 client backend[295680] pg_regress/insert_conflict STATEMENT:  insert into syscolconflicttest values (1) on conflict (key) do update set data = excluded.ctid::text;
2023-08-01 17:01:35.955 +07 client backend[295681] pg_regress/insert ERROR:  new row for relation "part1" violates partition constraint
2023-08-01 17:01:35.955 +07 client backend[295681] pg_regress/insert DETAIL:  Failing row contains (a, 11).
2023-08-01 17:01:35.955 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into part1 values ('a', 11);
2023-08-01 17:01:35.955 +07 client backend[295681] pg_regress/insert ERROR:  new row for relation "part1" violates partition constraint
2023-08-01 17:01:35.955 +07 client backend[295681] pg_regress/insert DETAIL:  Failing row contains (b, 1).
2023-08-01 17:01:35.955 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into part1 values ('b', 1);
2023-08-01 17:01:35.955 +07 client backend[295681] pg_regress/insert ERROR:  new row for relation "part4" violates partition constraint
2023-08-01 17:01:35.955 +07 client backend[295681] pg_regress/insert DETAIL:  Failing row contains (b, 21).
2023-08-01 17:01:35.955 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into part4 values ('b', 21);
2023-08-01 17:01:35.955 +07 client backend[295681] pg_regress/insert ERROR:  new row for relation "part4" violates partition constraint
2023-08-01 17:01:35.955 +07 client backend[295681] pg_regress/insert DETAIL:  Failing row contains (a, 10).
2023-08-01 17:01:35.955 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into part4 values ('a', 10);
2023-08-01 17:01:35.955 +07 client backend[295681] pg_regress/insert ERROR:  new row for relation "part1" violates partition constraint
2023-08-01 17:01:35.955 +07 client backend[295681] pg_regress/insert DETAIL:  Failing row contains (null, null).
2023-08-01 17:01:35.955 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into part1 values (null);
2023-08-01 17:01:35.955 +07 client backend[295681] pg_regress/insert ERROR:  new row for relation "part1" violates partition constraint
2023-08-01 17:01:35.955 +07 client backend[295681] pg_regress/insert DETAIL:  Failing row contains (1, null).
2023-08-01 17:01:35.955 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into part1 values (1);
2023-08-01 17:01:35.959 +07 client backend[295681] pg_regress/insert ERROR:  new row for relation "part_aa_bb" violates partition constraint
2023-08-01 17:01:35.959 +07 client backend[295681] pg_regress/insert DETAIL:  Failing row contains (cc, 1).
2023-08-01 17:01:35.959 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into part_aa_bb values ('cc', 1);
2023-08-01 17:01:35.959 +07 client backend[295681] pg_regress/insert ERROR:  new row for relation "part_aa_bb" violates partition constraint
2023-08-01 17:01:35.959 +07 client backend[295681] pg_regress/insert DETAIL:  Failing row contains (AAa, 1).
2023-08-01 17:01:35.959 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into part_aa_bb values ('AAa', 1);
2023-08-01 17:01:35.959 +07 client backend[295681] pg_regress/insert ERROR:  new row for relation "part_aa_bb" violates partition constraint
2023-08-01 17:01:35.959 +07 client backend[295681] pg_regress/insert DETAIL:  Failing row contains (null, null).
2023-08-01 17:01:35.959 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into part_aa_bb values (null);
2023-08-01 17:01:35.963 +07 client backend[295681] pg_regress/insert ERROR:  new row for relation "part_default" violates partition constraint
2023-08-01 17:01:35.963 +07 client backend[295681] pg_regress/insert DETAIL:  Failing row contains (aa, 2).
2023-08-01 17:01:35.963 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into part_default values ('aa', 2);
2023-08-01 17:01:35.963 +07 client backend[295681] pg_regress/insert ERROR:  new row for relation "part_default" violates partition constraint
2023-08-01 17:01:35.963 +07 client backend[295681] pg_regress/insert DETAIL:  Failing row contains (null, 2).
2023-08-01 17:01:35.963 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into part_default values (null, 2);
2023-08-01 17:01:35.967 +07 client backend[295680] pg_regress/insert_conflict ERROR:  table reference "excluded" is ambiguous at character 76
2023-08-01 17:01:35.967 +07 client backend[295680] pg_regress/insert_conflict STATEMENT:  insert into excluded values(1, '2') on conflict (key) do update set data = excluded.data RETURNING *;
2023-08-01 17:01:35.968 +07 client backend[295681] pg_regress/insert ERROR:  new row for relation "part_ee_ff1" violates partition constraint
2023-08-01 17:01:35.968 +07 client backend[295681] pg_regress/insert DETAIL:  Failing row contains (EE, 11).
2023-08-01 17:01:35.968 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into part_ee_ff1 values ('EE', 11);
2023-08-01 17:01:35.968 +07 client backend[295681] pg_regress/insert ERROR:  new row for relation "part_default_p2" violates partition constraint
2023-08-01 17:01:35.968 +07 client backend[295681] pg_regress/insert DETAIL:  Failing row contains (gg, 43).
2023-08-01 17:01:35.968 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into part_default_p2 values ('gg', 43);
2023-08-01 17:01:35.968 +07 client backend[295681] pg_regress/insert ERROR:  new row for relation "part_ee_ff1" violates partition constraint
2023-08-01 17:01:35.968 +07 client backend[295681] pg_regress/insert DETAIL:  Failing row contains (cc, 1).
2023-08-01 17:01:35.968 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into part_ee_ff1 values ('cc', 1);
2023-08-01 17:01:35.968 +07 client backend[295681] pg_regress/insert ERROR:  no partition of relation "part_default" found for row
2023-08-01 17:01:35.968 +07 client backend[295681] pg_regress/insert DETAIL:  Partition key of the failing row contains (b) = (43).
2023-08-01 17:01:35.968 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into part_default values ('gg', 43);
2023-08-01 17:01:35.970 +07 client backend[295681] pg_regress/insert ERROR:  no partition of relation "range_parted" found for row
2023-08-01 17:01:35.970 +07 client backend[295681] pg_regress/insert DETAIL:  Partition key of the failing row contains (a, (b + 0)) = (a, 0).
2023-08-01 17:01:35.970 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into range_parted values ('a', 0);
2023-08-01 17:01:35.970 +07 client backend[295681] pg_regress/insert ERROR:  no partition of relation "range_parted" found for row
2023-08-01 17:01:35.970 +07 client backend[295681] pg_regress/insert DETAIL:  Partition key of the failing row contains (a, (b + 0)) = (a, 20).
2023-08-01 17:01:35.970 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into range_parted values ('a', 20);
2023-08-01 17:01:35.971 +07 client backend[295681] pg_regress/insert ERROR:  no partition of relation "range_parted" found for row
2023-08-01 17:01:35.971 +07 client backend[295681] pg_regress/insert DETAIL:  Partition key of the failing row contains (a, (b + 0)) = (a, null).
2023-08-01 17:01:35.971 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into range_parted values ('a');
2023-08-01 17:01:35.972 +07 client backend[295681] pg_regress/insert ERROR:  new row for relation "part_def" violates partition constraint
2023-08-01 17:01:35.972 +07 client backend[295681] pg_regress/insert DETAIL:  Failing row contains (b, 10).
2023-08-01 17:01:35.972 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into part_def values ('b', 10);
2023-08-01 17:01:35.972 +07 client backend[295680] pg_regress/insert_conflict ERROR:  duplicate key value violates unique constraint "twoconstraints_f1_key"
2023-08-01 17:01:35.972 +07 client backend[295680] pg_regress/insert_conflict DETAIL:  Key (f1)=(1) already exists.
2023-08-01 17:01:35.972 +07 client backend[295680] pg_regress/insert_conflict STATEMENT:  insert into twoconstraints values(1, '((2,2),(3,3))');
2023-08-01 17:01:35.972 +07 client backend[295680] pg_regress/insert_conflict ERROR:  conflicting key value violates exclusion constraint "twoconstraints_f2_excl"
2023-08-01 17:01:35.972 +07 client backend[295680] pg_regress/insert_conflict DETAIL:  Key (f2)=((1,2),(0,0)) conflicts with existing key (f2)=((1,1),(0,0)).
2023-08-01 17:01:35.972 +07 client backend[295680] pg_regress/insert_conflict STATEMENT:  insert into twoconstraints values(2, '((0,0),(1,2))');
2023-08-01 17:01:35.972 +07 client backend[295680] pg_regress/insert_conflict ERROR:  conflicting key value violates exclusion constraint "twoconstraints_f2_excl"
2023-08-01 17:01:35.972 +07 client backend[295680] pg_regress/insert_conflict DETAIL:  Key (f2)=((1,2),(0,0)) conflicts with existing key (f2)=((1,1),(0,0)).
2023-08-01 17:01:35.972 +07 client backend[295680] pg_regress/insert_conflict STATEMENT:  insert into twoconstraints values(2, '((0,0),(1,2))')
	  on conflict on constraint twoconstraints_f1_key do nothing;
2023-08-01 17:01:35.973 +07 client backend[295681] pg_regress/insert ERROR:  no partition of relation "part_ee_ff" found for row
2023-08-01 17:01:35.973 +07 client backend[295681] pg_regress/insert DETAIL:  Partition key of the failing row contains (b) = (0).
2023-08-01 17:01:35.973 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into list_parted values ('EE', 0);
2023-08-01 17:01:35.973 +07 client backend[295681] pg_regress/insert ERROR:  no partition of relation "part_ee_ff" found for row
2023-08-01 17:01:35.973 +07 client backend[295681] pg_regress/insert DETAIL:  Partition key of the failing row contains (b) = (0).
2023-08-01 17:01:35.973 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into part_ee_ff values ('EE', 0);
2023-08-01 17:01:35.974 +07 client backend[295680] pg_regress/insert_conflict ERROR:  ON CONFLICT DO UPDATE command cannot affect row a second time
2023-08-01 17:01:35.974 +07 client backend[295680] pg_regress/insert_conflict HINT:  Ensure that no rows proposed for insertion within the same command have duplicate constrained values.
2023-08-01 17:01:35.974 +07 client backend[295680] pg_regress/insert_conflict STATEMENT:  insert into selfconflict values (4,1), (4,2) on conflict(f1) do update set f2 = 0;
2023-08-01 17:01:35.975 +07 client backend[295680] pg_regress/insert_conflict ERROR:  ON CONFLICT DO UPDATE command cannot affect row a second time
2023-08-01 17:01:35.975 +07 client backend[295680] pg_regress/insert_conflict HINT:  Ensure that no rows proposed for insertion within the same command have duplicate constrained values.
2023-08-01 17:01:35.975 +07 client backend[295680] pg_regress/insert_conflict STATEMENT:  insert into selfconflict values (5,1), (5,2) on conflict(f1) do update set f2 = 0;
2023-08-01 17:01:35.975 +07 client backend[295680] pg_regress/insert_conflict ERROR:  ON CONFLICT DO UPDATE command cannot affect row a second time
2023-08-01 17:01:35.975 +07 client backend[295680] pg_regress/insert_conflict HINT:  Ensure that no rows proposed for insertion within the same command have duplicate constrained values.
2023-08-01 17:01:35.975 +07 client backend[295680] pg_regress/insert_conflict STATEMENT:  insert into selfconflict values (6,1), (6,2) on conflict(f1) do update set f2 = 0;
2023-08-01 17:01:35.978 +07 client backend[295680] pg_regress/insert_conflict ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
2023-08-01 17:01:35.978 +07 client backend[295680] pg_regress/insert_conflict STATEMENT:  insert into parted_conflict_test values (2, 'b') on conflict (b) do update set a = excluded.a;
2023-08-01 17:01:35.989 +07 client backend[295681] pg_regress/insert ERROR:  new row for relation "hpart0" violates partition constraint
2023-08-01 17:01:35.989 +07 client backend[295681] pg_regress/insert DETAIL:  Failing row contains (11).
2023-08-01 17:01:35.989 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into hpart0 values(11);
2023-08-01 17:01:35.999 +07 client backend[295680] pg_regress/insert_conflict ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
2023-08-01 17:01:35.999 +07 client backend[295680] pg_regress/insert_conflict STATEMENT:  insert into parted_conflict_1 values (40, 'cuarenta')
	  on conflict (a) do update set b = excluded.b;
2023-08-01 17:01:36.006 +07 client backend[295681] pg_regress/insert ERROR:  no partition of relation "mlparted1" found for row
2023-08-01 17:01:36.006 +07 client backend[295681] pg_regress/insert DETAIL:  Partition key of the failing row contains ((b + 0)) = (5).
2023-08-01 17:01:36.006 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into mlparted (a, b) values (1, 5);
2023-08-01 17:01:36.007 +07 client backend[295681] pg_regress/insert ERROR:  new row for relation "mlparted11" violates check constraint "check_b"
2023-08-01 17:01:36.007 +07 client backend[295681] pg_regress/insert DETAIL:  Failing row contains (1, 4).
2023-08-01 17:01:36.007 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into mlparted values (1, 2);
2023-08-01 17:01:36.008 +07 client backend[295681] pg_regress/insert ERROR:  new row for relation "mlparted1" violates partition constraint
2023-08-01 17:01:36.008 +07 client backend[295681] pg_regress/insert DETAIL:  Failing row contains (3, 2).
2023-08-01 17:01:36.008 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into mlparted1 (a, b) values (2, 3);
2023-08-01 17:01:36.008 +07 client backend[295681] pg_regress/insert ERROR:  no partition of relation "lparted_nonullpart" found for row
2023-08-01 17:01:36.008 +07 client backend[295681] pg_regress/insert DETAIL:  Partition key of the failing row contains (b) = (null).
2023-08-01 17:01:36.008 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into lparted_nonullpart values (1);
2023-08-01 17:01:36.016 +07 client backend[295681] pg_regress/insert ERROR:  new row for relation "mlparted5a" violates check constraint "check_b"
2023-08-01 17:01:36.016 +07 client backend[295681] pg_regress/insert DETAIL:  Failing row contains (1, 45, a).
2023-08-01 17:01:36.016 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into mlparted values (1, 45, 'a');
2023-08-01 17:01:36.017 +07 client backend[295681] pg_regress/insert ERROR:  new row for relation "mlparted5a" violates partition constraint
2023-08-01 17:01:36.017 +07 client backend[295681] pg_regress/insert DETAIL:  Failing row contains (b, 1, 40).
2023-08-01 17:01:36.017 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into mlparted5 (a, b, c) values (1, 40, 'a');
2023-08-01 17:01:36.020 +07 client backend[295681] pg_regress/insert ERROR:  no partition of relation "mlparted_def" found for row
2023-08-01 17:01:36.020 +07 client backend[295681] pg_regress/insert DETAIL:  Partition key of the failing row contains (a) = (70).
2023-08-01 17:01:36.020 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into mlparted values (70, 100);
2023-08-01 17:01:36.020 +07 client backend[295681] pg_regress/insert ERROR:  new row for relation "mlparted_def1" violates partition constraint
2023-08-01 17:01:36.020 +07 client backend[295681] pg_regress/insert DETAIL:  Failing row contains (52, 50, null).
2023-08-01 17:01:36.020 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into mlparted_def1 values (52, 50);
2023-08-01 17:01:36.020 +07 client backend[295681] pg_regress/insert ERROR:  new row for relation "mlparted_def2" violates partition constraint
2023-08-01 17:01:36.020 +07 client backend[295681] pg_regress/insert DETAIL:  Failing row contains (34, 50, null).
2023-08-01 17:01:36.020 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into mlparted_def2 values (34, 50);
2023-08-01 17:01:36.030 +07 client backend[295681] pg_regress/insert ERROR:  no partition of relation "mlparted5_cd" found for row
2023-08-01 17:01:36.030 +07 client backend[295681] pg_regress/insert DETAIL:  Partition key of the failing row contains (c) = (c).
2023-08-01 17:01:36.030 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into mlparted values (1, 45, 'c', 1);
2023-08-01 17:01:36.030 +07 client backend[295681] pg_regress/insert ERROR:  no partition of relation "mlparted5" found for row
2023-08-01 17:01:36.030 +07 client backend[295681] pg_regress/insert DETAIL:  Partition key of the failing row contains (c) = (f).
2023-08-01 17:01:36.030 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into mlparted values (1, 45, 'f', 1);
2023-08-01 17:01:36.038 +07 client backend[295681] pg_regress/insert ERROR:  no partition of relation "mlparted5_cd" found for row
2023-08-01 17:01:36.038 +07 client backend[295681] pg_regress/insert DETAIL:  Partition key of the failing row contains (c) = (c).
2023-08-01 17:01:36.038 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into mlparted values (1, 45, 'c', 1);
2023-08-01 17:01:36.038 +07 client backend[295681] pg_regress/insert ERROR:  no partition of relation "mlparted5" found for row
2023-08-01 17:01:36.038 +07 client backend[295681] pg_regress/insert DETAIL:  Partition key of the failing row contains (c) = (f).
2023-08-01 17:01:36.038 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into mlparted values (1, 45, 'f', 1);
2023-08-01 17:01:36.041 +07 client backend[295681] pg_regress/insert ERROR:  no partition of relation "key_desc_1" found for row
2023-08-01 17:01:36.041 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into key_desc values (1, 1);
2023-08-01 17:01:36.041 +07 client backend[295681] pg_regress/insert ERROR:  no partition of relation "key_desc_1" found for row
2023-08-01 17:01:36.041 +07 client backend[295681] pg_regress/insert DETAIL:  Partition key of the failing row contains (b) = (1).
2023-08-01 17:01:36.041 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into key_desc values (1, 1);
2023-08-01 17:01:36.042 +07 client backend[295681] pg_regress/insert ERROR:  no partition of relation "key_desc" found for row
2023-08-01 17:01:36.042 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into key_desc values (2, 1);
2023-08-01 17:01:36.043 +07 client backend[295681] pg_regress/insert ERROR:  every bound following MINVALUE must also be MINVALUE at character 75
2023-08-01 17:01:36.043 +07 client backend[295681] pg_regress/insert STATEMENT:  create table mcrparted0 partition of mcrparted for values from (minvalue, 0, 0) to (1, maxvalue, maxvalue);
2023-08-01 17:01:36.043 +07 client backend[295681] pg_regress/insert ERROR:  every bound following MAXVALUE must also be MAXVALUE at character 100
2023-08-01 17:01:36.043 +07 client backend[295681] pg_regress/insert STATEMENT:  create table mcrparted2 partition of mcrparted for values from (10, 6, minvalue) to (10, maxvalue, minvalue);
2023-08-01 17:01:36.043 +07 client backend[295681] pg_regress/insert ERROR:  every bound following MINVALUE must also be MINVALUE at character 79
2023-08-01 17:01:36.043 +07 client backend[295681] pg_regress/insert STATEMENT:  create table mcrparted4 partition of mcrparted for values from (21, minvalue, 0) to (30, 20, minvalue);
2023-08-01 17:01:36.046 +07 client backend[295681] pg_regress/insert ERROR:  no partition of relation "mcrparted" found for row
2023-08-01 17:01:36.046 +07 client backend[295681] pg_regress/insert DETAIL:  Partition key of the failing row contains (a, abs(b), c) = (null, null, null).
2023-08-01 17:01:36.046 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into mcrparted values (null, null, null);
2023-08-01 17:01:36.047 +07 client backend[295681] pg_regress/insert ERROR:  no partition of relation "mcrparted" found for row
2023-08-01 17:01:36.047 +07 client backend[295681] pg_regress/insert DETAIL:  Partition key of the failing row contains (a, abs(b), c) = (11, 1, -1).
2023-08-01 17:01:36.047 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into mcrparted values (11, 1, -1);
2023-08-01 17:01:36.047 +07 client backend[295681] pg_regress/insert ERROR:  new row for relation "mcrparted3" violates partition constraint
2023-08-01 17:01:36.047 +07 client backend[295681] pg_regress/insert DETAIL:  Failing row contains (11, 1, -1).
2023-08-01 17:01:36.047 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into mcrparted3 values (11, 1, -1);
2023-08-01 17:01:36.048 +07 client backend[295681] pg_regress/insert ERROR:  new row for relation "mcrparted4" violates partition constraint
2023-08-01 17:01:36.048 +07 client backend[295681] pg_regress/insert DETAIL:  Failing row contains (30, 21, 20).
2023-08-01 17:01:36.048 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into mcrparted4 values (30, 21, 20);
2023-08-01 17:01:36.050 +07 client backend[295681] pg_regress/insert ERROR:  new row for relation "brtrigpartcon1" violates partition constraint
2023-08-01 17:01:36.050 +07 client backend[295681] pg_regress/insert DETAIL:  Failing row contains (2, hi there).
2023-08-01 17:01:36.050 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into brtrigpartcon values (1, 'hi there');
2023-08-01 17:01:36.050 +07 client backend[295681] pg_regress/insert ERROR:  new row for relation "brtrigpartcon1" violates partition constraint
2023-08-01 17:01:36.050 +07 client backend[295681] pg_regress/insert DETAIL:  Failing row contains (2, hi there).
2023-08-01 17:01:36.050 +07 client backend[295681] pg_regress/insert STATEMENT:  insert into brtrigpartcon1 values (1, 'hi there');
2023-08-01 17:01:36.052 +07 client backend[295681] pg_regress/insert ERROR:  new row for relation "brtrigpartcon1" violates partition constraint
2023-08-01 17:01:36.052 +07 client backend[295681] pg_regress/insert DETAIL:  Failing row contains (a, b) = (2, hi there).
2023-08-01 17:01:36.052 +07 client backend[295681] pg_regress/insert STATEMENT:  with result as (insert into brtrigpartcon values (1, 'hi there') returning 1)
	  insert into inserttest3 (f3) select * from result;
2023-08-01 17:01:36.106 +07 client backend[295679] pg_regress/copy ERROR:  cannot perform COPY FREEZE on a partitioned table
2023-08-01 17:01:36.106 +07 client backend[295679] pg_regress/copy STATEMENT:  copy parted_copytest from '/home/vlad/postgres_cluster/build/src/test/regress/results/parted_copytest.csv' (freeze);
2023-08-01 17:01:36.121 +07 client backend[295699] pg_regress/create_procedure ERROR:  procedure nonexistent() does not exist at character 6
2023-08-01 17:01:36.121 +07 client backend[295699] pg_regress/create_procedure HINT:  No procedure matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:36.121 +07 client backend[295699] pg_regress/create_procedure STATEMENT:  CALL nonexistent();
2023-08-01 17:01:36.121 +07 client backend[295699] pg_regress/create_procedure ERROR:  random() is not a procedure at character 6
2023-08-01 17:01:36.121 +07 client backend[295699] pg_regress/create_procedure HINT:  To call a function, use SELECT.
2023-08-01 17:01:36.121 +07 client backend[295699] pg_regress/create_procedure STATEMENT:  CALL random();
2023-08-01 17:01:36.122 +07 client backend[295698] pg_regress/create_operator ERROR:  operator does not exist: integer ######
2023-08-01 17:01:36.122 +07 client backend[295698] pg_regress/create_operator STATEMENT:  COMMENT ON OPERATOR ###### (int4, NONE) IS 'bad right unary';
2023-08-01 17:01:36.122 +07 client backend[295698] pg_regress/create_operator ERROR:  syntax error at or near "=>" at character 17
2023-08-01 17:01:36.122 +07 client backend[295698] pg_regress/create_operator STATEMENT:  CREATE OPERATOR => (
	   leftarg = int8,		
	   procedure = factorial
	);
2023-08-01 17:01:36.125 +07 client backend[295698] pg_regress/create_operator ERROR:  permission denied for schema schema_op1
2023-08-01 17:01:36.125 +07 client backend[295698] pg_regress/create_operator STATEMENT:  CREATE OPERATOR schema_op1.#*# (
	   leftarg = int8,		
	   procedure = factorial
	);
2023-08-01 17:01:36.125 +07 client backend[295698] pg_regress/create_operator ERROR:  SETOF type not allowed for operator argument
2023-08-01 17:01:36.125 +07 client backend[295698] pg_regress/create_operator STATEMENT:  CREATE OPERATOR #*# (
	   leftarg = SETOF int8,
	   procedure = factorial
	);
2023-08-01 17:01:36.125 +07 client backend[295698] pg_regress/create_operator ERROR:  SETOF type not allowed for operator argument
2023-08-01 17:01:36.125 +07 client backend[295698] pg_regress/create_operator STATEMENT:  CREATE OPERATOR #*# (
	   rightarg = SETOF int8,
	   procedure = factorial
	);
2023-08-01 17:01:36.126 +07 client backend[295698] pg_regress/create_operator WARNING:  operator attribute "invalid_att" not recognized
2023-08-01 17:01:36.126 +07 client backend[295698] pg_regress/create_operator ERROR:  at least one of leftarg or rightarg must be specified
2023-08-01 17:01:36.126 +07 client backend[295698] pg_regress/create_operator STATEMENT:  CREATE OPERATOR #@%# (
	   procedure = factorial
	);
2023-08-01 17:01:36.126 +07 client backend[295698] pg_regress/create_operator ERROR:  operator function must be specified
2023-08-01 17:01:36.126 +07 client backend[295698] pg_regress/create_operator STATEMENT:  CREATE OPERATOR #@%# (
	   leftarg = int8
	);
2023-08-01 17:01:36.127 +07 client backend[295698] pg_regress/create_operator ERROR:  permission denied for type type_op3
2023-08-01 17:01:36.127 +07 client backend[295698] pg_regress/create_operator STATEMENT:  CREATE OPERATOR #*# (
	   leftarg = type_op3,
	   rightarg = int8,
	   procedure = fn_op3
	);
2023-08-01 17:01:36.128 +07 client backend[295698] pg_regress/create_operator ERROR:  permission denied for type type_op4
2023-08-01 17:01:36.128 +07 client backend[295698] pg_regress/create_operator STATEMENT:  CREATE OPERATOR #*# (
	   leftarg = int8,
	   rightarg = type_op4,
	   procedure = fn_op4
	);
2023-08-01 17:01:36.129 +07 client backend[295698] pg_regress/create_operator ERROR:  permission denied for function fn_op5
2023-08-01 17:01:36.129 +07 client backend[295698] pg_regress/create_operator STATEMENT:  CREATE OPERATOR #*# (
	   leftarg = int8,
	   rightarg = int8,
	   procedure = fn_op5
	);
2023-08-01 17:01:36.130 +07 client backend[295698] pg_regress/create_operator ERROR:  permission denied for type type_op6
2023-08-01 17:01:36.130 +07 client backend[295698] pg_regress/create_operator STATEMENT:  CREATE OPERATOR #*# (
	   leftarg = int8,
	   rightarg = int8,
	   procedure = fn_op6
	);
2023-08-01 17:01:36.130 +07 client backend[295698] pg_regress/create_operator WARNING:  operator attribute "Leftarg" not recognized
2023-08-01 17:01:36.130 +07 client backend[295698] pg_regress/create_operator WARNING:  operator attribute "Rightarg" not recognized
2023-08-01 17:01:36.130 +07 client backend[295698] pg_regress/create_operator WARNING:  operator attribute "Procedure" not recognized
2023-08-01 17:01:36.130 +07 client backend[295698] pg_regress/create_operator WARNING:  operator attribute "Commutator" not recognized
2023-08-01 17:01:36.130 +07 client backend[295698] pg_regress/create_operator WARNING:  operator attribute "Negator" not recognized
2023-08-01 17:01:36.130 +07 client backend[295698] pg_regress/create_operator WARNING:  operator attribute "Restrict" not recognized
2023-08-01 17:01:36.130 +07 client backend[295698] pg_regress/create_operator WARNING:  operator attribute "Join" not recognized
2023-08-01 17:01:36.130 +07 client backend[295698] pg_regress/create_operator WARNING:  operator attribute "Hashes" not recognized
2023-08-01 17:01:36.130 +07 client backend[295698] pg_regress/create_operator WARNING:  operator attribute "Merges" not recognized
2023-08-01 17:01:36.130 +07 client backend[295698] pg_regress/create_operator ERROR:  operator function must be specified
2023-08-01 17:01:36.130 +07 client backend[295698] pg_regress/create_operator STATEMENT:  CREATE OPERATOR ===
	(
		"Leftarg" = box,
		"Rightarg" = box,
		"Procedure" = area_equal_function,
		"Commutator" = ===,
		"Negator" = !==,
		"Restrict" = area_restriction_function,
		"Join" = area_join_function,
		"Hashes",
		"Merges"
	);
2023-08-01 17:01:36.131 +07 client backend[295699] pg_regress/create_procedure ERROR:  ptest1(unknown) is a procedure at character 8
2023-08-01 17:01:36.131 +07 client backend[295699] pg_regress/create_procedure HINT:  To call a procedure, use CALL.
2023-08-01 17:01:36.131 +07 client backend[295699] pg_regress/create_procedure STATEMENT:  SELECT ptest1('x');
2023-08-01 17:01:36.133 +07 client backend[295699] pg_regress/create_procedure ERROR:  calling procedures with output arguments is not supported in SQL functions
2023-08-01 17:01:36.133 +07 client backend[295699] pg_regress/create_procedure CONTEXT:  SQL function "ptest4b"
2023-08-01 17:01:36.133 +07 client backend[295699] pg_regress/create_procedure STATEMENT:  CREATE PROCEDURE ptest4b(INOUT b int, INOUT a int)
	LANGUAGE SQL
	AS $$
	CALL ptest4a(a, b);  -- error, not supported
	$$;
2023-08-01 17:01:36.134 +07 client backend[295699] pg_regress/create_procedure ERROR:  version() is not a procedure at character 6
2023-08-01 17:01:36.134 +07 client backend[295699] pg_regress/create_procedure HINT:  To call a function, use SELECT.
2023-08-01 17:01:36.134 +07 client backend[295699] pg_regress/create_procedure STATEMENT:  CALL version();
2023-08-01 17:01:36.134 +07 client backend[295699] pg_regress/create_procedure ERROR:  sum(integer) is not a procedure at character 6
2023-08-01 17:01:36.134 +07 client backend[295699] pg_regress/create_procedure HINT:  To call a function, use SELECT.
2023-08-01 17:01:36.134 +07 client backend[295699] pg_regress/create_procedure STATEMENT:  CALL sum(1);
2023-08-01 17:01:36.134 +07 client backend[295699] pg_regress/create_procedure ERROR:  invalid attribute in procedure definition at character 40
2023-08-01 17:01:36.134 +07 client backend[295699] pg_regress/create_procedure STATEMENT:  CREATE PROCEDURE ptestx() LANGUAGE SQL WINDOW AS $$ INSERT INTO cp_test VALUES (1, 'a') $$;
2023-08-01 17:01:36.134 +07 client backend[295699] pg_regress/create_procedure ERROR:  invalid attribute in procedure definition at character 40
2023-08-01 17:01:36.134 +07 client backend[295699] pg_regress/create_procedure STATEMENT:  CREATE PROCEDURE ptestx() LANGUAGE SQL STRICT AS $$ INSERT INTO cp_test VALUES (1, 'a') $$;
2023-08-01 17:01:36.135 +07 client backend[295699] pg_regress/create_procedure ERROR:  procedures cannot have OUT arguments
2023-08-01 17:01:36.135 +07 client backend[295699] pg_regress/create_procedure HINT:  INOUT arguments are permitted.
2023-08-01 17:01:36.135 +07 client backend[295699] pg_regress/create_procedure STATEMENT:  CREATE PROCEDURE ptestx(OUT a int) LANGUAGE SQL AS $$ INSERT INTO cp_test VALUES (1, 'a') $$;
2023-08-01 17:01:36.135 +07 client backend[295699] pg_regress/create_procedure ERROR:  invalid attribute in procedure definition at character 30
2023-08-01 17:01:36.135 +07 client backend[295699] pg_regress/create_procedure STATEMENT:  ALTER PROCEDURE ptest1(text) STRICT;
2023-08-01 17:01:36.135 +07 client backend[295699] pg_regress/create_procedure ERROR:  ptest1(text) is not a function
2023-08-01 17:01:36.135 +07 client backend[295699] pg_regress/create_procedure STATEMENT:  ALTER FUNCTION ptest1(text) VOLATILE;
2023-08-01 17:01:36.135 +07 client backend[295699] pg_regress/create_procedure ERROR:  cp_testfunc1(integer) is not a procedure
2023-08-01 17:01:36.135 +07 client backend[295699] pg_regress/create_procedure STATEMENT:  ALTER PROCEDURE cp_testfunc1(int) VOLATILE;
2023-08-01 17:01:36.135 +07 client backend[295699] pg_regress/create_procedure ERROR:  procedure nonexistent() does not exist
2023-08-01 17:01:36.135 +07 client backend[295699] pg_regress/create_procedure STATEMENT:  ALTER PROCEDURE nonexistent() VOLATILE;
2023-08-01 17:01:36.135 +07 client backend[295699] pg_regress/create_procedure ERROR:  ptest1(text) is not a function
2023-08-01 17:01:36.135 +07 client backend[295699] pg_regress/create_procedure STATEMENT:  DROP FUNCTION ptest1(text);
2023-08-01 17:01:36.135 +07 client backend[295699] pg_regress/create_procedure ERROR:  cp_testfunc1(integer) is not a procedure
2023-08-01 17:01:36.135 +07 client backend[295699] pg_regress/create_procedure STATEMENT:  DROP PROCEDURE cp_testfunc1(int);
2023-08-01 17:01:36.135 +07 client backend[295699] pg_regress/create_procedure ERROR:  procedure nonexistent() does not exist
2023-08-01 17:01:36.135 +07 client backend[295699] pg_regress/create_procedure STATEMENT:  DROP PROCEDURE nonexistent();
2023-08-01 17:01:36.143 +07 client backend[295699] pg_regress/create_procedure ERROR:  permission denied for procedure ptest1
2023-08-01 17:01:36.143 +07 client backend[295699] pg_regress/create_procedure STATEMENT:  CALL ptest1('a');
2023-08-01 17:01:36.174 +07 client backend[295711] pg_regress/create_index ERROR:  syntax error at or near "ON" at character 28
2023-08-01 17:01:36.174 +07 client backend[295711] pg_regress/create_index STATEMENT:  CREATE INDEX IF NOT EXISTS ON onek USING btree(unique1 int4_ops);
2023-08-01 17:01:36.175 +07 client backend[295712] pg_regress/create_view ERROR:  relation "noview" does not exist
2023-08-01 17:01:36.175 +07 client backend[295712] pg_regress/create_view STATEMENT:  COMMENT ON VIEW noview IS 'no view';
2023-08-01 17:01:36.177 +07 client backend[295712] pg_regress/create_view ERROR:  cannot drop constraint view_base_table_pkey on table view_base_table because other objects depend on it
2023-08-01 17:01:36.177 +07 client backend[295712] pg_regress/create_view DETAIL:  view key_dependent_view depends on constraint view_base_table_pkey on table view_base_table
2023-08-01 17:01:36.177 +07 client backend[295712] pg_regress/create_view HINT:  Use DROP ... CASCADE to drop the dependent objects too.
2023-08-01 17:01:36.177 +07 client backend[295712] pg_regress/create_view STATEMENT:  ALTER TABLE view_base_table DROP CONSTRAINT view_base_table_pkey;
2023-08-01 17:01:36.180 +07 client backend[295712] pg_regress/create_view ERROR:  cannot drop columns from view
2023-08-01 17:01:36.180 +07 client backend[295712] pg_regress/create_view STATEMENT:  CREATE OR REPLACE VIEW viewtest AS
		SELECT a FROM viewtest_tbl WHERE a <> 20;
2023-08-01 17:01:36.180 +07 client backend[295712] pg_regress/create_view ERROR:  cannot change name of view column "a" to "?column?"
2023-08-01 17:01:36.180 +07 client backend[295712] pg_regress/create_view HINT:  Use ALTER VIEW ... RENAME COLUMN ... to change name of view column instead.
2023-08-01 17:01:36.180 +07 client backend[295712] pg_regress/create_view STATEMENT:  CREATE OR REPLACE VIEW viewtest AS
		SELECT 1, * FROM viewtest_tbl;
2023-08-01 17:01:36.181 +07 client backend[295712] pg_regress/create_view ERROR:  cannot change data type of view column "b" from integer to numeric
2023-08-01 17:01:36.181 +07 client backend[295712] pg_regress/create_view STATEMENT:  CREATE OR REPLACE VIEW viewtest AS
		SELECT a, b::numeric FROM viewtest_tbl;
2023-08-01 17:01:36.183 +07 client backend[295714] pg_regress/index_including ERROR:  could not create unique index "tbl_include_unique2_idx_unique"
2023-08-01 17:01:36.183 +07 client backend[295714] pg_regress/index_including DETAIL:  Key (c1, c2)=(1, 2) is duplicated.
2023-08-01 17:01:36.183 +07 client backend[295714] pg_regress/index_including STATEMENT:  CREATE UNIQUE INDEX tbl_include_unique2_idx_unique ON tbl_include_unique2 using btree (c1, c2) INCLUDE (c3, c4);
2023-08-01 17:01:36.183 +07 client backend[295714] pg_regress/index_including ERROR:  could not create unique index "tbl_include_unique2_c1_c2_c3_c4_key"
2023-08-01 17:01:36.183 +07 client backend[295714] pg_regress/index_including DETAIL:  Key (c1, c2)=(1, 2) is duplicated.
2023-08-01 17:01:36.183 +07 client backend[295714] pg_regress/index_including STATEMENT:  ALTER TABLE tbl_include_unique2 add UNIQUE (c1, c2) INCLUDE (c3, c4);
2023-08-01 17:01:36.185 +07 client backend[295712] pg_regress/create_view ERROR:  cannot create temporary relation in non-temporary schema
2023-08-01 17:01:36.185 +07 client backend[295712] pg_regress/create_view STATEMENT:  CREATE VIEW temp_view_test.v3_temp AS SELECT * FROM temp_table;
2023-08-01 17:01:36.185 +07 client backend[295712] pg_regress/create_view ERROR:  cannot create temporary relation in non-temporary schema
2023-08-01 17:01:36.185 +07 client backend[295712] pg_regress/create_view STATEMENT:  CREATE SCHEMA test_view_schema
	    CREATE TEMP VIEW testview AS SELECT 1;
2023-08-01 17:01:36.188 +07 client backend[295714] pg_regress/index_including ERROR:  could not create unique index "tbl_include_box_pk_pkey"
2023-08-01 17:01:36.188 +07 client backend[295714] pg_regress/index_including DETAIL:  Key (c1, c2)=(1, 2) is duplicated.
2023-08-01 17:01:36.188 +07 client backend[295714] pg_regress/index_including STATEMENT:  ALTER TABLE tbl_include_box_pk add PRIMARY KEY (c1, c2) INCLUDE (c3, c4);
2023-08-01 17:01:36.190 +07 client backend[295714] pg_regress/index_including ERROR:  duplicate key value violates unique constraint "covering"
2023-08-01 17:01:36.190 +07 client backend[295714] pg_regress/index_including DETAIL:  Key (c1, c2)=(1, 2) already exists.
2023-08-01 17:01:36.190 +07 client backend[295714] pg_regress/index_including STATEMENT:  INSERT INTO tbl SELECT 1, 2, 3*x, box('4,4,4,4') FROM generate_series(1,10) AS x;
2023-08-01 17:01:36.192 +07 client backend[295714] pg_regress/index_including ERROR:  duplicate key value violates unique constraint "covering"
2023-08-01 17:01:36.192 +07 client backend[295714] pg_regress/index_including DETAIL:  Key (c1, c2)=(1, 2) already exists.
2023-08-01 17:01:36.192 +07 client backend[295714] pg_regress/index_including STATEMENT:  INSERT INTO tbl SELECT 1, 2, 3*x, box('4,4,4,4') FROM generate_series(1,10) AS x;
2023-08-01 17:01:36.192 +07 client backend[295714] pg_regress/index_including ERROR:  null value in column "c2" of relation "tbl" violates not-null constraint
2023-08-01 17:01:36.192 +07 client backend[295714] pg_regress/index_including DETAIL:  Failing row contains (1, null, 3, (4,4),(4,4)).
2023-08-01 17:01:36.192 +07 client backend[295714] pg_regress/index_including STATEMENT:  INSERT INTO tbl SELECT 1, NULL, 3*x, box('4,4,4,4') FROM generate_series(1,10) AS x;
2023-08-01 17:01:36.196 +07 client backend[295714] pg_regress/index_including ERROR:  duplicate key value violates unique constraint "tbl_c1_c2_c3_c4_key"
2023-08-01 17:01:36.196 +07 client backend[295714] pg_regress/index_including DETAIL:  Key (c1, c2)=(1, 2) already exists.
2023-08-01 17:01:36.196 +07 client backend[295714] pg_regress/index_including STATEMENT:  INSERT INTO tbl SELECT 1, 2, 3*x, box('4,4,4,4') FROM generate_series(1,10) AS x;
2023-08-01 17:01:36.198 +07 client backend[295714] pg_regress/index_including ERROR:  duplicate key value violates unique constraint "tbl_pkey"
2023-08-01 17:01:36.198 +07 client backend[295714] pg_regress/index_including DETAIL:  Key (c1, c2)=(1, 2) already exists.
2023-08-01 17:01:36.198 +07 client backend[295714] pg_regress/index_including STATEMENT:  INSERT INTO tbl SELECT 1, 2, 3*x, box('4,4,4,4') FROM generate_series(1,10) AS x;
2023-08-01 17:01:36.198 +07 client backend[295714] pg_regress/index_including ERROR:  null value in column "c2" of relation "tbl" violates not-null constraint
2023-08-01 17:01:36.198 +07 client backend[295714] pg_regress/index_including DETAIL:  Failing row contains (1, null, 3, (4,4),(4,4)).
2023-08-01 17:01:36.198 +07 client backend[295714] pg_regress/index_including STATEMENT:  INSERT INTO tbl SELECT 1, NULL, 3*x, box('4,4,4,4') FROM generate_series(1,10) AS x;
2023-08-01 17:01:36.200 +07 client backend[295714] pg_regress/index_including ERROR:  conflicting key value violates exclusion constraint "tbl_c1_c3_c4_excl"
2023-08-01 17:01:36.200 +07 client backend[295714] pg_regress/index_including DETAIL:  Key (c1)=(1) conflicts with existing key (c1)=(1).
2023-08-01 17:01:36.200 +07 client backend[295714] pg_regress/index_including STATEMENT:  INSERT INTO tbl SELECT 1, 2, 3*x, box('4,4,4,4') FROM generate_series(1,10) AS x;
2023-08-01 17:01:36.208 +07 client backend[295712] pg_regress/create_view ERROR:  invalid value for boolean option "security_barrier": 100
2023-08-01 17:01:36.208 +07 client backend[295712] pg_regress/create_view STATEMENT:  CREATE VIEW mysecview5 WITH (security_barrier=100)	
	       AS SELECT * FROM tbl1 WHERE a > 100;
2023-08-01 17:01:36.208 +07 client backend[295712] pg_regress/create_view ERROR:  unrecognized parameter "invalid_option"
2023-08-01 17:01:36.208 +07 client backend[295712] pg_regress/create_view STATEMENT:  CREATE VIEW mysecview6 WITH (invalid_option)		
	       AS SELECT * FROM tbl1 WHERE a < 100;
2023-08-01 17:01:36.210 +07 client backend[295711] pg_regress/create_index ERROR:  relation "six_wrong" does not exist
2023-08-01 17:01:36.210 +07 client backend[295711] pg_regress/create_index STATEMENT:  COMMENT ON INDEX six_wrong IS 'bad index';
2023-08-01 17:01:36.212 +07 client backend[295714] pg_regress/index_including ERROR:  cannot alter statistics on non-expression column "c1" of index "tbl_idx"
2023-08-01 17:01:36.212 +07 client backend[295714] pg_regress/index_including HINT:  Alter statistics on table column instead.
2023-08-01 17:01:36.212 +07 client backend[295714] pg_regress/index_including STATEMENT:  ALTER INDEX tbl_idx ALTER COLUMN 1 SET STATISTICS 1000;
2023-08-01 17:01:36.212 +07 client backend[295714] pg_regress/index_including ERROR:  cannot alter statistics on included column "c2" of index "tbl_idx"
2023-08-01 17:01:36.212 +07 client backend[295714] pg_regress/index_including STATEMENT:  ALTER INDEX tbl_idx ALTER COLUMN 3 SET STATISTICS 1000;
2023-08-01 17:01:36.212 +07 client backend[295714] pg_regress/index_including ERROR:  column number 4 of relation "tbl_idx" does not exist
2023-08-01 17:01:36.212 +07 client backend[295714] pg_regress/index_including STATEMENT:  ALTER INDEX tbl_idx ALTER COLUMN 4 SET STATISTICS 1000;
2023-08-01 17:01:36.245 +07 client backend[295714] pg_regress/index_including ERROR:  relation "tbl_c1_c2_c3_c4_key" does not exist
2023-08-01 17:01:36.245 +07 client backend[295714] pg_regress/index_including STATEMENT:  REINDEX INDEX tbl_c1_c2_c3_c4_key;
2023-08-01 17:01:36.247 +07 client backend[295714] pg_regress/index_including ERROR:  access method "brin" does not support included columns
2023-08-01 17:01:36.247 +07 client backend[295714] pg_regress/index_including STATEMENT:  CREATE INDEX on tbl USING brin(c1, c2) INCLUDE (c3, c4);
2023-08-01 17:01:36.248 +07 client backend[295714] pg_regress/index_including ERROR:  access method "spgist" does not support included columns
2023-08-01 17:01:36.248 +07 client backend[295714] pg_regress/index_including STATEMENT:  CREATE INDEX on tbl USING spgist(c3) INCLUDE (c4);
2023-08-01 17:01:36.248 +07 client backend[295714] pg_regress/index_including ERROR:  access method "gin" does not support included columns
2023-08-01 17:01:36.248 +07 client backend[295714] pg_regress/index_including STATEMENT:  CREATE INDEX on tbl USING gin(c1, c2) INCLUDE (c3, c4);
2023-08-01 17:01:36.248 +07 client backend[295714] pg_regress/index_including ERROR:  access method "hash" does not support included columns
2023-08-01 17:01:36.248 +07 client backend[295714] pg_regress/index_including STATEMENT:  CREATE INDEX on tbl USING hash(c1, c2) INCLUDE (c3, c4);
2023-08-01 17:01:36.251 +07 client backend[295714] pg_regress/index_including ERROR:  duplicate key value violates unique constraint "tbl_idx_unique"
2023-08-01 17:01:36.251 +07 client backend[295714] pg_regress/index_including DETAIL:  Key (c1, c2)=(1, 2) already exists.
2023-08-01 17:01:36.251 +07 client backend[295714] pg_regress/index_including STATEMENT:  UPDATE tbl SET c2 = 2 WHERE c1 = 1;
2023-08-01 17:01:36.278 +07 client backend[295712] pg_regress/create_view ERROR:  attribute 3 of type record has been dropped
2023-08-01 17:01:36.278 +07 client backend[295712] pg_regress/create_view STATEMENT:  select * from tt14v;
2023-08-01 17:01:36.280 +07 client backend[295712] pg_regress/create_view ERROR:  attribute 4 of type record has wrong type
2023-08-01 17:01:36.280 +07 client backend[295712] pg_regress/create_view DETAIL:  Table has type integer, but query expects text.
2023-08-01 17:01:36.280 +07 client backend[295712] pg_regress/create_view STATEMENT:  select * from tt14v;
2023-08-01 17:01:36.284 +07 client backend[295712] pg_regress/create_view ERROR:  operator does not exist: text = text[] at character 20
2023-08-01 17:01:36.284 +07 client backend[295712] pg_regress/create_view HINT:  No operator matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:36.284 +07 client backend[295712] pg_regress/create_view STATEMENT:  select 'foo'::text = any((select array['abc','def','foo']::text[]));
2023-08-01 17:01:36.332 +07 client backend[295715] pg_regress/index_including_gist ERROR:  conflicting key value violates exclusion constraint "tbl_gist_c4_c1_c2_c3_excl"
2023-08-01 17:01:36.332 +07 client backend[295715] pg_regress/index_including_gist DETAIL:  Key (c4)=((4,5),(2,3)) conflicts with existing key (c4)=((2,3),(1,2)).
2023-08-01 17:01:36.332 +07 client backend[295715] pg_regress/index_including_gist STATEMENT:  INSERT INTO tbl_gist SELECT x, 2*x, 3*x, box(point(x,x+1),point(2*x,2*x+1)) FROM generate_series(1,10) AS x;
2023-08-01 17:01:36.377 +07 client backend[295711] pg_regress/create_index ERROR:  duplicate key value violates unique constraint "func_index_index"
2023-08-01 17:01:36.377 +07 client backend[295711] pg_regress/create_index DETAIL:  Key (textcat(f1, f2))=(ABCDEF) already exists.
2023-08-01 17:01:36.377 +07 client backend[295711] pg_regress/create_index STATEMENT:  INSERT INTO func_index_heap VALUES('ABCD', 'EF');
2023-08-01 17:01:36.384 +07 client backend[295711] pg_regress/create_index ERROR:  duplicate key value violates unique constraint "func_index_index"
2023-08-01 17:01:36.384 +07 client backend[295711] pg_regress/create_index DETAIL:  Key ((f1 || f2))=(ABCDEF) already exists.
2023-08-01 17:01:36.384 +07 client backend[295711] pg_regress/create_index STATEMENT:  INSERT INTO func_index_heap VALUES('ABCD', 'EF');
2023-08-01 17:01:36.387 +07 client backend[295711] pg_regress/create_index ERROR:  column "row" has pseudo-type record
2023-08-01 17:01:36.387 +07 client backend[295711] pg_regress/create_index STATEMENT:  create index on func_index_heap ((f1 || f2), (row(f1, f2)));
2023-08-01 17:01:36.389 +07 client backend[295711] pg_regress/create_index ERROR:  duplicate key value violates unique constraint "covering_index_index"
2023-08-01 17:01:36.389 +07 client backend[295711] pg_regress/create_index DETAIL:  Key (f1, f2)=(1, 2) already exists.
2023-08-01 17:01:36.389 +07 client backend[295711] pg_regress/create_index STATEMENT:  INSERT INTO covering_index_heap VALUES(1,2,'BBB');
2023-08-01 17:01:36.406 +07 client backend[295711] pg_regress/create_index ERROR:  duplicate key value violates unique constraint "concur_index2"
2023-08-01 17:01:36.406 +07 client backend[295711] pg_regress/create_index DETAIL:  Key (f1)=(b) already exists.
2023-08-01 17:01:36.406 +07 client backend[295711] pg_regress/create_index STATEMENT:  INSERT INTO concur_heap VALUES ('b','x');
2023-08-01 17:01:36.406 +07 client backend[295711] pg_regress/create_index ERROR:  could not create unique index "concur_index3"
2023-08-01 17:01:36.406 +07 client backend[295711] pg_regress/create_index DETAIL:  Key (f2)=(b) is duplicated.
2023-08-01 17:01:36.406 +07 client backend[295711] pg_regress/create_index STATEMENT:  CREATE UNIQUE INDEX CONCURRENTLY concur_index3 ON concur_heap(f2);
2023-08-01 17:01:36.432 +07 client backend[295711] pg_regress/create_index ERROR:  CREATE INDEX CONCURRENTLY cannot run inside a transaction block
2023-08-01 17:01:36.432 +07 client backend[295711] pg_regress/create_index STATEMENT:  CREATE INDEX CONCURRENTLY concur_index7 ON concur_heap(f1);
2023-08-01 17:01:36.446 +07 client backend[295711] pg_regress/create_index ERROR:  could not create unique index "concur_index3"
2023-08-01 17:01:36.446 +07 client backend[295711] pg_regress/create_index DETAIL:  Key (f2)=(b) is duplicated.
2023-08-01 17:01:36.446 +07 client backend[295711] pg_regress/create_index STATEMENT:  REINDEX TABLE concur_heap;
2023-08-01 17:01:36.458 +07 client backend[295711] pg_regress/create_index ERROR:  CREATE INDEX CONCURRENTLY cannot run inside a transaction block
2023-08-01 17:01:36.458 +07 client backend[295711] pg_regress/create_index STATEMENT:  CREATE INDEX CONCURRENTLY concur_temp_ind ON concur_temp(f1);
2023-08-01 17:01:36.461 +07 client backend[295711] pg_regress/create_index ERROR:  DROP INDEX CONCURRENTLY does not support dropping multiple objects
2023-08-01 17:01:36.461 +07 client backend[295711] pg_regress/create_index STATEMENT:  DROP INDEX CONCURRENTLY "concur_index2", "concur_index3";
2023-08-01 17:01:36.461 +07 client backend[295711] pg_regress/create_index ERROR:  DROP INDEX CONCURRENTLY cannot run inside a transaction block
2023-08-01 17:01:36.461 +07 client backend[295711] pg_regress/create_index STATEMENT:  DROP INDEX CONCURRENTLY "concur_index5";
2023-08-01 17:01:36.472 +07 client backend[295711] pg_regress/create_index ERROR:  cannot drop index cwi_replaced_pkey because constraint cwi_replaced_pkey on table cwi_test requires it
2023-08-01 17:01:36.472 +07 client backend[295711] pg_regress/create_index HINT:  You can drop constraint cwi_replaced_pkey on table cwi_test instead.
2023-08-01 17:01:36.472 +07 client backend[295711] pg_regress/create_index STATEMENT:  DROP INDEX cwi_replaced_pkey;
2023-08-01 17:01:36.472 +07 client backend[295711] pg_regress/create_index ERROR:  index "cwi_uniq3_idx" column number 1 does not have default sorting behavior at character 26
2023-08-01 17:01:36.472 +07 client backend[295711] pg_regress/create_index DETAIL:  Cannot create a primary key or unique constraint using such an index.
2023-08-01 17:01:36.472 +07 client backend[295711] pg_regress/create_index STATEMENT:  ALTER TABLE cwi_test ADD UNIQUE USING INDEX cwi_uniq3_idx;
2023-08-01 17:01:36.473 +07 client backend[295711] pg_regress/create_index ERROR:  index "cwi_uniq4_idx" column number 1 does not have default sorting behavior at character 26
2023-08-01 17:01:36.473 +07 client backend[295711] pg_regress/create_index DETAIL:  Cannot create a primary key or unique constraint using such an index.
2023-08-01 17:01:36.473 +07 client backend[295711] pg_regress/create_index STATEMENT:  ALTER TABLE cwi_test ADD UNIQUE USING INDEX cwi_uniq4_idx;
2023-08-01 17:01:36.474 +07 client backend[295711] pg_regress/create_index ERROR:  ALTER TABLE / ADD CONSTRAINT USING INDEX is not supported on partitioned tables
2023-08-01 17:01:36.474 +07 client backend[295711] pg_regress/create_index STATEMENT:  alter table cwi_test add primary key using index cwi_test_a_idx ;
2023-08-01 17:01:36.474 +07 client backend[295711] pg_regress/create_index ERROR:  relation "syscolcol_table" does not exist
2023-08-01 17:01:36.474 +07 client backend[295711] pg_regress/create_index STATEMENT:  CREATE INDEX ON syscolcol_table (ctid);
2023-08-01 17:01:36.474 +07 client backend[295711] pg_regress/create_index ERROR:  index creation on system columns is not supported
2023-08-01 17:01:36.474 +07 client backend[295711] pg_regress/create_index STATEMENT:  CREATE INDEX ON syscol_table ((ctid >= '(1000,0)'));
2023-08-01 17:01:36.475 +07 client backend[295711] pg_regress/create_index ERROR:  index creation on system columns is not supported
2023-08-01 17:01:36.475 +07 client backend[295711] pg_regress/create_index STATEMENT:  CREATE INDEX ON syscol_table (a) WHERE ctid >= '(1000,0)';
2023-08-01 17:01:36.511 +07 client backend[295711] pg_regress/create_index ERROR:  concurrent index creation for exclusion constraints is not supported
2023-08-01 17:01:36.511 +07 client backend[295711] pg_regress/create_index STATEMENT:  REINDEX INDEX CONCURRENTLY  concur_reindex_tab3_c2_excl;
2023-08-01 17:01:36.511 +07 client backend[295711] pg_regress/create_index WARNING:  cannot reindex exclusion constraint index "public.concur_reindex_tab3_c2_excl" concurrently, skipping
2023-08-01 17:01:36.512 +07 client backend[295711] pg_regress/create_index ERROR:  conflicting key value violates exclusion constraint "concur_reindex_tab3_c2_excl"
2023-08-01 17:01:36.512 +07 client backend[295711] pg_regress/create_index DETAIL:  Key (c2)=([2,5)) conflicts with existing key (c2)=([1,3)).
2023-08-01 17:01:36.512 +07 client backend[295711] pg_regress/create_index STATEMENT:  INSERT INTO concur_reindex_tab3 VALUES  (4, '[2,4]');
2023-08-01 17:01:36.527 +07 client backend[295711] pg_regress/create_index ERROR:  REINDEX is not yet implemented for partitioned indexes
2023-08-01 17:01:36.527 +07 client backend[295711] pg_regress/create_index STATEMENT:  REINDEX INDEX concur_reindex_part_index_10;
2023-08-01 17:01:36.527 +07 client backend[295711] pg_regress/create_index ERROR:  REINDEX is not yet implemented for partitioned indexes
2023-08-01 17:01:36.527 +07 client backend[295711] pg_regress/create_index STATEMENT:  REINDEX INDEX CONCURRENTLY concur_reindex_part_index_10;
2023-08-01 17:01:36.527 +07 client backend[295711] pg_regress/create_index WARNING:  REINDEX of partitioned tables is not yet implemented, skipping "concur_reindex_part_10"
2023-08-01 17:01:36.527 +07 client backend[295711] pg_regress/create_index WARNING:  REINDEX of partitioned tables is not yet implemented, skipping "concur_reindex_part_10"
2023-08-01 17:01:36.532 +07 client backend[295711] pg_regress/create_index ERROR:  REINDEX CONCURRENTLY cannot run inside a transaction block
2023-08-01 17:01:36.532 +07 client backend[295711] pg_regress/create_index STATEMENT:  REINDEX TABLE CONCURRENTLY concur_reindex_tab;
2023-08-01 17:01:36.532 +07 client backend[295711] pg_regress/create_index ERROR:  cannot reindex system catalogs concurrently
2023-08-01 17:01:36.532 +07 client backend[295711] pg_regress/create_index STATEMENT:  REINDEX TABLE CONCURRENTLY pg_class;
2023-08-01 17:01:36.532 +07 client backend[295711] pg_regress/create_index ERROR:  cannot reindex system catalogs concurrently
2023-08-01 17:01:36.532 +07 client backend[295711] pg_regress/create_index STATEMENT:  REINDEX INDEX CONCURRENTLY pg_class_oid_index;
2023-08-01 17:01:36.532 +07 client backend[295711] pg_regress/create_index ERROR:  cannot reindex system catalogs concurrently
2023-08-01 17:01:36.532 +07 client backend[295711] pg_regress/create_index STATEMENT:  REINDEX TABLE CONCURRENTLY pg_toast.pg_toast_1260;
2023-08-01 17:01:36.532 +07 client backend[295711] pg_regress/create_index ERROR:  cannot reindex system catalogs concurrently
2023-08-01 17:01:36.532 +07 client backend[295711] pg_regress/create_index STATEMENT:  REINDEX INDEX CONCURRENTLY pg_toast.pg_toast_1260_index;
2023-08-01 17:01:36.532 +07 client backend[295711] pg_regress/create_index ERROR:  cannot reindex system catalogs concurrently
2023-08-01 17:01:36.532 +07 client backend[295711] pg_regress/create_index STATEMENT:  REINDEX SYSTEM CONCURRENTLY postgres;
2023-08-01 17:01:36.532 +07 client backend[295711] pg_regress/create_index WARNING:  cannot reindex system catalogs concurrently, skipping all
2023-08-01 17:01:36.537 +07 client backend[295711] pg_regress/create_index ERROR:  could not create unique index "concur_reindex_ind5"
2023-08-01 17:01:36.537 +07 client backend[295711] pg_regress/create_index DETAIL:  Key (c1)=(1) is duplicated.
2023-08-01 17:01:36.537 +07 client backend[295711] pg_regress/create_index STATEMENT:  CREATE UNIQUE INDEX CONCURRENTLY concur_reindex_ind5 ON concur_reindex_tab4 (c1);
2023-08-01 17:01:36.537 +07 client backend[295711] pg_regress/create_index ERROR:  could not create unique index "concur_reindex_ind5_ccnew"
2023-08-01 17:01:36.537 +07 client backend[295711] pg_regress/create_index DETAIL:  Key (c1)=(1) is duplicated.
2023-08-01 17:01:36.537 +07 client backend[295711] pg_regress/create_index STATEMENT:  REINDEX INDEX CONCURRENTLY concur_reindex_ind5;
2023-08-01 17:01:36.540 +07 client backend[295711] pg_regress/create_index WARNING:  cannot reindex invalid index "public.concur_reindex_ind5" concurrently, skipping
2023-08-01 17:01:36.554 +07 client backend[295711] pg_regress/create_index ERROR:  REINDEX CONCURRENTLY cannot run inside a transaction block
2023-08-01 17:01:36.554 +07 client backend[295711] pg_regress/create_index STATEMENT:  REINDEX INDEX CONCURRENTLY concur_temp_ind_1;
2023-08-01 17:01:36.557 +07 client backend[295711] pg_regress/create_index ERROR:  REINDEX CONCURRENTLY cannot run inside a transaction block
2023-08-01 17:01:36.557 +07 client backend[295711] pg_regress/create_index STATEMENT:  REINDEX INDEX CONCURRENTLY concur_temp_ind_3;
2023-08-01 17:01:36.570 +07 client backend[295711] pg_regress/create_index ERROR:  schema "schema_to_reindex" does not exist
2023-08-01 17:01:36.570 +07 client backend[295711] pg_regress/create_index STATEMENT:  REINDEX SCHEMA schema_to_reindex;
2023-08-01 17:01:36.580 +07 client backend[295711] pg_regress/create_index ERROR:  REINDEX SCHEMA cannot run inside a transaction block
2023-08-01 17:01:36.580 +07 client backend[295711] pg_regress/create_index STATEMENT:  REINDEX SCHEMA schema_to_reindex;
2023-08-01 17:01:36.583 +07 client backend[295711] pg_regress/create_index ERROR:  must be owner of schema schema_to_reindex
2023-08-01 17:01:36.583 +07 client backend[295711] pg_regress/create_index STATEMENT:  REINDEX SCHEMA schema_to_reindex;
2023-08-01 17:01:36.584 +07 client backend[295711] pg_regress/create_index ERROR:  must be owner of table pg_toast_1260
2023-08-01 17:01:36.584 +07 client backend[295711] pg_regress/create_index STATEMENT:  REINDEX TABLE pg_toast.pg_toast_1260;
2023-08-01 17:01:36.584 +07 client backend[295711] pg_regress/create_index ERROR:  must be owner of index pg_toast_1260_index
2023-08-01 17:01:36.584 +07 client backend[295711] pg_regress/create_index STATEMENT:  REINDEX INDEX pg_toast.pg_toast_1260_index;
2023-08-01 17:01:36.596 +07 client backend[295748] pg_regress/typed_table ERROR:  type "nothing" does not exist
2023-08-01 17:01:36.596 +07 client backend[295748] pg_regress/typed_table STATEMENT:  CREATE TABLE ttable1 OF nothing;
2023-08-01 17:01:36.596 +07 client backend[295742] pg_regress/create_cast ERROR:  function casttestfunc(text) does not exist at character 8
2023-08-01 17:01:36.596 +07 client backend[295742] pg_regress/create_cast HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:36.596 +07 client backend[295742] pg_regress/create_cast STATEMENT:  SELECT casttestfunc('foo'::text);
2023-08-01 17:01:36.596 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  table "test_exists" does not exist
2023-08-01 17:01:36.596 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP TABLE test_exists;
2023-08-01 17:01:36.598 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  view "test_view_exists" does not exist
2023-08-01 17:01:36.598 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP VIEW test_view_exists;
2023-08-01 17:01:36.598 +07 client backend[295742] pg_regress/create_cast ERROR:  function casttestfunc(text) does not exist at character 8
2023-08-01 17:01:36.598 +07 client backend[295742] pg_regress/create_cast HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:36.598 +07 client backend[295742] pg_regress/create_cast STATEMENT:  SELECT casttestfunc('foo'::text);
2023-08-01 17:01:36.599 +07 client backend[295752] pg_regress/create_am ERROR:  function int4in(internal) does not exist
2023-08-01 17:01:36.599 +07 client backend[295752] pg_regress/create_am STATEMENT:  CREATE ACCESS METHOD bogus TYPE INDEX HANDLER int4in;
2023-08-01 17:01:36.599 +07 client backend[295752] pg_regress/create_am ERROR:  function heap_tableam_handler must return type index_am_handler
2023-08-01 17:01:36.599 +07 client backend[295752] pg_regress/create_am STATEMENT:  CREATE ACCESS METHOD bogus TYPE INDEX HANDLER heap_tableam_handler;
2023-08-01 17:01:36.599 +07 client backend[295752] pg_regress/create_am ERROR:  data type box has no default operator class for access method "gist2"
2023-08-01 17:01:36.599 +07 client backend[295752] pg_regress/create_am HINT:  You must specify an operator class for the index or define a default operator class for the data type.
2023-08-01 17:01:36.599 +07 client backend[295752] pg_regress/create_am STATEMENT:  CREATE INDEX grect2ind2 ON fast_emp4000 USING gist2 (home_base);
2023-08-01 17:01:36.599 +07 client backend[295756] pg_regress/errors ERROR:  relation "nonesuch" does not exist at character 15
2023-08-01 17:01:36.599 +07 client backend[295756] pg_regress/errors STATEMENT:  select * from nonesuch;
2023-08-01 17:01:36.599 +07 client backend[295756] pg_regress/errors ERROR:  column "nonesuch" does not exist at character 8
2023-08-01 17:01:36.599 +07 client backend[295756] pg_regress/errors STATEMENT:  select nonesuch from pg_database;
2023-08-01 17:01:36.599 +07 client backend[295742] pg_regress/create_cast ERROR:  cannot cast type integer to casttesttype at character 18
2023-08-01 17:01:36.599 +07 client backend[295742] pg_regress/create_cast STATEMENT:  SELECT 1234::int4::casttesttype;
2023-08-01 17:01:36.599 +07 client backend[295756] pg_regress/errors ERROR:  syntax error at or near "from" at character 17
2023-08-01 17:01:36.599 +07 client backend[295756] pg_regress/errors STATEMENT:  select distinct from pg_database;
2023-08-01 17:01:36.599 +07 client backend[295756] pg_regress/errors ERROR:  column "nonesuch" does not exist at character 33
2023-08-01 17:01:36.599 +07 client backend[295756] pg_regress/errors STATEMENT:  select * from pg_database where nonesuch = pg_database.datname;
2023-08-01 17:01:36.599 +07 client backend[295756] pg_regress/errors ERROR:  column "nonesuch" does not exist at character 55
2023-08-01 17:01:36.599 +07 client backend[295756] pg_regress/errors STATEMENT:  select * from pg_database where pg_database.datname = nonesuch;
2023-08-01 17:01:36.599 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  view "test_view_exists" does not exist
2023-08-01 17:01:36.599 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP VIEW test_view_exists;
2023-08-01 17:01:36.599 +07 client backend[295756] pg_regress/errors ERROR:  column "foobar" does not exist at character 21
2023-08-01 17:01:36.599 +07 client backend[295756] pg_regress/errors STATEMENT:  select distinct on (foobar) * from pg_database;
2023-08-01 17:01:36.599 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  index "test_index_exists" does not exist
2023-08-01 17:01:36.599 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP INDEX test_index_exists;
2023-08-01 17:01:36.599 +07 client backend[295756] pg_regress/errors ERROR:  syntax error at or near ";" at character 12
2023-08-01 17:01:36.599 +07 client backend[295756] pg_regress/errors STATEMENT:  delete from;
2023-08-01 17:01:36.600 +07 client backend[295756] pg_regress/errors ERROR:  relation "nonesuch" does not exist at character 13
2023-08-01 17:01:36.600 +07 client backend[295756] pg_regress/errors STATEMENT:  delete from nonesuch;
2023-08-01 17:01:36.600 +07 client backend[295756] pg_regress/errors ERROR:  syntax error at or near ";" at character 11
2023-08-01 17:01:36.600 +07 client backend[295756] pg_regress/errors STATEMENT:  drop table;
2023-08-01 17:01:36.600 +07 client backend[295756] pg_regress/errors ERROR:  table "nonesuch" does not exist
2023-08-01 17:01:36.600 +07 client backend[295756] pg_regress/errors STATEMENT:  drop table nonesuch;
2023-08-01 17:01:36.600 +07 client backend[295756] pg_regress/errors ERROR:  syntax error at or near ";" at character 19
2023-08-01 17:01:36.600 +07 client backend[295756] pg_regress/errors STATEMENT:  alter table rename;
2023-08-01 17:01:36.600 +07 client backend[295756] pg_regress/errors ERROR:  relation "nonesuch" does not exist
2023-08-01 17:01:36.600 +07 client backend[295756] pg_regress/errors STATEMENT:  alter table nonesuch rename to newnonesuch;
2023-08-01 17:01:36.600 +07 client backend[295756] pg_regress/errors ERROR:  relation "nonesuch" does not exist
2023-08-01 17:01:36.600 +07 client backend[295756] pg_regress/errors STATEMENT:  alter table nonesuch rename to stud_emp;
2023-08-01 17:01:36.600 +07 client backend[295756] pg_regress/errors ERROR:  relation "aggtest" already exists
2023-08-01 17:01:36.600 +07 client backend[295756] pg_regress/errors STATEMENT:  alter table stud_emp rename to aggtest;
2023-08-01 17:01:36.600 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  index "test_index_exists" does not exist
2023-08-01 17:01:36.600 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP INDEX test_index_exists;
2023-08-01 17:01:36.600 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  sequence "test_sequence_exists" does not exist
2023-08-01 17:01:36.600 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP SEQUENCE test_sequence_exists;
2023-08-01 17:01:36.600 +07 client backend[295756] pg_regress/errors ERROR:  relation "stud_emp" already exists
2023-08-01 17:01:36.600 +07 client backend[295756] pg_regress/errors STATEMENT:  alter table stud_emp rename to stud_emp;
2023-08-01 17:01:36.601 +07 client backend[295756] pg_regress/errors ERROR:  relation "nonesuchrel" does not exist
2023-08-01 17:01:36.601 +07 client backend[295756] pg_regress/errors STATEMENT:  alter table nonesuchrel rename column nonesuchatt to newnonesuchatt;
2023-08-01 17:01:36.601 +07 client backend[295739] pg_regress/create_aggregate ERROR:  aggregate newavg_wrong(integer) does not exist
2023-08-01 17:01:36.601 +07 client backend[295739] pg_regress/create_aggregate STATEMENT:  COMMENT ON AGGREGATE newavg_wrong (int4) IS 'an agg comment';
2023-08-01 17:01:36.601 +07 client backend[295756] pg_regress/errors ERROR:  column "nonesuchatt" does not exist
2023-08-01 17:01:36.601 +07 client backend[295756] pg_regress/errors STATEMENT:  alter table emp rename column nonesuchatt to newnonesuchatt;
2023-08-01 17:01:36.602 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  sequence "test_sequence_exists" does not exist
2023-08-01 17:01:36.602 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP SEQUENCE test_sequence_exists;
2023-08-01 17:01:36.602 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  schema "test_schema_exists" does not exist
2023-08-01 17:01:36.602 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP SCHEMA test_schema_exists;
2023-08-01 17:01:36.602 +07 client backend[295756] pg_regress/errors ERROR:  column "manager" of relation "stud_emp" already exists
2023-08-01 17:01:36.602 +07 client backend[295756] pg_regress/errors STATEMENT:  alter table emp rename column salary to manager;
2023-08-01 17:01:36.602 +07 client backend[295756] pg_regress/errors ERROR:  column name "ctid" conflicts with a system column name
2023-08-01 17:01:36.602 +07 client backend[295756] pg_regress/errors STATEMENT:  alter table emp rename column salary to ctid;
2023-08-01 17:01:36.602 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  schema "test_schema_exists" does not exist
2023-08-01 17:01:36.602 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP SCHEMA test_schema_exists;
2023-08-01 17:01:36.602 +07 client backend[295756] pg_regress/errors WARNING:  there is no transaction in progress
2023-08-01 17:01:36.602 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  type "test_type_exists" does not exist
2023-08-01 17:01:36.602 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP TYPE test_type_exists;
2023-08-01 17:01:36.602 +07 client backend[295756] pg_regress/errors WARNING:  there is no transaction in progress
2023-08-01 17:01:36.602 +07 client backend[295756] pg_regress/errors ERROR:  function int2um(integer) does not exist
2023-08-01 17:01:36.602 +07 client backend[295756] pg_regress/errors STATEMENT:  create aggregate newavg2 (sfunc = int4pl,
				  basetype = int4,
				  stype = int4,
				  finalfunc = int2um,
				  initcond = '0');
2023-08-01 17:01:36.603 +07 client backend[295756] pg_regress/errors ERROR:  aggregate input type must be specified
2023-08-01 17:01:36.603 +07 client backend[295756] pg_regress/errors STATEMENT:  create aggregate newcnt1 (sfunc = int4inc,
				  stype = int4,
				  initcond = '0');
2023-08-01 17:01:36.603 +07 client backend[295756] pg_regress/errors ERROR:  syntax error at or near ";" at character 11
2023-08-01 17:01:36.603 +07 client backend[295756] pg_regress/errors STATEMENT:  drop index;
2023-08-01 17:01:36.603 +07 client backend[295756] pg_regress/errors ERROR:  syntax error at or near "314159" at character 12
2023-08-01 17:01:36.603 +07 client backend[295756] pg_regress/errors STATEMENT:  drop index 314159;
2023-08-01 17:01:36.603 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  type "test_type_exists" does not exist
2023-08-01 17:01:36.603 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP TYPE test_type_exists;
2023-08-01 17:01:36.603 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  type "test_domain_exists" does not exist
2023-08-01 17:01:36.603 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP DOMAIN test_domain_exists;
2023-08-01 17:01:36.603 +07 client backend[295756] pg_regress/errors ERROR:  index "nonesuch" does not exist
2023-08-01 17:01:36.603 +07 client backend[295756] pg_regress/errors STATEMENT:  drop index nonesuch;
2023-08-01 17:01:36.603 +07 client backend[295756] pg_regress/errors ERROR:  syntax error at or near ";" at character 15
2023-08-01 17:01:36.603 +07 client backend[295756] pg_regress/errors STATEMENT:  drop aggregate;
2023-08-01 17:01:36.603 +07 client backend[295756] pg_regress/errors ERROR:  syntax error at or near ";" at character 23
2023-08-01 17:01:36.603 +07 client backend[295756] pg_regress/errors STATEMENT:  drop aggregate newcnt1;
2023-08-01 17:01:36.604 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  type "test_domain_exists" does not exist
2023-08-01 17:01:36.604 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP DOMAIN test_domain_exists;
2023-08-01 17:01:36.604 +07 client backend[295739] pg_regress/create_aggregate ERROR:  aggregate nosuchagg(*) does not exist
2023-08-01 17:01:36.604 +07 client backend[295739] pg_regress/create_aggregate STATEMENT:  COMMENT ON AGGREGATE nosuchagg (*) IS 'should fail';
2023-08-01 17:01:36.604 +07 client backend[295756] pg_regress/errors ERROR:  syntax error at or near "314159" at character 16
2023-08-01 17:01:36.604 +07 client backend[295756] pg_regress/errors STATEMENT:  drop aggregate 314159 (int);
2023-08-01 17:01:36.604 +07 client backend[295756] pg_regress/errors ERROR:  type "nonesuch" does not exist
2023-08-01 17:01:36.604 +07 client backend[295756] pg_regress/errors STATEMENT:  drop aggregate newcnt (nonesuch);
2023-08-01 17:01:36.604 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  role "regress_test_u2" does not exist
2023-08-01 17:01:36.604 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP USER regress_test_u2;
2023-08-01 17:01:36.604 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  role "regress_test_u1" does not exist
2023-08-01 17:01:36.604 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP USER regress_test_u1;
2023-08-01 17:01:36.604 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  role "regress_test_r2" does not exist
2023-08-01 17:01:36.604 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP ROLE regress_test_r2;
2023-08-01 17:01:36.605 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  role "regress_test_r1" does not exist
2023-08-01 17:01:36.605 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP ROLE regress_test_r1;
2023-08-01 17:01:36.605 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  role "regress_test_g2" does not exist
2023-08-01 17:01:36.605 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP GROUP regress_test_g2;
2023-08-01 17:01:36.605 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  role "regress_test_g1" does not exist
2023-08-01 17:01:36.605 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP GROUP regress_test_g1;
2023-08-01 17:01:36.605 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  conversion "test_conversion_exists" does not exist
2023-08-01 17:01:36.605 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP CONVERSION test_conversion_exists;
2023-08-01 17:01:36.606 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  text search parser "test_tsparser_exists" does not exist
2023-08-01 17:01:36.606 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP TEXT SEARCH PARSER test_tsparser_exists;
2023-08-01 17:01:36.606 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  text search dictionary "test_tsdict_exists" does not exist
2023-08-01 17:01:36.606 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP TEXT SEARCH DICTIONARY test_tsdict_exists;
2023-08-01 17:01:36.606 +07 client backend[295756] pg_regress/errors ERROR:  aggregate nonesuch(integer) does not exist
2023-08-01 17:01:36.606 +07 client backend[295756] pg_regress/errors STATEMENT:  drop aggregate nonesuch (int4);
2023-08-01 17:01:36.606 +07 client backend[295756] pg_regress/errors ERROR:  aggregate newcnt(real) does not exist
2023-08-01 17:01:36.606 +07 client backend[295756] pg_regress/errors STATEMENT:  drop aggregate newcnt (float4);
2023-08-01 17:01:36.606 +07 client backend[295756] pg_regress/errors ERROR:  syntax error at or near "(" at character 15
2023-08-01 17:01:36.606 +07 client backend[295756] pg_regress/errors STATEMENT:  drop function ();
2023-08-01 17:01:36.606 +07 client backend[295756] pg_regress/errors ERROR:  syntax error at or near "314159" at character 15
2023-08-01 17:01:36.606 +07 client backend[295756] pg_regress/errors STATEMENT:  drop function 314159();
2023-08-01 17:01:36.606 +07 client backend[295756] pg_regress/errors ERROR:  function nonesuch() does not exist
2023-08-01 17:01:36.606 +07 client backend[295756] pg_regress/errors STATEMENT:  drop function nonesuch();
2023-08-01 17:01:36.606 +07 client backend[295756] pg_regress/errors ERROR:  syntax error at or near ";" at character 10
2023-08-01 17:01:36.606 +07 client backend[295756] pg_regress/errors STATEMENT:  drop type;
2023-08-01 17:01:36.606 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  text search template "test_tstemplate_exists" does not exist
2023-08-01 17:01:36.606 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP TEXT SEARCH TEMPLATE test_tstemplate_exists;
2023-08-01 17:01:36.607 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  text search configuration "test_tsconfig_exists" does not exist
2023-08-01 17:01:36.607 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP TEXT SEARCH CONFIGURATION test_tsconfig_exists;
2023-08-01 17:01:36.607 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  extension "test_extension_exists" does not exist
2023-08-01 17:01:36.607 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP EXTENSION test_extension_exists;
2023-08-01 17:01:36.607 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  function test_function_exists() does not exist
2023-08-01 17:01:36.607 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP FUNCTION test_function_exists();
2023-08-01 17:01:36.607 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  function test_function_exists(integer, text, integer[]) does not exist
2023-08-01 17:01:36.607 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP FUNCTION test_function_exists(int, text, int[]);
2023-08-01 17:01:36.608 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  aggregate test_aggregate_exists(*) does not exist
2023-08-01 17:01:36.608 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP AGGREGATE test_aggregate_exists(*);
2023-08-01 17:01:36.608 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  aggregate test_aggregate_exists(integer) does not exist
2023-08-01 17:01:36.608 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP AGGREGATE test_aggregate_exists(int);
2023-08-01 17:01:36.608 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  operator does not exist: integer @#@ integer
2023-08-01 17:01:36.608 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP OPERATOR @#@ (int, int);
2023-08-01 17:01:36.608 +07 client backend[295756] pg_regress/errors ERROR:  syntax error at or near "314159" at character 11
2023-08-01 17:01:36.608 +07 client backend[295756] pg_regress/errors STATEMENT:  drop type 314159;
2023-08-01 17:01:36.608 +07 client backend[295756] pg_regress/errors ERROR:  type "nonesuch" does not exist
2023-08-01 17:01:36.608 +07 client backend[295756] pg_regress/errors STATEMENT:  drop type nonesuch;
2023-08-01 17:01:36.608 +07 client backend[295756] pg_regress/errors ERROR:  syntax error at or near ";" at character 14
2023-08-01 17:01:36.608 +07 client backend[295756] pg_regress/errors STATEMENT:  drop operator;
2023-08-01 17:01:36.608 +07 client backend[295756] pg_regress/errors ERROR:  syntax error at or near ";" at character 21
2023-08-01 17:01:36.608 +07 client backend[295756] pg_regress/errors STATEMENT:  drop operator equals;
2023-08-01 17:01:36.609 +07 client backend[295756] pg_regress/errors ERROR:  syntax error at or near ";" at character 18
2023-08-01 17:01:36.609 +07 client backend[295756] pg_regress/errors STATEMENT:  drop operator ===;
2023-08-01 17:01:36.609 +07 client backend[295756] pg_regress/errors ERROR:  syntax error at or near "," at character 19
2023-08-01 17:01:36.609 +07 client backend[295756] pg_regress/errors STATEMENT:  drop operator int4, int4;
2023-08-01 17:01:36.609 +07 client backend[295756] pg_regress/errors ERROR:  syntax error at or near "(" at character 15
2023-08-01 17:01:36.609 +07 client backend[295756] pg_regress/errors STATEMENT:  drop operator (int4, int4);
2023-08-01 17:01:36.609 +07 client backend[295756] pg_regress/errors ERROR:  syntax error at or near ")" at character 20
2023-08-01 17:01:36.609 +07 client backend[295756] pg_regress/errors STATEMENT:  drop operator === ();
2023-08-01 17:01:36.609 +07 client backend[295756] pg_regress/errors ERROR:  missing argument at character 24
2023-08-01 17:01:36.609 +07 client backend[295756] pg_regress/errors HINT:  Use NONE to denote the missing argument of a unary operator.
2023-08-01 17:01:36.609 +07 client backend[295756] pg_regress/errors STATEMENT:  drop operator === (int4);
2023-08-01 17:01:36.609 +07 client backend[295753] pg_regress/triggers ERROR:  trigger "check_fkeys2_pkey_bad" for table "fkeys2" does not exist
2023-08-01 17:01:36.609 +07 client backend[295753] pg_regress/triggers STATEMENT:  COMMENT ON TRIGGER check_fkeys2_pkey_bad ON fkeys2 IS 'wrong';
2023-08-01 17:01:36.609 +07 client backend[295756] pg_regress/errors ERROR:  operator does not exist: integer === integer
2023-08-01 17:01:36.609 +07 client backend[295756] pg_regress/errors STATEMENT:  drop operator === (int4, int4);
2023-08-01 17:01:36.609 +07 client backend[295756] pg_regress/errors ERROR:  missing argument at character 26
2023-08-01 17:01:36.609 +07 client backend[295756] pg_regress/errors HINT:  Use NONE to denote the missing argument of a unary operator.
2023-08-01 17:01:36.609 +07 client backend[295756] pg_regress/errors STATEMENT:  drop operator = (nonesuch);
2023-08-01 17:01:36.609 +07 client backend[295756] pg_regress/errors ERROR:  syntax error at or near "," at character 19
2023-08-01 17:01:36.609 +07 client backend[295756] pg_regress/errors STATEMENT:  drop operator = ( , int4);
2023-08-01 17:01:36.609 +07 client backend[295739] pg_regress/create_aggregate ERROR:  function least_accum(bigint, bigint) requires run-time type coercion
2023-08-01 17:01:36.609 +07 client backend[295739] pg_regress/create_aggregate STATEMENT:  create aggregate least_agg(int4) (
	  stype = int8, sfunc = least_accum
	);
2023-08-01 17:01:36.609 +07 client backend[295756] pg_regress/errors ERROR:  type "nonesuch" does not exist
2023-08-01 17:01:36.609 +07 client backend[295756] pg_regress/errors STATEMENT:  drop operator = (nonesuch, int4);
2023-08-01 17:01:36.610 +07 client backend[295756] pg_regress/errors ERROR:  type "nonesuch" does not exist
2023-08-01 17:01:36.610 +07 client backend[295756] pg_regress/errors STATEMENT:  drop operator = (int4, nonesuch);
2023-08-01 17:01:36.610 +07 client backend[295756] pg_regress/errors ERROR:  syntax error at or near ")" at character 24
2023-08-01 17:01:36.610 +07 client backend[295756] pg_regress/errors STATEMENT:  drop operator = (int4, );
2023-08-01 17:01:36.610 +07 client backend[295756] pg_regress/errors ERROR:  syntax error at or near ";" at character 10
2023-08-01 17:01:36.610 +07 client backend[295756] pg_regress/errors STATEMENT:  drop rule;
2023-08-01 17:01:36.610 +07 client backend[295756] pg_regress/errors ERROR:  syntax error at or near "314159" at character 11
2023-08-01 17:01:36.610 +07 client backend[295756] pg_regress/errors STATEMENT:  drop rule 314159;
2023-08-01 17:01:36.610 +07 client backend[295739] pg_regress/create_aggregate ERROR:  function least_accum(bigint, bigint) requires run-time type coercion
2023-08-01 17:01:36.610 +07 client backend[295739] pg_regress/create_aggregate STATEMENT:  create aggregate least_agg(int4) (
	  stype = int8, sfunc = least_accum
	);
2023-08-01 17:01:36.610 +07 client backend[295756] pg_regress/errors ERROR:  relation "noplace" does not exist
2023-08-01 17:01:36.610 +07 client backend[295756] pg_regress/errors STATEMENT:  drop rule nonesuch on noplace;
2023-08-01 17:01:36.610 +07 client backend[295756] pg_regress/errors ERROR:  syntax error at or near "tuple" at character 6
2023-08-01 17:01:36.610 +07 client backend[295756] pg_regress/errors STATEMENT:  drop tuple rule nonesuch;
2023-08-01 17:01:36.610 +07 client backend[295756] pg_regress/errors ERROR:  syntax error at or near "instance" at character 6
2023-08-01 17:01:36.610 +07 client backend[295756] pg_regress/errors STATEMENT:  drop instance rule nonesuch on noplace;
2023-08-01 17:01:36.610 +07 client backend[295756] pg_regress/errors ERROR:  syntax error at or near "rewrite" at character 6
2023-08-01 17:01:36.610 +07 client backend[295756] pg_regress/errors STATEMENT:  drop rewrite rule nonesuch;
2023-08-01 17:01:36.610 +07 client backend[295756] pg_regress/errors ERROR:  division by zero
2023-08-01 17:01:36.610 +07 client backend[295756] pg_regress/errors STATEMENT:  select 1/0;
2023-08-01 17:01:36.610 +07 client backend[295756] pg_regress/errors ERROR:  division by zero
2023-08-01 17:01:36.610 +07 client backend[295756] pg_regress/errors STATEMENT:  select 1::int8/0;
2023-08-01 17:01:36.610 +07 client backend[295756] pg_regress/errors ERROR:  division by zero
2023-08-01 17:01:36.610 +07 client backend[295756] pg_regress/errors STATEMENT:  select 1/0::int8;
2023-08-01 17:01:36.611 +07 client backend[295756] pg_regress/errors ERROR:  division by zero
2023-08-01 17:01:36.611 +07 client backend[295756] pg_regress/errors STATEMENT:  select 1::int2/0;
2023-08-01 17:01:36.611 +07 client backend[295756] pg_regress/errors ERROR:  division by zero
2023-08-01 17:01:36.611 +07 client backend[295756] pg_regress/errors STATEMENT:  select 1/0::int2;
2023-08-01 17:01:36.611 +07 client backend[295753] pg_regress/triggers ERROR:  tuple references non-existent key
2023-08-01 17:01:36.611 +07 client backend[295753] pg_regress/triggers DETAIL:  Trigger "check_fkeys2_pkey_exist" found tuple referencing non-existent key in "pkeys".
2023-08-01 17:01:36.611 +07 client backend[295753] pg_regress/triggers STATEMENT:  insert into fkeys2 values (70, '5', 3);
2023-08-01 17:01:36.611 +07 client backend[295756] pg_regress/errors ERROR:  division by zero
2023-08-01 17:01:36.611 +07 client backend[295756] pg_regress/errors STATEMENT:  select 1::numeric/0;
2023-08-01 17:01:36.611 +07 client backend[295745] pg_regress/constraints ERROR:  syntax error at or near ")" at character 45
2023-08-01 17:01:36.611 +07 client backend[295745] pg_regress/constraints STATEMENT:  CREATE TABLE error_tbl (i int DEFAULT (100, ));
2023-08-01 17:01:36.611 +07 client backend[295756] pg_regress/errors ERROR:  division by zero
2023-08-01 17:01:36.611 +07 client backend[295756] pg_regress/errors STATEMENT:  select 1/0::numeric;
2023-08-01 17:01:36.611 +07 client backend[295756] pg_regress/errors ERROR:  division by zero
2023-08-01 17:01:36.611 +07 client backend[295756] pg_regress/errors STATEMENT:  select 1::float8/0;
2023-08-01 17:01:36.611 +07 client backend[295756] pg_regress/errors ERROR:  division by zero
2023-08-01 17:01:36.611 +07 client backend[295756] pg_regress/errors STATEMENT:  select 1/0::float8;
2023-08-01 17:01:36.611 +07 client backend[295745] pg_regress/constraints ERROR:  syntax error at or near "IN" at character 43
2023-08-01 17:01:36.611 +07 client backend[295745] pg_regress/constraints STATEMENT:  CREATE TABLE error_tbl (b1 bool DEFAULT 1 IN (1, 2));
2023-08-01 17:01:36.611 +07 client backend[295756] pg_regress/errors ERROR:  division by zero
2023-08-01 17:01:36.611 +07 client backend[295756] pg_regress/errors STATEMENT:  select 1::float4/0;
2023-08-01 17:01:36.612 +07 client backend[295756] pg_regress/errors ERROR:  division by zero
2023-08-01 17:01:36.612 +07 client backend[295756] pg_regress/errors STATEMENT:  select 1/0::float4;
2023-08-01 17:01:36.612 +07 client backend[295756] pg_regress/errors ERROR:  syntax error at or near "xxx" at character 1
2023-08-01 17:01:36.612 +07 client backend[295756] pg_regress/errors STATEMENT:  xxx;
2023-08-01 17:01:36.612 +07 client backend[295753] pg_regress/triggers ERROR:  tuple references non-existent key
2023-08-01 17:01:36.612 +07 client backend[295753] pg_regress/triggers DETAIL:  Trigger "check_fkeys_pkey_exist" found tuple referencing non-existent key in "pkeys".
2023-08-01 17:01:36.612 +07 client backend[295753] pg_regress/triggers STATEMENT:  insert into fkeys values (70, '5', 1);
2023-08-01 17:01:36.612 +07 client backend[295756] pg_regress/errors ERROR:  syntax error at or near "foo" at character 8
2023-08-01 17:01:36.612 +07 client backend[295756] pg_regress/errors STATEMENT:  CREATE foo;
2023-08-01 17:01:36.612 +07 client backend[295756] pg_regress/errors ERROR:  syntax error at or near ";" at character 14
2023-08-01 17:01:36.612 +07 client backend[295756] pg_regress/errors STATEMENT:  CREATE TABLE ;
2023-08-01 17:01:36.612 +07 client backend[295756] pg_regress/errors ERROR:  syntax error at end of input at character 13
2023-08-01 17:01:36.612 +07 client backend[295756] pg_regress/errors STATEMENT:  CREATE TABLE
2023-08-01 17:01:36.612 +07 client backend[295753] pg_regress/triggers ERROR:  tuple references non-existent key
2023-08-01 17:01:36.612 +07 client backend[295753] pg_regress/triggers DETAIL:  Trigger "check_fkeys_pkey2_exist" found tuple referencing non-existent key in "fkeys2".
2023-08-01 17:01:36.612 +07 client backend[295753] pg_regress/triggers STATEMENT:  insert into fkeys values (60, '6', 4);
2023-08-01 17:01:36.612 +07 client backend[295756] pg_regress/errors ERROR:  syntax error at or near "foo" at character 29
2023-08-01 17:01:36.612 +07 client backend[295756] pg_regress/errors STATEMENT:  INSERT INTO foo VALUES(123) foo;
2023-08-01 17:01:36.612 +07 client backend[295756] pg_regress/errors ERROR:  syntax error at or near "123" at character 13
2023-08-01 17:01:36.612 +07 client backend[295756] pg_regress/errors STATEMENT:  INSERT INTO 123
	VALUES(123);
2023-08-01 17:01:36.612 +07 client backend[295756] pg_regress/errors ERROR:  syntax error at or near "123" at character 29
2023-08-01 17:01:36.612 +07 client backend[295756] pg_regress/errors STATEMENT:  INSERT INTO foo
	VALUES(123) 123
	;
2023-08-01 17:01:36.612 +07 client backend[295756] pg_regress/errors ERROR:  syntax error at or near "NUL" at character 94
2023-08-01 17:01:36.612 +07 client backend[295756] pg_regress/errors STATEMENT:  CREATE TABLE foo
	  (id INT4 UNIQUE NOT NULL, id2 TEXT NOT NULL PRIMARY KEY,
		id3 INTEGER NOT NUL,
	   id4 INT4 UNIQUE NOT NULL, id5 TEXT UNIQUE NOT NULL);
2023-08-01 17:01:36.612 +07 client backend[295756] pg_regress/errors ERROR:  syntax error at or near "NUL" at character 90
2023-08-01 17:01:36.612 +07 client backend[295756] pg_regress/errors STATEMENT:  CREATE TABLE foo(id INT4 UNIQUE NOT NULL, id2 TEXT NOT NULL PRIMARY KEY, id3 INTEGER NOT NUL,
	id4 INT4 UNIQUE NOT NULL, id5 TEXT UNIQUE NOT NULL);
2023-08-01 17:01:36.612 +07 client backend[295756] pg_regress/errors ERROR:  syntax error at or near "NUL" at character 35
2023-08-01 17:01:36.612 +07 client backend[295756] pg_regress/errors STATEMENT:  CREATE TABLE foo(
	id3 INTEGER NOT NUL, id4 INT4 UNIQUE NOT NULL, id5 TEXT UNIQUE NOT NULL, id INT4 UNIQUE NOT NULL, id2 TEXT NOT NULL PRIMARY KEY);
2023-08-01 17:01:36.612 +07 client backend[295756] pg_regress/errors ERROR:  syntax error at or near "NUL" at character 90
2023-08-01 17:01:36.612 +07 client backend[295756] pg_regress/errors STATEMENT:  CREATE TABLE foo(id INT4 UNIQUE NOT NULL, id2 TEXT NOT NULL PRIMARY KEY, id3 INTEGER NOT NUL, id4 INT4 UNIQUE NOT NULL, id5 TEXT UNIQUE NOT NULL);
2023-08-01 17:01:36.612 +07 client backend[295753] pg_regress/triggers ERROR:  "check_fkeys2_fkey_restrict": tuple is referenced in "fkeys"
2023-08-01 17:01:36.612 +07 client backend[295753] pg_regress/triggers CONTEXT:  SQL statement "delete from fkeys2 where fkey21 = $1 and fkey22 = $2 "
2023-08-01 17:01:36.612 +07 client backend[295753] pg_regress/triggers STATEMENT:  delete from pkeys where pkey1 = 30 and pkey2 = '3';
2023-08-01 17:01:36.612 +07 client backend[295756] pg_regress/errors ERROR:  syntax error at or near "NUL" at character 100
2023-08-01 17:01:36.612 +07 client backend[295756] pg_regress/errors STATEMENT:  CREATE
	TEMPORARY
	TABLE
	foo(id INT4 UNIQUE NOT NULL, id2 TEXT NOT NULL PRIMARY KEY, id3 INTEGER NOT NUL,
	id4 INT4
	UNIQUE
	NOT
	NULL,
	id5 TEXT
	UNIQUE
	NOT
	NULL)
	;
2023-08-01 17:01:36.612 +07 client backend[295752] pg_regress/create_am ERROR:  cannot drop access method gist2 because other objects depend on it
2023-08-01 17:01:36.612 +07 client backend[295752] pg_regress/create_am DETAIL:  index grect2ind2 depends on operator class box_ops for access method gist2
2023-08-01 17:01:36.612 +07 client backend[295752] pg_regress/create_am HINT:  Use DROP ... CASCADE to drop the dependent objects too.
2023-08-01 17:01:36.612 +07 client backend[295752] pg_regress/create_am STATEMENT:  DROP ACCESS METHOD gist2;
2023-08-01 17:01:36.612 +07 client backend[295756] pg_regress/errors ERROR:  syntax error at or near "NUL" at character 45
2023-08-01 17:01:36.612 +07 client backend[295756] pg_regress/errors STATEMENT:  CREATE
	TEMPORARY
	TABLE
	foo(
	id3 INTEGER NOT NUL, id4 INT4 UNIQUE NOT NULL, id5 TEXT UNIQUE NOT NULL, id INT4 UNIQUE NOT NULL, id2 TEXT NOT NULL PRIMARY KEY)
	;
2023-08-01 17:01:36.612 +07 client backend[295756] pg_regress/errors ERROR:  syntax error at or near "NUL" at character 153
2023-08-01 17:01:36.612 +07 client backend[295756] pg_regress/errors STATEMENT:  CREATE
	TEMPORARY
	TABLE
	foo
	(id
	INT4
	UNIQUE NOT NULL, idx INT4 UNIQUE NOT NULL, idy INT4 UNIQUE NOT NULL, id2 TEXT NOT NULL PRIMARY KEY, id3 INTEGER NOT NUL, id4 INT4 UNIQUE NOT NULL, id5 TEXT UNIQUE NOT NULL,
	idz INT4 UNIQUE NOT NULL,
	idv INT4 UNIQUE NOT NULL);
2023-08-01 17:01:36.613 +07 client backend[295756] pg_regress/errors ERROR:  syntax error at or near "NUL" at character 180
2023-08-01 17:01:36.613 +07 client backend[295756] pg_regress/errors STATEMENT:  CREATE
	TEMPORARY
	TABLE
	foo
	(id
	INT4
	UNIQUE
	NOT
	NULL
	,
	idm
	INT4
	UNIQUE
	NOT
	NULL,
	idx INT4 UNIQUE NOT NULL, idy INT4 UNIQUE NOT NULL, id2 TEXT NOT NULL PRIMARY KEY, id3 INTEGER NOT NUL, id4 INT4 UNIQUE NOT NULL, id5 TEXT UNIQUE NOT NULL,
	idz INT4 UNIQUE NOT NULL,
	idv
	INT4
	UNIQUE
	NOT
	NULL);
2023-08-01 17:01:36.613 +07 client backend[295753] pg_regress/triggers ERROR:  "check_fkeys2_fkey_restrict": tuple is referenced in "fkeys"
2023-08-01 17:01:36.613 +07 client backend[295753] pg_regress/triggers CONTEXT:  SQL statement "delete from fkeys2 where fkey21 = $1 and fkey22 = $2 "
2023-08-01 17:01:36.613 +07 client backend[295753] pg_regress/triggers STATEMENT:  update pkeys set pkey1 = 7, pkey2 = '70' where pkey1 = 50 and pkey2 = '5';
2023-08-01 17:01:36.615 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  language "test_language_exists" does not exist
2023-08-01 17:01:36.615 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP LANGUAGE test_language_exists;
2023-08-01 17:01:36.615 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  cast from type text to type text does not exist
2023-08-01 17:01:36.615 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP CAST (text AS text);
2023-08-01 17:01:36.616 +07 client backend[295748] pg_regress/typed_table ERROR:  cannot add column to typed table
2023-08-01 17:01:36.616 +07 client backend[295748] pg_regress/typed_table STATEMENT:  ALTER TABLE persons ADD COLUMN comment text;
2023-08-01 17:01:36.616 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  trigger "test_trigger_exists" for table "test_exists" does not exist
2023-08-01 17:01:36.616 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP TRIGGER test_trigger_exists ON test_exists;
2023-08-01 17:01:36.616 +07 client backend[295748] pg_regress/typed_table ERROR:  cannot drop column from typed table
2023-08-01 17:01:36.616 +07 client backend[295748] pg_regress/typed_table STATEMENT:  ALTER TABLE persons DROP COLUMN name;
2023-08-01 17:01:36.616 +07 client backend[295752] pg_regress/create_am ERROR:  invalid value for parameter "default_table_access_method": ""
2023-08-01 17:01:36.616 +07 client backend[295752] pg_regress/create_am DETAIL:  default_table_access_method cannot be empty.
2023-08-01 17:01:36.616 +07 client backend[295752] pg_regress/create_am STATEMENT:  SET default_table_access_method = '';
2023-08-01 17:01:36.616 +07 client backend[295752] pg_regress/create_am ERROR:  invalid value for parameter "default_table_access_method": "I do not exist AM"
2023-08-01 17:01:36.616 +07 client backend[295752] pg_regress/create_am DETAIL:  Table access method "I do not exist AM" does not exist.
2023-08-01 17:01:36.616 +07 client backend[295752] pg_regress/create_am STATEMENT:  SET default_table_access_method = 'I do not exist AM';
2023-08-01 17:01:36.616 +07 client backend[295752] pg_regress/create_am ERROR:  access method "btree" is not of type TABLE
2023-08-01 17:01:36.616 +07 client backend[295752] pg_regress/create_am STATEMENT:  SET default_table_access_method = 'btree';
2023-08-01 17:01:36.616 +07 client backend[295752] pg_regress/create_am ERROR:  function int4in(internal) does not exist
2023-08-01 17:01:36.616 +07 client backend[295752] pg_regress/create_am STATEMENT:  CREATE ACCESS METHOD bogus TYPE TABLE HANDLER int4in;
2023-08-01 17:01:36.616 +07 client backend[295752] pg_regress/create_am ERROR:  function bthandler must return type table_am_handler
2023-08-01 17:01:36.616 +07 client backend[295752] pg_regress/create_am STATEMENT:  CREATE ACCESS METHOD bogus TYPE TABLE HANDLER bthandler;
2023-08-01 17:01:36.616 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  relation "no_such_table" does not exist
2023-08-01 17:01:36.616 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP TRIGGER test_trigger_exists ON no_such_table;
2023-08-01 17:01:36.616 +07 client backend[295748] pg_regress/typed_table ERROR:  cannot rename column of typed table
2023-08-01 17:01:36.616 +07 client backend[295748] pg_regress/typed_table STATEMENT:  ALTER TABLE persons RENAME COLUMN id TO num;
2023-08-01 17:01:36.617 +07 client backend[295748] pg_regress/typed_table ERROR:  cannot alter column type of typed table
2023-08-01 17:01:36.617 +07 client backend[295748] pg_regress/typed_table STATEMENT:  ALTER TABLE persons ALTER COLUMN name TYPE varchar;
2023-08-01 17:01:36.617 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  schema "no_such_schema" does not exist
2023-08-01 17:01:36.617 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP TRIGGER test_trigger_exists ON no_such_schema.no_such_table;
2023-08-01 17:01:36.617 +07 client backend[295744] pg_regress/create_function_3 ERROR:  only superuser can define a leakproof function
2023-08-01 17:01:36.617 +07 client backend[295744] pg_regress/create_function_3 STATEMENT:  ALTER FUNCTION functest_E_2(int) LEAKPROOF;
2023-08-01 17:01:36.617 +07 client backend[295744] pg_regress/create_function_3 ERROR:  only superuser can define a leakproof function
2023-08-01 17:01:36.617 +07 client backend[295744] pg_regress/create_function_3 STATEMENT:  CREATE FUNCTION functest_E_3(int) RETURNS bool LANGUAGE 'sql'
	       LEAKPROOF AS 'SELECT $1 < 200';
2023-08-01 17:01:36.617 +07 client backend[295748] pg_regress/typed_table ERROR:  cannot change inheritance of typed table
2023-08-01 17:01:36.617 +07 client backend[295748] pg_regress/typed_table STATEMENT:  ALTER TABLE persons INHERIT stuff;
2023-08-01 17:01:36.617 +07 client backend[295748] pg_regress/typed_table ERROR:  column "myname" does not exist
2023-08-01 17:01:36.617 +07 client backend[295748] pg_regress/typed_table STATEMENT:  CREATE TABLE personsx OF person_type (myname WITH OPTIONS NOT NULL);
2023-08-01 17:01:36.617 +07 client backend[295739] pg_regress/create_aggregate ERROR:  must specify both or neither of serialization and deserialization functions
2023-08-01 17:01:36.617 +07 client backend[295739] pg_regress/create_aggregate STATEMENT:  CREATE AGGREGATE myavg (numeric)
	(
		stype = internal,
		sfunc = numeric_avg_accum,
		serialfunc = numeric_avg_serialize
	);
2023-08-01 17:01:36.618 +07 client backend[295739] pg_regress/create_aggregate ERROR:  function numeric_avg_deserialize(internal) does not exist
2023-08-01 17:01:36.618 +07 client backend[295739] pg_regress/create_aggregate STATEMENT:  CREATE AGGREGATE myavg (numeric)
	(
		stype = internal,
		sfunc = numeric_avg_accum,
		serialfunc = numeric_avg_deserialize,
		deserialfunc = numeric_avg_deserialize
	);
2023-08-01 17:01:36.618 +07 client backend[295739] pg_regress/create_aggregate ERROR:  function numeric_avg_serialize(bytea, internal) does not exist
2023-08-01 17:01:36.618 +07 client backend[295739] pg_regress/create_aggregate STATEMENT:  CREATE AGGREGATE myavg (numeric)
	(
		stype = internal,
		sfunc = numeric_avg_accum,
		serialfunc = numeric_avg_serialize,
		deserialfunc = numeric_avg_serialize
	);
2023-08-01 17:01:36.618 +07 client backend[295739] pg_regress/create_aggregate ERROR:  function int4larger(internal, internal) does not exist
2023-08-01 17:01:36.618 +07 client backend[295739] pg_regress/create_aggregate STATEMENT:  CREATE AGGREGATE myavg (numeric)
	(
		stype = internal,
		sfunc = numeric_avg_accum,
		serialfunc = numeric_avg_serialize,
		deserialfunc = numeric_avg_deserialize,
		combinefunc = int4larger
	);
2023-08-01 17:01:36.618 +07 client backend[295745] pg_regress/constraints ERROR:  new row for relation "check_tbl" violates check constraint "check_con"
2023-08-01 17:01:36.618 +07 client backend[295745] pg_regress/constraints DETAIL:  Failing row contains (3).
2023-08-01 17:01:36.618 +07 client backend[295745] pg_regress/constraints STATEMENT:  INSERT INTO CHECK_TBL VALUES (3);
2023-08-01 17:01:36.619 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  rule "test_rule_exists" for relation "test_exists" does not exist
2023-08-01 17:01:36.619 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP RULE test_rule_exists ON test_exists;
2023-08-01 17:01:36.619 +07 client backend[295745] pg_regress/constraints ERROR:  new row for relation "check_tbl" violates check constraint "check_con"
2023-08-01 17:01:36.619 +07 client backend[295745] pg_regress/constraints DETAIL:  Failing row contains (2).
2023-08-01 17:01:36.619 +07 client backend[295745] pg_regress/constraints STATEMENT:  INSERT INTO CHECK_TBL VALUES (2);
2023-08-01 17:01:36.619 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  relation "no_such_table" does not exist
2023-08-01 17:01:36.619 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP RULE test_rule_exists ON no_such_table;
2023-08-01 17:01:36.619 +07 client backend[295752] pg_regress/create_am ERROR:  syntax error at or near "USING" at character 41
2023-08-01 17:01:36.619 +07 client backend[295752] pg_regress/create_am STATEMENT:  SELECT INTO tableam_tblselectinto_heap2 USING heap2 FROM tableam_tbl_heap2;
2023-08-01 17:01:36.619 +07 client backend[295745] pg_regress/constraints ERROR:  new row for relation "check_tbl" violates check constraint "check_con"
2023-08-01 17:01:36.619 +07 client backend[295745] pg_regress/constraints DETAIL:  Failing row contains (1).
2023-08-01 17:01:36.619 +07 client backend[295745] pg_regress/constraints STATEMENT:  INSERT INTO CHECK_TBL VALUES (1);
2023-08-01 17:01:36.619 +07 client backend[295752] pg_regress/create_am ERROR:  syntax error at or near "USING" at character 32
2023-08-01 17:01:36.619 +07 client backend[295752] pg_regress/create_am STATEMENT:  CREATE VIEW tableam_view_heap2 USING heap2 AS SELECT * FROM tableam_tbl_heap2;
2023-08-01 17:01:36.619 +07 client backend[295752] pg_regress/create_am ERROR:  syntax error at or near "USING" at character 35
2023-08-01 17:01:36.619 +07 client backend[295752] pg_regress/create_am STATEMENT:  CREATE SEQUENCE tableam_seq_heap2 USING heap2;
2023-08-01 17:01:36.620 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  schema "no_such_schema" does not exist
2023-08-01 17:01:36.620 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP RULE test_rule_exists ON no_such_schema.no_such_table;
2023-08-01 17:01:36.620 +07 client backend[295752] pg_regress/create_am ERROR:  specifying a table access method is not supported on a partitioned table
2023-08-01 17:01:36.620 +07 client backend[295752] pg_regress/create_am STATEMENT:  CREATE TABLE tableam_parted_heap2 (a text, b int) PARTITION BY list (a) USING heap2;
2023-08-01 17:01:36.620 +07 client backend[295739] pg_regress/create_aggregate ERROR:  cannot change return type of existing function
2023-08-01 17:01:36.620 +07 client backend[295739] pg_regress/create_aggregate HINT:  Use DROP AGGREGATE myavg(numeric) first.
2023-08-01 17:01:36.620 +07 client backend[295739] pg_regress/create_aggregate STATEMENT:  CREATE OR REPLACE AGGREGATE myavg (numeric)
	(
		stype = numeric,
		sfunc = numeric_add,
		finalfunc = numeric_out
	);
2023-08-01 17:01:36.620 +07 client backend[295739] pg_regress/create_aggregate ERROR:  cannot change routine kind
2023-08-01 17:01:36.620 +07 client backend[295739] pg_regress/create_aggregate DETAIL:  "myavg" is an ordinary aggregate function.
2023-08-01 17:01:36.620 +07 client backend[295739] pg_regress/create_aggregate STATEMENT:  CREATE OR REPLACE AGGREGATE myavg (order by numeric)
	(
		stype = numeric,
		sfunc = numeric_add
	);
2023-08-01 17:01:36.621 +07 client backend[295739] pg_regress/create_aggregate ERROR:  cannot change routine kind
2023-08-01 17:01:36.621 +07 client backend[295739] pg_regress/create_aggregate DETAIL:  "sum3" is a function.
2023-08-01 17:01:36.621 +07 client backend[295739] pg_regress/create_aggregate STATEMENT:  CREATE OR REPLACE AGGREGATE sum3 (int8,int8,int8)
	(
		stype = int8,
		sfunc = sum4
	);
2023-08-01 17:01:36.621 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  foreign-data wrapper "test_fdw_exists" does not exist
2023-08-01 17:01:36.621 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP FOREIGN DATA WRAPPER test_fdw_exists;
2023-08-01 17:01:36.621 +07 client backend[295739] pg_regress/create_aggregate ERROR:  parameter "parallel" must be SAFE, RESTRICTED, or UNSAFE
2023-08-01 17:01:36.621 +07 client backend[295739] pg_regress/create_aggregate STATEMENT:  CREATE AGGREGATE mysum (int)
	(
		stype = int,
		sfunc = int4pl,
		parallel = pear
	);
2023-08-01 17:01:36.621 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  server "test_server_exists" does not exist
2023-08-01 17:01:36.621 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP SERVER test_server_exists;
2023-08-01 17:01:36.622 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  operator class "test_operator_class" does not exist for access method "btree"
2023-08-01 17:01:36.622 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP OPERATOR CLASS test_operator_class USING btree;
2023-08-01 17:01:36.622 +07 client backend[295745] pg_regress/constraints ERROR:  new row for relation "check2_tbl" violates check constraint "sequence_con"
2023-08-01 17:01:36.622 +07 client backend[295745] pg_regress/constraints DETAIL:  Failing row contains (1, x check failed, -2).
2023-08-01 17:01:36.622 +07 client backend[295745] pg_regress/constraints STATEMENT:  INSERT INTO CHECK2_TBL VALUES (1, 'x check failed', -2);
2023-08-01 17:01:36.622 +07 client backend[295739] pg_regress/create_aggregate ERROR:  strictness of aggregate's forward and inverse transition functions must match
2023-08-01 17:01:36.622 +07 client backend[295739] pg_regress/create_aggregate STATEMENT:  CREATE AGGREGATE invalidsumdouble (float8)
	(
	    stype = float8,
	    sfunc = float8pl,
	    mstype = float8,
	    msfunc = float8pl,
	    minvfunc = float8mi_n
	);
2023-08-01 17:01:36.622 +07 client backend[295745] pg_regress/constraints ERROR:  new row for relation "check2_tbl" violates check constraint "sequence_con"
2023-08-01 17:01:36.622 +07 client backend[295745] pg_regress/constraints DETAIL:  Failing row contains (5, z check failed, 10).
2023-08-01 17:01:36.622 +07 client backend[295745] pg_regress/constraints STATEMENT:  INSERT INTO CHECK2_TBL VALUES (5, 'z check failed', 10);
2023-08-01 17:01:36.622 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  access method "no_such_am" does not exist
2023-08-01 17:01:36.622 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP OPERATOR CLASS test_operator_class USING no_such_am;
2023-08-01 17:01:36.622 +07 client backend[295745] pg_regress/constraints ERROR:  new row for relation "check2_tbl" violates check constraint "sequence_con"
2023-08-01 17:01:36.622 +07 client backend[295745] pg_regress/constraints DETAIL:  Failing row contains (0, check failed, -2).
2023-08-01 17:01:36.622 +07 client backend[295745] pg_regress/constraints STATEMENT:  INSERT INTO CHECK2_TBL VALUES (0, 'check failed', -2);
2023-08-01 17:01:36.622 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  access method "no_such_am" does not exist
2023-08-01 17:01:36.622 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP OPERATOR CLASS IF EXISTS test_operator_class USING no_such_am;
2023-08-01 17:01:36.622 +07 client backend[295745] pg_regress/constraints ERROR:  new row for relation "check2_tbl" violates check constraint "sequence_con"
2023-08-01 17:01:36.622 +07 client backend[295745] pg_regress/constraints DETAIL:  Failing row contains (6, check failed, 11).
2023-08-01 17:01:36.622 +07 client backend[295745] pg_regress/constraints STATEMENT:  INSERT INTO CHECK2_TBL VALUES (6, 'check failed', 11);
2023-08-01 17:01:36.622 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  operator family "test_operator_family" does not exist for access method "btree"
2023-08-01 17:01:36.622 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP OPERATOR FAMILY test_operator_family USING btree;
2023-08-01 17:01:36.622 +07 client backend[295739] pg_regress/create_aggregate ERROR:  return type of inverse transition function float8mi_int is not double precision
2023-08-01 17:01:36.622 +07 client backend[295739] pg_regress/create_aggregate STATEMENT:  CREATE AGGREGATE wrongreturntype (float8)
	(
	    stype = float8,
	    sfunc = float8pl,
	    mstype = float8,
	    msfunc = float8pl,
	    minvfunc = float8mi_int
	);
2023-08-01 17:01:36.622 +07 client backend[295739] pg_regress/create_aggregate WARNING:  aggregate attribute "Sfunc1" not recognized
2023-08-01 17:01:36.622 +07 client backend[295739] pg_regress/create_aggregate WARNING:  aggregate attribute "Basetype" not recognized
2023-08-01 17:01:36.622 +07 client backend[295739] pg_regress/create_aggregate WARNING:  aggregate attribute "Stype1" not recognized
2023-08-01 17:01:36.622 +07 client backend[295739] pg_regress/create_aggregate WARNING:  aggregate attribute "Initcond1" not recognized
2023-08-01 17:01:36.622 +07 client backend[295739] pg_regress/create_aggregate WARNING:  aggregate attribute "Parallel" not recognized
2023-08-01 17:01:36.622 +07 client backend[295739] pg_regress/create_aggregate ERROR:  aggregate stype must be specified
2023-08-01 17:01:36.622 +07 client backend[295739] pg_regress/create_aggregate STATEMENT:  CREATE AGGREGATE case_agg ( 
		"Sfunc1" = int4pl,
		"Basetype" = int4,
		"Stype1" = int4,
		"Initcond1" = '0',
		"Parallel" = safe
	);
2023-08-01 17:01:36.622 +07 client backend[295739] pg_regress/create_aggregate WARNING:  aggregate attribute "Stype" not recognized
2023-08-01 17:01:36.622 +07 client backend[295739] pg_regress/create_aggregate WARNING:  aggregate attribute "Sfunc" not recognized
2023-08-01 17:01:36.622 +07 client backend[295739] pg_regress/create_aggregate WARNING:  aggregate attribute "Finalfunc" not recognized
2023-08-01 17:01:36.622 +07 client backend[295739] pg_regress/create_aggregate WARNING:  aggregate attribute "Finalfunc_extra" not recognized
2023-08-01 17:01:36.622 +07 client backend[295739] pg_regress/create_aggregate WARNING:  aggregate attribute "Finalfunc_modify" not recognized
2023-08-01 17:01:36.622 +07 client backend[295739] pg_regress/create_aggregate WARNING:  aggregate attribute "Parallel" not recognized
2023-08-01 17:01:36.622 +07 client backend[295739] pg_regress/create_aggregate ERROR:  aggregate stype must be specified
2023-08-01 17:01:36.622 +07 client backend[295739] pg_regress/create_aggregate STATEMENT:  CREATE AGGREGATE case_agg(float8)
	(
		"Stype" = internal,
		"Sfunc" = ordered_set_transition,
		"Finalfunc" = percentile_disc_final,
		"Finalfunc_extra" = true,
		"Finalfunc_modify" = read_write,
		"Parallel" = safe
	);
2023-08-01 17:01:36.623 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  access method "no_such_am" does not exist
2023-08-01 17:01:36.623 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP OPERATOR FAMILY test_operator_family USING no_such_am;
2023-08-01 17:01:36.623 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  access method "no_such_am" does not exist
2023-08-01 17:01:36.623 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP OPERATOR FAMILY IF EXISTS test_operator_family USING no_such_am;
2023-08-01 17:01:36.624 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  access method "no_such_am" does not exist
2023-08-01 17:01:36.624 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP ACCESS METHOD no_such_am;
2023-08-01 17:01:36.625 +07 client backend[295745] pg_regress/constraints ERROR:  new row for relation "insert_tbl" violates check constraint "insert_tbl_con"
2023-08-01 17:01:36.625 +07 client backend[295745] pg_regress/constraints DETAIL:  Failing row contains (2, -NULL-, -2).
2023-08-01 17:01:36.625 +07 client backend[295745] pg_regress/constraints STATEMENT:  INSERT INTO INSERT_TBL(x,z) VALUES (2, -2);
2023-08-01 17:01:36.626 +07 client backend[295745] pg_regress/constraints ERROR:  new row for relation "insert_tbl" violates check constraint "insert_tbl_con"
2023-08-01 17:01:36.626 +07 client backend[295745] pg_regress/constraints DETAIL:  Failing row contains (2, Y, -2).
2023-08-01 17:01:36.626 +07 client backend[295745] pg_regress/constraints STATEMENT:  INSERT INTO INSERT_TBL(y) VALUES ('Y');
2023-08-01 17:01:36.626 +07 client backend[295745] pg_regress/constraints ERROR:  new row for relation "insert_tbl" violates check constraint "insert_tbl_check"
2023-08-01 17:01:36.626 +07 client backend[295745] pg_regress/constraints DETAIL:  Failing row contains (1, -NULL-, -2).
2023-08-01 17:01:36.626 +07 client backend[295745] pg_regress/constraints STATEMENT:  INSERT INTO INSERT_TBL(x,z) VALUES (1, -2);
2023-08-01 17:01:36.626 +07 client backend[295745] pg_regress/constraints ERROR:  new row for relation "insert_tbl" violates check constraint "insert_tbl_con"
2023-08-01 17:01:36.626 +07 client backend[295745] pg_regress/constraints DETAIL:  Failing row contains (5, check failed, -5).
2023-08-01 17:01:36.626 +07 client backend[295745] pg_regress/constraints STATEMENT:  INSERT INTO INSERT_TBL VALUES (5, 'check failed', -5);
2023-08-01 17:01:36.627 +07 client backend[295745] pg_regress/constraints ERROR:  new row for relation "insert_tbl" violates check constraint "insert_tbl_check"
2023-08-01 17:01:36.627 +07 client backend[295745] pg_regress/constraints DETAIL:  Failing row contains (5, check failed, 4).
2023-08-01 17:01:36.627 +07 client backend[295745] pg_regress/constraints STATEMENT:  INSERT INTO INSERT_TBL(y,z) VALUES ('check failed', 4);
2023-08-01 17:01:36.627 +07 client backend[295745] pg_regress/constraints ERROR:  new row for relation "insert_tbl" violates check constraint "insert_tbl_con"
2023-08-01 17:01:36.627 +07 client backend[295745] pg_regress/constraints DETAIL:  Failing row contains (5, check failed, -5).
2023-08-01 17:01:36.627 +07 client backend[295745] pg_regress/constraints STATEMENT:  INSERT INTO INSERT_TBL(x,y) VALUES (5, 'check failed');
2023-08-01 17:01:36.627 +07 client backend[295745] pg_regress/constraints ERROR:  new row for relation "insert_tbl" violates check constraint "insert_tbl_con"
2023-08-01 17:01:36.627 +07 client backend[295745] pg_regress/constraints DETAIL:  Failing row contains (8, Y, -8).
2023-08-01 17:01:36.627 +07 client backend[295745] pg_regress/constraints STATEMENT:  INSERT INTO INSERT_TBL(y) VALUES ('Y');
2023-08-01 17:01:36.629 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  table "test_exists" does not exist
2023-08-01 17:01:36.629 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP TABLE test_exists;
2023-08-01 17:01:36.629 +07 client backend[295745] pg_regress/constraints ERROR:  new row for relation "sys_col_check_tbl" violates check constraint "sys_col_check_tbl_check"
2023-08-01 17:01:36.629 +07 client backend[295745] pg_regress/constraints DETAIL:  Failing row contains (Olympia, Washington, t, 100).
2023-08-01 17:01:36.629 +07 client backend[295745] pg_regress/constraints STATEMENT:  INSERT INTO SYS_COL_CHECK_TBL VALUES ('Olympia', 'Washington', true, 100);
2023-08-01 17:01:36.630 +07 client backend[295745] pg_regress/constraints ERROR:  system column "ctid" reference in check constraint is invalid at character 138
2023-08-01 17:01:36.630 +07 client backend[295745] pg_regress/constraints STATEMENT:  CREATE TABLE SYS_COL_CHECK_TBL (city text, state text, is_capital bool,
	                  altitude int,
					  CHECK (NOT (is_capital AND ctid::text = 'sys_col_check_tbl')));
2023-08-01 17:01:36.632 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  function name "test_ambiguous_funcname" is not unique
2023-08-01 17:01:36.632 +07 client backend[295750] pg_regress/drop_if_exists HINT:  Specify the argument list to select the function unambiguously.
2023-08-01 17:01:36.632 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP FUNCTION test_ambiguous_funcname;
2023-08-01 17:01:36.632 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  function name "test_ambiguous_funcname" is not unique
2023-08-01 17:01:36.632 +07 client backend[295750] pg_regress/drop_if_exists HINT:  Specify the argument list to select the function unambiguously.
2023-08-01 17:01:36.632 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP FUNCTION IF EXISTS test_ambiguous_funcname;
2023-08-01 17:01:36.633 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  procedure name "test_ambiguous_procname" is not unique
2023-08-01 17:01:36.633 +07 client backend[295750] pg_regress/drop_if_exists HINT:  Specify the argument list to select the procedure unambiguously.
2023-08-01 17:01:36.633 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP PROCEDURE test_ambiguous_procname;
2023-08-01 17:01:36.633 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  procedure name "test_ambiguous_procname" is not unique
2023-08-01 17:01:36.633 +07 client backend[295750] pg_regress/drop_if_exists HINT:  Specify the argument list to select the procedure unambiguously.
2023-08-01 17:01:36.633 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP PROCEDURE IF EXISTS test_ambiguous_procname;
2023-08-01 17:01:36.633 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  routine name "test_ambiguous_procname" is not unique
2023-08-01 17:01:36.633 +07 client backend[295750] pg_regress/drop_if_exists HINT:  Specify the argument list to select the routine unambiguously.
2023-08-01 17:01:36.633 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  DROP ROUTINE IF EXISTS test_ambiguous_procname;
2023-08-01 17:01:36.633 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  database "test_database_exists" does not exist
2023-08-01 17:01:36.633 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  drop database test_database_exists (force);
2023-08-01 17:01:36.633 +07 client backend[295745] pg_regress/constraints ERROR:  new row for relation "insert_child" violates check constraint "insert_child_check"
2023-08-01 17:01:36.633 +07 client backend[295745] pg_regress/constraints DETAIL:  Failing row contains (7, -NULL-, -7, 42, 6).
2023-08-01 17:01:36.633 +07 client backend[295745] pg_regress/constraints STATEMENT:  INSERT INTO INSERT_CHILD(x,z,cy) VALUES (7,-7,6);
2023-08-01 17:01:36.633 +07 client backend[295750] pg_regress/drop_if_exists ERROR:  database "test_database_exists" does not exist
2023-08-01 17:01:36.633 +07 client backend[295750] pg_regress/drop_if_exists STATEMENT:  drop database test_database_exists with (force);
2023-08-01 17:01:36.633 +07 client backend[295747] pg_regress/inherit ERROR:  null value in column "aa" of relation "z" violates not-null constraint
2023-08-01 17:01:36.633 +07 client backend[295747] pg_regress/inherit DETAIL:  Failing row contains (null, text).
2023-08-01 17:01:36.633 +07 client backend[295747] pg_regress/inherit STATEMENT:  INSERT INTO z VALUES (NULL, 'text');
2023-08-01 17:01:36.634 +07 client backend[295745] pg_regress/constraints ERROR:  new row for relation "insert_child" violates check constraint "insert_tbl_check"
2023-08-01 17:01:36.634 +07 client backend[295745] pg_regress/constraints DETAIL:  Failing row contains (6, -NULL-, -7, 42, 7).
2023-08-01 17:01:36.634 +07 client backend[295745] pg_regress/constraints STATEMENT:  INSERT INTO INSERT_CHILD(x,z,cy) VALUES (6,-7,7);
2023-08-01 17:01:36.634 +07 client backend[295745] pg_regress/constraints ERROR:  new row for relation "insert_child" violates check constraint "insert_tbl_con"
2023-08-01 17:01:36.634 +07 client backend[295745] pg_regress/constraints DETAIL:  Failing row contains (6, check failed, -6, 42, 7).
2023-08-01 17:01:36.634 +07 client backend[295745] pg_regress/constraints STATEMENT:  INSERT INTO INSERT_CHILD(x,y,z,cy) VALUES (6,'check failed',-6,7);
2023-08-01 17:01:36.634 +07 client backend[295748] pg_regress/typed_table ERROR:  column "name" specified more than once
2023-08-01 17:01:36.634 +07 client backend[295748] pg_regress/typed_table STATEMENT:  CREATE TABLE persons4 OF person_type (
	    name WITH OPTIONS NOT NULL,
	    name WITH OPTIONS DEFAULT ''  
	);
2023-08-01 17:01:36.635 +07 client backend[295748] pg_regress/typed_table ERROR:  cannot drop type person_type because other objects depend on it
2023-08-01 17:01:36.635 +07 client backend[295748] pg_regress/typed_table DETAIL:  table persons depends on type person_type
	function get_all_persons() depends on type person_type
	table persons2 depends on type person_type
	table persons3 depends on type person_type
2023-08-01 17:01:36.635 +07 client backend[295748] pg_regress/typed_table HINT:  Use DROP ... CASCADE to drop the dependent objects too.
2023-08-01 17:01:36.635 +07 client backend[295748] pg_regress/typed_table STATEMENT:  DROP TYPE person_type RESTRICT;
2023-08-01 17:01:36.636 +07 client backend[295745] pg_regress/constraints ERROR:  new row for relation "atacc1" violates check constraint "atacc1_test_check"
2023-08-01 17:01:36.636 +07 client backend[295745] pg_regress/constraints DETAIL:  Failing row contains (-3).
2023-08-01 17:01:36.636 +07 client backend[295745] pg_regress/constraints STATEMENT:  INSERT INTO ATACC1 (TEST) VALUES (-3);
2023-08-01 17:01:36.638 +07 client backend[295745] pg_regress/constraints ERROR:  new row for relation "atacc2" violates check constraint "atacc1_test_check"
2023-08-01 17:01:36.638 +07 client backend[295745] pg_regress/constraints DETAIL:  Failing row contains (-3, null).
2023-08-01 17:01:36.638 +07 client backend[295745] pg_regress/constraints STATEMENT:  INSERT INTO ATACC2 (TEST) VALUES (-3);
2023-08-01 17:01:36.638 +07 client backend[295745] pg_regress/constraints ERROR:  new row for relation "atacc1" violates check constraint "atacc1_test_check"
2023-08-01 17:01:36.638 +07 client backend[295745] pg_regress/constraints DETAIL:  Failing row contains (-3, null).
2023-08-01 17:01:36.638 +07 client backend[295745] pg_regress/constraints STATEMENT:  INSERT INTO ATACC1 (TEST) VALUES (-3);
2023-08-01 17:01:36.638 +07 client backend[295748] pg_regress/typed_table ERROR:  type stuff is not a composite type
2023-08-01 17:01:36.638 +07 client backend[295748] pg_regress/typed_table STATEMENT:  CREATE TABLE persons5 OF stuff;
2023-08-01 17:01:36.639 +07 client backend[295745] pg_regress/constraints ERROR:  new row for relation "atacc1" violates check constraint "atacc1_test2_check"
2023-08-01 17:01:36.639 +07 client backend[295745] pg_regress/constraints DETAIL:  Failing row contains (null, 3).
2023-08-01 17:01:36.639 +07 client backend[295745] pg_regress/constraints STATEMENT:  INSERT INTO ATACC1 (TEST2) VALUES (3);
2023-08-01 17:01:36.641 +07 client backend[295744] pg_regress/create_function_3 ERROR:  could not find a function named "functest_b_1"
2023-08-01 17:01:36.641 +07 client backend[295744] pg_regress/create_function_3 STATEMENT:  DROP FUNCTION functest_b_1;
2023-08-01 17:01:36.642 +07 client backend[295744] pg_regress/create_function_3 ERROR:  function name "functest_b_2" is not unique
2023-08-01 17:01:36.642 +07 client backend[295744] pg_regress/create_function_3 HINT:  Specify the argument list to select the function unambiguously.
2023-08-01 17:01:36.642 +07 client backend[295744] pg_regress/create_function_3 STATEMENT:  DROP FUNCTION functest_b_2;
2023-08-01 17:01:36.643 +07 client backend[295744] pg_regress/create_function_3 ERROR:  cannot change routine kind
2023-08-01 17:01:36.643 +07 client backend[295744] pg_regress/create_function_3 DETAIL:  "functest1" is a function.
2023-08-01 17:01:36.643 +07 client backend[295744] pg_regress/create_function_3 STATEMENT:  CREATE OR REPLACE FUNCTION functest1(a int) RETURNS int LANGUAGE SQL WINDOW AS 'SELECT $1';
2023-08-01 17:01:36.644 +07 client backend[295745] pg_regress/constraints ERROR:  new row for relation "insert_tbl" violates check constraint "insert_tbl_con"
2023-08-01 17:01:36.644 +07 client backend[295745] pg_regress/constraints DETAIL:  Failing row contains (8, try again, -8).
2023-08-01 17:01:36.644 +07 client backend[295745] pg_regress/constraints STATEMENT:  INSERT INTO INSERT_TBL(y,z) SELECT yd, -8 FROM tmp WHERE yd = 'try again';
2023-08-01 17:01:36.644 +07 client backend[295744] pg_regress/create_function_3 ERROR:  cannot change routine kind
2023-08-01 17:01:36.644 +07 client backend[295744] pg_regress/create_function_3 DETAIL:  "functest1" is a function.
2023-08-01 17:01:36.644 +07 client backend[295744] pg_regress/create_function_3 STATEMENT:  CREATE OR REPLACE PROCEDURE functest1(a int) LANGUAGE SQL AS 'SELECT $1';
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views ERROR:  cannot delete from view "ro_view1"
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Views containing DISTINCT are not automatically updatable.
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views HINT:  To enable deleting from the view, provide an INSTEAD OF DELETE trigger or an unconditional ON DELETE DO INSTEAD rule.
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  DELETE FROM ro_view1;
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views ERROR:  cannot delete from view "ro_view2"
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Views containing GROUP BY are not automatically updatable.
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views HINT:  To enable deleting from the view, provide an INSTEAD OF DELETE trigger or an unconditional ON DELETE DO INSTEAD rule.
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  DELETE FROM ro_view2;
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views ERROR:  cannot delete from view "ro_view3"
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Views containing HAVING are not automatically updatable.
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views HINT:  To enable deleting from the view, provide an INSTEAD OF DELETE trigger or an unconditional ON DELETE DO INSTEAD rule.
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  DELETE FROM ro_view3;
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views ERROR:  cannot delete from view "ro_view4"
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Views that return aggregate functions are not automatically updatable.
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views HINT:  To enable deleting from the view, provide an INSTEAD OF DELETE trigger or an unconditional ON DELETE DO INSTEAD rule.
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  DELETE FROM ro_view4;
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views ERROR:  cannot delete from view "ro_view5"
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Views that return window functions are not automatically updatable.
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views HINT:  To enable deleting from the view, provide an INSTEAD OF DELETE trigger or an unconditional ON DELETE DO INSTEAD rule.
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  DELETE FROM ro_view5;
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views ERROR:  cannot delete from view "ro_view6"
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Views containing UNION, INTERSECT, or EXCEPT are not automatically updatable.
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views HINT:  To enable deleting from the view, provide an INSTEAD OF DELETE trigger or an unconditional ON DELETE DO INSTEAD rule.
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  DELETE FROM ro_view6;
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views ERROR:  cannot update view "ro_view7"
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Views containing WITH are not automatically updatable.
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  UPDATE ro_view7 SET a=a+1;
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views ERROR:  cannot update view "ro_view8"
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Views containing LIMIT or OFFSET are not automatically updatable.
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  UPDATE ro_view8 SET a=a+1;
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views ERROR:  cannot update view "ro_view9"
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Views containing LIMIT or OFFSET are not automatically updatable.
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  UPDATE ro_view9 SET a=a+1;
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views ERROR:  cannot update view "ro_view10"
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Views that do not select from a single table or view are not automatically updatable.
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  UPDATE ro_view10 SET a=a+1;
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views ERROR:  cannot update view "ro_view11"
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Views that do not select from a single table or view are not automatically updatable.
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  UPDATE ro_view11 SET a=a+1;
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views ERROR:  cannot update view "ro_view12"
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Views that do not select from a single table or view are not automatically updatable.
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  UPDATE ro_view12 SET a=a+1;
2023-08-01 17:01:36.645 +07 client backend[295745] pg_regress/constraints ERROR:  new row for relation "insert_tbl" violates check constraint "insert_tbl_con"
2023-08-01 17:01:36.645 +07 client backend[295745] pg_regress/constraints DETAIL:  Failing row contains (-4, Y, 4).
2023-08-01 17:01:36.645 +07 client backend[295745] pg_regress/constraints STATEMENT:  UPDATE INSERT_TBL SET x = z, z = x;
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views ERROR:  cannot insert into view "ro_view13"
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Views that do not select from a single table or view are not automatically updatable.
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views HINT:  To enable inserting into the view, provide an INSTEAD OF INSERT trigger or an unconditional ON INSERT DO INSTEAD rule.
2023-08-01 17:01:36.645 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  INSERT INTO ro_view13 VALUES (3, 'Row 3');
2023-08-01 17:01:36.646 +07 client backend[295751] pg_regress/updatable_views ERROR:  cannot insert into column "ctid" of view "rw_view14"
2023-08-01 17:01:36.646 +07 client backend[295751] pg_regress/updatable_views DETAIL:  View columns that refer to system columns are not updatable.
2023-08-01 17:01:36.646 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  INSERT INTO rw_view14 VALUES (null, 3, 'Row 3');
2023-08-01 17:01:36.646 +07 client backend[295751] pg_regress/updatable_views ERROR:  cannot update column "ctid" of view "rw_view14"
2023-08-01 17:01:36.646 +07 client backend[295751] pg_regress/updatable_views DETAIL:  View columns that refer to system columns are not updatable.
2023-08-01 17:01:36.646 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  UPDATE rw_view14 SET ctid=null WHERE a=3;
2023-08-01 17:01:36.647 +07 client backend[295751] pg_regress/updatable_views ERROR:  cannot insert into column "upper" of view "rw_view15"
2023-08-01 17:01:36.647 +07 client backend[295751] pg_regress/updatable_views DETAIL:  View columns that are not columns of their base relation are not updatable.
2023-08-01 17:01:36.647 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  INSERT INTO rw_view15 VALUES (3, 'ROW 3');
2023-08-01 17:01:36.648 +07 client backend[295751] pg_regress/updatable_views ERROR:  cannot insert into column "upper" of view "rw_view15"
2023-08-01 17:01:36.648 +07 client backend[295751] pg_regress/updatable_views DETAIL:  View columns that are not columns of their base relation are not updatable.
2023-08-01 17:01:36.648 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  INSERT INTO rw_view15 (a) VALUES (3) ON CONFLICT (a) DO UPDATE set upper = 'blarg';
2023-08-01 17:01:36.648 +07 client backend[295745] pg_regress/constraints ERROR:  new row for relation "copy_tbl" violates check constraint "copy_con"
2023-08-01 17:01:36.648 +07 client backend[295745] pg_regress/constraints DETAIL:  Failing row contains (7, check failed, 6).
2023-08-01 17:01:36.648 +07 client backend[295745] pg_regress/constraints CONTEXT:  COPY copy_tbl, line 2: "7	check failed	6"
2023-08-01 17:01:36.648 +07 client backend[295745] pg_regress/constraints STATEMENT:  COPY COPY_TBL FROM '/home/vlad/postgres_cluster/build/../src/test/regress/data/constrf.data';
2023-08-01 17:01:36.648 +07 client backend[295749] pg_regress/vacuum ERROR:  ANALYZE cannot be executed from VACUUM or ANALYZE
2023-08-01 17:01:36.648 +07 client backend[295749] pg_regress/vacuum CONTEXT:  SQL function "do_analyze" statement 1
	SQL function "wrap_do_analyze" statement 1
2023-08-01 17:01:36.648 +07 client backend[295749] pg_regress/vacuum STATEMENT:  ANALYZE vaccluster;
2023-08-01 17:01:36.649 +07 client backend[295751] pg_regress/updatable_views ERROR:  cannot insert into column "upper" of view "rw_view15"
2023-08-01 17:01:36.649 +07 client backend[295751] pg_regress/updatable_views DETAIL:  View columns that are not columns of their base relation are not updatable.
2023-08-01 17:01:36.649 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  INSERT INTO rw_view15 (a) VALUES (4);
2023-08-01 17:01:36.649 +07 client backend[295751] pg_regress/updatable_views ERROR:  cannot update column "upper" of view "rw_view15"
2023-08-01 17:01:36.649 +07 client backend[295751] pg_regress/updatable_views DETAIL:  View columns that are not columns of their base relation are not updatable.
2023-08-01 17:01:36.649 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  UPDATE rw_view15 SET upper='ROW 3' WHERE a=3;
2023-08-01 17:01:36.649 +07 client backend[295751] pg_regress/updatable_views ERROR:  cannot update column "upper" of view "rw_view15"
2023-08-01 17:01:36.649 +07 client backend[295751] pg_regress/updatable_views DETAIL:  View columns that are not columns of their base relation are not updatable.
2023-08-01 17:01:36.649 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  UPDATE rw_view15 SET upper=DEFAULT WHERE a=3;
2023-08-01 17:01:36.649 +07 client backend[295751] pg_regress/updatable_views ERROR:  multiple assignments to same column "a"
2023-08-01 17:01:36.649 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  INSERT INTO rw_view16 VALUES (3, 'Row 3', 3);
2023-08-01 17:01:36.650 +07 client backend[295751] pg_regress/updatable_views ERROR:  multiple assignments to same column "a"
2023-08-01 17:01:36.650 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  UPDATE rw_view16 SET a=3, aa=-3 WHERE a=3;
2023-08-01 17:01:36.650 +07 client backend[295751] pg_regress/updatable_views ERROR:  cannot insert into view "ro_view1"
2023-08-01 17:01:36.650 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Views containing DISTINCT are not automatically updatable.
2023-08-01 17:01:36.650 +07 client backend[295751] pg_regress/updatable_views HINT:  To enable inserting into the view, provide an INSTEAD OF INSERT trigger or an unconditional ON INSERT DO INSTEAD rule.
2023-08-01 17:01:36.650 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  INSERT INTO ro_view17 VALUES (3, 'ROW 3');
2023-08-01 17:01:36.650 +07 client backend[295751] pg_regress/updatable_views ERROR:  cannot delete from view "ro_view18"
2023-08-01 17:01:36.650 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Views that do not select from a single table or view are not automatically updatable.
2023-08-01 17:01:36.650 +07 client backend[295751] pg_regress/updatable_views HINT:  To enable deleting from the view, provide an INSTEAD OF DELETE trigger or an unconditional ON DELETE DO INSTEAD rule.
2023-08-01 17:01:36.650 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  DELETE FROM ro_view18;
2023-08-01 17:01:36.650 +07 client backend[295751] pg_regress/updatable_views ERROR:  cannot update view "ro_view19"
2023-08-01 17:01:36.650 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Views that do not select from a single table or view are not automatically updatable.
2023-08-01 17:01:36.650 +07 client backend[295751] pg_regress/updatable_views HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.
2023-08-01 17:01:36.650 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  UPDATE ro_view19 SET last_value=1000;
2023-08-01 17:01:36.651 +07 client backend[295751] pg_regress/updatable_views ERROR:  cannot update view "ro_view20"
2023-08-01 17:01:36.651 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Views that return set-returning functions are not automatically updatable.
2023-08-01 17:01:36.651 +07 client backend[295751] pg_regress/updatable_views HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.
2023-08-01 17:01:36.651 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  UPDATE ro_view20 SET b=upper(b);
2023-08-01 17:01:36.652 +07 client backend[295752] pg_regress/create_am ERROR:  zero-length delimited identifier at or near """" at character 37
2023-08-01 17:01:36.652 +07 client backend[295752] pg_regress/create_am STATEMENT:  CREATE TABLE i_am_a_failure() USING "";
2023-08-01 17:01:36.652 +07 client backend[295752] pg_regress/create_am ERROR:  access method "i_do_not_exist_am" does not exist
2023-08-01 17:01:36.652 +07 client backend[295752] pg_regress/create_am STATEMENT:  CREATE TABLE i_am_a_failure() USING i_do_not_exist_am;
2023-08-01 17:01:36.652 +07 client backend[295752] pg_regress/create_am ERROR:  access method "I do not exist AM" does not exist
2023-08-01 17:01:36.652 +07 client backend[295752] pg_regress/create_am STATEMENT:  CREATE TABLE i_am_a_failure() USING "I do not exist AM";
2023-08-01 17:01:36.652 +07 client backend[295751] pg_regress/updatable_views ERROR:  cannot insert into view "rw_view16"
2023-08-01 17:01:36.652 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Views with conditional DO INSTEAD rules are not automatically updatable.
2023-08-01 17:01:36.652 +07 client backend[295751] pg_regress/updatable_views HINT:  To enable inserting into the view, provide an INSTEAD OF INSERT trigger or an unconditional ON INSERT DO INSTEAD rule.
2023-08-01 17:01:36.652 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  INSERT INTO rw_view16 (a, b) VALUES (3, 'Row 3');
2023-08-01 17:01:36.652 +07 client backend[295752] pg_regress/create_am ERROR:  access method "btree" is not of type TABLE
2023-08-01 17:01:36.652 +07 client backend[295752] pg_regress/create_am STATEMENT:  CREATE TABLE i_am_a_failure() USING "btree";
2023-08-01 17:01:36.652 +07 client backend[295751] pg_regress/updatable_views ERROR:  cannot update view "rw_view16"
2023-08-01 17:01:36.652 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Views with conditional DO INSTEAD rules are not automatically updatable.
2023-08-01 17:01:36.652 +07 client backend[295751] pg_regress/updatable_views HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.
2023-08-01 17:01:36.652 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  UPDATE rw_view16 SET b='ROW 2' WHERE a=2;
2023-08-01 17:01:36.652 +07 client backend[295751] pg_regress/updatable_views ERROR:  cannot delete from view "rw_view16"
2023-08-01 17:01:36.652 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Views with conditional DO INSTEAD rules are not automatically updatable.
2023-08-01 17:01:36.652 +07 client backend[295751] pg_regress/updatable_views HINT:  To enable deleting from the view, provide an INSTEAD OF DELETE trigger or an unconditional ON DELETE DO INSTEAD rule.
2023-08-01 17:01:36.652 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  DELETE FROM rw_view16 WHERE a=2;
2023-08-01 17:01:36.652 +07 client backend[295753] pg_regress/triggers ERROR:  ttdummy (tttest): you cannot change price_on and/or price_off columns (use set_ttdummy)
2023-08-01 17:01:36.652 +07 client backend[295753] pg_regress/triggers STATEMENT:  update tttest set price_on = -1 where price_id = 1;
2023-08-01 17:01:36.652 +07 client backend[295752] pg_regress/create_am ERROR:  cannot drop access method heap2 because other objects depend on it
2023-08-01 17:01:36.652 +07 client backend[295752] pg_regress/create_am DETAIL:  table tableam_tbl_heap2 depends on access method heap2
	table tableam_tblas_heap2 depends on access method heap2
	materialized view tableam_tblmv_heap2 depends on access method heap2
	table tableam_parted_b_heap2 depends on access method heap2
	table tableam_parted_d_heap2 depends on access method heap2
2023-08-01 17:01:36.652 +07 client backend[295752] pg_regress/create_am HINT:  Use DROP ... CASCADE to drop the dependent objects too.
2023-08-01 17:01:36.652 +07 client backend[295752] pg_regress/create_am STATEMENT:  DROP ACCESS METHOD heap2;
2023-08-01 17:01:36.652 +07 client backend[295745] pg_regress/constraints ERROR:  duplicate key value violates unique constraint "primary_tbl_pkey"
2023-08-01 17:01:36.652 +07 client backend[295745] pg_regress/constraints DETAIL:  Key (i)=(1) already exists.
2023-08-01 17:01:36.652 +07 client backend[295745] pg_regress/constraints STATEMENT:  INSERT INTO PRIMARY_TBL VALUES (1, 'three');
2023-08-01 17:01:36.654 +07 client backend[295745] pg_regress/constraints ERROR:  null value in column "i" of relation "primary_tbl" violates not-null constraint
2023-08-01 17:01:36.654 +07 client backend[295745] pg_regress/constraints DETAIL:  Failing row contains (null, six).
2023-08-01 17:01:36.654 +07 client backend[295745] pg_regress/constraints STATEMENT:  INSERT INTO PRIMARY_TBL (t) VALUES ('six');
2023-08-01 17:01:36.662 +07 client backend[295745] pg_regress/constraints ERROR:  null value in column "i" of relation "primary_tbl" violates not-null constraint
2023-08-01 17:01:36.662 +07 client backend[295745] pg_regress/constraints DETAIL:  Failing row contains (null, six).
2023-08-01 17:01:36.662 +07 client backend[295745] pg_regress/constraints STATEMENT:  INSERT INTO PRIMARY_TBL (t) VALUES ('six');
2023-08-01 17:01:36.664 +07 client backend[295749] pg_regress/vacuum ERROR:  ANALYZE cannot be executed from VACUUM or ANALYZE
2023-08-01 17:01:36.664 +07 client backend[295749] pg_regress/vacuum CONTEXT:  SQL function "do_analyze" statement 1
	SQL function "wrap_do_analyze" statement 1
2023-08-01 17:01:36.664 +07 client backend[295749] pg_regress/vacuum STATEMENT:  VACUUM FULL vaccluster;
2023-08-01 17:01:36.665 +07 client backend[295745] pg_regress/constraints ERROR:  duplicate key value violates unique constraint "unique_tbl_i_key"
2023-08-01 17:01:36.665 +07 client backend[295745] pg_regress/constraints DETAIL:  Key (i)=(1) already exists.
2023-08-01 17:01:36.665 +07 client backend[295745] pg_regress/constraints STATEMENT:  INSERT INTO UNIQUE_TBL VALUES (1, 'three');
2023-08-01 17:01:36.666 +07 client backend[295747] pg_regress/inherit ERROR:  column "tomorrow" inherits conflicting default values
2023-08-01 17:01:36.666 +07 client backend[295747] pg_regress/inherit HINT:  To resolve the conflict, specify a default explicitly.
2023-08-01 17:01:36.666 +07 client backend[295747] pg_regress/inherit STATEMENT:  CREATE TABLE otherchild () INHERITS (firstparent, thirdparent);
2023-08-01 17:01:36.666 +07 client backend[295745] pg_regress/constraints ERROR:  ON CONFLICT DO UPDATE command cannot affect row a second time
2023-08-01 17:01:36.666 +07 client backend[295745] pg_regress/constraints HINT:  Ensure that no rows proposed for insertion within the same command have duplicate constrained values.
2023-08-01 17:01:36.666 +07 client backend[295745] pg_regress/constraints STATEMENT:  INSERT INTO UNIQUE_TBL VALUES (1, 'a'), (2, 'b'), (2, 'b') ON CONFLICT (i) DO UPDATE SET t = 'fails';
2023-08-01 17:01:36.669 +07 client backend[295745] pg_regress/constraints ERROR:  duplicate key value violates unique constraint "unique_tbl_i_t_key"
2023-08-01 17:01:36.669 +07 client backend[295745] pg_regress/constraints DETAIL:  Key (i, t)=(1, one) already exists.
2023-08-01 17:01:36.669 +07 client backend[295745] pg_regress/constraints STATEMENT:  INSERT INTO UNIQUE_TBL VALUES (1, 'one');
2023-08-01 17:01:36.673 +07 client backend[295745] pg_regress/constraints ERROR:  duplicate key value violates unique constraint "unique_tbl_i_key"
2023-08-01 17:01:36.673 +07 client backend[295745] pg_regress/constraints DETAIL:  Key (i)=(1) already exists.
2023-08-01 17:01:36.673 +07 client backend[295745] pg_regress/constraints STATEMENT:  UPDATE unique_tbl SET i = 1 WHERE i = 0;
2023-08-01 17:01:36.676 +07 client backend[295745] pg_regress/constraints ERROR:  duplicate key value violates unique constraint "unique_tbl_i_key"
2023-08-01 17:01:36.676 +07 client backend[295745] pg_regress/constraints DETAIL:  Key (i)=(3) already exists.
2023-08-01 17:01:36.676 +07 client backend[295745] pg_regress/constraints STATEMENT:  COMMIT;
2023-08-01 17:01:36.676 +07 client backend[295745] pg_regress/constraints ERROR:  duplicate key value violates unique constraint "unique_tbl_i_key"
2023-08-01 17:01:36.676 +07 client backend[295745] pg_regress/constraints DETAIL:  Key (i)=(3) already exists.
2023-08-01 17:01:36.676 +07 client backend[295745] pg_regress/constraints STATEMENT:  INSERT INTO unique_tbl VALUES (3, 'Three');
2023-08-01 17:01:36.676 +07 client backend[295745] pg_regress/constraints ERROR:  duplicate key value violates unique constraint "unique_tbl_i_key"
2023-08-01 17:01:36.676 +07 client backend[295745] pg_regress/constraints DETAIL:  Key (i)=(3) already exists.
2023-08-01 17:01:36.676 +07 client backend[295745] pg_regress/constraints STATEMENT:  SET CONSTRAINTS ALL IMMEDIATE;
2023-08-01 17:01:36.677 +07 client backend[295753] pg_regress/triggers ERROR:  duplicate trigger events specified at or near "ON" at character 63
2023-08-01 17:01:36.677 +07 client backend[295753] pg_regress/triggers STATEMENT:  CREATE TRIGGER error_upd_and_col BEFORE UPDATE OR UPDATE OF a ON main_table
	FOR EACH ROW EXECUTE PROCEDURE trigger_func('error_upd_and_col');
2023-08-01 17:01:36.677 +07 client backend[295747] pg_regress/inherit ERROR:  cannot alter inherited column "f1" of relation "childtab"
2023-08-01 17:01:36.677 +07 client backend[295747] pg_regress/inherit STATEMENT:  alter table parent1 alter column f1 type bigint;
2023-08-01 17:01:36.677 +07 client backend[295753] pg_regress/triggers ERROR:  column "a" specified more than once
2023-08-01 17:01:36.677 +07 client backend[295753] pg_regress/triggers STATEMENT:  CREATE TRIGGER error_upd_a_a BEFORE UPDATE OF a, a ON main_table
	FOR EACH ROW EXECUTE PROCEDURE trigger_func('error_upd_a_a');
2023-08-01 17:01:36.678 +07 client backend[295753] pg_regress/triggers ERROR:  syntax error at or near "OF" at character 42
2023-08-01 17:01:36.678 +07 client backend[295753] pg_regress/triggers STATEMENT:  CREATE TRIGGER error_ins_a BEFORE INSERT OF a ON main_table
	FOR EACH ROW EXECUTE PROCEDURE trigger_func('error_ins_a');
2023-08-01 17:01:36.678 +07 client backend[295753] pg_regress/triggers ERROR:  INSERT trigger's WHEN condition cannot reference OLD values at character 88
2023-08-01 17:01:36.678 +07 client backend[295753] pg_regress/triggers STATEMENT:  CREATE TRIGGER error_ins_when BEFORE INSERT OR UPDATE ON main_table
	FOR EACH ROW WHEN (OLD.a <> NEW.a)
	EXECUTE PROCEDURE trigger_func('error_ins_old');
2023-08-01 17:01:36.678 +07 client backend[295753] pg_regress/triggers ERROR:  DELETE trigger's WHEN condition cannot reference NEW values at character 97
2023-08-01 17:01:36.678 +07 client backend[295753] pg_regress/triggers STATEMENT:  CREATE TRIGGER error_del_when BEFORE DELETE OR UPDATE ON main_table
	FOR EACH ROW WHEN (OLD.a <> NEW.a)
	EXECUTE PROCEDURE trigger_func('error_del_new');
2023-08-01 17:01:36.678 +07 client backend[295753] pg_regress/triggers ERROR:  BEFORE trigger's WHEN condition cannot reference NEW system columns at character 88
2023-08-01 17:01:36.678 +07 client backend[295753] pg_regress/triggers STATEMENT:  CREATE TRIGGER error_del_when BEFORE INSERT OR UPDATE ON main_table
	FOR EACH ROW WHEN (NEW.tableoid <> 0)
	EXECUTE PROCEDURE trigger_func('error_when_sys_column');
2023-08-01 17:01:36.678 +07 client backend[295753] pg_regress/triggers ERROR:  statement trigger's WHEN condition cannot reference column values at character 90
2023-08-01 17:01:36.678 +07 client backend[295753] pg_regress/triggers STATEMENT:  CREATE TRIGGER error_stmt_when BEFORE UPDATE OF a ON main_table
	FOR EACH STATEMENT WHEN (OLD.* IS DISTINCT FROM NEW.*)
	EXECUTE PROCEDURE trigger_func('error_stmt_when');
2023-08-01 17:01:36.678 +07 client backend[295753] pg_regress/triggers ERROR:  cannot drop column b of table main_table because other objects depend on it
2023-08-01 17:01:36.678 +07 client backend[295753] pg_regress/triggers DETAIL:  trigger after_upd_b_row_trig on table main_table depends on column b of table main_table
	trigger after_upd_a_b_row_trig on table main_table depends on column b of table main_table
	trigger after_upd_b_stmt_trig on table main_table depends on column b of table main_table
2023-08-01 17:01:36.678 +07 client backend[295753] pg_regress/triggers HINT:  Use DROP ... CASCADE to drop the dependent objects too.
2023-08-01 17:01:36.678 +07 client backend[295753] pg_regress/triggers STATEMENT:  ALTER TABLE main_table DROP COLUMN b;
2023-08-01 17:01:36.680 +07 client backend[295745] pg_regress/constraints ERROR:  duplicate key value violates unique constraint "parted_uniq_tbl_1_i_key"
2023-08-01 17:01:36.680 +07 client backend[295745] pg_regress/constraints DETAIL:  Key (i)=(1) already exists.
2023-08-01 17:01:36.680 +07 client backend[295745] pg_regress/constraints STATEMENT:  INSERT INTO parted_uniq_tbl VALUES (1);
2023-08-01 17:01:36.681 +07 client backend[295745] pg_regress/constraints ERROR:  duplicate key value violates unique constraint "parted_uniq_tbl_1_i_key"
2023-08-01 17:01:36.681 +07 client backend[295745] pg_regress/constraints DETAIL:  Key (i)=(1) already exists.
2023-08-01 17:01:36.681 +07 client backend[295745] pg_regress/constraints STATEMENT:  COMMIT;
2023-08-01 17:01:36.682 +07 client backend[295745] pg_regress/constraints ERROR:  duplicate key value violates unique constraint "unique_tbl_i_key"
2023-08-01 17:01:36.682 +07 client backend[295745] pg_regress/constraints DETAIL:  Key (i)=(3) already exists.
2023-08-01 17:01:36.682 +07 client backend[295745] pg_regress/constraints STATEMENT:  COMMIT;
2023-08-01 17:01:36.686 +07 client backend[295745] pg_regress/constraints ERROR:  conflicting key value violates exclusion constraint "circles_c1_c2_excl"
2023-08-01 17:01:36.686 +07 client backend[295745] pg_regress/constraints DETAIL:  Key (c1, (c2::circle))=(<(20,20),10>, <(0,0),4>) conflicts with existing key (c1, (c2::circle))=(<(10,10),10>, <(0,0),5>).
2023-08-01 17:01:36.686 +07 client backend[295745] pg_regress/constraints STATEMENT:  INSERT INTO circles VALUES('<(20,20), 10>', '<(0,0), 4>');
2023-08-01 17:01:36.686 +07 client backend[295745] pg_regress/constraints ERROR:  ON CONFLICT DO UPDATE not supported with exclusion constraints
2023-08-01 17:01:36.686 +07 client backend[295745] pg_regress/constraints STATEMENT:  INSERT INTO circles VALUES('<(20,20), 10>', '<(0,0), 4>')
	  ON CONFLICT ON CONSTRAINT circles_c1_c2_excl DO UPDATE SET c2 = EXCLUDED.c2;
2023-08-01 17:01:36.687 +07 client backend[295745] pg_regress/constraints ERROR:  could not create exclusion constraint "circles_c1_c2_excl1"
2023-08-01 17:01:36.687 +07 client backend[295745] pg_regress/constraints DETAIL:  Key (c1, (c2::circle))=(<(0,0),5>, <(0,0),5>) conflicts with key (c1, (c2::circle))=(<(0,0),5>, <(0,0),4>).
2023-08-01 17:01:36.687 +07 client backend[295745] pg_regress/constraints STATEMENT:  ALTER TABLE circles ADD EXCLUDE USING gist
	  (c1 WITH &&, (c2::circle) WITH &&);
2023-08-01 17:01:36.689 +07 client backend[295747] pg_regress/inherit ERROR:  constraint "p2chk" conflicts with inherited constraint on relation "c2"
2023-08-01 17:01:36.689 +07 client backend[295747] pg_regress/inherit STATEMENT:  create table c2 (constraint p2chk check (ff1 > 10) no inherit) inherits (p1);
2023-08-01 17:01:36.690 +07 client backend[295745] pg_regress/constraints ERROR:  conflicting key value violates exclusion constraint "deferred_excl_con"
2023-08-01 17:01:36.690 +07 client backend[295745] pg_regress/constraints DETAIL:  Key (f1)=(1) conflicts with existing key (f1)=(1).
2023-08-01 17:01:36.690 +07 client backend[295745] pg_regress/constraints STATEMENT:  INSERT INTO deferred_excl VALUES(1);
2023-08-01 17:01:36.690 +07 client backend[295745] pg_regress/constraints ERROR:  ON CONFLICT does not support deferrable unique constraints/exclusion constraints as arbiters
2023-08-01 17:01:36.690 +07 client backend[295745] pg_regress/constraints STATEMENT:  INSERT INTO deferred_excl VALUES(1) ON CONFLICT ON CONSTRAINT deferred_excl_con DO NOTHING;
2023-08-01 17:01:36.690 +07 client backend[295745] pg_regress/constraints ERROR:  conflicting key value violates exclusion constraint "deferred_excl_con"
2023-08-01 17:01:36.690 +07 client backend[295745] pg_regress/constraints DETAIL:  Key (f1)=(2) conflicts with existing key (f1)=(2).
2023-08-01 17:01:36.690 +07 client backend[295745] pg_regress/constraints STATEMENT:  COMMIT;
2023-08-01 17:01:36.690 +07 client backend[295745] pg_regress/constraints ERROR:  conflicting key value violates exclusion constraint "deferred_excl_con"
2023-08-01 17:01:36.690 +07 client backend[295745] pg_regress/constraints DETAIL:  Key (f1)=(3) conflicts with existing key (f1)=(3).
2023-08-01 17:01:36.690 +07 client backend[295745] pg_regress/constraints STATEMENT:  COMMIT;
2023-08-01 17:01:36.692 +07 client backend[295745] pg_regress/constraints ERROR:  could not create exclusion constraint "deferred_excl_f1_excl"
2023-08-01 17:01:36.692 +07 client backend[295745] pg_regress/constraints DETAIL:  Key (f1)=(3) conflicts with key (f1)=(3).
2023-08-01 17:01:36.692 +07 client backend[295745] pg_regress/constraints STATEMENT:  ALTER TABLE deferred_excl ADD EXCLUDE (f1 WITH =);
2023-08-01 17:01:36.694 +07 client backend[295745] pg_regress/constraints ERROR:  constraint "no_constraint" for table "constraint_comments_tbl" does not exist
2023-08-01 17:01:36.694 +07 client backend[295745] pg_regress/constraints STATEMENT:  COMMENT ON CONSTRAINT no_constraint ON constraint_comments_tbl IS 'yes, the comment';
2023-08-01 17:01:36.694 +07 client backend[295745] pg_regress/constraints ERROR:  constraint "no_constraint" for domain constraint_comments_dom does not exist
2023-08-01 17:01:36.694 +07 client backend[295745] pg_regress/constraints STATEMENT:  COMMENT ON CONSTRAINT no_constraint ON DOMAIN constraint_comments_dom IS 'yes, another comment';
2023-08-01 17:01:36.694 +07 client backend[295745] pg_regress/constraints ERROR:  relation "no_comments_tbl" does not exist
2023-08-01 17:01:36.694 +07 client backend[295745] pg_regress/constraints STATEMENT:  COMMENT ON CONSTRAINT the_constraint ON no_comments_tbl IS 'bad comment';
2023-08-01 17:01:36.694 +07 client backend[295745] pg_regress/constraints ERROR:  type "no_comments_dom" does not exist
2023-08-01 17:01:36.694 +07 client backend[295745] pg_regress/constraints STATEMENT:  COMMENT ON CONSTRAINT the_constraint ON DOMAIN no_comments_dom IS 'another bad comment';
2023-08-01 17:01:36.694 +07 client backend[295745] pg_regress/constraints ERROR:  must be owner of relation constraint_comments_tbl
2023-08-01 17:01:36.694 +07 client backend[295745] pg_regress/constraints STATEMENT:  COMMENT ON CONSTRAINT the_constraint ON constraint_comments_tbl IS 'no, the comment';
2023-08-01 17:01:36.694 +07 client backend[295745] pg_regress/constraints ERROR:  must be owner of type constraint_comments_dom
2023-08-01 17:01:36.694 +07 client backend[295745] pg_regress/constraints STATEMENT:  COMMENT ON CONSTRAINT the_constraint ON DOMAIN constraint_comments_dom IS 'no, another comment';
2023-08-01 17:01:36.699 +07 client backend[295747] pg_regress/inherit ERROR:  new row for relation "ac" violates check constraint "ac_check"
2023-08-01 17:01:36.699 +07 client backend[295747] pg_regress/inherit DETAIL:  Failing row contains (null).
2023-08-01 17:01:36.699 +07 client backend[295747] pg_regress/inherit STATEMENT:  insert into ac (aa) values (NULL);
2023-08-01 17:01:36.699 +07 client backend[295747] pg_regress/inherit ERROR:  new row for relation "bc" violates check constraint "ac_check"
2023-08-01 17:01:36.699 +07 client backend[295747] pg_regress/inherit DETAIL:  Failing row contains (null, null).
2023-08-01 17:01:36.699 +07 client backend[295747] pg_regress/inherit STATEMENT:  insert into bc (aa) values (NULL);
2023-08-01 17:01:36.699 +07 client backend[295747] pg_regress/inherit ERROR:  cannot drop inherited constraint "ac_check" of relation "bc"
2023-08-01 17:01:36.699 +07 client backend[295747] pg_regress/inherit STATEMENT:  alter table bc drop constraint ac_check;
2023-08-01 17:01:36.701 +07 client backend[295747] pg_regress/inherit ERROR:  new row for relation "ac" violates check constraint "ac_aa_check"
2023-08-01 17:01:36.701 +07 client backend[295747] pg_regress/inherit DETAIL:  Failing row contains (null).
2023-08-01 17:01:36.701 +07 client backend[295747] pg_regress/inherit STATEMENT:  insert into ac (aa) values (NULL);
2023-08-01 17:01:36.701 +07 client backend[295747] pg_regress/inherit ERROR:  new row for relation "bc" violates check constraint "ac_aa_check"
2023-08-01 17:01:36.701 +07 client backend[295747] pg_regress/inherit DETAIL:  Failing row contains (null, null).
2023-08-01 17:01:36.701 +07 client backend[295747] pg_regress/inherit STATEMENT:  insert into bc (aa) values (NULL);
2023-08-01 17:01:36.701 +07 client backend[295747] pg_regress/inherit ERROR:  cannot drop inherited constraint "ac_aa_check" of relation "bc"
2023-08-01 17:01:36.701 +07 client backend[295747] pg_regress/inherit STATEMENT:  alter table bc drop constraint ac_aa_check;
2023-08-01 17:01:36.707 +07 client backend[295753] pg_regress/triggers ERROR:  "main_view" is a view
2023-08-01 17:01:36.707 +07 client backend[295753] pg_regress/triggers DETAIL:  Views cannot have row-level BEFORE or AFTER triggers.
2023-08-01 17:01:36.707 +07 client backend[295753] pg_regress/triggers STATEMENT:  CREATE TRIGGER invalid_trig BEFORE INSERT ON main_view
	FOR EACH ROW EXECUTE PROCEDURE trigger_func('before_ins_row');
2023-08-01 17:01:36.707 +07 client backend[295753] pg_regress/triggers ERROR:  "main_view" is a view
2023-08-01 17:01:36.707 +07 client backend[295753] pg_regress/triggers DETAIL:  Views cannot have row-level BEFORE or AFTER triggers.
2023-08-01 17:01:36.707 +07 client backend[295753] pg_regress/triggers STATEMENT:  CREATE TRIGGER invalid_trig BEFORE UPDATE ON main_view
	FOR EACH ROW EXECUTE PROCEDURE trigger_func('before_upd_row');
2023-08-01 17:01:36.707 +07 client backend[295753] pg_regress/triggers ERROR:  "main_view" is a view
2023-08-01 17:01:36.707 +07 client backend[295753] pg_regress/triggers DETAIL:  Views cannot have row-level BEFORE or AFTER triggers.
2023-08-01 17:01:36.707 +07 client backend[295753] pg_regress/triggers STATEMENT:  CREATE TRIGGER invalid_trig BEFORE DELETE ON main_view
	FOR EACH ROW EXECUTE PROCEDURE trigger_func('before_del_row');
2023-08-01 17:01:36.707 +07 client backend[295753] pg_regress/triggers ERROR:  "main_view" is a view
2023-08-01 17:01:36.707 +07 client backend[295753] pg_regress/triggers DETAIL:  Views cannot have row-level BEFORE or AFTER triggers.
2023-08-01 17:01:36.707 +07 client backend[295753] pg_regress/triggers STATEMENT:  CREATE TRIGGER invalid_trig AFTER INSERT ON main_view
	FOR EACH ROW EXECUTE PROCEDURE trigger_func('before_ins_row');
2023-08-01 17:01:36.707 +07 client backend[295753] pg_regress/triggers ERROR:  "main_view" is a view
2023-08-01 17:01:36.707 +07 client backend[295753] pg_regress/triggers DETAIL:  Views cannot have row-level BEFORE or AFTER triggers.
2023-08-01 17:01:36.707 +07 client backend[295753] pg_regress/triggers STATEMENT:  CREATE TRIGGER invalid_trig AFTER UPDATE ON main_view
	FOR EACH ROW EXECUTE PROCEDURE trigger_func('before_upd_row');
2023-08-01 17:01:36.707 +07 client backend[295753] pg_regress/triggers ERROR:  "main_view" is a view
2023-08-01 17:01:36.707 +07 client backend[295753] pg_regress/triggers DETAIL:  Views cannot have row-level BEFORE or AFTER triggers.
2023-08-01 17:01:36.707 +07 client backend[295753] pg_regress/triggers STATEMENT:  CREATE TRIGGER invalid_trig AFTER DELETE ON main_view
	FOR EACH ROW EXECUTE PROCEDURE trigger_func('before_del_row');
2023-08-01 17:01:36.707 +07 client backend[295753] pg_regress/triggers ERROR:  "main_view" is a view
2023-08-01 17:01:36.707 +07 client backend[295753] pg_regress/triggers DETAIL:  Views cannot have TRUNCATE triggers.
2023-08-01 17:01:36.707 +07 client backend[295753] pg_regress/triggers STATEMENT:  CREATE TRIGGER invalid_trig BEFORE TRUNCATE ON main_view
	EXECUTE PROCEDURE trigger_func('before_tru_row');
2023-08-01 17:01:36.707 +07 client backend[295753] pg_regress/triggers ERROR:  "main_view" is a view
2023-08-01 17:01:36.707 +07 client backend[295753] pg_regress/triggers DETAIL:  Views cannot have TRUNCATE triggers.
2023-08-01 17:01:36.707 +07 client backend[295753] pg_regress/triggers STATEMENT:  CREATE TRIGGER invalid_trig AFTER TRUNCATE ON main_view
	EXECUTE PROCEDURE trigger_func('before_tru_row');
2023-08-01 17:01:36.707 +07 client backend[295753] pg_regress/triggers ERROR:  "main_table" is a table
2023-08-01 17:01:36.707 +07 client backend[295753] pg_regress/triggers DETAIL:  Tables cannot have INSTEAD OF triggers.
2023-08-01 17:01:36.707 +07 client backend[295753] pg_regress/triggers STATEMENT:  CREATE TRIGGER invalid_trig INSTEAD OF INSERT ON main_table
	FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_ins');
2023-08-01 17:01:36.707 +07 client backend[295753] pg_regress/triggers ERROR:  "main_table" is a table
2023-08-01 17:01:36.707 +07 client backend[295753] pg_regress/triggers DETAIL:  Tables cannot have INSTEAD OF triggers.
2023-08-01 17:01:36.707 +07 client backend[295753] pg_regress/triggers STATEMENT:  CREATE TRIGGER invalid_trig INSTEAD OF UPDATE ON main_table
	FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_upd');
2023-08-01 17:01:36.708 +07 client backend[295753] pg_regress/triggers ERROR:  "main_table" is a table
2023-08-01 17:01:36.708 +07 client backend[295753] pg_regress/triggers DETAIL:  Tables cannot have INSTEAD OF triggers.
2023-08-01 17:01:36.708 +07 client backend[295753] pg_regress/triggers STATEMENT:  CREATE TRIGGER invalid_trig INSTEAD OF DELETE ON main_table
	FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_del');
2023-08-01 17:01:36.708 +07 client backend[295753] pg_regress/triggers ERROR:  INSTEAD OF triggers cannot have WHEN conditions
2023-08-01 17:01:36.708 +07 client backend[295753] pg_regress/triggers STATEMENT:  CREATE TRIGGER invalid_trig INSTEAD OF UPDATE ON main_view
	FOR EACH ROW WHEN (OLD.a <> NEW.a) EXECUTE PROCEDURE view_trigger('instead_of_upd');
2023-08-01 17:01:36.708 +07 client backend[295753] pg_regress/triggers ERROR:  INSTEAD OF triggers cannot have column lists
2023-08-01 17:01:36.708 +07 client backend[295753] pg_regress/triggers STATEMENT:  CREATE TRIGGER invalid_trig INSTEAD OF UPDATE OF a ON main_view
	FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_upd');
2023-08-01 17:01:36.708 +07 client backend[295753] pg_regress/triggers ERROR:  INSTEAD OF triggers must be FOR EACH ROW
2023-08-01 17:01:36.708 +07 client backend[295753] pg_regress/triggers STATEMENT:  CREATE TRIGGER invalid_trig INSTEAD OF UPDATE ON main_view
	EXECUTE PROCEDURE view_trigger('instead_of_upd');
2023-08-01 17:01:36.710 +07 client backend[295757] pg_regress/infinite_recurse ERROR:  stack depth limit exceeded
2023-08-01 17:01:36.710 +07 client backend[295757] pg_regress/infinite_recurse HINT:  Increase the configuration parameter "max_stack_depth" (currently 2048kB), after ensuring the platform's stack depth limit is adequate.
2023-08-01 17:01:36.710 +07 client backend[295757] pg_regress/infinite_recurse CONTEXT:  SQL function "infinite_recurse" during inlining
	SQL function "infinite_recurse" during startup
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
	SQL function "infinite_recurse" statement 1
2023-08-01 17:01:36.710 +07 client backend[295757] pg_regress/infinite_recurse STATEMENT:  select infinite_recurse();
2023-08-01 17:01:36.713 +07 client backend[295747] pg_regress/inherit ERROR:  check constraint "cc" of relation "c1" is violated by some row
2023-08-01 17:01:36.713 +07 client backend[295747] pg_regress/inherit STATEMENT:  alter table p2 add constraint cc check (f2>0);
2023-08-01 17:01:36.713 +07 client backend[295747] pg_regress/inherit ERROR:  check constraint "p2_f2_check" of relation "c1" is violated by some row
2023-08-01 17:01:36.713 +07 client backend[295747] pg_regress/inherit STATEMENT:  alter table p2 add check (f2>0);
2023-08-01 17:01:36.714 +07 client backend[295747] pg_regress/inherit ERROR:  new row for relation "c1" violates check constraint "p2_f2_check"
2023-08-01 17:01:36.714 +07 client backend[295747] pg_regress/inherit DETAIL:  Failing row contains (1, -1, 2).
2023-08-01 17:01:36.714 +07 client backend[295747] pg_regress/inherit STATEMENT:  insert into c1 values(1,-1,2);
2023-08-01 17:01:36.716 +07 client backend[295749] pg_regress/vacuum ERROR:  parallel vacuum degree must be between 0 and 1024 at character 9
2023-08-01 17:01:36.716 +07 client backend[295749] pg_regress/vacuum STATEMENT:  VACUUM (PARALLEL -1) pvactst;
2023-08-01 17:01:36.717 +07 client backend[295749] pg_regress/vacuum ERROR:  VACUUM FULL cannot be performed in parallel
2023-08-01 17:01:36.717 +07 client backend[295749] pg_regress/vacuum STATEMENT:  VACUUM (PARALLEL 2, FULL TRUE) pvactst;
2023-08-01 17:01:36.717 +07 client backend[295749] pg_regress/vacuum ERROR:  parallel option requires a value between 0 and 1024 at character 9
2023-08-01 17:01:36.717 +07 client backend[295749] pg_regress/vacuum STATEMENT:  VACUUM (PARALLEL) pvactst;
2023-08-01 17:01:36.718 +07 client backend[295749] pg_regress/vacuum WARNING:  disabling parallel option of vacuum on "tmp" --- cannot vacuum temporary tables in parallel
2023-08-01 17:01:36.731 +07 client backend[295751] pg_regress/updatable_views ERROR:  permission denied for table base_tbl
2023-08-01 17:01:36.731 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  INSERT INTO base_tbl VALUES (3, 'Row 3', 3.0);
2023-08-01 17:01:36.731 +07 client backend[295751] pg_regress/updatable_views ERROR:  permission denied for view rw_view1
2023-08-01 17:01:36.731 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  INSERT INTO rw_view1 VALUES ('Row 3', 3.0, 3);
2023-08-01 17:01:36.731 +07 client backend[295751] pg_regress/updatable_views ERROR:  permission denied for table base_tbl
2023-08-01 17:01:36.731 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  INSERT INTO rw_view2 VALUES ('Row 3', 3.0, 3);
2023-08-01 17:01:36.732 +07 client backend[295751] pg_regress/updatable_views ERROR:  permission denied for table base_tbl
2023-08-01 17:01:36.732 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  UPDATE base_tbl SET b=b;
2023-08-01 17:01:36.732 +07 client backend[295751] pg_regress/updatable_views ERROR:  permission denied for view rw_view1
2023-08-01 17:01:36.732 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  UPDATE rw_view1 SET aa=aa;
2023-08-01 17:01:36.732 +07 client backend[295751] pg_regress/updatable_views ERROR:  permission denied for table base_tbl
2023-08-01 17:01:36.732 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  UPDATE rw_view2 SET bb=bb;
2023-08-01 17:01:36.732 +07 client backend[295751] pg_regress/updatable_views ERROR:  permission denied for table base_tbl
2023-08-01 17:01:36.732 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  DELETE FROM base_tbl;
2023-08-01 17:01:36.732 +07 client backend[295751] pg_regress/updatable_views ERROR:  permission denied for view rw_view1
2023-08-01 17:01:36.732 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  DELETE FROM rw_view1;
2023-08-01 17:01:36.732 +07 client backend[295751] pg_regress/updatable_views ERROR:  permission denied for table base_tbl
2023-08-01 17:01:36.732 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  DELETE FROM rw_view2;
2023-08-01 17:01:36.733 +07 client backend[295751] pg_regress/updatable_views ERROR:  permission denied for view rw_view1
2023-08-01 17:01:36.733 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  INSERT INTO rw_view1 VALUES ('Row 4', 4.0, 4);
2023-08-01 17:01:36.733 +07 client backend[295751] pg_regress/updatable_views ERROR:  permission denied for view rw_view1
2023-08-01 17:01:36.733 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  DELETE FROM rw_view1 WHERE aa=2;
2023-08-01 17:01:36.735 +07 client backend[295751] pg_regress/updatable_views ERROR:  permission denied for table base_tbl
2023-08-01 17:01:36.735 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  INSERT INTO base_tbl VALUES (5, 'Row 5', 5.0);
2023-08-01 17:01:36.735 +07 client backend[295751] pg_regress/updatable_views ERROR:  permission denied for table base_tbl
2023-08-01 17:01:36.735 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  INSERT INTO rw_view2 VALUES ('Row 6', 6.0, 6);
2023-08-01 17:01:36.735 +07 client backend[295751] pg_regress/updatable_views ERROR:  permission denied for table base_tbl
2023-08-01 17:01:36.735 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  DELETE FROM base_tbl WHERE a=3;
2023-08-01 17:01:36.735 +07 client backend[295751] pg_regress/updatable_views ERROR:  permission denied for table base_tbl
2023-08-01 17:01:36.735 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  DELETE FROM rw_view2 WHERE aa=4;
2023-08-01 17:01:36.737 +07 client backend[295747] pg_regress/inherit ERROR:  cannot rename inherited column "b"
2023-08-01 17:01:36.737 +07 client backend[295747] pg_regress/inherit STATEMENT:  ALTER TABLE inht1 RENAME b TO bb;
2023-08-01 17:01:36.737 +07 client backend[295747] pg_regress/inherit ERROR:  cannot rename inherited column "aa"
2023-08-01 17:01:36.737 +07 client backend[295747] pg_regress/inherit STATEMENT:  ALTER TABLE inhts RENAME aa TO aaa;
2023-08-01 17:01:36.739 +07 client backend[295751] pg_regress/updatable_views ERROR:  permission denied for table base_tbl
2023-08-01 17:01:36.739 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  SELECT * FROM rw_view1;
2023-08-01 17:01:36.739 +07 client backend[295751] pg_regress/updatable_views ERROR:  permission denied for table base_tbl
2023-08-01 17:01:36.739 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  SELECT * FROM rw_view1 FOR UPDATE;
2023-08-01 17:01:36.739 +07 client backend[295753] pg_regress/triggers ERROR:  No such country: "Japon"
2023-08-01 17:01:36.739 +07 client backend[295753] pg_regress/triggers CONTEXT:  PL/pgSQL function city_update() line 9 at RAISE
2023-08-01 17:01:36.739 +07 client backend[295753] pg_regress/triggers STATEMENT:  UPDATE city_view SET country_name = 'Japon' WHERE city_name = 'Tokyo';
2023-08-01 17:01:36.739 +07 client backend[295751] pg_regress/updatable_views ERROR:  permission denied for table base_tbl
2023-08-01 17:01:36.739 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  UPDATE rw_view1 SET b = 'foo' WHERE a = 1;
2023-08-01 17:01:36.740 +07 client backend[295751] pg_regress/updatable_views ERROR:  permission denied for view rw_view1
2023-08-01 17:01:36.740 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  SELECT * FROM rw_view2;
2023-08-01 17:01:36.740 +07 client backend[295751] pg_regress/updatable_views ERROR:  permission denied for view rw_view1
2023-08-01 17:01:36.740 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  SELECT * FROM rw_view2 FOR UPDATE;
2023-08-01 17:01:36.740 +07 client backend[295751] pg_regress/updatable_views ERROR:  permission denied for view rw_view1
2023-08-01 17:01:36.740 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  UPDATE rw_view2 SET b = 'bar' WHERE a = 1;
2023-08-01 17:01:36.740 +07 client backend[295749] pg_regress/vacuum ERROR:  null value in column "i" of relation "vac_truncate_test" violates not-null constraint
2023-08-01 17:01:36.740 +07 client backend[295749] pg_regress/vacuum DETAIL:  Failing row contains (null, null).
2023-08-01 17:01:36.740 +07 client backend[295749] pg_regress/vacuum STATEMENT:  INSERT INTO vac_truncate_test VALUES (1, NULL), (NULL, NULL);
2023-08-01 17:01:36.741 +07 client backend[295751] pg_regress/updatable_views ERROR:  permission denied for table base_tbl
2023-08-01 17:01:36.741 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  SELECT * FROM rw_view1 FOR UPDATE;
2023-08-01 17:01:36.741 +07 client backend[295751] pg_regress/updatable_views ERROR:  permission denied for table base_tbl
2023-08-01 17:01:36.741 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  UPDATE rw_view1 SET b = 'foo' WHERE a = 1;
2023-08-01 17:01:36.741 +07 client backend[295751] pg_regress/updatable_views ERROR:  permission denied for view rw_view1
2023-08-01 17:01:36.741 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  SELECT * FROM rw_view2;
2023-08-01 17:01:36.741 +07 client backend[295751] pg_regress/updatable_views ERROR:  permission denied for view rw_view1
2023-08-01 17:01:36.741 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  SELECT * FROM rw_view2 FOR UPDATE;
2023-08-01 17:01:36.741 +07 client backend[295751] pg_regress/updatable_views ERROR:  permission denied for view rw_view1
2023-08-01 17:01:36.741 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  UPDATE rw_view2 SET b = 'bar' WHERE a = 1;
2023-08-01 17:01:36.742 +07 client backend[295751] pg_regress/updatable_views ERROR:  permission denied for view rw_view1
2023-08-01 17:01:36.742 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  SELECT * FROM rw_view2 FOR UPDATE;
2023-08-01 17:01:36.742 +07 client backend[295751] pg_regress/updatable_views ERROR:  permission denied for view rw_view1
2023-08-01 17:01:36.742 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  UPDATE rw_view2 SET b = 'bar' WHERE a = 1;
2023-08-01 17:01:36.743 +07 client backend[295751] pg_regress/updatable_views ERROR:  permission denied for view rw_view1
2023-08-01 17:01:36.743 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  SELECT * FROM rw_view2 FOR UPDATE;
2023-08-01 17:01:36.743 +07 client backend[295751] pg_regress/updatable_views ERROR:  permission denied for view rw_view1
2023-08-01 17:01:36.743 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  UPDATE rw_view2 SET b = 'bar' WHERE a = 1;
2023-08-01 17:01:36.745 +07 client backend[295751] pg_regress/updatable_views ERROR:  permission denied for table base_tbl
2023-08-01 17:01:36.745 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  SELECT * FROM rw_view1 FOR UPDATE;
2023-08-01 17:01:36.745 +07 client backend[295751] pg_regress/updatable_views ERROR:  permission denied for table base_tbl
2023-08-01 17:01:36.745 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  UPDATE rw_view1 SET b = 'foo' WHERE a = 1;
2023-08-01 17:01:36.745 +07 client backend[295751] pg_regress/updatable_views ERROR:  permission denied for table base_tbl
2023-08-01 17:01:36.745 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  SELECT * FROM rw_view2 FOR UPDATE;
2023-08-01 17:01:36.745 +07 client backend[295751] pg_regress/updatable_views ERROR:  permission denied for table base_tbl
2023-08-01 17:01:36.745 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  UPDATE rw_view2 SET b = 'bar' WHERE a = 1;
2023-08-01 17:01:36.746 +07 client backend[295747] pg_regress/inherit ERROR:  cannot rename inherited column "b"
2023-08-01 17:01:36.746 +07 client backend[295747] pg_regress/inherit STATEMENT:  ALTER TABLE inht1 RENAME b TO bb;
2023-08-01 17:01:36.746 +07 client backend[295749] pg_regress/vacuum ERROR:  column "a" of relation "vacparted" appears more than once
2023-08-01 17:01:36.746 +07 client backend[295749] pg_regress/vacuum STATEMENT:  VACUUM ANALYZE vacparted(a,b,a);
2023-08-01 17:01:36.747 +07 client backend[295749] pg_regress/vacuum ERROR:  column "b" of relation "vacparted" appears more than once
2023-08-01 17:01:36.747 +07 client backend[295749] pg_regress/vacuum STATEMENT:  ANALYZE vacparted(a,b,b);
2023-08-01 17:01:36.747 +07 client backend[295749] pg_regress/vacuum ERROR:  relation "does_not_exist" does not exist
2023-08-01 17:01:36.747 +07 client backend[295749] pg_regress/vacuum STATEMENT:  VACUUM vacparted, does_not_exist;
2023-08-01 17:01:36.748 +07 client backend[295749] pg_regress/vacuum ERROR:  relation "does_not_exist" does not exist
2023-08-01 17:01:36.748 +07 client backend[295749] pg_regress/vacuum STATEMENT:  VACUUM (FREEZE) does_not_exist, vaccluster;
2023-08-01 17:01:36.749 +07 client backend[295749] pg_regress/vacuum ERROR:  column "does_not_exist" of relation "vactst" does not exist
2023-08-01 17:01:36.749 +07 client backend[295749] pg_regress/vacuum STATEMENT:  VACUUM ANALYZE vactst (does_not_exist), vacparted (b);
2023-08-01 17:01:36.750 +07 client backend[295749] pg_regress/vacuum ERROR:  ANALYZE option must be specified when a column list is provided
2023-08-01 17:01:36.750 +07 client backend[295749] pg_regress/vacuum STATEMENT:  VACUUM FULL vactst, vacparted (a, b), vaccluster (i);
2023-08-01 17:01:36.751 +07 client backend[295749] pg_regress/vacuum ERROR:  relation "does_not_exist" does not exist
2023-08-01 17:01:36.751 +07 client backend[295749] pg_regress/vacuum STATEMENT:  ANALYZE vactst, does_not_exist, vacparted;
2023-08-01 17:01:36.751 +07 client backend[295749] pg_regress/vacuum ERROR:  column "does_not_exist" of relation "vacparted" does not exist
2023-08-01 17:01:36.751 +07 client backend[295749] pg_regress/vacuum STATEMENT:  ANALYZE vactst (i), vacparted (does_not_exist);
2023-08-01 17:01:36.751 +07 client backend[295749] pg_regress/vacuum ERROR:  relation "does_not_exist" does not exist
2023-08-01 17:01:36.751 +07 client backend[295749] pg_regress/vacuum STATEMENT:  ANALYZE (VERBOSE) does_not_exist;
2023-08-01 17:01:36.751 +07 client backend[295749] pg_regress/vacuum ERROR:  syntax error at or near "arg" at character 22
2023-08-01 17:01:36.751 +07 client backend[295749] pg_regress/vacuum STATEMENT:  ANALYZE (nonexistent-arg) does_not_exist;
2023-08-01 17:01:36.751 +07 client backend[295749] pg_regress/vacuum ERROR:  unrecognized ANALYZE option "nonexistentarg" at character 10
2023-08-01 17:01:36.751 +07 client backend[295749] pg_regress/vacuum STATEMENT:  ANALYZE (nonexistentarg) does_not_exit;
2023-08-01 17:01:36.751 +07 client backend[295749] pg_regress/vacuum ERROR:  relation "does_not_exist" does not exist
2023-08-01 17:01:36.751 +07 client backend[295749] pg_regress/vacuum STATEMENT:  ANALYZE (SKIP_LOCKED, VERBOSE) does_not_exist;
2023-08-01 17:01:36.751 +07 client backend[295749] pg_regress/vacuum ERROR:  relation "does_not_exist" does not exist
2023-08-01 17:01:36.751 +07 client backend[295749] pg_regress/vacuum STATEMENT:  ANALYZE (VERBOSE, SKIP_LOCKED) does_not_exist;
2023-08-01 17:01:36.758 +07 client backend[295749] pg_regress/vacuum WARNING:  skipping "vacowned" --- only table or database owner can vacuum it
2023-08-01 17:01:36.758 +07 client backend[295749] pg_regress/vacuum WARNING:  skipping "vacowned" --- only table or database owner can analyze it
2023-08-01 17:01:36.758 +07 client backend[295749] pg_regress/vacuum WARNING:  skipping "vacowned" --- only table or database owner can vacuum it
2023-08-01 17:01:36.759 +07 client backend[295749] pg_regress/vacuum WARNING:  skipping "pg_class" --- only superuser or database owner can vacuum it
2023-08-01 17:01:36.759 +07 client backend[295749] pg_regress/vacuum WARNING:  skipping "pg_class" --- only superuser or database owner can analyze it
2023-08-01 17:01:36.759 +07 client backend[295749] pg_regress/vacuum WARNING:  skipping "pg_class" --- only superuser or database owner can vacuum it
2023-08-01 17:01:36.760 +07 client backend[295749] pg_regress/vacuum WARNING:  skipping "pg_authid" --- only superuser can vacuum it
2023-08-01 17:01:36.760 +07 client backend[295749] pg_regress/vacuum WARNING:  skipping "pg_authid" --- only superuser can analyze it
2023-08-01 17:01:36.760 +07 client backend[295749] pg_regress/vacuum WARNING:  skipping "pg_authid" --- only superuser can vacuum it
2023-08-01 17:01:36.761 +07 client backend[295749] pg_regress/vacuum WARNING:  skipping "vacowned_parted" --- only table or database owner can vacuum it
2023-08-01 17:01:36.761 +07 client backend[295749] pg_regress/vacuum WARNING:  skipping "vacowned_part1" --- only table or database owner can vacuum it
2023-08-01 17:01:36.761 +07 client backend[295749] pg_regress/vacuum WARNING:  skipping "vacowned_part2" --- only table or database owner can vacuum it
2023-08-01 17:01:36.761 +07 client backend[295749] pg_regress/vacuum WARNING:  skipping "vacowned_part1" --- only table or database owner can vacuum it
2023-08-01 17:01:36.761 +07 client backend[295749] pg_regress/vacuum WARNING:  skipping "vacowned_part2" --- only table or database owner can vacuum it
2023-08-01 17:01:36.762 +07 client backend[295749] pg_regress/vacuum WARNING:  skipping "vacowned_parted" --- only table or database owner can analyze it
2023-08-01 17:01:36.762 +07 client backend[295749] pg_regress/vacuum WARNING:  skipping "vacowned_part1" --- only table or database owner can analyze it
2023-08-01 17:01:36.762 +07 client backend[295749] pg_regress/vacuum WARNING:  skipping "vacowned_part2" --- only table or database owner can analyze it
2023-08-01 17:01:36.762 +07 client backend[295749] pg_regress/vacuum WARNING:  skipping "vacowned_part1" --- only table or database owner can analyze it
2023-08-01 17:01:36.762 +07 client backend[295749] pg_regress/vacuum WARNING:  skipping "vacowned_part2" --- only table or database owner can analyze it
2023-08-01 17:01:36.762 +07 client backend[295749] pg_regress/vacuum WARNING:  skipping "vacowned_parted" --- only table or database owner can vacuum it
2023-08-01 17:01:36.762 +07 client backend[295749] pg_regress/vacuum WARNING:  skipping "vacowned_part1" --- only table or database owner can vacuum it
2023-08-01 17:01:36.762 +07 client backend[295749] pg_regress/vacuum WARNING:  skipping "vacowned_part2" --- only table or database owner can vacuum it
2023-08-01 17:01:36.763 +07 client backend[295749] pg_regress/vacuum WARNING:  skipping "vacowned_part1" --- only table or database owner can vacuum it
2023-08-01 17:01:36.763 +07 client backend[295749] pg_regress/vacuum WARNING:  skipping "vacowned_part2" --- only table or database owner can vacuum it
2023-08-01 17:01:36.763 +07 client backend[295753] pg_regress/triggers ERROR:  U9999
2023-08-01 17:01:36.763 +07 client backend[295753] pg_regress/triggers CONTEXT:  PL/pgSQL function depth_c_tf() line 5 at RAISE
	SQL statement "insert into depth_c values (1)"
	PL/pgSQL function depth_b_tf() line 12 at EXECUTE
	SQL statement "insert into depth_b values (new.id)"
	PL/pgSQL function depth_a_tf() line 4 at SQL statement
2023-08-01 17:01:36.763 +07 client backend[295753] pg_regress/triggers STATEMENT:  insert into depth_a values (1);
2023-08-01 17:01:36.764 +07 client backend[295749] pg_regress/vacuum WARNING:  skipping "vacowned_part2" --- only table or database owner can vacuum it
2023-08-01 17:01:36.764 +07 client backend[295751] pg_regress/updatable_views ERROR:  cannot insert into column "ctid" of view "rw_view1"
2023-08-01 17:01:36.764 +07 client backend[295751] pg_regress/updatable_views DETAIL:  View columns that refer to system columns are not updatable.
2023-08-01 17:01:36.764 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  INSERT INTO rw_view1 VALUES (null, null, 1.1, null);
2023-08-01 17:01:36.764 +07 client backend[295751] pg_regress/updatable_views ERROR:  cannot insert into column "s" of view "rw_view1"
2023-08-01 17:01:36.764 +07 client backend[295751] pg_regress/updatable_views DETAIL:  View columns that are not columns of their base relation are not updatable.
2023-08-01 17:01:36.764 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  INSERT INTO rw_view1 (s, c, a) VALUES (null, null, 1.1);
2023-08-01 17:01:36.765 +07 client backend[295751] pg_regress/updatable_views ERROR:  cannot update column "s" of view "rw_view1"
2023-08-01 17:01:36.765 +07 client backend[295751] pg_regress/updatable_views DETAIL:  View columns that are not columns of their base relation are not updatable.
2023-08-01 17:01:36.765 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  UPDATE rw_view1 SET s = s WHERE a = 1.1;
2023-08-01 17:01:36.765 +07 client backend[295749] pg_regress/vacuum WARNING:  skipping "vacowned_part2" --- only table or database owner can vacuum it
2023-08-01 17:01:36.765 +07 client backend[295749] pg_regress/vacuum WARNING:  skipping "vacowned_part2" --- only table or database owner can analyze it
2023-08-01 17:01:36.765 +07 client backend[295749] pg_regress/vacuum WARNING:  skipping "vacowned_part2" --- only table or database owner can analyze it
2023-08-01 17:01:36.766 +07 client backend[295751] pg_regress/updatable_views ERROR:  cannot insert into column "t" of view "rw_view2"
2023-08-01 17:01:36.766 +07 client backend[295751] pg_regress/updatable_views DETAIL:  View columns that are not columns of their base relation are not updatable.
2023-08-01 17:01:36.766 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  INSERT INTO rw_view2 VALUES (null, null, null, 1.1, null);
2023-08-01 17:01:36.766 +07 client backend[295749] pg_regress/vacuum WARNING:  skipping "vacowned_part2" --- only table or database owner can vacuum it
2023-08-01 17:01:36.766 +07 client backend[295751] pg_regress/updatable_views ERROR:  cannot insert into column "s" of view "rw_view1"
2023-08-01 17:01:36.766 +07 client backend[295751] pg_regress/updatable_views DETAIL:  View columns that are not columns of their base relation are not updatable.
2023-08-01 17:01:36.766 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  INSERT INTO rw_view2(s, c, base_a) VALUES (null, null, 1.1);
2023-08-01 17:01:36.766 +07 client backend[295751] pg_regress/updatable_views ERROR:  cannot update column "s" of view "rw_view1"
2023-08-01 17:01:36.766 +07 client backend[295751] pg_regress/updatable_views DETAIL:  View columns that are not columns of their base relation are not updatable.
2023-08-01 17:01:36.766 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  UPDATE rw_view2 SET s = s WHERE base_a = 1.1;
2023-08-01 17:01:36.766 +07 client backend[295751] pg_regress/updatable_views ERROR:  cannot update column "t" of view "rw_view2"
2023-08-01 17:01:36.766 +07 client backend[295751] pg_regress/updatable_views DETAIL:  View columns that are not columns of their base relation are not updatable.
2023-08-01 17:01:36.766 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  UPDATE rw_view2 SET t = t WHERE base_a = 1.1;
2023-08-01 17:01:36.767 +07 client backend[295749] pg_regress/vacuum WARNING:  skipping "vacowned_part2" --- only table or database owner can vacuum it
2023-08-01 17:01:36.767 +07 client backend[295751] pg_regress/updatable_views ERROR:  cannot insert into column "t" of view "rw_view3"
2023-08-01 17:01:36.767 +07 client backend[295751] pg_regress/updatable_views DETAIL:  View columns that are not columns of their base relation are not updatable.
2023-08-01 17:01:36.767 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  INSERT INTO rw_view3 VALUES (null, null, null, null);
2023-08-01 17:01:36.767 +07 client backend[295751] pg_regress/updatable_views ERROR:  cannot insert into column "s" of view "rw_view1"
2023-08-01 17:01:36.767 +07 client backend[295751] pg_regress/updatable_views DETAIL:  View columns that are not columns of their base relation are not updatable.
2023-08-01 17:01:36.767 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  INSERT INTO rw_view3(s) VALUES (null);
2023-08-01 17:01:36.767 +07 client backend[295751] pg_regress/updatable_views ERROR:  cannot update column "s" of view "rw_view1"
2023-08-01 17:01:36.767 +07 client backend[295751] pg_regress/updatable_views DETAIL:  View columns that are not columns of their base relation are not updatable.
2023-08-01 17:01:36.767 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  UPDATE rw_view3 SET s = s;
2023-08-01 17:01:36.767 +07 client backend[295749] pg_regress/vacuum WARNING:  skipping "vacowned_parted" --- only table or database owner can vacuum it
2023-08-01 17:01:36.767 +07 client backend[295749] pg_regress/vacuum WARNING:  skipping "vacowned_part2" --- only table or database owner can vacuum it
2023-08-01 17:01:36.768 +07 client backend[295749] pg_regress/vacuum WARNING:  skipping "vacowned_part2" --- only table or database owner can vacuum it
2023-08-01 17:01:36.768 +07 client backend[295749] pg_regress/vacuum WARNING:  skipping "vacowned_parted" --- only table or database owner can analyze it
2023-08-01 17:01:36.768 +07 client backend[295749] pg_regress/vacuum WARNING:  skipping "vacowned_part2" --- only table or database owner can analyze it
2023-08-01 17:01:36.769 +07 client backend[295749] pg_regress/vacuum WARNING:  skipping "vacowned_part2" --- only table or database owner can analyze it
2023-08-01 17:01:36.769 +07 client backend[295749] pg_regress/vacuum WARNING:  skipping "vacowned_parted" --- only table or database owner can vacuum it
2023-08-01 17:01:36.769 +07 client backend[295749] pg_regress/vacuum WARNING:  skipping "vacowned_part2" --- only table or database owner can vacuum it
2023-08-01 17:01:36.770 +07 client backend[295749] pg_regress/vacuum WARNING:  skipping "vacowned_part2" --- only table or database owner can vacuum it
2023-08-01 17:01:36.771 +07 client backend[295749] pg_regress/vacuum WARNING:  skipping "vacowned_part1" --- only table or database owner can vacuum it
2023-08-01 17:01:36.771 +07 client backend[295749] pg_regress/vacuum WARNING:  skipping "vacowned_part2" --- only table or database owner can vacuum it
2023-08-01 17:01:36.771 +07 client backend[295749] pg_regress/vacuum WARNING:  skipping "vacowned_part1" --- only table or database owner can vacuum it
2023-08-01 17:01:36.772 +07 client backend[295749] pg_regress/vacuum WARNING:  skipping "vacowned_part2" --- only table or database owner can vacuum it
2023-08-01 17:01:36.772 +07 client backend[295749] pg_regress/vacuum WARNING:  skipping "vacowned_part1" --- only table or database owner can analyze it
2023-08-01 17:01:36.772 +07 client backend[295749] pg_regress/vacuum WARNING:  skipping "vacowned_part2" --- only table or database owner can analyze it
2023-08-01 17:01:36.772 +07 client backend[295749] pg_regress/vacuum WARNING:  skipping "vacowned_part1" --- only table or database owner can analyze it
2023-08-01 17:01:36.772 +07 client backend[295749] pg_regress/vacuum WARNING:  skipping "vacowned_part2" --- only table or database owner can analyze it
2023-08-01 17:01:36.772 +07 client backend[295751] pg_regress/updatable_views ERROR:  cannot insert into column "idplus1"
2023-08-01 17:01:36.772 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Column "idplus1" is a generated column.
2023-08-01 17:01:36.772 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  INSERT INTO base_tbl (id, idplus1) VALUES (5, 6);
2023-08-01 17:01:36.772 +07 client backend[295751] pg_regress/updatable_views ERROR:  cannot insert into column "idplus1"
2023-08-01 17:01:36.772 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Column "idplus1" is a generated column.
2023-08-01 17:01:36.772 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  INSERT INTO rw_view1 (id, idplus1) VALUES (6, 7);
2023-08-01 17:01:36.773 +07 client backend[295749] pg_regress/vacuum WARNING:  skipping "vacowned_part1" --- only table or database owner can vacuum it
2023-08-01 17:01:36.773 +07 client backend[295749] pg_regress/vacuum WARNING:  skipping "vacowned_part2" --- only table or database owner can vacuum it
2023-08-01 17:01:36.773 +07 client backend[295749] pg_regress/vacuum WARNING:  skipping "vacowned_part1" --- only table or database owner can vacuum it
2023-08-01 17:01:36.773 +07 client backend[295753] pg_regress/triggers ERROR:  tuple to be updated was already modified by an operation triggered by the current command
2023-08-01 17:01:36.773 +07 client backend[295753] pg_regress/triggers HINT:  Consider using an AFTER trigger instead of a BEFORE trigger to propagate changes to other rows.
2023-08-01 17:01:36.773 +07 client backend[295753] pg_regress/triggers STATEMENT:  update parent set val1 = 'b' where aid = 1;
2023-08-01 17:01:36.773 +07 client backend[295749] pg_regress/vacuum WARNING:  skipping "vacowned_part2" --- only table or database owner can vacuum it
2023-08-01 17:01:36.774 +07 client backend[295753] pg_regress/triggers ERROR:  tuple to be deleted was already modified by an operation triggered by the current command
2023-08-01 17:01:36.774 +07 client backend[295753] pg_regress/triggers HINT:  Consider using an AFTER trigger instead of a BEFORE trigger to propagate changes to other rows.
2023-08-01 17:01:36.774 +07 client backend[295753] pg_regress/triggers STATEMENT:  delete from parent where aid = 1;
2023-08-01 17:01:36.785 +07 client backend[295753] pg_regress/triggers ERROR:  tuple to be updated was already modified by an operation triggered by the current command
2023-08-01 17:01:36.785 +07 client backend[295753] pg_regress/triggers HINT:  Consider using an AFTER trigger instead of a BEFORE trigger to propagate changes to other rows.
2023-08-01 17:01:36.785 +07 client backend[295753] pg_regress/triggers STATEMENT:  delete from self_ref_trigger;
2023-08-01 17:01:36.786 +07 client backend[295751] pg_regress/updatable_views ERROR:  new row violates check option for view "rw_view1"
2023-08-01 17:01:36.786 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Failing row contains (4, 3).
2023-08-01 17:01:36.786 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  INSERT INTO rw_view1 VALUES(4,3);
2023-08-01 17:01:36.786 +07 client backend[295751] pg_regress/updatable_views ERROR:  new row violates check option for view "rw_view1"
2023-08-01 17:01:36.786 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Failing row contains (5, null).
2023-08-01 17:01:36.786 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  INSERT INTO rw_view1 VALUES(5,null);
2023-08-01 17:01:36.786 +07 client backend[295751] pg_regress/updatable_views ERROR:  new row violates check option for view "rw_view1"
2023-08-01 17:01:36.786 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Failing row contains (3, -5).
2023-08-01 17:01:36.786 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  UPDATE rw_view1 SET b = -5 WHERE a = 3;
2023-08-01 17:01:36.786 +07 client backend[295751] pg_regress/updatable_views ERROR:  new row violates check option for view "rw_view1"
2023-08-01 17:01:36.786 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Failing row contains (10, 10).
2023-08-01 17:01:36.786 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  INSERT INTO rw_view1(a) VALUES (10);
2023-08-01 17:01:36.791 +07 client backend[295751] pg_regress/updatable_views ERROR:  new row violates check option for view "rw_view1"
2023-08-01 17:01:36.791 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Failing row contains (-5).
2023-08-01 17:01:36.791 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  INSERT INTO rw_view2 VALUES (-5);
2023-08-01 17:01:36.791 +07 client backend[295751] pg_regress/updatable_views ERROR:  new row violates check option for view "rw_view2"
2023-08-01 17:01:36.791 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Failing row contains (15).
2023-08-01 17:01:36.791 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  INSERT INTO rw_view2 VALUES (15);
2023-08-01 17:01:36.791 +07 client backend[295751] pg_regress/updatable_views ERROR:  new row violates check option for view "rw_view1"
2023-08-01 17:01:36.791 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Failing row contains (-5).
2023-08-01 17:01:36.791 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  UPDATE rw_view2 SET a = a - 10;
2023-08-01 17:01:36.791 +07 client backend[295751] pg_regress/updatable_views ERROR:  new row violates check option for view "rw_view2"
2023-08-01 17:01:36.791 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Failing row contains (15).
2023-08-01 17:01:36.791 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  UPDATE rw_view2 SET a = a + 10;
2023-08-01 17:01:36.793 +07 client backend[295753] pg_regress/triggers ERROR:  cannot ALTER TABLE "trigger_ddl_table" because it is being used by active queries in this session
2023-08-01 17:01:36.793 +07 client backend[295753] pg_regress/triggers CONTEXT:  SQL statement "alter table trigger_ddl_table add primary key (col1)"
	PL/pgSQL function trigger_ddl_func() line 3 at SQL statement
2023-08-01 17:01:36.793 +07 client backend[295753] pg_regress/triggers STATEMENT:  insert into trigger_ddl_table values (1, 42);
2023-08-01 17:01:36.793 +07 client backend[295753] pg_regress/triggers ERROR:  cannot CREATE INDEX "trigger_ddl_table" because it is being used by active queries in this session
2023-08-01 17:01:36.793 +07 client backend[295753] pg_regress/triggers CONTEXT:  SQL statement "create index on trigger_ddl_table (col2)"
	PL/pgSQL function trigger_ddl_func() line 3 at SQL statement
2023-08-01 17:01:36.793 +07 client backend[295753] pg_regress/triggers STATEMENT:  insert into trigger_ddl_table values (1, 42);
2023-08-01 17:01:36.794 +07 client backend[295751] pg_regress/updatable_views ERROR:  new row violates check option for view "rw_view2"
2023-08-01 17:01:36.794 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Failing row contains (20).
2023-08-01 17:01:36.794 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  INSERT INTO rw_view2 VALUES (20);
2023-08-01 17:01:36.794 +07 client backend[295751] pg_regress/updatable_views ERROR:  invalid value for enum option "check_option": here
2023-08-01 17:01:36.794 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Valid values are "local" and "cascaded".
2023-08-01 17:01:36.794 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  ALTER VIEW rw_view1 SET (check_option=here);
2023-08-01 17:01:36.795 +07 client backend[295751] pg_regress/updatable_views ERROR:  new row violates check option for view "rw_view1"
2023-08-01 17:01:36.795 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Failing row contains (-20).
2023-08-01 17:01:36.795 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  INSERT INTO rw_view2 VALUES (-20);
2023-08-01 17:01:36.795 +07 client backend[295751] pg_regress/updatable_views ERROR:  new row violates check option for view "rw_view2"
2023-08-01 17:01:36.795 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Failing row contains (30).
2023-08-01 17:01:36.795 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  INSERT INTO rw_view2 VALUES (30);
2023-08-01 17:01:36.797 +07 client backend[295753] pg_regress/triggers WARNING:  before insert (new): (1,black)
2023-08-01 17:01:36.797 +07 client backend[295753] pg_regress/triggers CONTEXT:  PL/pgSQL function upsert_before_func() line 7 at RAISE
2023-08-01 17:01:36.797 +07 client backend[295753] pg_regress/triggers WARNING:  after insert (new): (1,black)
2023-08-01 17:01:36.797 +07 client backend[295753] pg_regress/triggers CONTEXT:  PL/pgSQL function upsert_after_func() line 7 at RAISE
2023-08-01 17:01:36.798 +07 client backend[295753] pg_regress/triggers WARNING:  before insert (new): (2,red)
2023-08-01 17:01:36.798 +07 client backend[295753] pg_regress/triggers CONTEXT:  PL/pgSQL function upsert_before_func() line 7 at RAISE
2023-08-01 17:01:36.798 +07 client backend[295753] pg_regress/triggers WARNING:  before insert (new, modified): (3,"red trig modified")
2023-08-01 17:01:36.798 +07 client backend[295753] pg_regress/triggers CONTEXT:  PL/pgSQL function upsert_before_func() line 11 at RAISE
2023-08-01 17:01:36.798 +07 client backend[295753] pg_regress/triggers WARNING:  after insert (new): (3,"red trig modified")
2023-08-01 17:01:36.798 +07 client backend[295753] pg_regress/triggers CONTEXT:  PL/pgSQL function upsert_after_func() line 7 at RAISE
2023-08-01 17:01:36.798 +07 client backend[295753] pg_regress/triggers WARNING:  before insert (new): (3,orange)
2023-08-01 17:01:36.798 +07 client backend[295753] pg_regress/triggers CONTEXT:  PL/pgSQL function upsert_before_func() line 7 at RAISE
2023-08-01 17:01:36.798 +07 client backend[295753] pg_regress/triggers WARNING:  before update (old): (3,"red trig modified")
2023-08-01 17:01:36.798 +07 client backend[295753] pg_regress/triggers CONTEXT:  PL/pgSQL function upsert_before_func() line 4 at RAISE
2023-08-01 17:01:36.798 +07 client backend[295753] pg_regress/triggers WARNING:  before update (new): (3,"updated red trig modified")
2023-08-01 17:01:36.798 +07 client backend[295753] pg_regress/triggers CONTEXT:  PL/pgSQL function upsert_before_func() line 5 at RAISE
2023-08-01 17:01:36.798 +07 client backend[295753] pg_regress/triggers WARNING:  after update (old): (3,"red trig modified")
2023-08-01 17:01:36.798 +07 client backend[295753] pg_regress/triggers CONTEXT:  PL/pgSQL function upsert_after_func() line 4 at RAISE
2023-08-01 17:01:36.798 +07 client backend[295753] pg_regress/triggers WARNING:  after update (new): (3,"updated red trig modified")
2023-08-01 17:01:36.798 +07 client backend[295753] pg_regress/triggers CONTEXT:  PL/pgSQL function upsert_after_func() line 5 at RAISE
2023-08-01 17:01:36.798 +07 client backend[295753] pg_regress/triggers WARNING:  before insert (new): (4,green)
2023-08-01 17:01:36.798 +07 client backend[295753] pg_regress/triggers CONTEXT:  PL/pgSQL function upsert_before_func() line 7 at RAISE
2023-08-01 17:01:36.798 +07 client backend[295753] pg_regress/triggers WARNING:  before insert (new, modified): (5,"green trig modified")
2023-08-01 17:01:36.798 +07 client backend[295753] pg_regress/triggers CONTEXT:  PL/pgSQL function upsert_before_func() line 11 at RAISE
2023-08-01 17:01:36.799 +07 client backend[295753] pg_regress/triggers WARNING:  after insert (new): (5,"green trig modified")
2023-08-01 17:01:36.799 +07 client backend[295753] pg_regress/triggers CONTEXT:  PL/pgSQL function upsert_after_func() line 7 at RAISE
2023-08-01 17:01:36.799 +07 client backend[295753] pg_regress/triggers WARNING:  before insert (new): (5,purple)
2023-08-01 17:01:36.799 +07 client backend[295753] pg_regress/triggers CONTEXT:  PL/pgSQL function upsert_before_func() line 7 at RAISE
2023-08-01 17:01:36.799 +07 client backend[295753] pg_regress/triggers WARNING:  before update (old): (5,"green trig modified")
2023-08-01 17:01:36.799 +07 client backend[295753] pg_regress/triggers CONTEXT:  PL/pgSQL function upsert_before_func() line 4 at RAISE
2023-08-01 17:01:36.799 +07 client backend[295753] pg_regress/triggers WARNING:  before update (new): (5,"updated green trig modified")
2023-08-01 17:01:36.799 +07 client backend[295753] pg_regress/triggers CONTEXT:  PL/pgSQL function upsert_before_func() line 5 at RAISE
2023-08-01 17:01:36.799 +07 client backend[295753] pg_regress/triggers WARNING:  after update (old): (5,"green trig modified")
2023-08-01 17:01:36.799 +07 client backend[295753] pg_regress/triggers CONTEXT:  PL/pgSQL function upsert_after_func() line 4 at RAISE
2023-08-01 17:01:36.799 +07 client backend[295753] pg_regress/triggers WARNING:  after update (new): (5,"updated green trig modified")
2023-08-01 17:01:36.799 +07 client backend[295753] pg_regress/triggers CONTEXT:  PL/pgSQL function upsert_after_func() line 5 at RAISE
2023-08-01 17:01:36.799 +07 client backend[295753] pg_regress/triggers WARNING:  before insert (new): (6,white)
2023-08-01 17:01:36.799 +07 client backend[295753] pg_regress/triggers CONTEXT:  PL/pgSQL function upsert_before_func() line 7 at RAISE
2023-08-01 17:01:36.799 +07 client backend[295753] pg_regress/triggers WARNING:  before insert (new, modified): (7,"white trig modified")
2023-08-01 17:01:36.799 +07 client backend[295753] pg_regress/triggers CONTEXT:  PL/pgSQL function upsert_before_func() line 11 at RAISE
2023-08-01 17:01:36.799 +07 client backend[295753] pg_regress/triggers WARNING:  after insert (new): (7,"white trig modified")
2023-08-01 17:01:36.799 +07 client backend[295753] pg_regress/triggers CONTEXT:  PL/pgSQL function upsert_after_func() line 7 at RAISE
2023-08-01 17:01:36.800 +07 client backend[295753] pg_regress/triggers WARNING:  before insert (new): (7,pink)
2023-08-01 17:01:36.800 +07 client backend[295753] pg_regress/triggers CONTEXT:  PL/pgSQL function upsert_before_func() line 7 at RAISE
2023-08-01 17:01:36.800 +07 client backend[295753] pg_regress/triggers WARNING:  before update (old): (7,"white trig modified")
2023-08-01 17:01:36.800 +07 client backend[295753] pg_regress/triggers CONTEXT:  PL/pgSQL function upsert_before_func() line 4 at RAISE
2023-08-01 17:01:36.800 +07 client backend[295753] pg_regress/triggers WARNING:  before update (new): (7,"updated white trig modified")
2023-08-01 17:01:36.800 +07 client backend[295753] pg_regress/triggers CONTEXT:  PL/pgSQL function upsert_before_func() line 5 at RAISE
2023-08-01 17:01:36.800 +07 client backend[295753] pg_regress/triggers WARNING:  after update (old): (7,"white trig modified")
2023-08-01 17:01:36.800 +07 client backend[295753] pg_regress/triggers CONTEXT:  PL/pgSQL function upsert_after_func() line 4 at RAISE
2023-08-01 17:01:36.800 +07 client backend[295753] pg_regress/triggers WARNING:  after update (new): (7,"updated white trig modified")
2023-08-01 17:01:36.800 +07 client backend[295753] pg_regress/triggers CONTEXT:  PL/pgSQL function upsert_after_func() line 5 at RAISE
2023-08-01 17:01:36.800 +07 client backend[295753] pg_regress/triggers WARNING:  before insert (new): (8,yellow)
2023-08-01 17:01:36.800 +07 client backend[295753] pg_regress/triggers CONTEXT:  PL/pgSQL function upsert_before_func() line 7 at RAISE
2023-08-01 17:01:36.800 +07 client backend[295753] pg_regress/triggers WARNING:  before insert (new, modified): (9,"yellow trig modified")
2023-08-01 17:01:36.800 +07 client backend[295753] pg_regress/triggers CONTEXT:  PL/pgSQL function upsert_before_func() line 11 at RAISE
2023-08-01 17:01:36.800 +07 client backend[295753] pg_regress/triggers WARNING:  after insert (new): (9,"yellow trig modified")
2023-08-01 17:01:36.800 +07 client backend[295753] pg_regress/triggers CONTEXT:  PL/pgSQL function upsert_after_func() line 7 at RAISE
2023-08-01 17:01:36.801 +07 client backend[295751] pg_regress/updatable_views ERROR:  new row violates check option for view "rw_view2"
2023-08-01 17:01:36.801 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Failing row contains (-3).
2023-08-01 17:01:36.801 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  INSERT INTO rw_view3 VALUES (-3);
2023-08-01 17:01:36.804 +07 client backend[295751] pg_regress/updatable_views ERROR:  new row violates check option for view "rw_view1"
2023-08-01 17:01:36.804 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Failing row contains (10, {4,5}).
2023-08-01 17:01:36.804 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  INSERT INTO rw_view1 VALUES (10, ARRAY[4,5]);
2023-08-01 17:01:36.804 +07 client backend[295753] pg_regress/triggers ERROR:  "my_view" is a view
2023-08-01 17:01:36.804 +07 client backend[295753] pg_regress/triggers DETAIL:  Triggers on views cannot have transition tables.
2023-08-01 17:01:36.804 +07 client backend[295753] pg_regress/triggers STATEMENT:  create trigger my_trigger after update on my_view referencing old table as old_table
	   for each statement execute procedure my_trigger_function();
2023-08-01 17:01:36.804 +07 client backend[295751] pg_regress/updatable_views ERROR:  new row violates check option for view "rw_view1"
2023-08-01 17:01:36.804 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Failing row contains (1, {-1,-2,3}).
2023-08-01 17:01:36.804 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  UPDATE rw_view1 SET b[1] = -b[1] WHERE a = 1;
2023-08-01 17:01:36.805 +07 client backend[295751] pg_regress/updatable_views ERROR:  new row violates check option for view "rw_view1"
2023-08-01 17:01:36.805 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Failing row contains (10, {4,5}).
2023-08-01 17:01:36.805 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  EXECUTE ins(10, ARRAY[4,5]);
2023-08-01 17:01:36.806 +07 client backend[295747] pg_regress/inherit ERROR:  constraint "inh_check_constraint" conflicts with NOT VALID constraint on relation "invalid_check_con_child"
2023-08-01 17:01:36.806 +07 client backend[295747] pg_regress/inherit STATEMENT:  alter table invalid_check_con add constraint inh_check_constraint check(f1 > 0);
2023-08-01 17:01:36.806 +07 client backend[295753] pg_regress/triggers ERROR:  "parted_trig" is a table
2023-08-01 17:01:36.806 +07 client backend[295753] pg_regress/triggers DETAIL:  Tables cannot have INSTEAD OF triggers.
2023-08-01 17:01:36.806 +07 client backend[295753] pg_regress/triggers STATEMENT:  create trigger failed instead of update on parted_trig
	  for each row execute procedure trigger_nothing();
2023-08-01 17:01:36.806 +07 client backend[295753] pg_regress/triggers ERROR:  "parted_trig" is a partitioned table
2023-08-01 17:01:36.806 +07 client backend[295753] pg_regress/triggers DETAIL:  Triggers on partitioned tables cannot have transition tables.
2023-08-01 17:01:36.806 +07 client backend[295753] pg_regress/triggers STATEMENT:  create trigger failed after update on parted_trig
	  referencing old table as old_table
	  for each row execute procedure trigger_nothing();
2023-08-01 17:01:36.807 +07 client backend[295747] pg_regress/inherit ERROR:  new row for relation "invalid_check_con" violates check constraint "inh_check_constraint"
2023-08-01 17:01:36.807 +07 client backend[295747] pg_regress/inherit DETAIL:  Failing row contains (0).
2023-08-01 17:01:36.807 +07 client backend[295747] pg_regress/inherit STATEMENT:  insert into invalid_check_con values(0);
2023-08-01 17:01:36.807 +07 client backend[295747] pg_regress/inherit ERROR:  new row for relation "invalid_check_con_child" violates check constraint "inh_check_constraint"
2023-08-01 17:01:36.807 +07 client backend[295747] pg_regress/inherit DETAIL:  Failing row contains (0).
2023-08-01 17:01:36.807 +07 client backend[295747] pg_regress/inherit STATEMENT:  insert into invalid_check_con_child values(0);
2023-08-01 17:01:36.808 +07 client backend[295751] pg_regress/updatable_views ERROR:  new row violates check option for view "rw_view1"
2023-08-01 17:01:36.808 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Failing row contains (15).
2023-08-01 17:01:36.808 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  INSERT INTO rw_view1 VALUES (15);
2023-08-01 17:01:36.808 +07 client backend[295751] pg_regress/updatable_views ERROR:  new row violates check option for view "rw_view1"
2023-08-01 17:01:36.808 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Failing row contains (15).
2023-08-01 17:01:36.808 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  UPDATE rw_view1 SET a = a + 5;
2023-08-01 17:01:36.811 +07 client backend[295751] pg_regress/updatable_views ERROR:  new row violates check option for view "rw_view1"
2023-08-01 17:01:36.811 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Failing row contains (15, 10).
2023-08-01 17:01:36.811 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  INSERT INTO rw_view1 VALUES (15, 20);
2023-08-01 17:01:36.812 +07 client backend[295751] pg_regress/updatable_views ERROR:  new row violates check option for view "rw_view1"
2023-08-01 17:01:36.812 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Failing row contains (20, 10).
2023-08-01 17:01:36.812 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  UPDATE rw_view1 SET a = 20, b = 30;
2023-08-01 17:01:36.812 +07 client backend[295753] pg_regress/triggers ERROR:  cannot drop trigger trg1 on table trigpart1 because trigger trg1 on table trigpart requires it
2023-08-01 17:01:36.812 +07 client backend[295753] pg_regress/triggers HINT:  You can drop trigger trg1 on table trigpart instead.
2023-08-01 17:01:36.812 +07 client backend[295753] pg_regress/triggers STATEMENT:  drop trigger trg1 on trigpart1;
2023-08-01 17:01:36.812 +07 client backend[295753] pg_regress/triggers ERROR:  cannot drop trigger trg1 on table trigpart2 because trigger trg1 on table trigpart requires it
2023-08-01 17:01:36.812 +07 client backend[295753] pg_regress/triggers HINT:  You can drop trigger trg1 on table trigpart instead.
2023-08-01 17:01:36.812 +07 client backend[295753] pg_regress/triggers STATEMENT:  drop trigger trg1 on trigpart2;
2023-08-01 17:01:36.813 +07 client backend[295753] pg_regress/triggers ERROR:  cannot drop trigger trg1 on table trigpart3 because trigger trg1 on table trigpart requires it
2023-08-01 17:01:36.813 +07 client backend[295753] pg_regress/triggers HINT:  You can drop trigger trg1 on table trigpart instead.
2023-08-01 17:01:36.813 +07 client backend[295753] pg_regress/triggers STATEMENT:  drop trigger trg1 on trigpart3;
2023-08-01 17:01:36.815 +07 client backend[295751] pg_regress/updatable_views ERROR:  new row violates check option for view "rw_view2"
2023-08-01 17:01:36.815 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Failing row contains (-5).
2023-08-01 17:01:36.815 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  INSERT INTO rw_view2 VALUES (-5);
2023-08-01 17:01:36.815 +07 client backend[295751] pg_regress/updatable_views ERROR:  new row violates check option for view "rw_view2"
2023-08-01 17:01:36.815 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Failing row contains (-5).
2023-08-01 17:01:36.815 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  UPDATE rw_view2 SET a = a - 10;
2023-08-01 17:01:36.821 +07 client backend[295753] pg_regress/triggers ERROR:  trigger "trg1" for table "trigpart3" does not exist
2023-08-01 17:01:36.821 +07 client backend[295753] pg_regress/triggers STATEMENT:  drop trigger trg1 on trigpart3;
2023-08-01 17:01:36.822 +07 client backend[295753] pg_regress/triggers ERROR:  trigger "trg1" for table "trigpart41" does not exist
2023-08-01 17:01:36.822 +07 client backend[295753] pg_regress/triggers STATEMENT:  drop trigger trg1 on trigpart41;
2023-08-01 17:01:36.830 +07 client backend[295753] pg_regress/triggers ERROR:  trigger "trg1" for relation "trigpart3" already exists
2023-08-01 17:01:36.830 +07 client backend[295753] pg_regress/triggers STATEMENT:  alter table trigpart attach partition trigpart3 FOR VALUES FROM (2000) to (3000);
2023-08-01 17:01:36.838 +07 client backend[295747] pg_regress/inherit ERROR:  cannot inherit from temporary relation "inh_temp_parent"
2023-08-01 17:01:36.838 +07 client backend[295747] pg_regress/inherit STATEMENT:  create table inh_perm_child () inherits (inh_temp_parent);
2023-08-01 17:01:36.874 +07 client backend[295751] pg_regress/updatable_views ERROR:  new row violates check option for view "v1"
2023-08-01 17:01:36.874 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Failing row contains (-2, minus two, 20).
2023-08-01 17:01:36.874 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  INSERT INTO v2 VALUES (-2, 'minus two', 20);
2023-08-01 17:01:36.874 +07 client backend[295751] pg_regress/updatable_views ERROR:  new row violates check option for view "v2"
2023-08-01 17:01:36.874 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Failing row contains (3, three, 30).
2023-08-01 17:01:36.874 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  INSERT INTO v2 VALUES (3, 'three', 30);
2023-08-01 17:01:36.874 +07 client backend[295751] pg_regress/updatable_views ERROR:  new row violates check option for view "v1"
2023-08-01 17:01:36.874 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Failing row contains (-1, ONE, 10).
2023-08-01 17:01:36.874 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  UPDATE v2 SET a = -1 WHERE a = 1;
2023-08-01 17:01:36.874 +07 client backend[295751] pg_regress/updatable_views ERROR:  new row violates check option for view "v2"
2023-08-01 17:01:36.874 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Failing row contains (1, ONE, 30).
2023-08-01 17:01:36.874 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  UPDATE v2 SET c = 30 WHERE a = 1;
2023-08-01 17:01:36.879 +07 client backend[295751] pg_regress/updatable_views ERROR:  new row violates check option for view "v1"
2023-08-01 17:01:36.879 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Failing row contains (-1, invalid).
2023-08-01 17:01:36.879 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  INSERT INTO v1 VALUES (-1, 'invalid');
2023-08-01 17:01:36.881 +07 client backend[295753] pg_regress/triggers ERROR:  moving row to another partition during a BEFORE FOR EACH ROW trigger is not supported
2023-08-01 17:01:36.881 +07 client backend[295753] pg_regress/triggers DETAIL:  Before executing trigger "t", the row was to be in partition "public.parted_1_1".
2023-08-01 17:01:36.881 +07 client backend[295753] pg_regress/triggers STATEMENT:  insert into parted values (1, 1, 'uno uno v2');
2023-08-01 17:01:36.881 +07 client backend[295753] pg_regress/triggers ERROR:  no partition of relation "parted" found for row
2023-08-01 17:01:36.881 +07 client backend[295753] pg_regress/triggers DETAIL:  Partition key of the failing row contains (a) = (2).
2023-08-01 17:01:36.881 +07 client backend[295753] pg_regress/triggers STATEMENT:  update parted set c = c || 'v3';
2023-08-01 17:01:36.881 +07 client backend[295753] pg_regress/triggers ERROR:  moving row to another partition during a BEFORE FOR EACH ROW trigger is not supported
2023-08-01 17:01:36.881 +07 client backend[295753] pg_regress/triggers DETAIL:  Before executing trigger "t", the row was to be in partition "public.parted_1_1".
2023-08-01 17:01:36.881 +07 client backend[295753] pg_regress/triggers STATEMENT:  insert into parted values (1, 1, 'uno uno v4');
2023-08-01 17:01:36.882 +07 client backend[295753] pg_regress/triggers ERROR:  no partition of relation "parted_1" found for row
2023-08-01 17:01:36.882 +07 client backend[295753] pg_regress/triggers DETAIL:  Partition key of the failing row contains (b) = (2).
2023-08-01 17:01:36.882 +07 client backend[295753] pg_regress/triggers STATEMENT:  update parted set c = c || 'v5';
2023-08-01 17:01:36.888 +07 client backend[295751] pg_regress/updatable_views ERROR:  new row violates check option for view "uv_ptv_wco"
2023-08-01 17:01:36.888 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Failing row contains (1, 2, null).
2023-08-01 17:01:36.888 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  insert into uv_ptv_wco values (1, 2);
2023-08-01 17:01:36.892 +07 client backend[295751] pg_regress/updatable_views ERROR:  new row violates check option for view "wcowrtest_v"
2023-08-01 17:01:36.892 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Failing row contains (1).
2023-08-01 17:01:36.892 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  insert into wcowrtest_v values (1);
2023-08-01 17:01:36.896 +07 client backend[295751] pg_regress/updatable_views ERROR:  new row violates check option for view "wcowrtest_v2"
2023-08-01 17:01:36.896 +07 client backend[295751] pg_regress/updatable_views DETAIL:  Failing row contains (2, no such row in sometable).
2023-08-01 17:01:36.896 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  insert into wcowrtest_v2 values (2, 'no such row in sometable');
2023-08-01 17:01:36.898 +07 client backend[295747] pg_regress/inherit ERROR:  new row for relation "errtst_child_fastdef" violates check constraint "errtest_child_fastdef_data_check"
2023-08-01 17:01:36.898 +07 client backend[295747] pg_regress/inherit DETAIL:  Failing row contains (0, 1, 10).
2023-08-01 17:01:36.898 +07 client backend[295747] pg_regress/inherit STATEMENT:  INSERT INTO errtst_parent(partid, shdata, data) VALUES ( '0', '1', '10');
2023-08-01 17:01:36.898 +07 client backend[295747] pg_regress/inherit ERROR:  new row for relation "errtst_child_plaindef" violates check constraint "errtst_child_plaindef_data_check"
2023-08-01 17:01:36.898 +07 client backend[295747] pg_regress/inherit DETAIL:  Failing row contains (10, 1, 10).
2023-08-01 17:01:36.898 +07 client backend[295747] pg_regress/inherit STATEMENT:  INSERT INTO errtst_parent(partid, shdata, data) VALUES ('10', '1', '10');
2023-08-01 17:01:36.898 +07 client backend[295747] pg_regress/inherit ERROR:  new row for relation "errtst_child_reorder" violates check constraint "errtst_child_reorder_data_check"
2023-08-01 17:01:36.898 +07 client backend[295747] pg_regress/inherit DETAIL:  Failing row contains (20, 1, 10).
2023-08-01 17:01:36.898 +07 client backend[295747] pg_regress/inherit STATEMENT:  INSERT INTO errtst_parent(partid, shdata, data) VALUES ('20', '1', '10');
2023-08-01 17:01:36.898 +07 client backend[295747] pg_regress/inherit ERROR:  null value in column "data" of relation "errtst_child_fastdef" violates not-null constraint
2023-08-01 17:01:36.898 +07 client backend[295747] pg_regress/inherit DETAIL:  Failing row contains (0, 1, null).
2023-08-01 17:01:36.898 +07 client backend[295747] pg_regress/inherit STATEMENT:  INSERT INTO errtst_parent(partid, shdata, data) VALUES ( '0', '1', NULL);
2023-08-01 17:01:36.898 +07 client backend[295747] pg_regress/inherit ERROR:  null value in column "data" of relation "errtst_child_plaindef" violates not-null constraint
2023-08-01 17:01:36.898 +07 client backend[295747] pg_regress/inherit DETAIL:  Failing row contains (10, 1, null).
2023-08-01 17:01:36.898 +07 client backend[295747] pg_regress/inherit STATEMENT:  INSERT INTO errtst_parent(partid, shdata, data) VALUES ('10', '1', NULL);
2023-08-01 17:01:36.898 +07 client backend[295747] pg_regress/inherit ERROR:  null value in column "data" of relation "errtst_child_reorder" violates not-null constraint
2023-08-01 17:01:36.898 +07 client backend[295747] pg_regress/inherit DETAIL:  Failing row contains (20, 1, null).
2023-08-01 17:01:36.898 +07 client backend[295747] pg_regress/inherit STATEMENT:  INSERT INTO errtst_parent(partid, shdata, data) VALUES ('20', '1', NULL);
2023-08-01 17:01:36.898 +07 client backend[295747] pg_regress/inherit ERROR:  new row for relation "errtst_child_fastdef" violates check constraint "shdata_small"
2023-08-01 17:01:36.898 +07 client backend[295747] pg_regress/inherit DETAIL:  Failing row contains (0, 5, 5).
2023-08-01 17:01:36.898 +07 client backend[295747] pg_regress/inherit STATEMENT:  INSERT INTO errtst_parent(partid, shdata, data) VALUES ( '0', '5', '5');
2023-08-01 17:01:36.898 +07 client backend[295747] pg_regress/inherit ERROR:  new row for relation "errtst_child_plaindef" violates check constraint "shdata_small"
2023-08-01 17:01:36.898 +07 client backend[295747] pg_regress/inherit DETAIL:  Failing row contains (10, 5, 5).
2023-08-01 17:01:36.898 +07 client backend[295747] pg_regress/inherit STATEMENT:  INSERT INTO errtst_parent(partid, shdata, data) VALUES ('10', '5', '5');
2023-08-01 17:01:36.899 +07 client backend[295747] pg_regress/inherit ERROR:  new row for relation "errtst_child_reorder" violates check constraint "shdata_small"
2023-08-01 17:01:36.899 +07 client backend[295747] pg_regress/inherit DETAIL:  Failing row contains (20, 5, 5).
2023-08-01 17:01:36.899 +07 client backend[295747] pg_regress/inherit STATEMENT:  INSERT INTO errtst_parent(partid, shdata, data) VALUES ('20', '5', '5');
2023-08-01 17:01:36.899 +07 client backend[295747] pg_regress/inherit ERROR:  new row for relation "errtst_child_fastdef" violates check constraint "errtest_child_fastdef_data_check"
2023-08-01 17:01:36.899 +07 client backend[295747] pg_regress/inherit DETAIL:  Failing row contains (0, 1, 15).
2023-08-01 17:01:36.899 +07 client backend[295747] pg_regress/inherit STATEMENT:  UPDATE errtst_parent SET data = data + 10 WHERE partid = 0;
2023-08-01 17:01:36.899 +07 client backend[295747] pg_regress/inherit ERROR:  new row for relation "errtst_child_plaindef" violates check constraint "errtst_child_plaindef_data_check"
2023-08-01 17:01:36.899 +07 client backend[295747] pg_regress/inherit DETAIL:  Failing row contains (10, 1, 15).
2023-08-01 17:01:36.899 +07 client backend[295747] pg_regress/inherit STATEMENT:  UPDATE errtst_parent SET data = data + 10 WHERE partid = 10;
2023-08-01 17:01:36.899 +07 client backend[295747] pg_regress/inherit ERROR:  new row for relation "errtst_child_reorder" violates check constraint "errtst_child_reorder_data_check"
2023-08-01 17:01:36.899 +07 client backend[295747] pg_regress/inherit DETAIL:  Failing row contains (15, 1, 20).
2023-08-01 17:01:36.899 +07 client backend[295747] pg_regress/inherit STATEMENT:  UPDATE errtst_parent SET data = data + 10 WHERE partid = 20;
2023-08-01 17:01:36.900 +07 client backend[295747] pg_regress/inherit ERROR:  new row for relation "errtst_child_fastdef" violates partition constraint
2023-08-01 17:01:36.900 +07 client backend[295747] pg_regress/inherit DETAIL:  Failing row contains (10, 1, 5).
2023-08-01 17:01:36.900 +07 client backend[295747] pg_regress/inherit STATEMENT:  UPDATE errtst_child_fastdef SET partid = partid + 10 WHERE partid = 0;
2023-08-01 17:01:36.900 +07 client backend[295747] pg_regress/inherit ERROR:  new row for relation "errtst_child_plaindef" violates partition constraint
2023-08-01 17:01:36.900 +07 client backend[295747] pg_regress/inherit DETAIL:  Failing row contains (20, 1, 5).
2023-08-01 17:01:36.900 +07 client backend[295747] pg_regress/inherit STATEMENT:  UPDATE errtst_child_plaindef SET partid = partid + 10 WHERE partid = 10;
2023-08-01 17:01:36.900 +07 client backend[295747] pg_regress/inherit ERROR:  new row for relation "errtst_child_reorder" violates partition constraint
2023-08-01 17:01:36.900 +07 client backend[295747] pg_regress/inherit DETAIL:  Failing row contains (5, 1, 30).
2023-08-01 17:01:36.900 +07 client backend[295747] pg_regress/inherit STATEMENT:  UPDATE errtst_child_reorder SET partid = partid + 10 WHERE partid = 20;
2023-08-01 17:01:36.901 +07 client backend[295747] pg_regress/inherit ERROR:  new row for relation "errtst_child_plaindef" violates check constraint "errtst_child_plaindef_data_check"
2023-08-01 17:01:36.901 +07 client backend[295747] pg_regress/inherit DETAIL:  Failing row contains (10, 1, 15).
2023-08-01 17:01:36.901 +07 client backend[295747] pg_regress/inherit STATEMENT:  UPDATE errtst_parent SET partid = 10, data = data + 10 WHERE partid = 0;
2023-08-01 17:01:36.901 +07 client backend[295747] pg_regress/inherit ERROR:  new row for relation "errtst_child_reorder" violates check constraint "errtst_child_reorder_data_check"
2023-08-01 17:01:36.901 +07 client backend[295747] pg_regress/inherit DETAIL:  Failing row contains (20, 1, 15).
2023-08-01 17:01:36.901 +07 client backend[295747] pg_regress/inherit STATEMENT:  UPDATE errtst_parent SET partid = 20, data = data + 10 WHERE partid = 10;
2023-08-01 17:01:36.901 +07 client backend[295747] pg_regress/inherit ERROR:  new row for relation "errtst_child_fastdef" violates check constraint "errtest_child_fastdef_data_check"
2023-08-01 17:01:36.901 +07 client backend[295747] pg_regress/inherit DETAIL:  Failing row contains (0, 1, 15).
2023-08-01 17:01:36.901 +07 client backend[295747] pg_regress/inherit STATEMENT:  UPDATE errtst_parent SET partid = 0, data = data + 10 WHERE partid = 20;
2023-08-01 17:01:36.901 +07 client backend[295747] pg_regress/inherit ERROR:  no partition of relation "errtst_parent" found for row
2023-08-01 17:01:36.901 +07 client backend[295747] pg_regress/inherit DETAIL:  Partition key of the failing row contains (partid) = (30).
2023-08-01 17:01:36.901 +07 client backend[295747] pg_regress/inherit STATEMENT:  UPDATE errtst_parent SET partid = 30, data = data + 10 WHERE partid = 20;
2023-08-01 17:01:36.905 +07 client backend[295753] pg_regress/triggers ERROR:  moving row to another partition during a BEFORE FOR EACH ROW trigger is not supported
2023-08-01 17:01:36.905 +07 client backend[295753] pg_regress/triggers DETAIL:  Before executing trigger "t", the row was to be in partition "public.parted_1".
2023-08-01 17:01:36.905 +07 client backend[295753] pg_regress/triggers STATEMENT:  insert into parted values (1, 1, 'one fail');
2023-08-01 17:01:36.905 +07 client backend[295753] pg_regress/triggers ERROR:  moving row to another partition during a BEFORE FOR EACH ROW trigger is not supported
2023-08-01 17:01:36.905 +07 client backend[295753] pg_regress/triggers DETAIL:  Before executing trigger "t", the row was to be in partition "public.parted_2".
2023-08-01 17:01:36.905 +07 client backend[295753] pg_regress/triggers STATEMENT:  insert into parted values (1, 2, 'two fail');
2023-08-01 17:01:36.908 +07 client backend[295751] pg_regress/updatable_views ERROR:  cannot insert into column "cc" of view "uv_iocu_view"
2023-08-01 17:01:36.908 +07 client backend[295751] pg_regress/updatable_views DETAIL:  View columns that are not columns of their base relation are not updatable.
2023-08-01 17:01:36.908 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  insert into uv_iocu_view (aa) values (1)
	   on conflict (aa) do update set cc = 'XXX';
2023-08-01 17:01:36.913 +07 client backend[295751] pg_regress/updatable_views ERROR:  permission denied for view rw_view1
2023-08-01 17:01:36.913 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  insert into rw_view1 values ('yyy',2.0,1)
	  on conflict (aa) do update set bb = excluded.cc;
2023-08-01 17:01:36.913 +07 client backend[295751] pg_regress/updatable_views ERROR:  permission denied for view rw_view1
2023-08-01 17:01:36.913 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  insert into rw_view1 values ('yyy',2.0,1)
	  on conflict (aa) do update set bb = rw_view1.cc;
2023-08-01 17:01:36.913 +07 client backend[295751] pg_regress/updatable_views ERROR:  permission denied for view rw_view1
2023-08-01 17:01:36.913 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  insert into rw_view1 values ('zzz',2.0,1)
	  on conflict (aa) do update set cc = 3.0;
2023-08-01 17:01:36.915 +07 client backend[295751] pg_regress/updatable_views ERROR:  permission denied for table base_tbl
2023-08-01 17:01:36.915 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  insert into rw_view2 (aa,bb) values (1,'xxx')
	  on conflict (aa) do update set bb = excluded.bb;
2023-08-01 17:01:36.916 +07 client backend[295751] pg_regress/updatable_views ERROR:  permission denied for view rw_view1
2023-08-01 17:01:36.916 +07 client backend[295751] pg_regress/updatable_views STATEMENT:  insert into rw_view4 (aa,bb) values (1,'yyy')
	  on conflict (aa) do update set bb = excluded.bb;
2023-08-01 17:01:37.029 +07 client backend[295753] pg_regress/triggers ERROR:  ROW triggers with transition tables are not supported on partitions
2023-08-01 17:01:37.029 +07 client backend[295753] pg_regress/triggers STATEMENT:  create trigger child_row_trig
	  after insert on child referencing new table as new_table
	  for each row execute procedure dump_insert();
2023-08-01 17:01:37.030 +07 client backend[295753] pg_regress/triggers ERROR:  trigger "child_row_trig" prevents table "child" from becoming a partition
2023-08-01 17:01:37.030 +07 client backend[295753] pg_regress/triggers DETAIL:  ROW triggers with transition tables are not supported on partitions
2023-08-01 17:01:37.030 +07 client backend[295753] pg_regress/triggers STATEMENT:  alter table parent attach partition child for values in ('AAA');
2023-08-01 17:01:37.059 +07 client backend[295753] pg_regress/triggers ERROR:  ROW triggers with transition tables are not supported on inheritance children
2023-08-01 17:01:37.059 +07 client backend[295753] pg_regress/triggers STATEMENT:  create trigger child_row_trig
	  after insert on child referencing new table as new_table
	  for each row execute procedure dump_insert();
2023-08-01 17:01:37.060 +07 client backend[295753] pg_regress/triggers ERROR:  trigger "child_row_trig" prevents table "child" from becoming an inheritance child
2023-08-01 17:01:37.060 +07 client backend[295753] pg_regress/triggers DETAIL:  ROW triggers with transition tables are not supported in inheritance hierarchies.
2023-08-01 17:01:37.060 +07 client backend[295753] pg_regress/triggers STATEMENT:  alter table child inherit parent;
2023-08-01 17:01:37.089 +07 client backend[295753] pg_regress/triggers ERROR:  transition tables cannot be specified for triggers with more than one event
2023-08-01 17:01:37.089 +07 client backend[295753] pg_regress/triggers STATEMENT:  create trigger my_table_multievent_trig
	  after insert or update on my_table referencing new table as new_table
	  for each statement execute procedure dump_insert();
2023-08-01 17:01:37.089 +07 client backend[295753] pg_regress/triggers ERROR:  transition tables cannot be specified for triggers with column lists
2023-08-01 17:01:37.089 +07 client backend[295753] pg_regress/triggers STATEMENT:  create trigger my_table_col_update_trig
	  after update of b on my_table referencing new table as new_table
	  for each statement execute procedure dump_insert();
2023-08-01 17:01:37.223 +07 client backend[295825] pg_regress/select_implicit ERROR:  column "test_missing_target.b" must appear in the GROUP BY clause or be used in an aggregate function at character 62
2023-08-01 17:01:37.223 +07 client backend[295825] pg_regress/select_implicit STATEMENT:  SELECT count(*) FROM test_missing_target GROUP BY a ORDER BY b;
2023-08-01 17:01:37.224 +07 client backend[295825] pg_regress/select_implicit ERROR:  GROUP BY position 3 is not in select list at character 54
2023-08-01 17:01:37.224 +07 client backend[295825] pg_regress/select_implicit STATEMENT:  SELECT c, count(*) FROM test_missing_target GROUP BY 3;
2023-08-01 17:01:37.224 +07 client backend[295825] pg_regress/select_implicit ERROR:  column reference "b" is ambiguous at character 105
2023-08-01 17:01:37.224 +07 client backend[295825] pg_regress/select_implicit STATEMENT:  SELECT count(*) FROM test_missing_target x, test_missing_target y
		WHERE x.a = y.a
		GROUP BY b ORDER BY b;
2023-08-01 17:01:37.226 +07 client backend[295829] pg_regress/delete ERROR:  invalid reference to FROM-clause entry for table "delete_test" at character 34
2023-08-01 17:01:37.226 +07 client backend[295829] pg_regress/delete HINT:  Perhaps you meant to reference the table alias "dt".
2023-08-01 17:01:37.226 +07 client backend[295829] pg_regress/delete STATEMENT:  DELETE FROM delete_test dt WHERE delete_test.a > 25;
2023-08-01 17:01:37.227 +07 client backend[295825] pg_regress/select_implicit ERROR:  column "test_missing_target.b" must appear in the GROUP BY clause or be used in an aggregate function at character 62
2023-08-01 17:01:37.227 +07 client backend[295825] pg_regress/select_implicit STATEMENT:  SELECT count(a) FROM test_missing_target GROUP BY a ORDER BY b;
2023-08-01 17:01:37.227 +07 client backend[295831] pg_regress/prepared_xacts ERROR:  transaction identifier "foo3" is already in use
2023-08-01 17:01:37.227 +07 client backend[295831] pg_regress/prepared_xacts STATEMENT:  PREPARE TRANSACTION 'foo3';
2023-08-01 17:01:37.227 +07 client backend[295833] pg_regress/arrays ERROR:  value too long for type character(5)
2023-08-01 17:01:37.227 +07 client backend[295833] pg_regress/arrays STATEMENT:  INSERT INTO arrtest (f)
	   VALUES ('{"too long"}');
2023-08-01 17:01:37.228 +07 client backend[295825] pg_regress/select_implicit ERROR:  column reference "b" is ambiguous at character 109
2023-08-01 17:01:37.228 +07 client backend[295825] pg_regress/select_implicit STATEMENT:  SELECT count(x.a) FROM test_missing_target x, test_missing_target y
		WHERE x.a = y.a
		GROUP BY b/2 ORDER BY b/2;
2023-08-01 17:01:37.228 +07 client backend[295831] pg_regress/prepared_xacts ERROR:  could not serialize access due to read/write dependencies among transactions
2023-08-01 17:01:37.228 +07 client backend[295831] pg_regress/prepared_xacts DETAIL:  Reason code: Canceled on identification as a pivot, during write.
2023-08-01 17:01:37.228 +07 client backend[295831] pg_regress/prepared_xacts HINT:  The transaction might succeed if retried.
2023-08-01 17:01:37.228 +07 client backend[295831] pg_regress/prepared_xacts STATEMENT:  INSERT INTO pxtest1 VALUES ('fff');
2023-08-01 17:01:37.228 +07 client backend[295825] pg_regress/select_implicit ERROR:  column reference "b" is ambiguous at character 14
2023-08-01 17:01:37.228 +07 client backend[295825] pg_regress/select_implicit STATEMENT:  SELECT count(b) FROM test_missing_target x, test_missing_target y
		WHERE x.a = y.a
		GROUP BY x.b/2;
2023-08-01 17:01:37.229 +07 client backend[295826] pg_regress/select_distinct_on ERROR:  SELECT DISTINCT ON expressions must match initial ORDER BY expressions at character 30
2023-08-01 17:01:37.229 +07 client backend[295826] pg_regress/select_distinct_on STATEMENT:  SELECT DISTINCT ON (string4, ten) string4, two, ten
	   FROM tmp
	   ORDER BY string4 using <, two using <, ten using <;
2023-08-01 17:01:37.230 +07 client backend[295828] pg_regress/join ERROR:  column reference "i" is ambiguous at character 21
2023-08-01 17:01:37.230 +07 client backend[295828] pg_regress/join STATEMENT:  SELECT '' AS "xxx", i, k, t
	  FROM J1_TBL CROSS JOIN J2_TBL;
2023-08-01 17:01:37.230 +07 client backend[295821] pg_regress/select_having ERROR:  column "test_having.a" must appear in the GROUP BY clause or be used in an aggregate function at character 8
2023-08-01 17:01:37.230 +07 client backend[295821] pg_regress/select_having STATEMENT:  SELECT a FROM test_having HAVING min(a) < max(a);
2023-08-01 17:01:37.230 +07 client backend[295821] pg_regress/select_having ERROR:  column "test_having.a" must appear in the GROUP BY clause or be used in an aggregate function at character 41
2023-08-01 17:01:37.230 +07 client backend[295821] pg_regress/select_having STATEMENT:  SELECT 1 AS one FROM test_having HAVING a > 1;
2023-08-01 17:01:37.232 +07 client backend[295833] pg_regress/arrays ERROR:  number of array dimensions (7) exceeds the maximum allowed (6)
2023-08-01 17:01:37.232 +07 client backend[295833] pg_regress/arrays STATEMENT:  SELECT ('{}'::int[])[1][2][3][4][5][6][7];
2023-08-01 17:01:37.232 +07 client backend[295824] pg_regress/case ERROR:  division by zero
2023-08-01 17:01:37.232 +07 client backend[295824] pg_regress/case STATEMENT:  SELECT CASE WHEN i > 100 THEN 1/0 ELSE 0 END FROM case_tbl;
2023-08-01 17:01:37.232 +07 client backend[295816] pg_regress/select_into ERROR:  permission denied for table tmp1
2023-08-01 17:01:37.232 +07 client backend[295816] pg_regress/select_into STATEMENT:  SELECT * INTO TABLE selinto_schema.tmp1
		  FROM pg_class WHERE relname like '%a%';
2023-08-01 17:01:37.232 +07 client backend[295833] pg_regress/arrays ERROR:  array subscript in assignment must not be null
2023-08-01 17:01:37.232 +07 client backend[295833] pg_regress/arrays STATEMENT:  UPDATE arrtest
	  SET c[NULL] = '{"can''t assign"}'
	  WHERE array_dims(c) is not null;
2023-08-01 17:01:37.232 +07 client backend[295833] pg_regress/arrays ERROR:  array subscript in assignment must not be null
2023-08-01 17:01:37.232 +07 client backend[295833] pg_regress/arrays STATEMENT:  UPDATE arrtest
	  SET c[NULL:1] = '{"can''t assign"}'
	  WHERE array_dims(c) is not null;
2023-08-01 17:01:37.232 +07 client backend[295833] pg_regress/arrays ERROR:  array subscript in assignment must not be null
2023-08-01 17:01:37.232 +07 client backend[295833] pg_regress/arrays STATEMENT:  UPDATE arrtest
	  SET c[1:NULL] = '{"can''t assign"}'
	  WHERE array_dims(c) is not null;
2023-08-01 17:01:37.233 +07 client backend[295823] pg_regress/union ERROR:  FOR NO KEY UPDATE is not allowed with UNION/INTERSECT/EXCEPT
2023-08-01 17:01:37.233 +07 client backend[295823] pg_regress/union STATEMENT:  SELECT q1 FROM int8_tbl EXCEPT ALL SELECT q1 FROM int8_tbl FOR NO KEY UPDATE;
2023-08-01 17:01:37.234 +07 client backend[295831] pg_regress/prepared_xacts ERROR:  cursor "foo" does not exist
2023-08-01 17:01:37.234 +07 client backend[295831] pg_regress/prepared_xacts STATEMENT:  FETCH 1 FROM foo;
2023-08-01 17:01:37.234 +07 client backend[295831] pg_regress/prepared_xacts ERROR:  relation "pxtest2" does not exist at character 15
2023-08-01 17:01:37.234 +07 client backend[295831] pg_regress/prepared_xacts STATEMENT:  SELECT * FROM pxtest2;
2023-08-01 17:01:37.235 +07 client backend[295816] pg_regress/select_into ERROR:  permission denied for table tmp2
2023-08-01 17:01:37.235 +07 client backend[295816] pg_regress/select_into STATEMENT:  SELECT oid AS clsoid, relname, relnatts + 10 AS x
		  INTO selinto_schema.tmp2
		  FROM pg_class WHERE relname like '%b%';
2023-08-01 17:01:37.235 +07 client backend[295830] pg_regress/namespace ERROR:  schema "test_ns_schema_renamed" already exists
2023-08-01 17:01:37.235 +07 client backend[295830] pg_regress/namespace STATEMENT:  CREATE SCHEMA test_ns_schema_renamed;
2023-08-01 17:01:37.235 +07 client backend[295831] pg_regress/prepared_xacts ERROR:  could not obtain lock on relation "pxtest3"
2023-08-01 17:01:37.235 +07 client backend[295831] pg_regress/prepared_xacts STATEMENT:  lock table pxtest3 in access share mode nowait;
2023-08-01 17:01:37.236 +07 client backend[295830] pg_regress/namespace ERROR:  CREATE SCHEMA IF NOT EXISTS cannot include schema elements at character 60
2023-08-01 17:01:37.236 +07 client backend[295830] pg_regress/namespace STATEMENT:  CREATE SCHEMA IF NOT EXISTS test_ns_schema_renamed 
	       CREATE TABLE abc (
	              a serial,
	              b int UNIQUE
	       );
2023-08-01 17:01:37.237 +07 client backend[295816] pg_regress/select_into ERROR:  permission denied for table tmp3
2023-08-01 17:01:37.237 +07 client backend[295816] pg_regress/select_into STATEMENT:  CREATE TABLE selinto_schema.tmp3 (a,b,c)
		   AS SELECT oid,relname,relacl FROM pg_class
		   WHERE relname like '%c%';
2023-08-01 17:01:37.237 +07 client backend[295836] pg_regress/update ERROR:  column "a" is of type integer but expression is of type record at character 28
2023-08-01 17:01:37.237 +07 client backend[295836] pg_regress/update HINT:  You will need to rewrite or cast the expression.
2023-08-01 17:01:37.237 +07 client backend[295836] pg_regress/update STATEMENT:  UPDATE update_test SET a = v.* FROM (VALUES(100, 20)) AS v(i, j)
	  WHERE update_test.b = v.j;
2023-08-01 17:01:37.238 +07 client backend[295833] pg_regress/arrays ERROR:  source array too small
2023-08-01 17:01:37.238 +07 client backend[295833] pg_regress/arrays STATEMENT:  UPDATE arrtest_s SET a[:] = '{23, 24, 25}';
2023-08-01 17:01:37.239 +07 client backend[295833] pg_regress/arrays ERROR:  array slice subscript must provide both boundaries
2023-08-01 17:01:37.239 +07 client backend[295833] pg_regress/arrays DETAIL:  When assigning to a slice of an empty array value, slice boundaries must be fully specified.
2023-08-01 17:01:37.239 +07 client backend[295833] pg_regress/arrays STATEMENT:  UPDATE arrtest_s SET a[:] = '{11, 12, 13, 14, 15}';
2023-08-01 17:01:37.239 +07 client backend[295833] pg_regress/arrays ERROR:  slices of fixed-length arrays not implemented
2023-08-01 17:01:37.239 +07 client backend[295833] pg_regress/arrays STATEMENT:  SELECT f1[0:1] FROM POINT_TBL;
2023-08-01 17:01:37.240 +07 client backend[295833] pg_regress/arrays ERROR:  slices of fixed-length arrays not implemented
2023-08-01 17:01:37.240 +07 client backend[295833] pg_regress/arrays STATEMENT:  SELECT f1[0:] FROM POINT_TBL;
2023-08-01 17:01:37.240 +07 client backend[295833] pg_regress/arrays ERROR:  slices of fixed-length arrays not implemented
2023-08-01 17:01:37.240 +07 client backend[295833] pg_regress/arrays STATEMENT:  SELECT f1[:1] FROM POINT_TBL;
2023-08-01 17:01:37.240 +07 client backend[295833] pg_regress/arrays ERROR:  slices of fixed-length arrays not implemented
2023-08-01 17:01:37.240 +07 client backend[295833] pg_regress/arrays STATEMENT:  SELECT f1[:] FROM POINT_TBL;
2023-08-01 17:01:37.241 +07 client backend[295836] pg_regress/update ERROR:  multiple assignments to same column "b"
2023-08-01 17:01:37.241 +07 client backend[295836] pg_regress/update STATEMENT:  UPDATE update_test SET (c,b) = ('car', a+b), b = a + 1 WHERE a = 10;
2023-08-01 17:01:37.241 +07 client backend[295833] pg_regress/arrays ERROR:  array subscript out of range
2023-08-01 17:01:37.241 +07 client backend[295833] pg_regress/arrays STATEMENT:  UPDATE point_tbl SET f1[3] = 10 WHERE f1::text = '(-10,-10)'::point::text RETURNING *;
2023-08-01 17:01:37.242 +07 client backend[295836] pg_regress/update ERROR:  more than one row returned by a subquery used as an expression
2023-08-01 17:01:37.242 +07 client backend[295836] pg_regress/update STATEMENT:  UPDATE update_test SET (b,a) = (select a+1,b from update_test);
2023-08-01 17:01:37.244 +07 client backend[295818] pg_regress/select_distinct LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295818.1", size 163840
2023-08-01 17:01:37.244 +07 client backend[295818] pg_regress/select_distinct STATEMENT:  CREATE TABLE distinct_group_1 AS
	SELECT DISTINCT g%1000 FROM generate_series(0,9999) g;
2023-08-01 17:01:37.244 +07 client backend[295818] pg_regress/select_distinct LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295818.0", size 140000
2023-08-01 17:01:37.244 +07 client backend[295818] pg_regress/select_distinct STATEMENT:  CREATE TABLE distinct_group_1 AS
	SELECT DISTINCT g%1000 FROM generate_series(0,9999) g;
2023-08-01 17:01:37.247 +07 client backend[295836] pg_regress/update ERROR:  source for a multiple-column UPDATE item must be a sub-SELECT or ROW() expression at character 33
2023-08-01 17:01:37.247 +07 client backend[295836] pg_regress/update STATEMENT:  UPDATE update_test SET (a,b) = (v.*) FROM (VALUES(21, 101)) AS v(i, j)
	  WHERE update_test.a = v.i;
2023-08-01 17:01:37.247 +07 client backend[295836] pg_regress/update ERROR:  invalid reference to FROM-clause entry for table "update_test" at character 33
2023-08-01 17:01:37.247 +07 client backend[295836] pg_regress/update HINT:  Perhaps you meant to reference the table alias "t".
2023-08-01 17:01:37.247 +07 client backend[295836] pg_regress/update STATEMENT:  UPDATE update_test AS t SET b = update_test.b + 10 WHERE t.a = 10;
2023-08-01 17:01:37.249 +07 client backend[295816] pg_regress/select_into ERROR:  too many column names were specified
2023-08-01 17:01:37.249 +07 client backend[295816] pg_regress/select_into STATEMENT:  CREATE TABLE ctas_nodata (ii, jj, kk) AS SELECT i, j FROM ctas_base;
2023-08-01 17:01:37.249 +07 client backend[295816] pg_regress/select_into ERROR:  too many column names were specified
2023-08-01 17:01:37.249 +07 client backend[295816] pg_regress/select_into STATEMENT:  CREATE TABLE ctas_nodata (ii, jj, kk) AS SELECT i, j FROM ctas_base WITH NO DATA;
2023-08-01 17:01:37.252 +07 client backend[295833] pg_regress/arrays ERROR:  searching for elements in multidimensional arrays is not supported
2023-08-01 17:01:37.252 +07 client backend[295833] pg_regress/arrays STATEMENT:  SELECT array_position(ARRAY[[1,2],[3,4]], 3);
2023-08-01 17:01:37.253 +07 client backend[295833] pg_regress/arrays ERROR:  searching for elements in multidimensional arrays is not supported
2023-08-01 17:01:37.253 +07 client backend[295833] pg_regress/arrays STATEMENT:  SELECT array_positions(ARRAY[[1,2],[3,4]], 4);
2023-08-01 17:01:37.265 +07 client backend[295833] pg_regress/arrays ERROR:  op ANY/ALL (array) requires operator to yield boolean at character 11
2023-08-01 17:01:37.265 +07 client backend[295833] pg_regress/arrays STATEMENT:  select 33 * any ('{1,2,3}');
2023-08-01 17:01:37.265 +07 client backend[295833] pg_regress/arrays ERROR:  op ANY/ALL (array) requires array on right side at character 11
2023-08-01 17:01:37.265 +07 client backend[295833] pg_regress/arrays STATEMENT:  select 33 * any (44);
2023-08-01 17:01:37.268 +07 client backend[295833] pg_regress/arrays ERROR:  duplicate key value violates unique constraint "arr_tbl_f1_key"
2023-08-01 17:01:37.268 +07 client backend[295833] pg_regress/arrays DETAIL:  Key (f1)=({1,2,3}) already exists.
2023-08-01 17:01:37.268 +07 client backend[295833] pg_regress/arrays STATEMENT:  insert into arr_tbl values ('{1,2,3}');
2023-08-01 17:01:37.269 +07 client backend[295818] pg_regress/select_distinct LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295818.3", size 163840
2023-08-01 17:01:37.269 +07 client backend[295818] pg_regress/select_distinct STATEMENT:  CREATE TABLE distinct_group_2 AS
	SELECT DISTINCT (g%1000)::text FROM generate_series(0,9999) g;
2023-08-01 17:01:37.269 +07 client backend[295818] pg_regress/select_distinct LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295818.2", size 140000
2023-08-01 17:01:37.269 +07 client backend[295818] pg_regress/select_distinct STATEMENT:  CREATE TABLE distinct_group_2 AS
	SELECT DISTINCT (g%1000)::text FROM generate_series(0,9999) g;
2023-08-01 17:01:37.269 +07 client backend[295823] pg_regress/union ERROR:  column "q2" does not exist at character 65
2023-08-01 17:01:37.269 +07 client backend[295823] pg_regress/union HINT:  There is a column named "q2" in table "*SELECT* 2", but it cannot be referenced from this part of the query.
2023-08-01 17:01:37.269 +07 client backend[295823] pg_regress/union STATEMENT:  SELECT q1 FROM int8_tbl EXCEPT SELECT q2 FROM int8_tbl ORDER BY q2 LIMIT 1;
2023-08-01 17:01:37.272 +07 client backend[295833] pg_regress/arrays ERROR:  malformed array literal: "{{1,{2}},{2,3}}" at character 8
2023-08-01 17:01:37.272 +07 client backend[295833] pg_regress/arrays DETAIL:  Unexpected "{" character.
2023-08-01 17:01:37.272 +07 client backend[295833] pg_regress/arrays STATEMENT:  select '{{1,{2}},{2,3}}'::text[];
2023-08-01 17:01:37.272 +07 client backend[295833] pg_regress/arrays ERROR:  malformed array literal: "{{},{}}" at character 8
2023-08-01 17:01:37.272 +07 client backend[295833] pg_regress/arrays DETAIL:  Unexpected "}" character.
2023-08-01 17:01:37.272 +07 client backend[295833] pg_regress/arrays STATEMENT:  select '{{},{}}'::text[];
2023-08-01 17:01:37.272 +07 client backend[295833] pg_regress/arrays ERROR:  malformed array literal: "{{1,2},\{2,3}}" at character 8
2023-08-01 17:01:37.272 +07 client backend[295833] pg_regress/arrays DETAIL:  Unexpected "\" character.
2023-08-01 17:01:37.272 +07 client backend[295833] pg_regress/arrays STATEMENT:  select E'{{1,2},\\{2,3}}'::text[];
2023-08-01 17:01:37.272 +07 client backend[295833] pg_regress/arrays ERROR:  malformed array literal: "{{"1 2" x},{3}}" at character 8
2023-08-01 17:01:37.272 +07 client backend[295833] pg_regress/arrays DETAIL:  Unexpected array element.
2023-08-01 17:01:37.272 +07 client backend[295833] pg_regress/arrays STATEMENT:  select '{{"1 2" x},{3}}'::text[];
2023-08-01 17:01:37.272 +07 client backend[295833] pg_regress/arrays ERROR:  malformed array literal: "{}}" at character 8
2023-08-01 17:01:37.272 +07 client backend[295833] pg_regress/arrays DETAIL:  Junk after closing right brace.
2023-08-01 17:01:37.272 +07 client backend[295833] pg_regress/arrays STATEMENT:  select '{}}'::text[];
2023-08-01 17:01:37.272 +07 client backend[295833] pg_regress/arrays ERROR:  malformed array literal: "{ }}" at character 8
2023-08-01 17:01:37.272 +07 client backend[295833] pg_regress/arrays DETAIL:  Junk after closing right brace.
2023-08-01 17:01:37.272 +07 client backend[295833] pg_regress/arrays STATEMENT:  select '{ }}'::text[];
2023-08-01 17:01:37.272 +07 client backend[295833] pg_regress/arrays ERROR:  cannot determine type of empty array at character 8
2023-08-01 17:01:37.272 +07 client backend[295833] pg_regress/arrays HINT:  Explicitly cast to the desired type, for example ARRAY[]::integer[].
2023-08-01 17:01:37.272 +07 client backend[295833] pg_regress/arrays STATEMENT:  select array[];
2023-08-01 17:01:37.272 +07 client backend[295823] pg_regress/union ERROR:  invalid input syntax for type numeric: "foo" at character 36
2023-08-01 17:01:37.272 +07 client backend[295823] pg_regress/union STATEMENT:  SELECT '3.4'::numeric UNION SELECT 'foo';
2023-08-01 17:01:37.274 +07 client backend[295839] pg_regress/prepared_xacts ERROR:  could not obtain lock on relation "pxtest3"
2023-08-01 17:01:37.274 +07 client backend[295839] pg_regress/prepared_xacts STATEMENT:  lock table pxtest3 in access share mode nowait;
2023-08-01 17:01:37.278 +07 client backend[295818] pg_regress/select_distinct LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295818.5", size 237568
2023-08-01 17:01:37.278 +07 client backend[295818] pg_regress/select_distinct STATEMENT:  CREATE TABLE distinct_hash_1 AS
	SELECT DISTINCT g%1000 FROM generate_series(0,9999) g;
2023-08-01 17:01:37.278 +07 client backend[295818] pg_regress/select_distinct LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295818.4", size 140000
2023-08-01 17:01:37.278 +07 client backend[295818] pg_regress/select_distinct STATEMENT:  CREATE TABLE distinct_hash_1 AS
	SELECT DISTINCT g%1000 FROM generate_series(0,9999) g;
2023-08-01 17:01:37.282 +07 client backend[295816] pg_regress/select_into ERROR:  SELECT ... INTO is not allowed here at character 38
2023-08-01 17:01:37.282 +07 client backend[295816] pg_regress/select_into STATEMENT:  DECLARE foo CURSOR FOR SELECT 1 INTO b;
2023-08-01 17:01:37.282 +07 client backend[295816] pg_regress/select_into ERROR:  COPY (SELECT INTO) is not supported
2023-08-01 17:01:37.282 +07 client backend[295816] pg_regress/select_into STATEMENT:  COPY (SELECT 1 INTO frak UNION SELECT 2) TO 'blob';
2023-08-01 17:01:37.282 +07 client backend[295816] pg_regress/select_into ERROR:  SELECT ... INTO is not allowed here at character 30
2023-08-01 17:01:37.282 +07 client backend[295816] pg_regress/select_into STATEMENT:  SELECT * FROM (SELECT 1 INTO f) bar;
2023-08-01 17:01:37.282 +07 client backend[295816] pg_regress/select_into ERROR:  views must not contain SELECT INTO
2023-08-01 17:01:37.282 +07 client backend[295816] pg_regress/select_into STATEMENT:  CREATE VIEW foo AS SELECT 1 INTO b;
2023-08-01 17:01:37.282 +07 client backend[295816] pg_regress/select_into ERROR:  SELECT ... INTO is not allowed here at character 29
2023-08-01 17:01:37.282 +07 client backend[295816] pg_regress/select_into STATEMENT:  INSERT INTO b SELECT 1 INTO f;
2023-08-01 17:01:37.284 +07 client backend[295833] pg_regress/arrays ERROR:  dimension array or low bound array cannot be null
2023-08-01 17:01:37.284 +07 client backend[295833] pg_regress/arrays STATEMENT:  select array_fill(1, null, array[2,2]);
2023-08-01 17:01:37.284 +07 client backend[295833] pg_regress/arrays ERROR:  dimension array or low bound array cannot be null
2023-08-01 17:01:37.284 +07 client backend[295833] pg_regress/arrays STATEMENT:  select array_fill(1, array[2,2], null);
2023-08-01 17:01:37.284 +07 client backend[295833] pg_regress/arrays ERROR:  wrong number of array subscripts
2023-08-01 17:01:37.284 +07 client backend[295833] pg_regress/arrays DETAIL:  Low bound array has different size than dimensions array.
2023-08-01 17:01:37.284 +07 client backend[295833] pg_regress/arrays STATEMENT:  select array_fill(1, array[2,2], '{}');
2023-08-01 17:01:37.284 +07 client backend[295833] pg_regress/arrays ERROR:  wrong number of array subscripts
2023-08-01 17:01:37.284 +07 client backend[295833] pg_regress/arrays DETAIL:  Low bound array has different size than dimensions array.
2023-08-01 17:01:37.284 +07 client backend[295833] pg_regress/arrays STATEMENT:  select array_fill(1, array[3,3], array[1,1,1]);
2023-08-01 17:01:37.284 +07 client backend[295833] pg_regress/arrays ERROR:  dimension values cannot be null
2023-08-01 17:01:37.284 +07 client backend[295833] pg_regress/arrays STATEMENT:  select array_fill(1, array[1,2,null]);
2023-08-01 17:01:37.284 +07 client backend[295833] pg_regress/arrays ERROR:  wrong number of array subscripts
2023-08-01 17:01:37.284 +07 client backend[295833] pg_regress/arrays DETAIL:  Dimension array must be one dimensional.
2023-08-01 17:01:37.284 +07 client backend[295833] pg_regress/arrays STATEMENT:  select array_fill(1, array[[1,2],[3,4]]);
2023-08-01 17:01:37.287 +07 client backend[295836] pg_regress/update ERROR:  new row for relation "part_c_100_200" violates partition constraint
2023-08-01 17:01:37.287 +07 client backend[295836] pg_regress/update DETAIL:  Failing row contains (105, 85, null, b, 15).
2023-08-01 17:01:37.287 +07 client backend[295836] pg_regress/update STATEMENT:  UPDATE part_c_100_200 set c = c - 20, d = c WHERE c = 105;
2023-08-01 17:01:37.287 +07 client backend[295836] pg_regress/update ERROR:  new row for relation "part_c_1_100" violates partition constraint
2023-08-01 17:01:37.287 +07 client backend[295836] pg_regress/update DETAIL:  Failing row contains (null, 1, 96, 12, a).
2023-08-01 17:01:37.287 +07 client backend[295836] pg_regress/update STATEMENT:  UPDATE part_b_10_b_20 set a = 'a';
2023-08-01 17:01:37.288 +07 client backend[295827] pg_regress/aggregates ERROR:  aggregate functions are not allowed in WHERE at character 114
2023-08-01 17:01:37.288 +07 client backend[295827] pg_regress/aggregates STATEMENT:  select ten, sum(distinct four) from onek a
	group by ten
	having exists (select 1 from onek b
	               where sum(distinct a.four + b.four) = b.four);
2023-08-01 17:01:37.288 +07 client backend[295839] pg_regress/prepared_xacts ERROR:  relation "pxtest3" does not exist at character 15
2023-08-01 17:01:37.288 +07 client backend[295839] pg_regress/prepared_xacts STATEMENT:  SELECT * FROM pxtest3;
2023-08-01 17:01:37.289 +07 client backend[295836] pg_regress/update ERROR:  new row for relation "part_d_1_15" violates partition constraint
2023-08-01 17:01:37.289 +07 client backend[295836] pg_regress/update DETAIL:  Failing row contains (2, 117, 2, b, 7).
2023-08-01 17:01:37.289 +07 client backend[295836] pg_regress/update STATEMENT:  UPDATE part_b_10_b_20 set b = b - 6 WHERE c > 116 returning *;
2023-08-01 17:01:37.290 +07 client backend[295833] pg_regress/arrays ERROR:  cannot accumulate empty arrays
2023-08-01 17:01:37.290 +07 client backend[295833] pg_regress/arrays STATEMENT:  select array_agg('{}'::int[]) from generate_series(1,2);
2023-08-01 17:01:37.290 +07 client backend[295833] pg_regress/arrays ERROR:  cannot accumulate null arrays
2023-08-01 17:01:37.290 +07 client backend[295833] pg_regress/arrays STATEMENT:  select array_agg(null::int[]) from generate_series(1,2);
2023-08-01 17:01:37.290 +07 client backend[295833] pg_regress/arrays ERROR:  cannot accumulate arrays of different dimensionality
2023-08-01 17:01:37.290 +07 client backend[295833] pg_regress/arrays STATEMENT:  select array_agg(ar)
	  from (values ('{1,2}'::int[]), ('{3}'::int[])) v(ar);
2023-08-01 17:01:37.291 +07 client backend[295837] pg_regress/transactions ERROR:  transaction read-write mode must be set before any query
2023-08-01 17:01:37.291 +07 client backend[295837] pg_regress/transactions STATEMENT:  SET TRANSACTION READ WRITE;
2023-08-01 17:01:37.292 +07 client backend[295836] pg_regress/update ERROR:  new row violates check option for view "upview"
2023-08-01 17:01:37.292 +07 client backend[295836] pg_regress/update DETAIL:  Failing row contains (a, 4, 120, 1, 1).
2023-08-01 17:01:37.292 +07 client backend[295836] pg_regress/update STATEMENT:  UPDATE upview set c = 120 WHERE b = 4;
2023-08-01 17:01:37.292 +07 client backend[295833] pg_regress/arrays ERROR:  removing elements from multidimensional arrays is not supported
2023-08-01 17:01:37.292 +07 client backend[295833] pg_regress/arrays STATEMENT:  select array_remove('{{1,2,2},{1,4,3}}', 2);
2023-08-01 17:01:37.292 +07 client backend[295836] pg_regress/update ERROR:  new row violates check option for view "upview"
2023-08-01 17:01:37.292 +07 client backend[295836] pg_regress/update DETAIL:  Failing row contains (b, 15, 120, 1, 1).
2023-08-01 17:01:37.292 +07 client backend[295836] pg_regress/update STATEMENT:  UPDATE upview set a = 'b', b = 15, c = 120 WHERE b = 4;
2023-08-01 17:01:37.293 +07 client backend[295818] pg_regress/select_distinct LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295818.7", size 237568
2023-08-01 17:01:37.293 +07 client backend[295818] pg_regress/select_distinct STATEMENT:  CREATE TABLE distinct_hash_2 AS
	SELECT DISTINCT (g%1000)::text FROM generate_series(0,9999) g;
2023-08-01 17:01:37.293 +07 client backend[295818] pg_regress/select_distinct LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295818.6", size 140000
2023-08-01 17:01:37.293 +07 client backend[295818] pg_regress/select_distinct STATEMENT:  CREATE TABLE distinct_hash_2 AS
	SELECT DISTINCT (g%1000)::text FROM generate_series(0,9999) g;
2023-08-01 17:01:37.295 +07 client backend[295839] pg_regress/prepared_xacts ERROR:  table "pxtest3" does not exist
2023-08-01 17:01:37.295 +07 client backend[295839] pg_regress/prepared_xacts STATEMENT:  DROP TABLE pxtest3;
2023-08-01 17:01:37.305 +07 client backend[295837] pg_regress/transactions ERROR:  cannot set transaction read-write mode inside a read-only transaction
2023-08-01 17:01:37.305 +07 client backend[295837] pg_regress/transactions STATEMENT:  SET TRANSACTION READ WRITE;
2023-08-01 17:01:37.306 +07 client backend[295837] pg_regress/transactions ERROR:  cannot set transaction read-write mode inside a read-only transaction
2023-08-01 17:01:37.306 +07 client backend[295837] pg_regress/transactions STATEMENT:  SET TRANSACTION READ WRITE;
2023-08-01 17:01:37.308 +07 client backend[295838] pg_regress/portals ERROR:  cursor can only scan forward
2023-08-01 17:01:37.308 +07 client backend[295838] pg_regress/portals HINT:  Declare it with SCROLL option to enable backward scan.
2023-08-01 17:01:37.308 +07 client backend[295838] pg_regress/portals STATEMENT:  FETCH BACKWARD 1 FROM foo24;
2023-08-01 17:01:37.308 +07 client backend[295837] pg_regress/transactions ERROR:  cannot execute DROP TABLE in a read-only transaction
2023-08-01 17:01:37.308 +07 client backend[295837] pg_regress/transactions STATEMENT:  DROP TABLE writetest;
2023-08-01 17:01:37.308 +07 client backend[295837] pg_regress/transactions ERROR:  cannot execute INSERT in a read-only transaction
2023-08-01 17:01:37.308 +07 client backend[295837] pg_regress/transactions STATEMENT:  INSERT INTO writetest VALUES (1);
2023-08-01 17:01:37.309 +07 client backend[295837] pg_regress/transactions ERROR:  cannot execute UPDATE in a read-only transaction
2023-08-01 17:01:37.309 +07 client backend[295837] pg_regress/transactions STATEMENT:  EXECUTE test;
2023-08-01 17:01:37.309 +07 client backend[295822] pg_regress/subselect ERROR:  operator does not exist: bigint = text at character 33
2023-08-01 17:01:37.309 +07 client backend[295822] pg_regress/subselect HINT:  No operator matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:37.309 +07 client backend[295822] pg_regress/subselect STATEMENT:  select * from int8_tbl where q1 in (select c1 from inner_text);
2023-08-01 17:01:37.309 +07 client backend[295837] pg_regress/transactions ERROR:  cannot execute CREATE TABLE AS in a read-only transaction
2023-08-01 17:01:37.309 +07 client backend[295837] pg_regress/transactions STATEMENT:  CREATE TABLE test AS SELECT * FROM writetest;
2023-08-01 17:01:37.312 +07 client backend[295828] pg_regress/join ERROR:  column t1.x does not exist at character 8
2023-08-01 17:01:37.312 +07 client backend[295828] pg_regress/join HINT:  Perhaps you meant to reference the column "t3.x".
2023-08-01 17:01:37.312 +07 client backend[295828] pg_regress/join STATEMENT:  select t1.x from t1 join t3 on (t1.a = t3.x);
2023-08-01 17:01:37.316 +07 client backend[295837] pg_regress/transactions ERROR:  relation "trans_bar" does not exist at character 15
2023-08-01 17:01:37.316 +07 client backend[295837] pg_regress/transactions STATEMENT:  SELECT * FROM trans_bar;
2023-08-01 17:01:37.316 +07 client backend[295837] pg_regress/transactions ERROR:  relation "trans_bar" does not exist at character 13
2023-08-01 17:01:37.316 +07 client backend[295837] pg_regress/transactions STATEMENT:  INSERT into trans_bar VALUES (1);
2023-08-01 17:01:37.317 +07 client backend[295838] pg_regress/portals LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295838.0", size 2580000
2023-08-01 17:01:37.317 +07 client backend[295838] pg_regress/portals STATEMENT:  CLOSE foo25;
2023-08-01 17:01:37.318 +07 client backend[295838] pg_regress/portals ERROR:  cursor "foo26" does not exist
2023-08-01 17:01:37.318 +07 client backend[295838] pg_regress/portals STATEMENT:  FETCH FROM foo26;
2023-08-01 17:01:37.318 +07 client backend[295837] pg_regress/transactions ERROR:  column "trans_foo" does not exist at character 8
2023-08-01 17:01:37.318 +07 client backend[295837] pg_regress/transactions STATEMENT:  SELECT trans_foo;
2023-08-01 17:01:37.319 +07 client backend[295837] pg_regress/transactions WARNING:  there is no transaction in progress
2023-08-01 17:01:37.322 +07 client backend[295837] pg_regress/transactions WARNING:  there is no transaction in progress
2023-08-01 17:01:37.322 +07 client backend[295837] pg_regress/transactions ERROR:  column "trans_foo" does not exist at character 8
2023-08-01 17:01:37.322 +07 client backend[295837] pg_regress/transactions STATEMENT:  SELECT trans_foo;
2023-08-01 17:01:37.325 +07 client backend[295837] pg_regress/transactions ERROR:  SAVEPOINT can only be used in transaction blocks
2023-08-01 17:01:37.325 +07 client backend[295837] pg_regress/transactions STATEMENT:  SAVEPOINT one;
2023-08-01 17:01:37.326 +07 client backend[295837] pg_regress/transactions ERROR:  ROLLBACK TO SAVEPOINT can only be used in transaction blocks
2023-08-01 17:01:37.326 +07 client backend[295837] pg_regress/transactions STATEMENT:  ROLLBACK TO SAVEPOINT one;
2023-08-01 17:01:37.326 +07 client backend[295837] pg_regress/transactions ERROR:  RELEASE SAVEPOINT can only be used in transaction blocks
2023-08-01 17:01:37.326 +07 client backend[295837] pg_regress/transactions STATEMENT:  RELEASE SAVEPOINT one;
2023-08-01 17:01:37.326 +07 client backend[295837] pg_regress/transactions ERROR:  division by zero
2023-08-01 17:01:37.326 +07 client backend[295837] pg_regress/transactions STATEMENT:  SELECT 0/0;
2023-08-01 17:01:37.326 +07 client backend[295837] pg_regress/transactions ERROR:  current transaction is aborted, commands ignored until end of transaction block
2023-08-01 17:01:37.326 +07 client backend[295837] pg_regress/transactions STATEMENT:  SAVEPOINT two;
2023-08-01 17:01:37.326 +07 client backend[295837] pg_regress/transactions ERROR:  current transaction is aborted, commands ignored until end of transaction block
2023-08-01 17:01:37.326 +07 client backend[295837] pg_regress/transactions STATEMENT:  RELEASE SAVEPOINT one;
2023-08-01 17:01:37.327 +07 client backend[295837] pg_regress/transactions ERROR:  division by zero
2023-08-01 17:01:37.327 +07 client backend[295837] pg_regress/transactions STATEMENT:  FETCH 10 FROM c;
2023-08-01 17:01:37.327 +07 client backend[295837] pg_regress/transactions ERROR:  portal "c" cannot be run
2023-08-01 17:01:37.327 +07 client backend[295837] pg_regress/transactions STATEMENT:  FETCH 10 FROM c;
2023-08-01 17:01:37.327 +07 client backend[295837] pg_regress/transactions ERROR:  portal "c" cannot be run
2023-08-01 17:01:37.327 +07 client backend[295837] pg_regress/transactions STATEMENT:  FETCH 10 FROM c;
2023-08-01 17:01:37.334 +07 client backend[295837] pg_regress/transactions ERROR:  duplicate key value violates unique constraint "koju_a_key"
2023-08-01 17:01:37.334 +07 client backend[295837] pg_regress/transactions DETAIL:  Key (a)=(1) already exists.
2023-08-01 17:01:37.334 +07 client backend[295837] pg_regress/transactions STATEMENT:  INSERT INTO koju VALUES (1);
2023-08-01 17:01:37.340 +07 client backend[295837] pg_regress/transactions ERROR:  duplicate key value violates unique constraint "koju_a_key"
2023-08-01 17:01:37.340 +07 client backend[295837] pg_regress/transactions DETAIL:  Key (a)=(1) already exists.
2023-08-01 17:01:37.340 +07 client backend[295837] pg_regress/transactions STATEMENT:  INSERT INTO koju VALUES (1);
2023-08-01 17:01:37.345 +07 client backend[295833] pg_regress/arrays ERROR:  function width_bucket(text, integer[]) does not exist at character 8
2023-08-01 17:01:37.345 +07 client backend[295833] pg_regress/arrays HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:37.345 +07 client backend[295833] pg_regress/arrays STATEMENT:  SELECT width_bucket('5'::text, ARRAY[3, 4]::integer[]);
2023-08-01 17:01:37.345 +07 client backend[295833] pg_regress/arrays ERROR:  thresholds array must not contain NULLs
2023-08-01 17:01:37.345 +07 client backend[295833] pg_regress/arrays STATEMENT:  SELECT width_bucket(5, ARRAY[3, 4, NULL]);
2023-08-01 17:01:37.345 +07 client backend[295833] pg_regress/arrays ERROR:  thresholds must be one-dimensional array
2023-08-01 17:01:37.345 +07 client backend[295833] pg_regress/arrays STATEMENT:  SELECT width_bucket(5, ARRAY[ARRAY[1, 2], ARRAY[3, 4]]);
2023-08-01 17:01:37.346 +07 client backend[295827] pg_regress/aggregates ERROR:  aggregate function calls cannot be nested at character 12
2023-08-01 17:01:37.346 +07 client backend[295827] pg_regress/aggregates STATEMENT:  select max(min(unique1)) from tenk1;
2023-08-01 17:01:37.346 +07 client backend[295827] pg_regress/aggregates ERROR:  aggregate function calls cannot be nested at character 20
2023-08-01 17:01:37.346 +07 client backend[295827] pg_regress/aggregates STATEMENT:  select (select max(min(unique1)) from int8_tbl) from tenk1;
2023-08-01 17:01:37.348 +07 client backend[295837] pg_regress/transactions ERROR:  cursor "foo" does not exist
2023-08-01 17:01:37.348 +07 client backend[295837] pg_regress/transactions STATEMENT:  fetch from foo;
2023-08-01 17:01:37.352 +07 client backend[295837] pg_regress/transactions ERROR:  division by zero
2023-08-01 17:01:37.352 +07 client backend[295837] pg_regress/transactions CONTEXT:  PL/pgSQL function invert(double precision) line 1 at RETURN
	SQL statement "INSERT INTO new_table SELECT invert(0.0)"
	PL/pgSQL function create_temp_tab() line 6 at SQL statement
2023-08-01 17:01:37.352 +07 client backend[295837] pg_regress/transactions STATEMENT:  FETCH ctt;
2023-08-01 17:01:37.352 +07 client backend[295837] pg_regress/transactions ERROR:  portal "ctt" cannot be run
2023-08-01 17:01:37.352 +07 client backend[295837] pg_regress/transactions STATEMENT:  FETCH ctt;
2023-08-01 17:01:37.354 +07 client backend[295838] pg_regress/portals ERROR:  cursor can only scan forward
2023-08-01 17:01:37.354 +07 client backend[295838] pg_regress/portals HINT:  Declare it with SCROLL option to enable backward scan.
2023-08-01 17:01:37.354 +07 client backend[295838] pg_regress/portals STATEMENT:  FETCH RELATIVE 0 FROM c1;
2023-08-01 17:01:37.354 +07 client backend[295837] pg_regress/transactions ERROR:  invalid input syntax for type integer: "error" at character 25
2023-08-01 17:01:37.354 +07 client backend[295837] pg_regress/transactions STATEMENT:  INSERT INTO abc VALUES ('error');
2023-08-01 17:01:37.354 +07 client backend[295837] pg_regress/transactions ERROR:  current transaction is aborted, commands ignored until end of transaction block
2023-08-01 17:01:37.354 +07 client backend[295837] pg_regress/transactions STATEMENT:  INSERT INTO abc VALUES (3);
2023-08-01 17:01:37.355 +07 client backend[295837] pg_regress/transactions ERROR:  invalid input syntax for type integer: "error" at character 25
2023-08-01 17:01:37.355 +07 client backend[295837] pg_regress/transactions STATEMENT:  INSERT INTO abc VALUES ('error');
2023-08-01 17:01:37.357 +07 client backend[295837] pg_regress/transactions ERROR:  invalid input syntax for type integer: "error" at character 25
2023-08-01 17:01:37.357 +07 client backend[295837] pg_regress/transactions STATEMENT:  INSERT INTO abc VALUES ('error');
2023-08-01 17:01:37.357 +07 client backend[295837] pg_regress/transactions ERROR:  COMMIT AND CHAIN can only be used in transaction blocks
2023-08-01 17:01:37.357 +07 client backend[295837] pg_regress/transactions STATEMENT:  COMMIT AND CHAIN;
2023-08-01 17:01:37.357 +07 client backend[295837] pg_regress/transactions ERROR:  ROLLBACK AND CHAIN can only be used in transaction blocks
2023-08-01 17:01:37.357 +07 client backend[295837] pg_regress/transactions STATEMENT:  ROLLBACK AND CHAIN;
2023-08-01 17:01:37.358 +07 client backend[295838] pg_regress/portals ERROR:  cursor "c1" is not a simply updatable scan of table "uctest"
2023-08-01 17:01:37.358 +07 client backend[295838] pg_regress/portals STATEMENT:  UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;
2023-08-01 17:01:37.359 +07 client backend[295836] pg_regress/update ERROR:  new row violates row-level security policy for table "range_parted"
2023-08-01 17:01:37.359 +07 client backend[295836] pg_regress/update STATEMENT:  UPDATE range_parted set a = 'b', c = 151 WHERE a = 'a' and c = 200;
2023-08-01 17:01:37.359 +07 client backend[295837] pg_regress/transactions ERROR:  division by zero
2023-08-01 17:01:37.359 +07 client backend[295837] pg_regress/transactions STATEMENT:  insert into i_table values(2); select * from i_table; select 1/0;
2023-08-01 17:01:37.359 +07 client backend[295838] pg_regress/portals ERROR:  cursor "c1" has multiple FOR UPDATE/SHARE references to table "uctest"
2023-08-01 17:01:37.359 +07 client backend[295838] pg_regress/portals STATEMENT:  UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;
2023-08-01 17:01:37.359 +07 client backend[295837] pg_regress/transactions WARNING:  there is no transaction in progress
2023-08-01 17:01:37.360 +07 client backend[295837] pg_regress/transactions WARNING:  there is no transaction in progress
2023-08-01 17:01:37.360 +07 client backend[295837] pg_regress/transactions WARNING:  there is no transaction in progress
2023-08-01 17:01:37.360 +07 client backend[295838] pg_regress/portals ERROR:  cursor "c1" does not exist
2023-08-01 17:01:37.360 +07 client backend[295838] pg_regress/portals STATEMENT:  DELETE FROM uctest WHERE CURRENT OF c1;
2023-08-01 17:01:37.360 +07 client backend[295837] pg_regress/transactions WARNING:  there is no transaction in progress
2023-08-01 17:01:37.360 +07 client backend[295837] pg_regress/transactions ERROR:  division by zero
2023-08-01 17:01:37.360 +07 client backend[295837] pg_regress/transactions STATEMENT:  insert into i_table values(7); commit; insert into i_table values(8); select 1/0;
2023-08-01 17:01:37.361 +07 client backend[295837] pg_regress/transactions WARNING:  there is no transaction in progress
2023-08-01 17:01:37.361 +07 client backend[295838] pg_regress/portals ERROR:  cursor "cx" is held from a previous transaction
2023-08-01 17:01:37.361 +07 client backend[295838] pg_regress/portals STATEMENT:  DELETE FROM uctest WHERE CURRENT OF cx;
2023-08-01 17:01:37.361 +07 client backend[295837] pg_regress/transactions WARNING:  there is no transaction in progress
2023-08-01 17:01:37.361 +07 client backend[295837] pg_regress/transactions ERROR:  VACUUM cannot run inside a transaction block
2023-08-01 17:01:37.361 +07 client backend[295837] pg_regress/transactions STATEMENT:  SELECT 1; VACUUM;
2023-08-01 17:01:37.361 +07 client backend[295838] pg_regress/portals ERROR:  cursor "c" is not a simply updatable scan of table "uctest"
2023-08-01 17:01:37.361 +07 client backend[295838] pg_regress/portals STATEMENT:  DELETE FROM uctest WHERE CURRENT OF c;
2023-08-01 17:01:37.361 +07 client backend[295837] pg_regress/transactions WARNING:  there is no transaction in progress
2023-08-01 17:01:37.361 +07 client backend[295837] pg_regress/transactions ERROR:  VACUUM cannot run inside a transaction block
2023-08-01 17:01:37.361 +07 client backend[295837] pg_regress/transactions STATEMENT:  SELECT 1; COMMIT; VACUUM;
2023-08-01 17:01:37.361 +07 client backend[295837] pg_regress/transactions ERROR:  SAVEPOINT can only be used in transaction blocks
2023-08-01 17:01:37.361 +07 client backend[295837] pg_regress/transactions STATEMENT:  SELECT 1; SAVEPOINT sp;
2023-08-01 17:01:37.361 +07 client backend[295837] pg_regress/transactions WARNING:  there is no transaction in progress
2023-08-01 17:01:37.361 +07 client backend[295837] pg_regress/transactions ERROR:  SAVEPOINT can only be used in transaction blocks
2023-08-01 17:01:37.361 +07 client backend[295837] pg_regress/transactions STATEMENT:  SELECT 1; COMMIT; SAVEPOINT sp;
2023-08-01 17:01:37.361 +07 client backend[295837] pg_regress/transactions ERROR:  ROLLBACK TO SAVEPOINT can only be used in transaction blocks
2023-08-01 17:01:37.361 +07 client backend[295837] pg_regress/transactions STATEMENT:  ROLLBACK TO SAVEPOINT sp; SELECT 2;
2023-08-01 17:01:37.361 +07 client backend[295838] pg_regress/portals ERROR:  cursor "c" does not have a FOR UPDATE/SHARE reference to table "uctest"
2023-08-01 17:01:37.361 +07 client backend[295838] pg_regress/portals STATEMENT:  DELETE FROM uctest WHERE CURRENT OF c;
2023-08-01 17:01:37.361 +07 client backend[295837] pg_regress/transactions ERROR:  RELEASE SAVEPOINT can only be used in transaction blocks
2023-08-01 17:01:37.361 +07 client backend[295837] pg_regress/transactions STATEMENT:  SELECT 2; RELEASE SAVEPOINT sp; SELECT 3;
2023-08-01 17:01:37.361 +07 client backend[295837] pg_regress/transactions ERROR:  COMMIT AND CHAIN can only be used in transaction blocks
2023-08-01 17:01:37.361 +07 client backend[295837] pg_regress/transactions STATEMENT:  SET TRANSACTION READ ONLY; COMMIT AND CHAIN;
2023-08-01 17:01:37.362 +07 client backend[295837] pg_regress/transactions ERROR:  ROLLBACK AND CHAIN can only be used in transaction blocks
2023-08-01 17:01:37.362 +07 client backend[295837] pg_regress/transactions STATEMENT:  SET TRANSACTION READ ONLY; ROLLBACK AND CHAIN;
2023-08-01 17:01:37.362 +07 client backend[295838] pg_regress/portals ERROR:  cursor "c" is not a simply updatable scan of table "tenk1"
2023-08-01 17:01:37.362 +07 client backend[295838] pg_regress/portals STATEMENT:  DELETE FROM tenk1 WHERE CURRENT OF c;
2023-08-01 17:01:37.362 +07 client backend[295838] pg_regress/portals ERROR:  cursor "c" is not a simply updatable scan of table "uctest"
2023-08-01 17:01:37.362 +07 client backend[295838] pg_regress/portals STATEMENT:  DELETE FROM uctest WHERE CURRENT OF c;
2023-08-01 17:01:37.362 +07 client backend[295837] pg_regress/transactions WARNING:  there is no transaction in progress
2023-08-01 17:01:37.362 +07 client backend[295838] pg_regress/portals ERROR:  cursor "c1" is not positioned on a row
2023-08-01 17:01:37.362 +07 client backend[295838] pg_regress/portals STATEMENT:  DELETE FROM uctest WHERE CURRENT OF c1;
2023-08-01 17:01:37.362 +07 client backend[295837] pg_regress/transactions ERROR:  COMMIT AND CHAIN can only be used in transaction blocks
2023-08-01 17:01:37.362 +07 client backend[295837] pg_regress/transactions STATEMENT:  INSERT INTO abc VALUES (7); COMMIT; INSERT INTO abc VALUES (8); COMMIT AND CHAIN;
2023-08-01 17:01:37.362 +07 client backend[295837] pg_regress/transactions WARNING:  there is no transaction in progress
2023-08-01 17:01:37.362 +07 client backend[295837] pg_regress/transactions ERROR:  ROLLBACK AND CHAIN can only be used in transaction blocks
2023-08-01 17:01:37.362 +07 client backend[295837] pg_regress/transactions STATEMENT:  INSERT INTO abc VALUES (9); ROLLBACK; INSERT INTO abc VALUES (10); ROLLBACK AND CHAIN;
2023-08-01 17:01:37.362 +07 client backend[295838] pg_regress/portals ERROR:  FOR UPDATE is not allowed with aggregate functions
2023-08-01 17:01:37.362 +07 client backend[295838] pg_regress/portals STATEMENT:  DECLARE c1 CURSOR FOR SELECT MIN(f1) FROM uctest FOR UPDATE;
2023-08-01 17:01:37.363 +07 client backend[295837] pg_regress/transactions ERROR:  COMMIT AND CHAIN can only be used in transaction blocks
2023-08-01 17:01:37.363 +07 client backend[295837] pg_regress/transactions STATEMENT:  INSERT INTO abc VALUES (11); COMMIT AND CHAIN; INSERT INTO abc VALUES (12); COMMIT;
2023-08-01 17:01:37.363 +07 client backend[295837] pg_regress/transactions ERROR:  ROLLBACK AND CHAIN can only be used in transaction blocks
2023-08-01 17:01:37.363 +07 client backend[295837] pg_regress/transactions STATEMENT:  INSERT INTO abc VALUES (13); ROLLBACK AND CHAIN; INSERT INTO abc VALUES (14); ROLLBACK;
2023-08-01 17:01:37.363 +07 client backend[295837] pg_regress/transactions ERROR:  COMMIT AND CHAIN can only be used in transaction blocks
2023-08-01 17:01:37.363 +07 client backend[295837] pg_regress/transactions STATEMENT:  START TRANSACTION ISOLATION LEVEL REPEATABLE READ; INSERT INTO abc VALUES (17); COMMIT; INSERT INTO abc VALUES (18); COMMIT AND CHAIN;
2023-08-01 17:01:37.364 +07 client backend[295837] pg_regress/transactions ERROR:  ROLLBACK AND CHAIN can only be used in transaction blocks
2023-08-01 17:01:37.364 +07 client backend[295837] pg_regress/transactions STATEMENT:  START TRANSACTION ISOLATION LEVEL REPEATABLE READ; INSERT INTO abc VALUES (19); ROLLBACK; INSERT INTO abc VALUES (20); ROLLBACK AND CHAIN;
2023-08-01 17:01:37.364 +07 client backend[295827] pg_regress/aggregates ERROR:  column "t1.f1" must appear in the GROUP BY clause or be used in an aggregate function at character 8
2023-08-01 17:01:37.364 +07 client backend[295827] pg_regress/aggregates STATEMENT:  select t1.f1 from t1 left join t2 using (f1) group by f1;
2023-08-01 17:01:37.365 +07 client backend[295837] pg_regress/transactions ERROR:  division by zero
2023-08-01 17:01:37.365 +07 client backend[295837] pg_regress/transactions STATEMENT:  select 1/0;
2023-08-01 17:01:37.365 +07 client backend[295838] pg_regress/portals ERROR:  WHERE CURRENT OF on a view is not implemented
2023-08-01 17:01:37.365 +07 client backend[295838] pg_regress/portals STATEMENT:  DELETE FROM ucview WHERE CURRENT OF c1;
2023-08-01 17:01:37.365 +07 client backend[295837] pg_regress/transactions ERROR:  savepoint "x" does not exist
2023-08-01 17:01:37.365 +07 client backend[295837] pg_regress/transactions STATEMENT:  rollback to X;
2023-08-01 17:01:37.374 +07 client backend[295836] pg_regress/update ERROR:  new row violates row-level security policy for table "range_parted"
2023-08-01 17:01:37.374 +07 client backend[295836] pg_regress/update STATEMENT:  UPDATE range_parted set a = 'b', c = 150 WHERE a = 'a' and c = 200;
2023-08-01 17:01:37.379 +07 client backend[295827] pg_regress/aggregates ERROR:  in an aggregate with DISTINCT, ORDER BY expressions must appear in argument list at character 39
2023-08-01 17:01:37.379 +07 client backend[295827] pg_regress/aggregates STATEMENT:  select aggfns(distinct a,b,c order by i)
	  from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;
2023-08-01 17:01:37.379 +07 client backend[295827] pg_regress/aggregates ERROR:  in an aggregate with DISTINCT, ORDER BY expressions must appear in argument list at character 41
2023-08-01 17:01:37.379 +07 client backend[295827] pg_regress/aggregates STATEMENT:  select aggfns(distinct a,b,c order by a,b+1)
	  from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;
2023-08-01 17:01:37.379 +07 client backend[295827] pg_regress/aggregates ERROR:  in an aggregate with DISTINCT, ORDER BY expressions must appear in argument list at character 43
2023-08-01 17:01:37.379 +07 client backend[295827] pg_regress/aggregates STATEMENT:  select aggfns(distinct a,b,c order by a,b,i,c)
	  from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;
2023-08-01 17:01:37.379 +07 client backend[295827] pg_regress/aggregates ERROR:  in an aggregate with DISTINCT, ORDER BY expressions must appear in argument list at character 41
2023-08-01 17:01:37.379 +07 client backend[295827] pg_regress/aggregates STATEMENT:  select aggfns(distinct a,a,c order by a,b)
	  from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;
2023-08-01 17:01:37.380 +07 client backend[295827] pg_regress/aggregates ERROR:  in an aggregate with DISTINCT, ORDER BY expressions must appear in argument list at character 51
2023-08-01 17:01:37.380 +07 client backend[295827] pg_regress/aggregates STATEMENT:  select string_agg(distinct f1::text, ',' order by f1) from varchar_tbl;
2023-08-01 17:01:37.380 +07 client backend[295827] pg_regress/aggregates ERROR:  in an aggregate with DISTINCT, ORDER BY expressions must appear in argument list at character 45
2023-08-01 17:01:37.380 +07 client backend[295827] pg_regress/aggregates STATEMENT:  select string_agg(distinct f1, ',' order by f1::text) from varchar_tbl;
2023-08-01 17:01:37.380 +07 client backend[295836] pg_regress/update ERROR:  new row violates row-level security policy "policy_range_parted_subplan" for table "range_parted"
2023-08-01 17:01:37.380 +07 client backend[295836] pg_regress/update STATEMENT:  UPDATE range_parted set a = 'b', c = 122 WHERE a = 'a' and c = 200;
2023-08-01 17:01:37.393 +07 client backend[295836] pg_regress/update ERROR:  new row violates row-level security policy "policy_range_parted_wholerow" for table "range_parted"
2023-08-01 17:01:37.393 +07 client backend[295836] pg_regress/update STATEMENT:  UPDATE range_parted set a = 'b', c = 116 WHERE a = 'a' and c = 200;
2023-08-01 17:01:37.393 +07 client backend[295827] pg_regress/aggregates ERROR:  cannot use multiple ORDER BY clauses with WITHIN GROUP at character 41
2023-08-01 17:01:37.393 +07 client backend[295827] pg_regress/aggregates STATEMENT:  select p, percentile_cont(p order by p) within group (order by x)  
	from generate_series(1,5) x,
	     (values (0::float8),(0.1),(0.25),(0.4),(0.5),(0.6),(0.75),(0.9),(1)) v(p)
	group by p order by p;
2023-08-01 17:01:37.393 +07 client backend[295827] pg_regress/aggregates ERROR:  sum is not an ordered-set aggregate, so it cannot have WITHIN GROUP at character 11
2023-08-01 17:01:37.393 +07 client backend[295827] pg_regress/aggregates STATEMENT:  select p, sum() within group (order by x::float8)  
	from generate_series(1,5) x,
	     (values (0::float8),(0.1),(0.25),(0.4),(0.5),(0.6),(0.75),(0.9),(1)) v(p)
	group by p order by p;
2023-08-01 17:01:37.393 +07 client backend[295827] pg_regress/aggregates ERROR:  WITHIN GROUP is required for ordered-set aggregate percentile_cont at character 11
2023-08-01 17:01:37.393 +07 client backend[295827] pg_regress/aggregates STATEMENT:  select p, percentile_cont(p,p)  
	from generate_series(1,5) x,
	     (values (0::float8),(0.1),(0.25),(0.4),(0.5),(0.6),(0.75),(0.9),(1)) v(p)
	group by p order by p;
2023-08-01 17:01:37.410 +07 client backend[295827] pg_regress/aggregates ERROR:  column "x.x" must appear in the GROUP BY clause or be used in an aggregate function at character 13
2023-08-01 17:01:37.410 +07 client backend[295827] pg_regress/aggregates DETAIL:  Direct arguments of an ordered-set aggregate must use only grouped columns.
2023-08-01 17:01:37.410 +07 client backend[295827] pg_regress/aggregates STATEMENT:  select rank(x) within group (order by x) from generate_series(1,5) x;
2023-08-01 17:01:37.410 +07 client backend[295827] pg_regress/aggregates ERROR:  outer-level aggregate cannot contain a lower-level variable in its direct arguments at character 37
2023-08-01 17:01:37.410 +07 client backend[295827] pg_regress/aggregates STATEMENT:  select array(select percentile_disc(a) within group (order by x)
	               from (values (0.3),(0.7)) v(a) group by a)
	  from generate_series(1,5) g(x);
2023-08-01 17:01:37.410 +07 client backend[295827] pg_regress/aggregates ERROR:  aggregate function calls cannot be nested at character 13
2023-08-01 17:01:37.410 +07 client backend[295827] pg_regress/aggregates STATEMENT:  select rank(sum(x)) within group (order by x) from generate_series(1,5) x;
2023-08-01 17:01:37.411 +07 client backend[295827] pg_regress/aggregates ERROR:  WITHIN GROUP types text and integer cannot be matched at character 13
2023-08-01 17:01:37.411 +07 client backend[295827] pg_regress/aggregates STATEMENT:  select rank(3) within group (order by x) from (values ('fred'),('jim')) v(x);
2023-08-01 17:01:37.411 +07 client backend[295827] pg_regress/aggregates ERROR:  function rank(integer, name, name) does not exist at character 8
2023-08-01 17:01:37.411 +07 client backend[295827] pg_regress/aggregates HINT:  To use the hypothetical-set aggregate rank, the number of hypothetical direct arguments (here 1) must match the number of ordering columns (here 2).
2023-08-01 17:01:37.411 +07 client backend[295827] pg_regress/aggregates STATEMENT:  select rank(3) within group (order by stringu1,stringu2) from tenk1;
2023-08-01 17:01:37.411 +07 client backend[295827] pg_regress/aggregates ERROR:  invalid input syntax for type integer: "fred" at character 13
2023-08-01 17:01:37.411 +07 client backend[295827] pg_regress/aggregates STATEMENT:  select rank('fred') within group (order by x) from generate_series(1,5) x;
2023-08-01 17:01:37.411 +07 client backend[295827] pg_regress/aggregates ERROR:  collation mismatch between explicit collations "C" and "POSIX" at character 64
2023-08-01 17:01:37.411 +07 client backend[295827] pg_regress/aggregates STATEMENT:  select rank('adam'::text collate "C") within group (order by x collate "POSIX")
	  from (values ('fred'),('jim')) v(x);
2023-08-01 17:01:37.415 +07 client backend[295832] pg_regress/hash_index ERROR:  value 9 out of bounds for option "fillfactor"
2023-08-01 17:01:37.415 +07 client backend[295832] pg_regress/hash_index DETAIL:  Valid values are between "10" and "100".
2023-08-01 17:01:37.415 +07 client backend[295832] pg_regress/hash_index STATEMENT:  CREATE INDEX hash_f8_index2 ON hash_f8_heap USING hash (random float8_ops)
		WITH (fillfactor=9);
2023-08-01 17:01:37.415 +07 client backend[295832] pg_regress/hash_index ERROR:  value 101 out of bounds for option "fillfactor"
2023-08-01 17:01:37.415 +07 client backend[295832] pg_regress/hash_index DETAIL:  Valid values are between "10" and "100".
2023-08-01 17:01:37.415 +07 client backend[295832] pg_regress/hash_index STATEMENT:  CREATE INDEX hash_f8_index2 ON hash_f8_heap USING hash (random float8_ops)
		WITH (fillfactor=101);
2023-08-01 17:01:37.418 +07 client backend[295836] pg_regress/update ERROR:  new row for relation "part_def" violates partition constraint
2023-08-01 17:01:37.418 +07 client backend[295836] pg_regress/update DETAIL:  Failing row contains (a, 9, null, null, null).
2023-08-01 17:01:37.418 +07 client backend[295836] pg_regress/update STATEMENT:  update part_def set a = 'a' where a = 'd';
2023-08-01 17:01:37.419 +07 client backend[295836] pg_regress/update ERROR:  new row for relation "part_a_10_a_20" violates partition constraint
2023-08-01 17:01:37.419 +07 client backend[295836] pg_regress/update DETAIL:  Failing row contains (ad, 10, 200, 1, null).
2023-08-01 17:01:37.419 +07 client backend[295836] pg_regress/update STATEMENT:  UPDATE part_a_10_a_20 set a = 'ad' WHERE a = 'a';
2023-08-01 17:01:37.428 +07 client backend[295836] pg_regress/update ERROR:  new row for relation "list_default" violates partition constraint
2023-08-01 17:01:37.428 +07 client backend[295836] pg_regress/update DETAIL:  Failing row contains (a, 10).
2023-08-01 17:01:37.428 +07 client backend[295836] pg_regress/update STATEMENT:  UPDATE list_default set a = 'a' WHERE a = 'd';
2023-08-01 17:01:37.435 +07 client backend[295836] pg_regress/update ERROR:  new row for relation "sub_part2" violates partition constraint
2023-08-01 17:01:37.435 +07 client backend[295836] pg_regress/update DETAIL:  Failing row contains (2, 10, 2).
2023-08-01 17:01:37.435 +07 client backend[295836] pg_regress/update STATEMENT:  UPDATE sub_parted set a = 2 WHERE c = 10;
2023-08-01 17:01:37.447 +07 client backend[295828] pg_regress/join ERROR:  column reference "f1" is ambiguous at character 78
2023-08-01 17:01:37.447 +07 client backend[295828] pg_regress/join STATEMENT:  select * from
	  int8_tbl x join (int4_tbl x cross join int4_tbl y) j on q1 = f1;
2023-08-01 17:01:37.447 +07 client backend[295828] pg_regress/join ERROR:  invalid reference to FROM-clause entry for table "y" at character 78
2023-08-01 17:01:37.447 +07 client backend[295828] pg_regress/join HINT:  There is an entry for table "y", but it cannot be referenced from this part of the query.
2023-08-01 17:01:37.447 +07 client backend[295828] pg_regress/join STATEMENT:  select * from
	  int8_tbl x join (int4_tbl x cross join int4_tbl y) j on q1 = y.f1;
2023-08-01 17:01:37.447 +07 client backend[295828] pg_regress/join ERROR:  column t1.uunique1 does not exist at character 8
2023-08-01 17:01:37.447 +07 client backend[295828] pg_regress/join HINT:  Perhaps you meant to reference the column "t1.unique1".
2023-08-01 17:01:37.447 +07 client backend[295828] pg_regress/join STATEMENT:  select t1.uunique1 from
	  tenk1 t1 join tenk2 t2 on t1.two = t2.two;
2023-08-01 17:01:37.447 +07 client backend[295828] pg_regress/join ERROR:  column t2.uunique1 does not exist at character 8
2023-08-01 17:01:37.447 +07 client backend[295828] pg_regress/join HINT:  Perhaps you meant to reference the column "t2.unique1".
2023-08-01 17:01:37.447 +07 client backend[295828] pg_regress/join STATEMENT:  select t2.uunique1 from
	  tenk1 t1 join tenk2 t2 on t1.two = t2.two;
2023-08-01 17:01:37.447 +07 client backend[295828] pg_regress/join ERROR:  column "uunique1" does not exist at character 8
2023-08-01 17:01:37.447 +07 client backend[295828] pg_regress/join HINT:  Perhaps you meant to reference the column "t1.unique1" or the column "t2.unique1".
2023-08-01 17:01:37.447 +07 client backend[295828] pg_regress/join STATEMENT:  select uunique1 from
	  tenk1 t1 join tenk2 t2 on t1.two = t2.two;
2023-08-01 17:01:37.448 +07 client backend[295828] pg_regress/join ERROR:  column atts.relid does not exist at character 8
2023-08-01 17:01:37.448 +07 client backend[295828] pg_regress/join STATEMENT:  select atts.relid::regclass, s.* from pg_stats s join
	    pg_attribute a on s.attname = a.attname and s.tablename =
	    a.attrelid::regclass::text join (select unnest(indkey) attnum,
	    indexrelid from pg_index i) atts on atts.attnum = a.attnum where
	    schemaname != 'pg_catalog';
2023-08-01 17:01:37.454 +07 client backend[295836] pg_regress/update ERROR:  new row for relation "hpart1" violates partition constraint
2023-08-01 17:01:37.454 +07 client backend[295836] pg_regress/update DETAIL:  Failing row contains (3, 4).
2023-08-01 17:01:37.454 +07 client backend[295836] pg_regress/update STATEMENT:  update hpart1 set a = 3, b=4 where a = 1;
2023-08-01 17:01:37.481 +07 client backend[295828] pg_regress/join ERROR:  column "f1" does not exist at character 38
2023-08-01 17:01:37.481 +07 client backend[295828] pg_regress/join HINT:  There is a column named "f1" in table "a", but it cannot be referenced from this part of the query.
2023-08-01 17:01:37.481 +07 client backend[295828] pg_regress/join STATEMENT:  select f1,g from int4_tbl a, (select f1 as g) ss;
2023-08-01 17:01:37.481 +07 client backend[295828] pg_regress/join ERROR:  invalid reference to FROM-clause entry for table "a" at character 38
2023-08-01 17:01:37.481 +07 client backend[295828] pg_regress/join HINT:  There is an entry for table "a", but it cannot be referenced from this part of the query.
2023-08-01 17:01:37.481 +07 client backend[295828] pg_regress/join STATEMENT:  select f1,g from int4_tbl a, (select a.f1 as g) ss;
2023-08-01 17:01:37.481 +07 client backend[295828] pg_regress/join ERROR:  column "f1" does not exist at character 48
2023-08-01 17:01:37.481 +07 client backend[295828] pg_regress/join HINT:  There is a column named "f1" in table "a", but it cannot be referenced from this part of the query.
2023-08-01 17:01:37.481 +07 client backend[295828] pg_regress/join STATEMENT:  select f1,g from int4_tbl a cross join (select f1 as g) ss;
2023-08-01 17:01:37.481 +07 client backend[295828] pg_regress/join ERROR:  invalid reference to FROM-clause entry for table "a" at character 48
2023-08-01 17:01:37.481 +07 client backend[295828] pg_regress/join HINT:  There is an entry for table "a", but it cannot be referenced from this part of the query.
2023-08-01 17:01:37.481 +07 client backend[295828] pg_regress/join STATEMENT:  select f1,g from int4_tbl a cross join (select a.f1 as g) ss;
2023-08-01 17:01:37.481 +07 client backend[295828] pg_regress/join ERROR:  invalid reference to FROM-clause entry for table "a" at character 67
2023-08-01 17:01:37.481 +07 client backend[295828] pg_regress/join DETAIL:  The combining JOIN type must be INNER or LEFT for a LATERAL reference.
2023-08-01 17:01:37.481 +07 client backend[295828] pg_regress/join STATEMENT:  select f1,g from int4_tbl a right join lateral generate_series(0, a.f1) g on true;
2023-08-01 17:01:37.481 +07 client backend[295828] pg_regress/join ERROR:  invalid reference to FROM-clause entry for table "a" at character 66
2023-08-01 17:01:37.481 +07 client backend[295828] pg_regress/join DETAIL:  The combining JOIN type must be INNER or LEFT for a LATERAL reference.
2023-08-01 17:01:37.481 +07 client backend[295828] pg_regress/join STATEMENT:  select f1,g from int4_tbl a full join lateral generate_series(0, a.f1) g on true;
2023-08-01 17:01:37.481 +07 client backend[295828] pg_regress/join ERROR:  table reference "x" is ambiguous at character 78
2023-08-01 17:01:37.481 +07 client backend[295828] pg_regress/join STATEMENT:  select * from
	  int8_tbl x cross join (int4_tbl x cross join lateral (select x.f1) ss);
2023-08-01 17:01:37.481 +07 client backend[295828] pg_regress/join ERROR:  aggregate functions are not allowed in FROM clause of their own query level at character 40
2023-08-01 17:01:37.481 +07 client backend[295828] pg_regress/join STATEMENT:  select 1 from tenk1 a, lateral (select max(a.unique1) from int4_tbl b) ss;
2023-08-01 17:01:37.482 +07 client backend[295828] pg_regress/join ERROR:  column "x1" does not exist at character 64
2023-08-01 17:01:37.482 +07 client backend[295828] pg_regress/join HINT:  There is a column named "x1" in table "xx1", but it cannot be referenced from this part of the query.
2023-08-01 17:01:37.482 +07 client backend[295828] pg_regress/join STATEMENT:  update xx1 set x2 = f1 from (select * from int4_tbl where f1 = x1) ss;
2023-08-01 17:01:37.482 +07 client backend[295828] pg_regress/join ERROR:  invalid reference to FROM-clause entry for table "xx1" at character 64
2023-08-01 17:01:37.482 +07 client backend[295828] pg_regress/join HINT:  There is an entry for table "xx1", but it cannot be referenced from this part of the query.
2023-08-01 17:01:37.482 +07 client backend[295828] pg_regress/join STATEMENT:  update xx1 set x2 = f1 from (select * from int4_tbl where f1 = xx1.x1) ss;
2023-08-01 17:01:37.482 +07 client backend[295828] pg_regress/join ERROR:  invalid reference to FROM-clause entry for table "xx1" at character 72
2023-08-01 17:01:37.482 +07 client backend[295828] pg_regress/join HINT:  There is an entry for table "xx1", but it cannot be referenced from this part of the query.
2023-08-01 17:01:37.482 +07 client backend[295828] pg_regress/join STATEMENT:  update xx1 set x2 = f1 from lateral (select * from int4_tbl where f1 = x1) ss;
2023-08-01 17:01:37.482 +07 client backend[295828] pg_regress/join ERROR:  table name "xx1" specified more than once
2023-08-01 17:01:37.482 +07 client backend[295828] pg_regress/join STATEMENT:  update xx1 set x2 = f1 from xx1, lateral (select * from int4_tbl where f1 = x1) ss;
2023-08-01 17:01:37.482 +07 client backend[295828] pg_regress/join ERROR:  column "x1" does not exist at character 58
2023-08-01 17:01:37.482 +07 client backend[295828] pg_regress/join HINT:  There is a column named "x1" in table "xx1", but it cannot be referenced from this part of the query.
2023-08-01 17:01:37.482 +07 client backend[295828] pg_regress/join STATEMENT:  delete from xx1 using (select * from int4_tbl where f1 = x1) ss;
2023-08-01 17:01:37.482 +07 client backend[295828] pg_regress/join ERROR:  invalid reference to FROM-clause entry for table "xx1" at character 58
2023-08-01 17:01:37.482 +07 client backend[295828] pg_regress/join HINT:  There is an entry for table "xx1", but it cannot be referenced from this part of the query.
2023-08-01 17:01:37.482 +07 client backend[295828] pg_regress/join STATEMENT:  delete from xx1 using (select * from int4_tbl where f1 = xx1.x1) ss;
2023-08-01 17:01:37.482 +07 client backend[295828] pg_regress/join ERROR:  invalid reference to FROM-clause entry for table "xx1" at character 66
2023-08-01 17:01:37.482 +07 client backend[295828] pg_regress/join HINT:  There is an entry for table "xx1", but it cannot be referenced from this part of the query.
2023-08-01 17:01:37.482 +07 client backend[295828] pg_regress/join STATEMENT:  delete from xx1 using lateral (select * from int4_tbl where f1 = x1) ss;
2023-08-01 17:01:37.488 +07 client backend[295827] pg_regress/aggregates LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295827.1", size 280000
2023-08-01 17:01:37.488 +07 client backend[295827] pg_regress/aggregates STATEMENT:  create table agg_data_20k as
	select g from generate_series(0, 19999) g;
2023-08-01 17:01:37.525 +07 client backend[295827] pg_regress/aggregates LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295827.2", size 376832
2023-08-01 17:01:37.525 +07 client backend[295827] pg_regress/aggregates STATEMENT:  create table agg_group_1 as
	select g%10000 as c1, sum(g::numeric) as c2, count(*) as c3
	  from agg_data_20k group by g%10000;
2023-08-01 17:01:37.568 +07 client backend[295827] pg_regress/aggregates LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295827.5", size 802816
2023-08-01 17:01:37.568 +07 client backend[295827] pg_regress/aggregates STATEMENT:  create table agg_hash_1 as
	select g%10000 as c1, sum(g::numeric) as c2, count(*) as c3
	  from agg_data_20k group by g%10000;
2023-08-01 17:01:37.577 +07 client backend[295827] pg_regress/aggregates LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295827.6", size 204800
2023-08-01 17:01:37.577 +07 client backend[295827] pg_regress/aggregates STATEMENT:  create table agg_hash_2 as
	select * from
	  (values (100), (300), (500)) as r(a),
	  lateral (
	    select (g/2)::numeric as c1,
	           array_agg(g::numeric) as c2,
		   count(*) as c3
	    from agg_data_2k
	    where g < r.a
	    group by g/2) as s;
2023-08-01 17:01:37.578 +07 client backend[295827] pg_regress/aggregates LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295827.7", size 204800
2023-08-01 17:01:37.578 +07 client backend[295827] pg_regress/aggregates STATEMENT:  create table agg_hash_2 as
	select * from
	  (values (100), (300), (500)) as r(a),
	  lateral (
	    select (g/2)::numeric as c1,
	           array_agg(g::numeric) as c2,
		   count(*) as c3
	    from agg_data_2k
	    where g < r.a
	    group by g/2) as s;
2023-08-01 17:01:37.579 +07 client backend[295827] pg_regress/aggregates LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295827.8", size 204800
2023-08-01 17:01:37.579 +07 client backend[295827] pg_regress/aggregates STATEMENT:  create table agg_hash_2 as
	select * from
	  (values (100), (300), (500)) as r(a),
	  lateral (
	    select (g/2)::numeric as c1,
	           array_agg(g::numeric) as c2,
		   count(*) as c3
	    from agg_data_2k
	    where g < r.a
	    group by g/2) as s;
2023-08-01 17:01:37.581 +07 client backend[295827] pg_regress/aggregates LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295827.9", size 212992
2023-08-01 17:01:37.581 +07 client backend[295827] pg_regress/aggregates STATEMENT:  create table agg_hash_3 as
	select (g/2)::numeric as c1, sum(7::int4) as c2, count(*) as c3
	  from agg_data_2k group by g/2;
2023-08-01 17:01:37.584 +07 client backend[295827] pg_regress/aggregates LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295827.10", size 262144
2023-08-01 17:01:37.584 +07 client backend[295827] pg_regress/aggregates STATEMENT:  create table agg_hash_4 as
	select (g/2)::numeric as c1, array_agg(g::numeric) as c2, count(*) as c3
	  from agg_data_2k group by g/2;
2023-08-01 17:01:37.851 +07 client backend[295834] pg_regress/btree_index ERROR:  value -10.0 out of bounds for option "vacuum_cleanup_index_scale_factor"
2023-08-01 17:01:37.851 +07 client backend[295834] pg_regress/btree_index DETAIL:  Valid values are between "0.000000" and "10000000000.000000".
2023-08-01 17:01:37.851 +07 client backend[295834] pg_regress/btree_index STATEMENT:  create index btree_idx_err on btree_test(a) with (vacuum_cleanup_index_scale_factor = -10.0);
2023-08-01 17:01:37.851 +07 client backend[295834] pg_regress/btree_index ERROR:  invalid value for floating point option "vacuum_cleanup_index_scale_factor": string
2023-08-01 17:01:37.851 +07 client backend[295834] pg_regress/btree_index STATEMENT:  create index btree_idx_err on btree_test(a) with (vacuum_cleanup_index_scale_factor = 'string');
2023-08-01 17:01:37.851 +07 client backend[295834] pg_regress/btree_index ERROR:  invalid value for floating point option "vacuum_cleanup_index_scale_factor": true
2023-08-01 17:01:37.851 +07 client backend[295834] pg_regress/btree_index STATEMENT:  create index btree_idx_err on btree_test(a) with (vacuum_cleanup_index_scale_factor = true);
2023-08-01 17:01:37.924 +07 client backend[295834] pg_regress/btree_index LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295834.0", size 1120000
2023-08-01 17:01:37.924 +07 client backend[295834] pg_regress/btree_index STATEMENT:  INSERT INTO delete_test_table SELECT i, 1, 2, 3 FROM generate_series(1,80000) i;
2023-08-01 17:01:38.035 +07 client backend[295834] pg_regress/btree_index ERROR:  operator class int4_ops has no options
2023-08-01 17:01:38.035 +07 client backend[295834] pg_regress/btree_index STATEMENT:  create index on btree_tall_tbl (id int4_ops(foo=1));
2023-08-01 17:01:38.065 +07 client backend[295958] pg_regress/password ERROR:  invalid value for parameter "password_encryption": "novalue"
2023-08-01 17:01:38.065 +07 client backend[295958] pg_regress/password HINT:  Available values: md5, scram-sha-256.
2023-08-01 17:01:38.065 +07 client backend[295958] pg_regress/password STATEMENT:  SET password_encryption = 'novalue';
2023-08-01 17:01:38.066 +07 client backend[295950] pg_regress/privileges ERROR:  role "regress_priv_user5" already exists
2023-08-01 17:01:38.066 +07 client backend[295950] pg_regress/privileges STATEMENT:  CREATE USER regress_priv_user5;
2023-08-01 17:01:38.075 +07 client backend[295946] pg_regress/matview ERROR:  materialized view "mvtest_tm" has not been populated
2023-08-01 17:01:38.075 +07 client backend[295946] pg_regress/matview HINT:  Use the REFRESH MATERIALIZED VIEW command.
2023-08-01 17:01:38.075 +07 client backend[295946] pg_regress/matview STATEMENT:  SELECT * FROM mvtest_tm ORDER BY type;
2023-08-01 17:01:38.077 +07 client backend[295947] pg_regress/security_label ERROR:  no security label providers have been loaded
2023-08-01 17:01:38.077 +07 client backend[295947] pg_regress/security_label STATEMENT:  SECURITY LABEL ON TABLE seclabel_tbl1 IS 'classified';
2023-08-01 17:01:38.077 +07 client backend[295947] pg_regress/security_label ERROR:  security label provider "dummy" is not loaded
2023-08-01 17:01:38.077 +07 client backend[295947] pg_regress/security_label STATEMENT:  SECURITY LABEL FOR 'dummy' ON TABLE seclabel_tbl1 IS 'classified';
2023-08-01 17:01:38.077 +07 client backend[295947] pg_regress/security_label ERROR:  no security label providers have been loaded
2023-08-01 17:01:38.077 +07 client backend[295947] pg_regress/security_label STATEMENT:  SECURITY LABEL ON TABLE seclabel_tbl1 IS '...invalid label...';
2023-08-01 17:01:38.077 +07 client backend[295947] pg_regress/security_label ERROR:  no security label providers have been loaded
2023-08-01 17:01:38.077 +07 client backend[295947] pg_regress/security_label STATEMENT:  SECURITY LABEL ON TABLE seclabel_tbl3 IS 'unclassified';
2023-08-01 17:01:38.077 +07 client backend[295947] pg_regress/security_label ERROR:  no security label providers have been loaded
2023-08-01 17:01:38.077 +07 client backend[295947] pg_regress/security_label STATEMENT:  SECURITY LABEL ON ROLE regress_seclabel_user1 IS 'classified';
2023-08-01 17:01:38.077 +07 client backend[295947] pg_regress/security_label ERROR:  security label provider "dummy" is not loaded
2023-08-01 17:01:38.077 +07 client backend[295947] pg_regress/security_label STATEMENT:  SECURITY LABEL FOR 'dummy' ON ROLE regress_seclabel_user1 IS 'classified';
2023-08-01 17:01:38.077 +07 client backend[295947] pg_regress/security_label ERROR:  no security label providers have been loaded
2023-08-01 17:01:38.077 +07 client backend[295947] pg_regress/security_label STATEMENT:  SECURITY LABEL ON ROLE regress_seclabel_user1 IS '...invalid label...';
2023-08-01 17:01:38.077 +07 client backend[295947] pg_regress/security_label ERROR:  no security label providers have been loaded
2023-08-01 17:01:38.077 +07 client backend[295947] pg_regress/security_label STATEMENT:  SECURITY LABEL ON ROLE regress_seclabel_user3 IS 'unclassified';
2023-08-01 17:01:38.077 +07 client backend[295948] pg_regress/gist ERROR:  invalid value for enum option "buffering": invalid_value
2023-08-01 17:01:38.077 +07 client backend[295948] pg_regress/gist DETAIL:  Valid values are "on", "off", and "auto".
2023-08-01 17:01:38.077 +07 client backend[295948] pg_regress/gist STATEMENT:  create index gist_pointidx5 on gist_point_tbl using gist(p) with (buffering = invalid_value);
2023-08-01 17:01:38.077 +07 client backend[295948] pg_regress/gist ERROR:  value 9 out of bounds for option "fillfactor"
2023-08-01 17:01:38.077 +07 client backend[295948] pg_regress/gist DETAIL:  Valid values are between "10" and "100".
2023-08-01 17:01:38.077 +07 client backend[295948] pg_regress/gist STATEMENT:  create index gist_pointidx5 on gist_point_tbl using gist(p) with (fillfactor=9);
2023-08-01 17:01:38.077 +07 client backend[295948] pg_regress/gist ERROR:  value 101 out of bounds for option "fillfactor"
2023-08-01 17:01:38.077 +07 client backend[295948] pg_regress/gist DETAIL:  Valid values are between "10" and "100".
2023-08-01 17:01:38.077 +07 client backend[295948] pg_regress/gist STATEMENT:  create index gist_pointidx5 on gist_point_tbl using gist(p) with (fillfactor=101);
2023-08-01 17:01:38.089 +07 client backend[295951] pg_regress/collate ERROR:  collations are not supported by type integer at character 44
2023-08-01 17:01:38.089 +07 client backend[295951] pg_regress/collate STATEMENT:  CREATE TABLE collate_test_fail (
	    a int COLLATE "C",
	    b text
	);
2023-08-01 17:01:38.096 +07 client backend[295961] pg_regress/replica_identity ERROR:  cannot use non-unique index "test_replica_identity_keyab" as replica identity
2023-08-01 17:01:38.096 +07 client backend[295961] pg_regress/replica_identity STATEMENT:  ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_keyab;
2023-08-01 17:01:38.096 +07 client backend[295961] pg_regress/replica_identity ERROR:  index "test_replica_identity_nonkey" cannot be used as replica identity because column "nonkey" is nullable
2023-08-01 17:01:38.096 +07 client backend[295961] pg_regress/replica_identity STATEMENT:  ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_nonkey;
2023-08-01 17:01:38.096 +07 client backend[295952] pg_regress/identity ERROR:  column "a" of relation "itest3" is already an identity column
2023-08-01 17:01:38.096 +07 client backend[295952] pg_regress/identity STATEMENT:  ALTER TABLE itest3 ALTER COLUMN a ADD GENERATED ALWAYS AS IDENTITY;
2023-08-01 17:01:38.097 +07 client backend[295961] pg_regress/replica_identity ERROR:  cannot use non-unique index "test_replica_identity_hash" as replica identity
2023-08-01 17:01:38.097 +07 client backend[295961] pg_regress/replica_identity STATEMENT:  ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_hash;
2023-08-01 17:01:38.098 +07 client backend[295961] pg_regress/replica_identity ERROR:  cannot use expression index "test_replica_identity_expr" as replica identity
2023-08-01 17:01:38.098 +07 client backend[295961] pg_regress/replica_identity STATEMENT:  ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_expr;
2023-08-01 17:01:38.098 +07 client backend[295961] pg_regress/replica_identity ERROR:  cannot use partial index "test_replica_identity_partial" as replica identity
2023-08-01 17:01:38.098 +07 client backend[295961] pg_regress/replica_identity STATEMENT:  ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_partial;
2023-08-01 17:01:38.099 +07 client backend[295961] pg_regress/replica_identity ERROR:  "test_replica_identity_othertable_pkey" is not an index for table "test_replica_identity"
2023-08-01 17:01:38.099 +07 client backend[295961] pg_regress/replica_identity STATEMENT:  ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_othertable_pkey;
2023-08-01 17:01:38.100 +07 client backend[295961] pg_regress/replica_identity ERROR:  cannot use non-immediate index "test_replica_identity_unique_defer" as replica identity
2023-08-01 17:01:38.100 +07 client backend[295961] pg_regress/replica_identity STATEMENT:  ALTER TABLE test_replica_identity REPLICA IDENTITY USING INDEX test_replica_identity_unique_defer;
2023-08-01 17:01:38.102 +07 client backend[295957] pg_regress/object_address WARNING:  wal_level is insufficient to publish logical changes
2023-08-01 17:01:38.102 +07 client backend[295957] pg_regress/object_address HINT:  Set wal_level to logical before creating subscriptions.
2023-08-01 17:01:38.103 +07 client backend[295957] pg_regress/object_address WARNING:  tables were not subscribed, you will have to run ALTER SUBSCRIPTION ... REFRESH PUBLICATION to subscribe the tables
2023-08-01 17:01:38.104 +07 client backend[295957] pg_regress/object_address ERROR:  unrecognized object type "stone"
2023-08-01 17:01:38.104 +07 client backend[295957] pg_regress/object_address STATEMENT:  SELECT pg_get_object_address('stone', '{}', '{}');
2023-08-01 17:01:38.104 +07 client backend[295957] pg_regress/object_address ERROR:  name list length must be at least 1
2023-08-01 17:01:38.104 +07 client backend[295957] pg_regress/object_address STATEMENT:  SELECT pg_get_object_address('table', '{}', '{}');
2023-08-01 17:01:38.104 +07 client backend[295957] pg_regress/object_address ERROR:  name or argument lists may not contain nulls
2023-08-01 17:01:38.104 +07 client backend[295957] pg_regress/object_address STATEMENT:  SELECT pg_get_object_address('table', '{NULL}', '{}');
2023-08-01 17:01:38.104 +07 client backend[295957] pg_regress/object_address WARNING:  error for toast table: unsupported object type "toast table"
2023-08-01 17:01:38.104 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 11 at RAISE
2023-08-01 17:01:38.104 +07 client backend[295957] pg_regress/object_address WARNING:  error for index column: unsupported object type "index column"
2023-08-01 17:01:38.104 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 11 at RAISE
2023-08-01 17:01:38.104 +07 client backend[295957] pg_regress/object_address WARNING:  error for sequence column: unsupported object type "sequence column"
2023-08-01 17:01:38.104 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 11 at RAISE
2023-08-01 17:01:38.104 +07 client backend[295957] pg_regress/object_address WARNING:  error for toast table column: unsupported object type "toast table column"
2023-08-01 17:01:38.104 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 11 at RAISE
2023-08-01 17:01:38.104 +07 client backend[295957] pg_regress/object_address WARNING:  error for view column: unsupported object type "view column"
2023-08-01 17:01:38.104 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 11 at RAISE
2023-08-01 17:01:38.104 +07 client backend[295957] pg_regress/object_address WARNING:  error for materialized view column: unsupported object type "materialized view column"
2023-08-01 17:01:38.104 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 11 at RAISE
2023-08-01 17:01:38.105 +07 client backend[295957] pg_regress/object_address ERROR:  operator 1 (int4, bool) of operator family integer_ops for access method btree does not exist
2023-08-01 17:01:38.105 +07 client backend[295957] pg_regress/object_address STATEMENT:  select * from pg_get_object_address('operator of access method', '{btree,integer_ops,1}', '{int4,bool}');
2023-08-01 17:01:38.105 +07 client backend[295957] pg_regress/object_address ERROR:  operator 99 (int4, int4) of operator family integer_ops for access method btree does not exist
2023-08-01 17:01:38.105 +07 client backend[295957] pg_regress/object_address STATEMENT:  select * from pg_get_object_address('operator of access method', '{btree,integer_ops,99}', '{int4,int4}');
2023-08-01 17:01:38.105 +07 client backend[295957] pg_regress/object_address ERROR:  function 1 (int4, bool) of operator family integer_ops for access method btree does not exist
2023-08-01 17:01:38.105 +07 client backend[295957] pg_regress/object_address STATEMENT:  select * from pg_get_object_address('function of access method', '{btree,integer_ops,1}', '{int4,bool}');
2023-08-01 17:01:38.105 +07 client backend[295957] pg_regress/object_address ERROR:  function 99 (int4, int4) of operator family integer_ops for access method btree does not exist
2023-08-01 17:01:38.105 +07 client backend[295957] pg_regress/object_address STATEMENT:  select * from pg_get_object_address('function of access method', '{btree,integer_ops,99}', '{int4,int4}');
2023-08-01 17:01:38.105 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest2
2023-08-01 17:01:38.105 +07 client backend[295950] pg_regress/privileges STATEMENT:  INSERT INTO atest2 VALUES ('foo', true);
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address WARNING:  error for table,{eins},{}: relation "eins" does not exist
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address WARNING:  error for table,{eins},{integer}: relation "eins" does not exist
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address WARNING:  error for table,{addr_nsp,zwei},{}: relation "addr_nsp.zwei" does not exist
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address WARNING:  error for table,{addr_nsp,zwei},{integer}: relation "addr_nsp.zwei" does not exist
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address WARNING:  error for table,{eins,zwei,drei},{}: cross-database references are not implemented: "eins.zwei.drei"
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address WARNING:  error for table,{eins,zwei,drei},{integer}: cross-database references are not implemented: "eins.zwei.drei"
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address WARNING:  error for index,{eins},{}: relation "eins" does not exist
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address WARNING:  error for index,{eins},{integer}: relation "eins" does not exist
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address WARNING:  error for index,{addr_nsp,zwei},{}: relation "addr_nsp.zwei" does not exist
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address WARNING:  error for index,{addr_nsp,zwei},{integer}: relation "addr_nsp.zwei" does not exist
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address WARNING:  error for index,{eins,zwei,drei},{}: cross-database references are not implemented: "eins.zwei.drei"
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address WARNING:  error for index,{eins,zwei,drei},{integer}: cross-database references are not implemented: "eins.zwei.drei"
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address WARNING:  error for sequence,{eins},{}: relation "eins" does not exist
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address WARNING:  error for sequence,{eins},{integer}: relation "eins" does not exist
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address WARNING:  error for sequence,{addr_nsp,zwei},{}: relation "addr_nsp.zwei" does not exist
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address WARNING:  error for sequence,{addr_nsp,zwei},{integer}: relation "addr_nsp.zwei" does not exist
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address WARNING:  error for sequence,{eins,zwei,drei},{}: cross-database references are not implemented: "eins.zwei.drei"
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address WARNING:  error for sequence,{eins,zwei,drei},{integer}: cross-database references are not implemented: "eins.zwei.drei"
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address WARNING:  error for view,{eins},{}: relation "eins" does not exist
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address WARNING:  error for view,{eins},{integer}: relation "eins" does not exist
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address WARNING:  error for view,{addr_nsp,zwei},{}: relation "addr_nsp.zwei" does not exist
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address WARNING:  error for view,{addr_nsp,zwei},{integer}: relation "addr_nsp.zwei" does not exist
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address WARNING:  error for view,{eins,zwei,drei},{}: cross-database references are not implemented: "eins.zwei.drei"
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address WARNING:  error for view,{eins,zwei,drei},{integer}: cross-database references are not implemented: "eins.zwei.drei"
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address WARNING:  error for materialized view,{eins},{}: relation "eins" does not exist
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address WARNING:  error for materialized view,{eins},{integer}: relation "eins" does not exist
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address WARNING:  error for materialized view,{addr_nsp,zwei},{}: relation "addr_nsp.zwei" does not exist
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address WARNING:  error for materialized view,{addr_nsp,zwei},{integer}: relation "addr_nsp.zwei" does not exist
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address WARNING:  error for materialized view,{eins,zwei,drei},{}: cross-database references are not implemented: "eins.zwei.drei"
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address WARNING:  error for materialized view,{eins,zwei,drei},{integer}: cross-database references are not implemented: "eins.zwei.drei"
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address WARNING:  error for foreign table,{eins},{}: relation "eins" does not exist
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address WARNING:  error for foreign table,{eins},{integer}: relation "eins" does not exist
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address WARNING:  error for foreign table,{addr_nsp,zwei},{}: relation "addr_nsp.zwei" does not exist
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address WARNING:  error for foreign table,{addr_nsp,zwei},{integer}: relation "addr_nsp.zwei" does not exist
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address WARNING:  error for foreign table,{eins,zwei,drei},{}: cross-database references are not implemented: "eins.zwei.drei"
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address WARNING:  error for foreign table,{eins,zwei,drei},{integer}: cross-database references are not implemented: "eins.zwei.drei"
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address WARNING:  error for table column,{eins},{}: column name must be qualified
2023-08-01 17:01:38.106 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.107 +07 client backend[295957] pg_regress/object_address WARNING:  error for table column,{eins},{integer}: column name must be qualified
2023-08-01 17:01:38.107 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.107 +07 client backend[295957] pg_regress/object_address WARNING:  error for table column,{addr_nsp,zwei},{}: relation "addr_nsp" does not exist
2023-08-01 17:01:38.107 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.107 +07 client backend[295957] pg_regress/object_address WARNING:  error for table column,{addr_nsp,zwei},{integer}: relation "addr_nsp" does not exist
2023-08-01 17:01:38.107 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.107 +07 client backend[295957] pg_regress/object_address WARNING:  error for table column,{eins,zwei,drei},{}: schema "eins" does not exist
2023-08-01 17:01:38.107 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.107 +07 client backend[295957] pg_regress/object_address WARNING:  error for table column,{eins,zwei,drei},{integer}: schema "eins" does not exist
2023-08-01 17:01:38.107 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.107 +07 client backend[295957] pg_regress/object_address WARNING:  error for foreign table column,{eins},{}: column name must be qualified
2023-08-01 17:01:38.107 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.107 +07 client backend[295957] pg_regress/object_address WARNING:  error for foreign table column,{eins},{integer}: column name must be qualified
2023-08-01 17:01:38.107 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.107 +07 client backend[295957] pg_regress/object_address WARNING:  error for foreign table column,{addr_nsp,zwei},{}: relation "addr_nsp" does not exist
2023-08-01 17:01:38.107 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.107 +07 client backend[295957] pg_regress/object_address WARNING:  error for foreign table column,{addr_nsp,zwei},{integer}: relation "addr_nsp" does not exist
2023-08-01 17:01:38.107 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.107 +07 client backend[295957] pg_regress/object_address WARNING:  error for foreign table column,{eins,zwei,drei},{}: schema "eins" does not exist
2023-08-01 17:01:38.107 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.107 +07 client backend[295957] pg_regress/object_address WARNING:  error for foreign table column,{eins,zwei,drei},{integer}: schema "eins" does not exist
2023-08-01 17:01:38.107 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address WARNING:  error for aggregate,{eins},{}: aggregate eins(*) does not exist
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address WARNING:  error for aggregate,{eins},{integer}: aggregate eins(integer) does not exist
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address WARNING:  error for aggregate,{addr_nsp,zwei},{}: aggregate addr_nsp.zwei(*) does not exist
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address WARNING:  error for aggregate,{addr_nsp,zwei},{integer}: aggregate addr_nsp.zwei(integer) does not exist
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address WARNING:  error for aggregate,{eins,zwei,drei},{}: cross-database references are not implemented: eins.zwei.drei
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address WARNING:  error for aggregate,{eins,zwei,drei},{integer}: cross-database references are not implemented: eins.zwei.drei
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address WARNING:  error for function,{eins},{}: function eins() does not exist
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address WARNING:  error for function,{eins},{integer}: function eins(integer) does not exist
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address WARNING:  error for function,{addr_nsp,zwei},{}: function addr_nsp.zwei() does not exist
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address WARNING:  error for function,{addr_nsp,zwei},{integer}: function addr_nsp.zwei(integer) does not exist
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address WARNING:  error for function,{eins,zwei,drei},{}: cross-database references are not implemented: eins.zwei.drei
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address WARNING:  error for function,{eins,zwei,drei},{integer}: cross-database references are not implemented: eins.zwei.drei
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address WARNING:  error for procedure,{eins},{}: procedure eins() does not exist
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address WARNING:  error for procedure,{eins},{integer}: procedure eins(integer) does not exist
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address WARNING:  error for procedure,{addr_nsp,zwei},{}: procedure addr_nsp.zwei() does not exist
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address WARNING:  error for procedure,{addr_nsp,zwei},{integer}: procedure addr_nsp.zwei(integer) does not exist
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address WARNING:  error for procedure,{eins,zwei,drei},{}: cross-database references are not implemented: eins.zwei.drei
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address WARNING:  error for procedure,{eins,zwei,drei},{integer}: cross-database references are not implemented: eins.zwei.drei
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address WARNING:  error for type,{eins},{}: type "eins" does not exist
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address WARNING:  error for type,{eins},{integer}: type "eins" does not exist
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address WARNING:  error for type,{addr_nsp,zwei},{}: name list length must be exactly 1
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address WARNING:  error for type,{addr_nsp,zwei},{integer}: name list length must be exactly 1
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address WARNING:  error for type,{eins,zwei,drei},{}: name list length must be exactly 1
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address WARNING:  error for type,{eins,zwei,drei},{integer}: name list length must be exactly 1
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address WARNING:  error for cast,{eins},{}: argument list length must be exactly 1
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.108 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest2
2023-08-01 17:01:38.108 +07 client backend[295950] pg_regress/privileges STATEMENT:  UPDATE atest2 SET col2 = NOT col2;
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address WARNING:  error for cast,{eins},{integer}: type "eins" does not exist
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address WARNING:  error for cast,{addr_nsp,zwei},{}: name list length must be exactly 1
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address WARNING:  error for cast,{addr_nsp,zwei},{integer}: name list length must be exactly 1
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address WARNING:  error for cast,{eins,zwei,drei},{}: name list length must be exactly 1
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address WARNING:  error for cast,{eins,zwei,drei},{integer}: name list length must be exactly 1
2023-08-01 17:01:38.108 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address WARNING:  error for table constraint,{eins},{}: must specify relation and object name
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address WARNING:  error for table constraint,{eins},{integer}: must specify relation and object name
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address WARNING:  error for table constraint,{addr_nsp,zwei},{}: relation "addr_nsp" does not exist
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address WARNING:  error for table constraint,{addr_nsp,zwei},{integer}: relation "addr_nsp" does not exist
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address WARNING:  error for table constraint,{eins,zwei,drei},{}: schema "eins" does not exist
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address WARNING:  error for table constraint,{eins,zwei,drei},{integer}: schema "eins" does not exist
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address WARNING:  error for domain constraint,{eins},{}: argument list length must be exactly 1
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address WARNING:  error for domain constraint,{eins},{integer}: type "eins" does not exist
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address WARNING:  error for domain constraint,{addr_nsp,zwei},{}: name list length must be exactly 1
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address WARNING:  error for domain constraint,{addr_nsp,zwei},{integer}: name list length must be exactly 1
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address WARNING:  error for domain constraint,{eins,zwei,drei},{}: name list length must be exactly 1
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address WARNING:  error for domain constraint,{eins,zwei,drei},{integer}: name list length must be exactly 1
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address WARNING:  error for conversion,{eins},{}: conversion "eins" does not exist
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address WARNING:  error for conversion,{eins},{integer}: conversion "eins" does not exist
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address WARNING:  error for conversion,{addr_nsp,zwei},{}: conversion "addr_nsp.zwei" does not exist
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address WARNING:  error for conversion,{addr_nsp,zwei},{integer}: conversion "addr_nsp.zwei" does not exist
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address WARNING:  error for conversion,{eins,zwei,drei},{}: cross-database references are not implemented: eins.zwei.drei
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address WARNING:  error for conversion,{eins,zwei,drei},{integer}: cross-database references are not implemented: eins.zwei.drei
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address WARNING:  error for default value,{eins},{}: column name must be qualified
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address WARNING:  error for default value,{eins},{integer}: column name must be qualified
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address WARNING:  error for default value,{addr_nsp,zwei},{}: relation "addr_nsp" does not exist
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address WARNING:  error for default value,{addr_nsp,zwei},{integer}: relation "addr_nsp" does not exist
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address WARNING:  error for default value,{eins,zwei,drei},{}: schema "eins" does not exist
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address WARNING:  error for default value,{eins,zwei,drei},{integer}: schema "eins" does not exist
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address WARNING:  error for operator,{eins},{}: argument list length must be exactly 2
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address WARNING:  error for operator,{eins},{integer}: argument list length must be exactly 2
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address WARNING:  error for operator,{addr_nsp,zwei},{}: argument list length must be exactly 2
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address WARNING:  error for operator,{addr_nsp,zwei},{integer}: argument list length must be exactly 2
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address WARNING:  error for operator,{eins,zwei,drei},{}: argument list length must be exactly 2
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address WARNING:  error for operator,{eins,zwei,drei},{integer}: argument list length must be exactly 2
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address WARNING:  error for operator class,{eins},{}: name list length must be at least 2
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address WARNING:  error for operator class,{eins},{integer}: name list length must be at least 2
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address WARNING:  error for operator class,{addr_nsp,zwei},{}: access method "addr_nsp" does not exist
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address WARNING:  error for operator class,{addr_nsp,zwei},{integer}: access method "addr_nsp" does not exist
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address WARNING:  error for operator class,{eins,zwei,drei},{}: access method "eins" does not exist
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address WARNING:  error for operator class,{eins,zwei,drei},{integer}: access method "eins" does not exist
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address WARNING:  error for operator family,{eins},{}: name list length must be at least 2
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address WARNING:  error for operator family,{eins},{integer}: name list length must be at least 2
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address WARNING:  error for operator family,{addr_nsp,zwei},{}: access method "addr_nsp" does not exist
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address WARNING:  error for operator family,{addr_nsp,zwei},{integer}: access method "addr_nsp" does not exist
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address WARNING:  error for operator family,{eins,zwei,drei},{}: access method "eins" does not exist
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address WARNING:  error for operator family,{eins,zwei,drei},{integer}: access method "eins" does not exist
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address WARNING:  error for rule,{eins},{}: must specify relation and object name
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address WARNING:  error for rule,{eins},{integer}: must specify relation and object name
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address WARNING:  error for rule,{addr_nsp,zwei},{}: relation "addr_nsp" does not exist
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address WARNING:  error for rule,{addr_nsp,zwei},{integer}: relation "addr_nsp" does not exist
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address WARNING:  error for rule,{eins,zwei,drei},{}: schema "eins" does not exist
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address WARNING:  error for rule,{eins,zwei,drei},{integer}: schema "eins" does not exist
2023-08-01 17:01:38.109 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address WARNING:  error for trigger,{eins},{}: must specify relation and object name
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address WARNING:  error for trigger,{eins},{integer}: must specify relation and object name
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address WARNING:  error for trigger,{addr_nsp,zwei},{}: relation "addr_nsp" does not exist
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address WARNING:  error for trigger,{addr_nsp,zwei},{integer}: relation "addr_nsp" does not exist
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address WARNING:  error for trigger,{eins,zwei,drei},{}: schema "eins" does not exist
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address WARNING:  error for trigger,{eins,zwei,drei},{integer}: schema "eins" does not exist
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address WARNING:  error for text search parser,{eins},{}: text search parser "eins" does not exist
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address WARNING:  error for text search parser,{eins},{integer}: text search parser "eins" does not exist
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address WARNING:  error for text search parser,{addr_nsp,zwei},{}: text search parser "addr_nsp.zwei" does not exist
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address WARNING:  error for text search parser,{addr_nsp,zwei},{integer}: text search parser "addr_nsp.zwei" does not exist
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address WARNING:  error for text search parser,{eins,zwei,drei},{}: cross-database references are not implemented: eins.zwei.drei
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address WARNING:  error for text search parser,{eins,zwei,drei},{integer}: cross-database references are not implemented: eins.zwei.drei
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address WARNING:  error for text search dictionary,{eins},{}: text search dictionary "eins" does not exist
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address WARNING:  error for text search dictionary,{eins},{integer}: text search dictionary "eins" does not exist
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address WARNING:  error for text search dictionary,{addr_nsp,zwei},{}: text search dictionary "addr_nsp.zwei" does not exist
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address WARNING:  error for text search dictionary,{addr_nsp,zwei},{integer}: text search dictionary "addr_nsp.zwei" does not exist
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address WARNING:  error for text search dictionary,{eins,zwei,drei},{}: cross-database references are not implemented: eins.zwei.drei
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address WARNING:  error for text search dictionary,{eins,zwei,drei},{integer}: cross-database references are not implemented: eins.zwei.drei
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address WARNING:  error for text search template,{eins},{}: text search template "eins" does not exist
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address WARNING:  error for text search template,{eins},{integer}: text search template "eins" does not exist
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address WARNING:  error for text search template,{addr_nsp,zwei},{}: text search template "addr_nsp.zwei" does not exist
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address WARNING:  error for text search template,{addr_nsp,zwei},{integer}: text search template "addr_nsp.zwei" does not exist
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address WARNING:  error for text search template,{eins,zwei,drei},{}: cross-database references are not implemented: eins.zwei.drei
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address WARNING:  error for text search template,{eins,zwei,drei},{integer}: cross-database references are not implemented: eins.zwei.drei
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address WARNING:  error for text search configuration,{eins},{}: text search configuration "eins" does not exist
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address WARNING:  error for text search configuration,{eins},{integer}: text search configuration "eins" does not exist
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address WARNING:  error for text search configuration,{addr_nsp,zwei},{}: text search configuration "addr_nsp.zwei" does not exist
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address WARNING:  error for text search configuration,{addr_nsp,zwei},{integer}: text search configuration "addr_nsp.zwei" does not exist
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address WARNING:  error for text search configuration,{eins,zwei,drei},{}: cross-database references are not implemented: eins.zwei.drei
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address WARNING:  error for text search configuration,{eins,zwei,drei},{integer}: cross-database references are not implemented: eins.zwei.drei
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address WARNING:  error for policy,{eins},{}: must specify relation and object name
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address WARNING:  error for policy,{eins},{integer}: must specify relation and object name
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address WARNING:  error for policy,{addr_nsp,zwei},{}: relation "addr_nsp" does not exist
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address WARNING:  error for policy,{addr_nsp,zwei},{integer}: relation "addr_nsp" does not exist
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address WARNING:  error for policy,{eins,zwei,drei},{}: schema "eins" does not exist
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address WARNING:  error for policy,{eins,zwei,drei},{integer}: schema "eins" does not exist
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address WARNING:  error for user mapping,{eins},{}: argument list length must be exactly 1
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address WARNING:  error for user mapping,{eins},{integer}: user mapping for user "eins" on server "integer" does not exist
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address WARNING:  error for user mapping,{addr_nsp,zwei},{}: argument list length must be exactly 1
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address WARNING:  error for user mapping,{addr_nsp,zwei},{integer}: user mapping for user "addr_nsp" on server "integer" does not exist
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address WARNING:  error for user mapping,{eins,zwei,drei},{}: argument list length must be exactly 1
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address WARNING:  error for user mapping,{eins,zwei,drei},{integer}: user mapping for user "eins" on server "integer" does not exist
2023-08-01 17:01:38.110 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address WARNING:  error for default acl,{eins},{}: argument list length must be exactly 1
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address WARNING:  error for default acl,{eins},{integer}: unrecognized default ACL object type "i"
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address WARNING:  error for default acl,{addr_nsp,zwei},{}: argument list length must be exactly 1
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address WARNING:  error for default acl,{addr_nsp,zwei},{integer}: unrecognized default ACL object type "i"
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address WARNING:  error for default acl,{eins,zwei,drei},{}: argument list length must be exactly 1
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address WARNING:  error for default acl,{eins,zwei,drei},{integer}: unrecognized default ACL object type "i"
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address WARNING:  error for transform,{eins},{}: argument list length must be exactly 1
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address WARNING:  error for transform,{eins},{integer}: type "eins" does not exist
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address WARNING:  error for transform,{addr_nsp,zwei},{}: name list length must be exactly 1
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address WARNING:  error for transform,{addr_nsp,zwei},{integer}: name list length must be exactly 1
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address WARNING:  error for transform,{eins,zwei,drei},{}: name list length must be exactly 1
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address WARNING:  error for transform,{eins,zwei,drei},{integer}: name list length must be exactly 1
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address WARNING:  error for operator of access method,{eins},{}: name list length must be at least 3
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address WARNING:  error for operator of access method,{eins},{integer}: name list length must be at least 3
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address WARNING:  error for operator of access method,{addr_nsp,zwei},{}: name list length must be at least 3
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address WARNING:  error for operator of access method,{addr_nsp,zwei},{integer}: name list length must be at least 3
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address WARNING:  error for operator of access method,{eins,zwei,drei},{}: argument list length must be exactly 2
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address WARNING:  error for operator of access method,{eins,zwei,drei},{integer}: argument list length must be exactly 2
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address WARNING:  error for function of access method,{eins},{}: name list length must be at least 3
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address WARNING:  error for function of access method,{eins},{integer}: name list length must be at least 3
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address WARNING:  error for function of access method,{addr_nsp,zwei},{}: name list length must be at least 3
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address WARNING:  error for function of access method,{addr_nsp,zwei},{integer}: name list length must be at least 3
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address WARNING:  error for function of access method,{eins,zwei,drei},{}: argument list length must be exactly 2
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address WARNING:  error for function of access method,{eins,zwei,drei},{integer}: argument list length must be exactly 2
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address WARNING:  error for publication relation,{eins},{}: argument list length must be exactly 1
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address WARNING:  error for publication relation,{eins},{integer}: relation "eins" does not exist
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address WARNING:  error for publication relation,{addr_nsp,zwei},{}: argument list length must be exactly 1
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address WARNING:  error for publication relation,{addr_nsp,zwei},{integer}: relation "addr_nsp.zwei" does not exist
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address WARNING:  error for publication relation,{eins,zwei,drei},{}: argument list length must be exactly 1
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address WARNING:  error for publication relation,{eins,zwei,drei},{integer}: cross-database references are not implemented: "eins.zwei.drei"
2023-08-01 17:01:38.111 +07 client backend[295957] pg_regress/object_address CONTEXT:  PL/pgSQL function inline_code_block line 27 at RAISE
2023-08-01 17:01:38.111 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest2
2023-08-01 17:01:38.111 +07 client backend[295950] pg_regress/privileges STATEMENT:  SELECT * FROM atest2 FOR UPDATE;
2023-08-01 17:01:38.112 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest2
2023-08-01 17:01:38.112 +07 client backend[295950] pg_regress/privileges STATEMENT:  DELETE FROM atest2;
2023-08-01 17:01:38.112 +07 client backend[295957] pg_regress/object_address ERROR:  language "one" does not exist
2023-08-01 17:01:38.112 +07 client backend[295957] pg_regress/object_address STATEMENT:  SELECT pg_get_object_address('language', '{one}', '{}');
2023-08-01 17:01:38.112 +07 client backend[295957] pg_regress/object_address ERROR:  name list length must be exactly 1
2023-08-01 17:01:38.112 +07 client backend[295957] pg_regress/object_address STATEMENT:  SELECT pg_get_object_address('language', '{one,two}', '{}');
2023-08-01 17:01:38.112 +07 client backend[295957] pg_regress/object_address ERROR:  large object 123 does not exist
2023-08-01 17:01:38.112 +07 client backend[295957] pg_regress/object_address STATEMENT:  SELECT pg_get_object_address('large object', '{123}', '{}');
2023-08-01 17:01:38.112 +07 client backend[295957] pg_regress/object_address ERROR:  name list length must be exactly 1
2023-08-01 17:01:38.112 +07 client backend[295957] pg_regress/object_address STATEMENT:  SELECT pg_get_object_address('large object', '{123,456}', '{}');
2023-08-01 17:01:38.112 +07 client backend[295957] pg_regress/object_address ERROR:  invalid input syntax for type oid: "blargh"
2023-08-01 17:01:38.112 +07 client backend[295957] pg_regress/object_address STATEMENT:  SELECT pg_get_object_address('large object', '{blargh}', '{}');
2023-08-01 17:01:38.112 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest2
2023-08-01 17:01:38.112 +07 client backend[295950] pg_regress/privileges STATEMENT:  TRUNCATE atest2;
2023-08-01 17:01:38.113 +07 client backend[295957] pg_regress/object_address ERROR:  schema "one" does not exist
2023-08-01 17:01:38.113 +07 client backend[295957] pg_regress/object_address STATEMENT:  SELECT pg_get_object_address('schema', '{one}', '{}');
2023-08-01 17:01:38.113 +07 client backend[295957] pg_regress/object_address ERROR:  name list length must be exactly 1
2023-08-01 17:01:38.113 +07 client backend[295957] pg_regress/object_address STATEMENT:  SELECT pg_get_object_address('schema', '{one,two}', '{}');
2023-08-01 17:01:38.113 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest2
2023-08-01 17:01:38.113 +07 client backend[295950] pg_regress/privileges STATEMENT:  LOCK atest2 IN ACCESS EXCLUSIVE MODE;
2023-08-01 17:01:38.113 +07 client backend[295951] pg_regress/collate ERROR:  collation mismatch between explicit collations "C" and "POSIX" at character 58
2023-08-01 17:01:38.113 +07 client backend[295951] pg_regress/collate STATEMENT:  SELECT * FROM collate_test1 WHERE b COLLATE "C" >= 'bbc' COLLATE "POSIX";
2023-08-01 17:01:38.113 +07 client backend[295957] pg_regress/object_address ERROR:  role "one" does not exist
2023-08-01 17:01:38.113 +07 client backend[295957] pg_regress/object_address STATEMENT:  SELECT pg_get_object_address('role', '{one}', '{}');
2023-08-01 17:01:38.113 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest2
2023-08-01 17:01:38.113 +07 client backend[295950] pg_regress/privileges STATEMENT:  COPY atest2 FROM stdin;
2023-08-01 17:01:38.113 +07 client backend[295957] pg_regress/object_address ERROR:  name list length must be exactly 1
2023-08-01 17:01:38.113 +07 client backend[295957] pg_regress/object_address STATEMENT:  SELECT pg_get_object_address('role', '{one,two}', '{}');
2023-08-01 17:01:38.113 +07 client backend[295950] pg_regress/privileges WARNING:  no privileges were granted for "atest1"
2023-08-01 17:01:38.113 +07 client backend[295957] pg_regress/object_address ERROR:  database "one" does not exist
2023-08-01 17:01:38.113 +07 client backend[295957] pg_regress/object_address STATEMENT:  SELECT pg_get_object_address('database', '{one}', '{}');
2023-08-01 17:01:38.113 +07 client backend[295957] pg_regress/object_address ERROR:  name list length must be exactly 1
2023-08-01 17:01:38.113 +07 client backend[295957] pg_regress/object_address STATEMENT:  SELECT pg_get_object_address('database', '{one,two}', '{}');
2023-08-01 17:01:38.113 +07 client backend[295957] pg_regress/object_address ERROR:  tablespace "one" does not exist
2023-08-01 17:01:38.113 +07 client backend[295957] pg_regress/object_address STATEMENT:  SELECT pg_get_object_address('tablespace', '{one}', '{}');
2023-08-01 17:01:38.113 +07 client backend[295957] pg_regress/object_address ERROR:  name list length must be exactly 1
2023-08-01 17:01:38.113 +07 client backend[295957] pg_regress/object_address STATEMENT:  SELECT pg_get_object_address('tablespace', '{one,two}', '{}');
2023-08-01 17:01:38.113 +07 client backend[295957] pg_regress/object_address ERROR:  foreign-data wrapper "one" does not exist
2023-08-01 17:01:38.113 +07 client backend[295957] pg_regress/object_address STATEMENT:  SELECT pg_get_object_address('foreign-data wrapper', '{one}', '{}');
2023-08-01 17:01:38.114 +07 client backend[295957] pg_regress/object_address ERROR:  name list length must be exactly 1
2023-08-01 17:01:38.114 +07 client backend[295957] pg_regress/object_address STATEMENT:  SELECT pg_get_object_address('foreign-data wrapper', '{one,two}', '{}');
2023-08-01 17:01:38.114 +07 client backend[295957] pg_regress/object_address ERROR:  server "one" does not exist
2023-08-01 17:01:38.114 +07 client backend[295957] pg_regress/object_address STATEMENT:  SELECT pg_get_object_address('server', '{one}', '{}');
2023-08-01 17:01:38.114 +07 client backend[295957] pg_regress/object_address ERROR:  name list length must be exactly 1
2023-08-01 17:01:38.114 +07 client backend[295957] pg_regress/object_address STATEMENT:  SELECT pg_get_object_address('server', '{one,two}', '{}');
2023-08-01 17:01:38.114 +07 client backend[295957] pg_regress/object_address ERROR:  extension "one" does not exist
2023-08-01 17:01:38.114 +07 client backend[295957] pg_regress/object_address STATEMENT:  SELECT pg_get_object_address('extension', '{one}', '{}');
2023-08-01 17:01:38.114 +07 client backend[295957] pg_regress/object_address ERROR:  name list length must be exactly 1
2023-08-01 17:01:38.114 +07 client backend[295957] pg_regress/object_address STATEMENT:  SELECT pg_get_object_address('extension', '{one,two}', '{}');
2023-08-01 17:01:38.114 +07 client backend[295957] pg_regress/object_address ERROR:  event trigger "one" does not exist
2023-08-01 17:01:38.114 +07 client backend[295957] pg_regress/object_address STATEMENT:  SELECT pg_get_object_address('event trigger', '{one}', '{}');
2023-08-01 17:01:38.114 +07 client backend[295957] pg_regress/object_address ERROR:  name list length must be exactly 1
2023-08-01 17:01:38.114 +07 client backend[295957] pg_regress/object_address STATEMENT:  SELECT pg_get_object_address('event trigger', '{one,two}', '{}');
2023-08-01 17:01:38.114 +07 client backend[295957] pg_regress/object_address ERROR:  access method "one" does not exist
2023-08-01 17:01:38.114 +07 client backend[295957] pg_regress/object_address STATEMENT:  SELECT pg_get_object_address('access method', '{one}', '{}');
2023-08-01 17:01:38.114 +07 client backend[295957] pg_regress/object_address ERROR:  name list length must be exactly 1
2023-08-01 17:01:38.114 +07 client backend[295957] pg_regress/object_address STATEMENT:  SELECT pg_get_object_address('access method', '{one,two}', '{}');
2023-08-01 17:01:38.114 +07 client backend[295957] pg_regress/object_address ERROR:  publication "one" does not exist
2023-08-01 17:01:38.114 +07 client backend[295957] pg_regress/object_address STATEMENT:  SELECT pg_get_object_address('publication', '{one}', '{}');
2023-08-01 17:01:38.115 +07 client backend[295957] pg_regress/object_address ERROR:  name list length must be exactly 1
2023-08-01 17:01:38.115 +07 client backend[295957] pg_regress/object_address STATEMENT:  SELECT pg_get_object_address('publication', '{one,two}', '{}');
2023-08-01 17:01:38.115 +07 client backend[295957] pg_regress/object_address ERROR:  subscription "one" does not exist
2023-08-01 17:01:38.115 +07 client backend[295957] pg_regress/object_address STATEMENT:  SELECT pg_get_object_address('subscription', '{one}', '{}');
2023-08-01 17:01:38.115 +07 client backend[295957] pg_regress/object_address ERROR:  name list length must be exactly 1
2023-08-01 17:01:38.115 +07 client backend[295957] pg_regress/object_address STATEMENT:  SELECT pg_get_object_address('subscription', '{one,two}', '{}');
2023-08-01 17:01:38.116 +07 client backend[295952] pg_regress/identity ERROR:  column "a" of relation "itest4" must be declared NOT NULL before identity can be added
2023-08-01 17:01:38.116 +07 client backend[295952] pg_regress/identity STATEMENT:  ALTER TABLE itest4 ALTER COLUMN a ADD GENERATED ALWAYS AS IDENTITY;
2023-08-01 17:01:38.119 +07 client backend[295951] pg_regress/collate ERROR:  collations are not supported by type integer
2023-08-01 17:01:38.119 +07 client backend[295951] pg_regress/collate STATEMENT:  CREATE DOMAIN testdomain_i AS int COLLATE "POSIX";
2023-08-01 17:01:38.121 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest2
2023-08-01 17:01:38.121 +07 client backend[295950] pg_regress/privileges STATEMENT:  SELECT * FROM atest2;
2023-08-01 17:01:38.122 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest1
2023-08-01 17:01:38.122 +07 client backend[295950] pg_regress/privileges STATEMENT:  INSERT INTO atest1 VALUES (2, 'two');
2023-08-01 17:01:38.122 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest2
2023-08-01 17:01:38.122 +07 client backend[295950] pg_regress/privileges STATEMENT:  INSERT INTO atest2 VALUES ('foo', true);
2023-08-01 17:01:38.123 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest1
2023-08-01 17:01:38.123 +07 client backend[295950] pg_regress/privileges STATEMENT:  INSERT INTO atest1 SELECT 1, b FROM atest1;
2023-08-01 17:01:38.125 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest1
2023-08-01 17:01:38.125 +07 client backend[295950] pg_regress/privileges STATEMENT:  UPDATE atest1 SET a = 1 WHERE a = 2;
2023-08-01 17:01:38.125 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest2
2023-08-01 17:01:38.125 +07 client backend[295950] pg_regress/privileges STATEMENT:  UPDATE atest2 SET col2 = NOT col2;
2023-08-01 17:01:38.125 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest1
2023-08-01 17:01:38.125 +07 client backend[295950] pg_regress/privileges STATEMENT:  SELECT * FROM atest1 FOR UPDATE;
2023-08-01 17:01:38.125 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest2
2023-08-01 17:01:38.125 +07 client backend[295950] pg_regress/privileges STATEMENT:  SELECT * FROM atest2 FOR UPDATE;
2023-08-01 17:01:38.125 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest2
2023-08-01 17:01:38.125 +07 client backend[295950] pg_regress/privileges STATEMENT:  DELETE FROM atest2;
2023-08-01 17:01:38.126 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest2
2023-08-01 17:01:38.126 +07 client backend[295950] pg_regress/privileges STATEMENT:  TRUNCATE atest2;
2023-08-01 17:01:38.126 +07 client backend[295952] pg_regress/identity ERROR:  column "a" of relation "itest4" is an identity column
2023-08-01 17:01:38.126 +07 client backend[295952] pg_regress/identity STATEMENT:  ALTER TABLE itest4 ALTER COLUMN a DROP NOT NULL;
2023-08-01 17:01:38.127 +07 client backend[295952] pg_regress/identity ERROR:  column "a" of relation "itest4" is already an identity column
2023-08-01 17:01:38.127 +07 client backend[295952] pg_regress/identity STATEMENT:  ALTER TABLE itest4 ALTER COLUMN a ADD GENERATED ALWAYS AS IDENTITY;
2023-08-01 17:01:38.128 +07 client backend[295952] pg_regress/identity ERROR:  identity column type must be smallint, integer, or bigint
2023-08-01 17:01:38.128 +07 client backend[295952] pg_regress/identity STATEMENT:  ALTER TABLE itest4 ALTER COLUMN b ADD GENERATED ALWAYS AS IDENTITY;
2023-08-01 17:01:38.129 +07 client backend[295952] pg_regress/identity ERROR:  identity column type must be smallint, integer, or bigint
2023-08-01 17:01:38.129 +07 client backend[295952] pg_regress/identity STATEMENT:  CREATE TABLE itest_err_1 (a text generated by default as identity);
2023-08-01 17:01:38.129 +07 client backend[295952] pg_regress/identity ERROR:  multiple identity specifications for column "a" of table "itest_err_2" at character 62
2023-08-01 17:01:38.129 +07 client backend[295952] pg_regress/identity STATEMENT:  CREATE TABLE itest_err_2 (a int generated always as identity generated by default as identity);
2023-08-01 17:01:38.129 +07 client backend[295952] pg_regress/identity ERROR:  both default and identity specified for column "a" of table "itest_err_3" at character 43
2023-08-01 17:01:38.129 +07 client backend[295952] pg_regress/identity STATEMENT:  CREATE TABLE itest_err_3 (a int default 5 generated by default as identity);
2023-08-01 17:01:38.129 +07 client backend[295952] pg_regress/identity ERROR:  both default and identity specified for column "a" of table "itest_err_4"
2023-08-01 17:01:38.129 +07 client backend[295952] pg_regress/identity STATEMENT:  CREATE TABLE itest_err_4 (a serial generated by default as identity);
2023-08-01 17:01:38.132 +07 client backend[295952] pg_regress/identity ERROR:  cannot insert into column "a"
2023-08-01 17:01:38.132 +07 client backend[295952] pg_regress/identity DETAIL:  Column "a" is an identity column defined as GENERATED ALWAYS.
2023-08-01 17:01:38.132 +07 client backend[295952] pg_regress/identity HINT:  Use OVERRIDING SYSTEM VALUE to override.
2023-08-01 17:01:38.132 +07 client backend[295952] pg_regress/identity STATEMENT:  INSERT INTO itest2 VALUES (10, 'xyz');
2023-08-01 17:01:38.133 +07 client backend[295952] pg_regress/identity ERROR:  column "a" can only be updated to DEFAULT
2023-08-01 17:01:38.133 +07 client backend[295952] pg_regress/identity DETAIL:  Column "a" is an identity column defined as GENERATED ALWAYS.
2023-08-01 17:01:38.133 +07 client backend[295952] pg_regress/identity STATEMENT:  UPDATE itest2 SET a = 101 WHERE a = 1;
2023-08-01 17:01:38.136 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest2
2023-08-01 17:01:38.136 +07 client backend[295950] pg_regress/privileges STATEMENT:  COPY atest2 FROM stdin;
2023-08-01 17:01:38.136 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest2
2023-08-01 17:01:38.136 +07 client backend[295950] pg_regress/privileges STATEMENT:  SELECT * FROM atest1 WHERE ( b IN ( SELECT col1 FROM atest2 ) );
2023-08-01 17:01:38.137 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest2
2023-08-01 17:01:38.137 +07 client backend[295950] pg_regress/privileges STATEMENT:  SELECT * FROM atest2 WHERE ( col1 IN ( SELECT b FROM atest1 ) );
2023-08-01 17:01:38.142 +07 client backend[295952] pg_regress/identity ERROR:  column "a" of relation "itest4" is not an identity column
2023-08-01 17:01:38.142 +07 client backend[295952] pg_regress/identity STATEMENT:  ALTER TABLE itest4 ALTER COLUMN a DROP IDENTITY;
2023-08-01 17:01:38.142 +07 client backend[295952] pg_regress/identity ERROR:  null value in column "a" of relation "itest4" violates not-null constraint
2023-08-01 17:01:38.142 +07 client backend[295952] pg_regress/identity DETAIL:  Failing row contains (null, ).
2023-08-01 17:01:38.142 +07 client backend[295952] pg_regress/identity STATEMENT:  INSERT INTO itest4 DEFAULT VALUES;
2023-08-01 17:01:38.143 +07 client backend[295952] pg_regress/identity ERROR:  relation "itest4_a_seq" does not exist at character 27
2023-08-01 17:01:38.143 +07 client backend[295952] pg_regress/identity STATEMENT:  SELECT sequence_name FROM itest4_a_seq;
2023-08-01 17:01:38.147 +07 client backend[295959] pg_regress/lock ERROR:  permission denied for table lock_tbl2
2023-08-01 17:01:38.147 +07 client backend[295959] pg_regress/lock STATEMENT:  LOCK TABLE lock_tbl2;
2023-08-01 17:01:38.150 +07 client backend[295952] pg_regress/identity ERROR:  cannot insert into column "a"
2023-08-01 17:01:38.150 +07 client backend[295952] pg_regress/identity DETAIL:  Column "a" is an identity column defined as GENERATED ALWAYS.
2023-08-01 17:01:38.150 +07 client backend[295952] pg_regress/identity HINT:  Use OVERRIDING SYSTEM VALUE to override.
2023-08-01 17:01:38.150 +07 client backend[295952] pg_regress/identity STATEMENT:  INSERT INTO itestv11 VALUES (10, 'xyz');
2023-08-01 17:01:38.155 +07 client backend[295956] pg_regress/generated ERROR:  multiple generation clauses specified for column "b" of table "gtest_err_1" at character 87
2023-08-01 17:01:38.155 +07 client backend[295956] pg_regress/generated STATEMENT:  CREATE TABLE gtest_err_1 (a int PRIMARY KEY, b int GENERATED ALWAYS AS (a * 2) STORED GENERATED ALWAYS AS (a * 3) STORED);
2023-08-01 17:01:38.155 +07 client backend[295952] pg_regress/identity ERROR:  column "a" of relation "itest1" is an identity column
2023-08-01 17:01:38.155 +07 client backend[295952] pg_regress/identity STATEMENT:  ALTER TABLE itest1 ALTER COLUMN a SET DEFAULT 1;
2023-08-01 17:01:38.157 +07 client backend[295956] pg_regress/generated ERROR:  cannot use generated column "b" in column generation expression at character 74
2023-08-01 17:01:38.157 +07 client backend[295956] pg_regress/generated DETAIL:  A generated column cannot reference another generated column.
2023-08-01 17:01:38.157 +07 client backend[295956] pg_regress/generated STATEMENT:  CREATE TABLE gtest_err_2a (a int PRIMARY KEY, b int GENERATED ALWAYS AS (b * 2) STORED);
2023-08-01 17:01:38.159 +07 client backend[295955] pg_regress/rowsecurity ERROR:  unrecognized row security option "ugly" at character 33
2023-08-01 17:01:38.159 +07 client backend[295955] pg_regress/rowsecurity HINT:  Only PERMISSIVE or RESTRICTIVE policies are supported currently.
2023-08-01 17:01:38.159 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  CREATE POLICY p1 ON document AS UGLY
	    USING (dlevel <= (SELECT seclv FROM uaccount WHERE pguser = current_user));
2023-08-01 17:01:38.160 +07 client backend[295956] pg_regress/generated ERROR:  cannot use generated column "b" in column generation expression at character 116
2023-08-01 17:01:38.160 +07 client backend[295956] pg_regress/generated DETAIL:  A generated column cannot reference another generated column.
2023-08-01 17:01:38.160 +07 client backend[295956] pg_regress/generated STATEMENT:  CREATE TABLE gtest_err_2b (a int PRIMARY KEY, b int GENERATED ALWAYS AS (a * 2) STORED, c int GENERATED ALWAYS AS (b * 3) STORED);
2023-08-01 17:01:38.164 +07 client backend[295956] pg_regress/generated ERROR:  column "c" does not exist at character 73
2023-08-01 17:01:38.164 +07 client backend[295956] pg_regress/generated STATEMENT:  CREATE TABLE gtest_err_3 (a int PRIMARY KEY, b int GENERATED ALWAYS AS (c * 2) STORED);
2023-08-01 17:01:38.165 +07 client backend[295949] pg_regress/groupingsets ERROR:  aggregate functions are not allowed in FROM clause of their own query level at character 69
2023-08-01 17:01:38.165 +07 client backend[295949] pg_regress/groupingsets STATEMENT:  select *
	  from (values (1),(2)) v(x),
	       lateral (select a, b, sum(v.x) from gstest_data(v.x) group by rollup (a,b)) s;
2023-08-01 17:01:38.166 +07 client backend[295956] pg_regress/generated ERROR:  generation expression is not immutable
2023-08-01 17:01:38.166 +07 client backend[295956] pg_regress/generated STATEMENT:  CREATE TABLE gtest_err_4 (a int PRIMARY KEY, b double precision GENERATED ALWAYS AS (random()) STORED);
2023-08-01 17:01:38.167 +07 client backend[295956] pg_regress/generated ERROR:  both default and generation expression specified for column "b" of table "gtest_err_5a" at character 63
2023-08-01 17:01:38.167 +07 client backend[295956] pg_regress/generated STATEMENT:  CREATE TABLE gtest_err_5a (a int PRIMARY KEY, b int DEFAULT 5 GENERATED ALWAYS AS (a * 2) STORED);
2023-08-01 17:01:38.167 +07 client backend[295956] pg_regress/generated ERROR:  both identity and generation expression specified for column "b" of table "gtest_err_5b" at character 82
2023-08-01 17:01:38.167 +07 client backend[295956] pg_regress/generated STATEMENT:  CREATE TABLE gtest_err_5b (a int PRIMARY KEY, b int GENERATED ALWAYS AS identity GENERATED ALWAYS AS (a * 2) STORED);
2023-08-01 17:01:38.168 +07 client backend[295956] pg_regress/generated ERROR:  cannot use system column "xmin" in column generation expression at character 75
2023-08-01 17:01:38.168 +07 client backend[295956] pg_regress/generated STATEMENT:  CREATE TABLE gtest_err_6a (a int PRIMARY KEY, b bool GENERATED ALWAYS AS (xmin <> 37) STORED);
2023-08-01 17:01:38.168 +07 client backend[295956] pg_regress/generated ERROR:  aggregate functions are not allowed in column generation expressions at character 74
2023-08-01 17:01:38.168 +07 client backend[295956] pg_regress/generated STATEMENT:  CREATE TABLE gtest_err_7a (a int PRIMARY KEY, b int GENERATED ALWAYS AS (avg(a)) STORED);
2023-08-01 17:01:38.169 +07 client backend[295956] pg_regress/generated ERROR:  window functions are not allowed in column generation expressions at character 74
2023-08-01 17:01:38.169 +07 client backend[295956] pg_regress/generated STATEMENT:  CREATE TABLE gtest_err_7b (a int PRIMARY KEY, b int GENERATED ALWAYS AS (row_number() OVER (ORDER BY a)) STORED);
2023-08-01 17:01:38.169 +07 client backend[295956] pg_regress/generated ERROR:  cannot use subquery in column generation expression at character 74
2023-08-01 17:01:38.169 +07 client backend[295956] pg_regress/generated STATEMENT:  CREATE TABLE gtest_err_7c (a int PRIMARY KEY, b int GENERATED ALWAYS AS ((SELECT a)) STORED);
2023-08-01 17:01:38.169 +07 client backend[295956] pg_regress/generated ERROR:  set-returning functions are not allowed in column generation expressions at character 74
2023-08-01 17:01:38.169 +07 client backend[295956] pg_regress/generated STATEMENT:  CREATE TABLE gtest_err_7d (a int PRIMARY KEY, b int GENERATED ALWAYS AS (generate_series(1, a)) STORED);
2023-08-01 17:01:38.170 +07 client backend[295956] pg_regress/generated ERROR:  for a generated column, GENERATED ALWAYS must be specified at character 62
2023-08-01 17:01:38.170 +07 client backend[295956] pg_regress/generated STATEMENT:  CREATE TABLE gtest_err_8 (a int PRIMARY KEY, b int GENERATED BY DEFAULT AS (a * 2) STORED);
2023-08-01 17:01:38.170 +07 client backend[295952] pg_regress/identity ERROR:  column "a" of relation "itest5" already has a default value
2023-08-01 17:01:38.170 +07 client backend[295952] pg_regress/identity STATEMENT:  ALTER TABLE itest5 ALTER COLUMN a ADD GENERATED ALWAYS AS IDENTITY;
2023-08-01 17:01:38.177 +07 client backend[295946] pg_regress/matview ERROR:  cannot refresh materialized view "public.mvtest_tvmm" concurrently
2023-08-01 17:01:38.177 +07 client backend[295946] pg_regress/matview HINT:  Create a unique index with no WHERE clause on one or more columns of the materialized view.
2023-08-01 17:01:38.177 +07 client backend[295946] pg_regress/matview STATEMENT:  REFRESH MATERIALIZED VIEW CONCURRENTLY mvtest_tvmm;
2023-08-01 17:01:38.177 +07 client backend[295952] pg_regress/identity ERROR:  identity column type must be smallint, integer, or bigint
2023-08-01 17:01:38.177 +07 client backend[295952] pg_regress/identity STATEMENT:  ALTER TABLE itest3 ALTER COLUMN a TYPE text;
2023-08-01 17:01:38.178 +07 client backend[295956] pg_regress/generated ERROR:  cannot insert into column "b"
2023-08-01 17:01:38.178 +07 client backend[295956] pg_regress/generated DETAIL:  Column "b" is a generated column.
2023-08-01 17:01:38.178 +07 client backend[295956] pg_regress/generated STATEMENT:  INSERT INTO gtest1 VALUES (3, 33);
2023-08-01 17:01:38.181 +07 client backend[295956] pg_regress/generated ERROR:  column "b" can only be updated to DEFAULT
2023-08-01 17:01:38.181 +07 client backend[295956] pg_regress/generated DETAIL:  Column "b" is a generated column.
2023-08-01 17:01:38.181 +07 client backend[295956] pg_regress/generated STATEMENT:  UPDATE gtest1 SET b = 11 WHERE a = 1;
2023-08-01 17:01:38.182 +07 client backend[295946] pg_regress/matview ERROR:  CONCURRENTLY and WITH NO DATA options cannot be used together
2023-08-01 17:01:38.182 +07 client backend[295946] pg_regress/matview STATEMENT:  REFRESH MATERIALIZED VIEW CONCURRENTLY mvtest_tvmm WITH NO DATA;
2023-08-01 17:01:38.182 +07 client backend[295946] pg_regress/matview ERROR:  cannot lock rows in materialized view "mvtest_tvvm"
2023-08-01 17:01:38.182 +07 client backend[295946] pg_regress/matview STATEMENT:  SELECT * FROM mvtest_tvvm FOR SHARE;
2023-08-01 17:01:38.183 +07 client backend[295956] pg_regress/generated ERROR:  integer out of range
2023-08-01 17:01:38.183 +07 client backend[295956] pg_regress/generated STATEMENT:  INSERT INTO gtest1 VALUES (2000000000);
2023-08-01 17:01:38.185 +07 client backend[295949] pg_regress/groupingsets ERROR:  arguments to GROUPING must be grouping expressions of the associated query level at character 25
2023-08-01 17:01:38.185 +07 client backend[295949] pg_regress/groupingsets STATEMENT:  select (select grouping(a,b) from gstest2) from gstest2 group by a,b;
2023-08-01 17:01:38.191 +07 client backend[295952] pg_regress/identity ERROR:  column "b" of relation "itest6" is not an identity column
2023-08-01 17:01:38.191 +07 client backend[295952] pg_regress/identity STATEMENT:  ALTER TABLE itest6 ALTER COLUMN b SET INCREMENT BY 2;
2023-08-01 17:01:38.191 +07 client backend[295952] pg_regress/identity ERROR:  cannot change ownership of identity sequence
2023-08-01 17:01:38.191 +07 client backend[295952] pg_regress/identity DETAIL:  Sequence "itest6_a_seq" is linked to table "itest6".
2023-08-01 17:01:38.191 +07 client backend[295952] pg_regress/identity STATEMENT:  ALTER SEQUENCE itest6_a_seq OWNED BY NONE;
2023-08-01 17:01:38.195 +07 client backend[295953] pg_regress/tablesample ERROR:  tablesample method foobar does not exist at character 45
2023-08-01 17:01:38.195 +07 client backend[295953] pg_regress/tablesample STATEMENT:  SELECT id FROM test_tablesample TABLESAMPLE FOOBAR (1);
2023-08-01 17:01:38.195 +07 client backend[295953] pg_regress/tablesample ERROR:  TABLESAMPLE parameter cannot be null
2023-08-01 17:01:38.195 +07 client backend[295953] pg_regress/tablesample STATEMENT:  SELECT id FROM test_tablesample TABLESAMPLE SYSTEM (NULL);
2023-08-01 17:01:38.196 +07 client backend[295953] pg_regress/tablesample ERROR:  TABLESAMPLE REPEATABLE parameter cannot be null
2023-08-01 17:01:38.196 +07 client backend[295953] pg_regress/tablesample STATEMENT:  SELECT id FROM test_tablesample TABLESAMPLE SYSTEM (50) REPEATABLE (NULL);
2023-08-01 17:01:38.196 +07 client backend[295953] pg_regress/tablesample ERROR:  sample percentage must be between 0 and 100
2023-08-01 17:01:38.196 +07 client backend[295953] pg_regress/tablesample STATEMENT:  SELECT id FROM test_tablesample TABLESAMPLE BERNOULLI (-1);
2023-08-01 17:01:38.197 +07 client backend[295949] pg_regress/groupingsets ERROR:  could not implement GROUP BY
2023-08-01 17:01:38.197 +07 client backend[295949] pg_regress/groupingsets DETAIL:  Some of the datatypes only support hashing, while others only support sorting.
2023-08-01 17:01:38.197 +07 client backend[295949] pg_regress/groupingsets STATEMENT:  select count(*) from gstest4 group by rollup(unhashable_col,unsortable_col);
2023-08-01 17:01:38.197 +07 client backend[295952] pg_regress/identity ERROR:  cannot recursively add identity column to table that has child tables
2023-08-01 17:01:38.197 +07 client backend[295952] pg_regress/identity STATEMENT:  ALTER TABLE itest7d ADD COLUMN b int GENERATED ALWAYS AS IDENTITY;
2023-08-01 17:01:38.197 +07 client backend[295949] pg_regress/groupingsets ERROR:  could not implement GROUP BY
2023-08-01 17:01:38.197 +07 client backend[295949] pg_regress/groupingsets DETAIL:  Some of the datatypes only support hashing, while others only support sorting.
2023-08-01 17:01:38.197 +07 client backend[295949] pg_regress/groupingsets STATEMENT:  select array_agg(v order by v) from gstest4 group by grouping sets ((id,unsortable_col),(id));
2023-08-01 17:01:38.197 +07 client backend[295953] pg_regress/tablesample ERROR:  sample percentage must be between 0 and 100
2023-08-01 17:01:38.197 +07 client backend[295953] pg_regress/tablesample STATEMENT:  SELECT id FROM test_tablesample TABLESAMPLE BERNOULLI (200);
2023-08-01 17:01:38.197 +07 client backend[295953] pg_regress/tablesample ERROR:  sample percentage must be between 0 and 100
2023-08-01 17:01:38.197 +07 client backend[295953] pg_regress/tablesample STATEMENT:  SELECT id FROM test_tablesample TABLESAMPLE SYSTEM (-1);
2023-08-01 17:01:38.197 +07 client backend[295953] pg_regress/tablesample ERROR:  sample percentage must be between 0 and 100
2023-08-01 17:01:38.197 +07 client backend[295953] pg_regress/tablesample STATEMENT:  SELECT id FROM test_tablesample TABLESAMPLE SYSTEM (200);
2023-08-01 17:01:38.198 +07 client backend[295953] pg_regress/tablesample ERROR:  TABLESAMPLE clause can only be applied to tables and materialized views at character 16
2023-08-01 17:01:38.198 +07 client backend[295953] pg_regress/tablesample STATEMENT:  SELECT id FROM test_tablesample_v1 TABLESAMPLE BERNOULLI (1);
2023-08-01 17:01:38.198 +07 client backend[295953] pg_regress/tablesample ERROR:  cannot insert into view "test_tablesample_v1"
2023-08-01 17:01:38.198 +07 client backend[295953] pg_regress/tablesample DETAIL:  Views containing TABLESAMPLE are not automatically updatable.
2023-08-01 17:01:38.198 +07 client backend[295953] pg_regress/tablesample HINT:  To enable inserting into the view, provide an INSTEAD OF INSERT trigger or an unconditional ON INSERT DO INSTEAD rule.
2023-08-01 17:01:38.198 +07 client backend[295953] pg_regress/tablesample STATEMENT:  INSERT INTO test_tablesample_v1 VALUES(1);
2023-08-01 17:01:38.198 +07 client backend[295953] pg_regress/tablesample ERROR:  TABLESAMPLE clause can only be applied to tables and materialized views at character 69
2023-08-01 17:01:38.198 +07 client backend[295953] pg_regress/tablesample STATEMENT:  WITH query_select AS (SELECT * FROM test_tablesample)
	SELECT * FROM query_select TABLESAMPLE BERNOULLI (5.5) REPEATABLE (1);
2023-08-01 17:01:38.199 +07 client backend[295953] pg_regress/tablesample ERROR:  syntax error at or near "TABLESAMPLE" at character 55
2023-08-01 17:01:38.199 +07 client backend[295953] pg_regress/tablesample STATEMENT:  SELECT q.* FROM (SELECT * FROM test_tablesample) as q TABLESAMPLE BERNOULLI (5);
2023-08-01 17:01:38.200 +07 client backend[295946] pg_regress/matview ERROR:  cannot drop table mvtest_t because other objects depend on it
2023-08-01 17:01:38.200 +07 client backend[295946] pg_regress/matview DETAIL:  view mvtest_tv depends on table mvtest_t
	materialized view mvtest_mvschema.mvtest_tvm depends on view mvtest_tv
	materialized view mvtest_tvmm depends on materialized view mvtest_mvschema.mvtest_tvm
	view mvtest_tvv depends on view mvtest_tv
	materialized view mvtest_tvvm depends on view mvtest_tvv
	view mvtest_tvvmv depends on materialized view mvtest_tvvm
	materialized view mvtest_bb depends on view mvtest_tvvmv
	materialized view mvtest_tm depends on table mvtest_t
	materialized view mvtest_tmm depends on materialized view mvtest_tm
2023-08-01 17:01:38.200 +07 client backend[295946] pg_regress/matview HINT:  Use DROP ... CASCADE to drop the dependent objects too.
2023-08-01 17:01:38.200 +07 client backend[295946] pg_regress/matview STATEMENT:  DROP TABLE mvtest_t;
2023-08-01 17:01:38.204 +07 client backend[295955] pg_regress/rowsecurity ERROR:  new row violates row-level security policy "p1r" for table "document"
2023-08-01 17:01:38.204 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  INSERT INTO document VALUES (100, 44, 1, 'regress_rls_dave', 'testing sorting of policies');
2023-08-01 17:01:38.204 +07 client backend[295955] pg_regress/rowsecurity ERROR:  new row violates row-level security policy "p2r" for table "document"
2023-08-01 17:01:38.204 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  INSERT INTO document VALUES (100, 55, 1, 'regress_rls_dave', 'testing sorting of policies');
2023-08-01 17:01:38.204 +07 client backend[295955] pg_regress/rowsecurity ERROR:  must be owner of table document
2023-08-01 17:01:38.204 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  ALTER POLICY p1 ON document USING (true);
2023-08-01 17:01:38.204 +07 client backend[295955] pg_regress/rowsecurity ERROR:  must be owner of relation document
2023-08-01 17:01:38.204 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  DROP POLICY p1 ON document;
2023-08-01 17:01:38.207 +07 client backend[295955] pg_regress/rowsecurity ERROR:  update or delete on table "category" violates foreign key constraint "document_cid_fkey" on table "document"
2023-08-01 17:01:38.207 +07 client backend[295955] pg_regress/rowsecurity DETAIL:  Key is still referenced from table "document".
2023-08-01 17:01:38.207 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  DELETE FROM category WHERE cid = 33;
2023-08-01 17:01:38.208 +07 client backend[295955] pg_regress/rowsecurity ERROR:  duplicate key value violates unique constraint "document_pkey"
2023-08-01 17:01:38.208 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  INSERT INTO document VALUES (8, 44, 1, 'regress_rls_bob', 'my third manga');
2023-08-01 17:01:38.208 +07 client backend[295955] pg_regress/rowsecurity ERROR:  new row violates row-level security policy for table "document"
2023-08-01 17:01:38.208 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  INSERT INTO document VALUES (8, 44, 1, 'regress_rls_carol', 'my third manga');
2023-08-01 17:01:38.208 +07 client backend[295955] pg_regress/rowsecurity ERROR:  new row violates row-level security policy for table "document"
2023-08-01 17:01:38.208 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  UPDATE document SET did = 8, dauthor = 'regress_rls_carol' WHERE did = 5;
2023-08-01 17:01:38.209 +07 client backend[295949] pg_regress/groupingsets ERROR:  aggregate functions are not allowed in FROM clause of their own query level at character 69
2023-08-01 17:01:38.209 +07 client backend[295949] pg_regress/groupingsets STATEMENT:  select *
	  from (values (1),(2)) v(x),
	       lateral (select a, b, sum(v.x) from gstest_data(v.x) group by grouping sets (a,b)) s;
2023-08-01 17:01:38.209 +07 client backend[295949] pg_regress/groupingsets ERROR:  aggregate functions are not allowed in FROM clause of their own query level at character 95
2023-08-01 17:01:38.209 +07 client backend[295949] pg_regress/groupingsets STATEMENT:  explain (costs off)
	  select *
	    from (values (1),(2)) v(x),
	         lateral (select a, b, sum(v.x) from gstest_data(v.x) group by grouping sets (a,b)) s;
2023-08-01 17:01:38.216 +07 client backend[295956] pg_regress/generated ERROR:  cannot insert into column "b"
2023-08-01 17:01:38.216 +07 client backend[295956] pg_regress/generated DETAIL:  Column "b" is a generated column.
2023-08-01 17:01:38.216 +07 client backend[295956] pg_regress/generated STATEMENT:  INSERT INTO gtest1v VALUES (4, 8);
2023-08-01 17:01:38.224 +07 client backend[295946] pg_regress/matview ERROR:  could not create unique index "mvtest_mv_a_idx"
2023-08-01 17:01:38.224 +07 client backend[295946] pg_regress/matview DETAIL:  Key (a)=(1) is duplicated.
2023-08-01 17:01:38.224 +07 client backend[295946] pg_regress/matview STATEMENT:  REFRESH MATERIALIZED VIEW mvtest_mv;
2023-08-01 17:01:38.225 +07 client backend[295946] pg_regress/matview ERROR:  new data for materialized view "mvtest_mv" contains duplicate rows without any null columns
2023-08-01 17:01:38.225 +07 client backend[295946] pg_regress/matview DETAIL:  Row: (1,10)
2023-08-01 17:01:38.225 +07 client backend[295946] pg_regress/matview STATEMENT:  REFRESH MATERIALIZED VIEW CONCURRENTLY mvtest_mv;
2023-08-01 17:01:38.225 +07 client backend[295952] pg_regress/identity ERROR:  column "f22" of relation "itest8" contains null values
2023-08-01 17:01:38.225 +07 client backend[295952] pg_regress/identity STATEMENT:  ALTER TABLE itest8
	  ADD COLUMN f22 int NOT NULL,
	  ALTER COLUMN f22 ADD GENERATED ALWAYS AS IDENTITY;
2023-08-01 17:01:38.226 +07 client backend[295949] pg_regress/groupingsets LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295949.0", size 598016
2023-08-01 17:01:38.226 +07 client backend[295949] pg_regress/groupingsets STATEMENT:  select * from
	  (values (1),(2)) v(a),
	  lateral (select a, i, j, count(*) from
	             bug_16784 group by cube(i,j)) s
	  order by v.a, i, j;
2023-08-01 17:01:38.228 +07 client backend[295949] pg_regress/groupingsets LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295949.1", size 598016
2023-08-01 17:01:38.228 +07 client backend[295949] pg_regress/groupingsets STATEMENT:  select * from
	  (values (1),(2)) v(a),
	  lateral (select a, i, j, count(*) from
	             bug_16784 group by cube(i,j)) s
	  order by v.a, i, j;
2023-08-01 17:01:38.236 +07 client backend[295952] pg_regress/identity ERROR:  identity columns are not supported on typed tables
2023-08-01 17:01:38.236 +07 client backend[295952] pg_regress/identity STATEMENT:  CREATE TABLE itest12 OF itest_type (f1 WITH OPTIONS GENERATED ALWAYS AS IDENTITY);
2023-08-01 17:01:38.237 +07 client backend[295952] pg_regress/identity ERROR:  identity columns are not supported on partitions
2023-08-01 17:01:38.237 +07 client backend[295952] pg_regress/identity STATEMENT:  CREATE TABLE itest_child PARTITION OF itest_parent (
	    f3 WITH OPTIONS GENERATED ALWAYS AS IDENTITY
	) FOR VALUES FROM ('2016-07-01') TO ('2016-08-01');
2023-08-01 17:01:38.243 +07 client backend[295946] pg_regress/matview ERROR:  too many column names were specified
2023-08-01 17:01:38.243 +07 client backend[295946] pg_regress/matview STATEMENT:  CREATE MATERIALIZED VIEW mvtest_mv_v (ii, jj, kk) AS SELECT i, j FROM mvtest_v;
2023-08-01 17:01:38.244 +07 client backend[295946] pg_regress/matview ERROR:  too many column names were specified
2023-08-01 17:01:38.244 +07 client backend[295946] pg_regress/matview STATEMENT:  CREATE MATERIALIZED VIEW mvtest_mv_v_3 (ii, jj, kk) AS SELECT i, j FROM mvtest_v WITH NO DATA;
2023-08-01 17:01:38.246 +07 client backend[295956] pg_regress/generated ERROR:  child column "b" specifies generation expression
2023-08-01 17:01:38.246 +07 client backend[295956] pg_regress/generated HINT:  Omit the generation expression in the definition of the child table column to inherit the generation expression from the parent table.
2023-08-01 17:01:38.246 +07 client backend[295956] pg_regress/generated STATEMENT:  CREATE TABLE gtestx (x int, b int GENERATED ALWAYS AS (a * 22) STORED) INHERITS (gtest1);
2023-08-01 17:01:38.246 +07 client backend[295956] pg_regress/generated ERROR:  column "b" inherits from generated column but specifies default
2023-08-01 17:01:38.246 +07 client backend[295956] pg_regress/generated STATEMENT:  CREATE TABLE gtestx (x int, b int DEFAULT 10) INHERITS (gtest1);
2023-08-01 17:01:38.246 +07 client backend[295956] pg_regress/generated ERROR:  column "b" inherits from generated column but specifies identity
2023-08-01 17:01:38.246 +07 client backend[295956] pg_regress/generated STATEMENT:  CREATE TABLE gtestx (x int, b int GENERATED ALWAYS AS IDENTITY) INHERITS (gtest1);
2023-08-01 17:01:38.247 +07 client backend[295956] pg_regress/generated ERROR:  inherited column "b" has a generation conflict
2023-08-01 17:01:38.247 +07 client backend[295956] pg_regress/generated STATEMENT:  CREATE TABLE gtest1_2 () INHERITS (gtest1, gtesty);
2023-08-01 17:01:38.248 +07 client backend[295956] pg_regress/generated ERROR:  column "b" inherits conflicting generation expressions
2023-08-01 17:01:38.248 +07 client backend[295956] pg_regress/generated STATEMENT:  CREATE TABLE gtest1_2 () INHERITS (gtest1, gtesty);
2023-08-01 17:01:38.249 +07 client backend[295956] pg_regress/generated ERROR:  inherited column "b" has a generation conflict
2023-08-01 17:01:38.249 +07 client backend[295956] pg_regress/generated STATEMENT:  CREATE TABLE gtest1_2 () INHERITS (gtest0, gtesty);
2023-08-01 17:01:38.251 +07 client backend[295951] pg_regress/collate ERROR:  collation mismatch between explicit collations "C" and "POSIX" at character 36
2023-08-01 17:01:38.251 +07 client backend[295951] pg_regress/collate STATEMENT:  SELECT string_agg(x COLLATE "C", y COLLATE "POSIX") FROM collate_test10;
2023-08-01 17:01:38.252 +07 client backend[295951] pg_regress/collate ERROR:  collation mismatch between implicit collations "C" and "POSIX" at character 32
2023-08-01 17:01:38.252 +07 client backend[295951] pg_regress/collate HINT:  You can choose the collation by applying the COLLATE clause to one or both expressions.
2023-08-01 17:01:38.252 +07 client backend[295951] pg_regress/collate STATEMENT:  SELECT array_agg(a ORDER BY x||y) FROM collate_test10;
2023-08-01 17:01:38.253 +07 client backend[295951] pg_regress/collate ERROR:  could not determine which collation to use for string comparison
2023-08-01 17:01:38.253 +07 client backend[295951] pg_regress/collate HINT:  Use the COLLATE clause to set the collation explicitly.
2023-08-01 17:01:38.253 +07 client backend[295951] pg_regress/collate STATEMENT:  SELECT a, b FROM collate_test1 UNION ALL SELECT a, b FROM collate_test2 ORDER BY 2;
2023-08-01 17:01:38.253 +07 client backend[295951] pg_regress/collate ERROR:  collation mismatch between implicit collations "C" and "POSIX" at character 48
2023-08-01 17:01:38.253 +07 client backend[295951] pg_regress/collate HINT:  You can choose the collation by applying the COLLATE clause to one or both expressions.
2023-08-01 17:01:38.253 +07 client backend[295951] pg_regress/collate STATEMENT:  SELECT a, b FROM collate_test1 UNION SELECT a, b FROM collate_test2 ORDER BY 2;
2023-08-01 17:01:38.254 +07 client backend[295951] pg_regress/collate ERROR:  collation mismatch between implicit collations "C" and "POSIX" at character 52
2023-08-01 17:01:38.254 +07 client backend[295951] pg_regress/collate HINT:  You can choose the collation by applying the COLLATE clause to one or both expressions.
2023-08-01 17:01:38.254 +07 client backend[295951] pg_regress/collate STATEMENT:  SELECT a, b FROM collate_test1 INTERSECT SELECT a, b FROM collate_test2 ORDER BY 2;
2023-08-01 17:01:38.254 +07 client backend[295951] pg_regress/collate ERROR:  collation mismatch between implicit collations "C" and "POSIX" at character 49
2023-08-01 17:01:38.254 +07 client backend[295951] pg_regress/collate HINT:  You can choose the collation by applying the COLLATE clause to one or both expressions.
2023-08-01 17:01:38.254 +07 client backend[295951] pg_regress/collate STATEMENT:  SELECT a, b FROM collate_test1 EXCEPT SELECT a, b FROM collate_test2 ORDER BY 2;
2023-08-01 17:01:38.254 +07 client backend[295951] pg_regress/collate ERROR:  no collation was derived for column "b" with collatable type text
2023-08-01 17:01:38.254 +07 client backend[295951] pg_regress/collate HINT:  Use the COLLATE clause to set the collation explicitly.
2023-08-01 17:01:38.254 +07 client backend[295951] pg_regress/collate STATEMENT:  CREATE TABLE test_u AS SELECT a, b FROM collate_test1 UNION ALL SELECT a, b FROM collate_test2;
2023-08-01 17:01:38.254 +07 client backend[295951] pg_regress/collate ERROR:  could not determine which collation to use for string comparison
2023-08-01 17:01:38.254 +07 client backend[295951] pg_regress/collate HINT:  Use the COLLATE clause to set the collation explicitly.
2023-08-01 17:01:38.254 +07 client backend[295951] pg_regress/collate STATEMENT:  select x < y from collate_test10;
2023-08-01 17:01:38.254 +07 client backend[295951] pg_regress/collate ERROR:  collation mismatch between implicit collations "C" and "POSIX" at character 47
2023-08-01 17:01:38.254 +07 client backend[295951] pg_regress/collate HINT:  You can choose the collation by applying the COLLATE clause to one or both expressions.
2023-08-01 17:01:38.254 +07 client backend[295951] pg_regress/collate STATEMENT:  select x, y from collate_test10 order by x || y;
2023-08-01 17:01:38.254 +07 client backend[295951] pg_regress/collate ERROR:  recursive query "foo" column 1 has collation "C" in non-recursive term but collation "POSIX" overall at character 37
2023-08-01 17:01:38.254 +07 client backend[295951] pg_regress/collate HINT:  Use the COLLATE clause to set the collation of the non-recursive term.
2023-08-01 17:01:38.254 +07 client backend[295951] pg_regress/collate STATEMENT:  WITH RECURSIVE foo(x) AS
	   (SELECT x FROM (VALUES('a' COLLATE "C"),('b')) t(x)
	   UNION ALL
	   SELECT (x || 'c') COLLATE "POSIX" FROM foo WHERE length(x) < 10)
	SELECT * FROM foo;
2023-08-01 17:01:38.255 +07 client backend[295951] pg_regress/collate ERROR:  could not determine which collation to use for string hashing
2023-08-01 17:01:38.255 +07 client backend[295951] pg_regress/collate HINT:  Use the COLLATE clause to set the collation explicitly.
2023-08-01 17:01:38.255 +07 client backend[295951] pg_regress/collate STATEMENT:  SELECT * FROM collate_test10 WHERE (x, y) NOT IN (SELECT y, x FROM collate_test10);
2023-08-01 17:01:38.255 +07 client backend[295951] pg_regress/collate ERROR:  syntax error at or near "COLLATE" at character 26
2023-08-01 17:01:38.255 +07 client backend[295951] pg_regress/collate STATEMENT:  SELECT CAST('42' AS text COLLATE "C");
2023-08-01 17:01:38.258 +07 client backend[295951] pg_regress/collate ERROR:  collations are not supported by type integer
2023-08-01 17:01:38.258 +07 client backend[295951] pg_regress/collate STATEMENT:  CREATE INDEX collate_test1_idx5 ON collate_test1 (a COLLATE "POSIX");
2023-08-01 17:01:38.258 +07 client backend[295951] pg_regress/collate ERROR:  collations are not supported by type integer at character 54
2023-08-01 17:01:38.258 +07 client backend[295951] pg_regress/collate STATEMENT:  CREATE INDEX collate_test1_idx6 ON collate_test1 ((a COLLATE "POSIX"));
2023-08-01 17:01:38.261 +07 client backend[295956] pg_regress/generated ERROR:  column "b" is a generated column
2023-08-01 17:01:38.261 +07 client backend[295956] pg_regress/generated DETAIL:  Generated columns cannot be used in COPY.
2023-08-01 17:01:38.261 +07 client backend[295956] pg_regress/generated STATEMENT:  COPY gtest1 (a, b) TO stdout;
2023-08-01 17:01:38.261 +07 client backend[295956] pg_regress/generated ERROR:  column "b" is a generated column
2023-08-01 17:01:38.261 +07 client backend[295956] pg_regress/generated DETAIL:  Generated columns cannot be used in COPY.
2023-08-01 17:01:38.261 +07 client backend[295956] pg_regress/generated STATEMENT:  COPY gtest1 (a, b) FROM stdin;
2023-08-01 17:01:38.262 +07 client backend[295951] pg_regress/collate ERROR:  insert or update on table "collate_test21" violates foreign key constraint "collate_test21_f2_fkey"
2023-08-01 17:01:38.262 +07 client backend[295951] pg_regress/collate DETAIL:  Key (f2)=(baz) is not present in table "collate_test20".
2023-08-01 17:01:38.262 +07 client backend[295951] pg_regress/collate STATEMENT:  INSERT INTO collate_test21 VALUES ('baz');
2023-08-01 17:01:38.262 +07 client backend[295956] pg_regress/generated ERROR:  column "b" is a generated column
2023-08-01 17:01:38.262 +07 client backend[295956] pg_regress/generated DETAIL:  Generated columns cannot be used in COPY.
2023-08-01 17:01:38.262 +07 client backend[295956] pg_regress/generated STATEMENT:  COPY gtest3 (a, b) TO stdout;
2023-08-01 17:01:38.263 +07 client backend[295956] pg_regress/generated ERROR:  column "b" is a generated column
2023-08-01 17:01:38.263 +07 client backend[295956] pg_regress/generated DETAIL:  Generated columns cannot be used in COPY.
2023-08-01 17:01:38.263 +07 client backend[295956] pg_regress/generated STATEMENT:  COPY gtest3 (a, b) FROM stdin;
2023-08-01 17:01:38.263 +07 client backend[295946] pg_regress/matview ERROR:  division by zero
2023-08-01 17:01:38.263 +07 client backend[295946] pg_regress/matview STATEMENT:  create materialized view mvtest_error as select 1/0 as x;
2023-08-01 17:01:38.267 +07 client backend[295955] pg_regress/rowsecurity ERROR:  new row violates row-level security policy for table "part_document"
2023-08-01 17:01:38.267 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  INSERT INTO part_document VALUES (100, 11, 5, 'regress_rls_dave', 'testing pp1');
2023-08-01 17:01:38.268 +07 client backend[295955] pg_regress/rowsecurity ERROR:  new row violates row-level security policy "pp1r" for table "part_document"
2023-08-01 17:01:38.268 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  INSERT INTO part_document VALUES (100, 99, 1, 'regress_rls_dave', 'testing pp1r');
2023-08-01 17:01:38.268 +07 client backend[295955] pg_regress/rowsecurity ERROR:  new row violates row-level security policy "pp1r" for table "part_document"
2023-08-01 17:01:38.268 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  INSERT INTO part_document VALUES (100, 55, 1, 'regress_rls_dave', 'testing RLS with partitions');
2023-08-01 17:01:38.268 +07 client backend[295946] pg_regress/matview ERROR:  division by zero
2023-08-01 17:01:38.268 +07 client backend[295946] pg_regress/matview STATEMENT:  refresh materialized view mvtest_error;
2023-08-01 17:01:38.281 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest12
2023-08-01 17:01:38.281 +07 client backend[295950] pg_regress/privileges STATEMENT:  EXPLAIN (COSTS OFF) SELECT * FROM atest12 WHERE a >>> 0;
2023-08-01 17:01:38.281 +07 client backend[295955] pg_regress/rowsecurity ERROR:  new row violates row-level security policy for table "part_document_satire"
2023-08-01 17:01:38.281 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  INSERT INTO part_document_satire VALUES (101, 55, 1, 'regress_rls_dave', 'testing RLS with partitions');
2023-08-01 17:01:38.284 +07 client backend[295955] pg_regress/rowsecurity ERROR:  must be owner of table part_document
2023-08-01 17:01:38.284 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  ALTER POLICY pp1 ON part_document USING (true);
2023-08-01 17:01:38.284 +07 client backend[295955] pg_regress/rowsecurity ERROR:  must be owner of relation part_document
2023-08-01 17:01:38.284 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  DROP POLICY pp1 ON part_document;
2023-08-01 17:01:38.284 +07 client backend[295951] pg_regress/collate ERROR:  insert or update on table "collate_test22" violates foreign key constraint "collate_test22_f2_fkey"
2023-08-01 17:01:38.284 +07 client backend[295951] pg_regress/collate DETAIL:  Key (f2)=(baz) is not present in table "collate_test20".
2023-08-01 17:01:38.284 +07 client backend[295951] pg_regress/collate STATEMENT:  ALTER TABLE collate_test22 ADD FOREIGN KEY (f2) REFERENCES collate_test20;
2023-08-01 17:01:38.286 +07 client backend[295951] pg_regress/collate ERROR:  collation "default" cannot be copied
2023-08-01 17:01:38.286 +07 client backend[295951] pg_regress/collate STATEMENT:  CREATE COLLATION mycoll3 FROM "default";
2023-08-01 17:01:38.288 +07 client backend[295951] pg_regress/collate ERROR:  cannot drop collation mycoll2 because other objects depend on it
2023-08-01 17:01:38.288 +07 client backend[295951] pg_regress/collate DETAIL:  column f1 of table collate_test23 depends on collation mycoll2
2023-08-01 17:01:38.288 +07 client backend[295951] pg_regress/collate HINT:  Use DROP ... CASCADE to drop the dependent objects too.
2023-08-01 17:01:38.288 +07 client backend[295951] pg_regress/collate STATEMENT:  DROP COLLATION mycoll2;
2023-08-01 17:01:38.288 +07 client backend[295951] pg_regress/collate ERROR:  collation attribute "Lc_Collate" not recognized at character 29
2023-08-01 17:01:38.288 +07 client backend[295951] pg_regress/collate STATEMENT:  CREATE COLLATION case_coll ("Lc_Collate" = "POSIX", "Lc_Ctype" = "POSIX");
2023-08-01 17:01:38.289 +07 client backend[295951] pg_regress/collate ERROR:  collations are not supported by type integer
2023-08-01 17:01:38.289 +07 client backend[295951] pg_regress/collate STATEMENT:  SELECT collation for ((SELECT a FROM collate_test1 LIMIT 1));
2023-08-01 17:01:38.290 +07 client backend[295955] pg_regress/rowsecurity ERROR:  query would be affected by row-level security policy for table "part_document"
2023-08-01 17:01:38.290 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  SELECT * FROM part_document ORDER by did;
2023-08-01 17:01:38.290 +07 client backend[295955] pg_regress/rowsecurity ERROR:  query would be affected by row-level security policy for table "part_document_satire"
2023-08-01 17:01:38.290 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  SELECT * FROM part_document_satire ORDER by did;
2023-08-01 17:01:38.291 +07 client backend[295955] pg_regress/rowsecurity ERROR:  new row violates row-level security policy "pp3" for table "part_document"
2023-08-01 17:01:38.291 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  INSERT INTO part_document VALUES (100, 11, 5, 'regress_rls_carol', 'testing pp3');
2023-08-01 17:01:38.294 +07 client backend[295955] pg_regress/rowsecurity ERROR:  cannot drop table dependee because other objects depend on it
2023-08-01 17:01:38.294 +07 client backend[295955] pg_regress/rowsecurity DETAIL:  policy d1 on table dependent depends on table dependee
2023-08-01 17:01:38.294 +07 client backend[295955] pg_regress/rowsecurity HINT:  Use DROP ... CASCADE to drop the dependent objects too.
2023-08-01 17:01:38.294 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  DROP TABLE dependee;
2023-08-01 17:01:38.294 +07 client backend[295946] pg_regress/matview ERROR:  relation "mvtest_mv_foo" already exists
2023-08-01 17:01:38.294 +07 client backend[295946] pg_regress/matview STATEMENT:  CREATE MATERIALIZED VIEW mvtest_mv_foo AS SELECT * FROM mvtest_foo_data;
2023-08-01 17:01:38.296 +07 client backend[295955] pg_regress/rowsecurity ERROR:  infinite recursion detected in policy for relation "rec1"
2023-08-01 17:01:38.296 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  SELECT * FROM rec1;
2023-08-01 17:01:38.297 +07 client backend[295955] pg_regress/rowsecurity ERROR:  infinite recursion detected in policy for relation "rec1"
2023-08-01 17:01:38.297 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  SELECT * FROM rec1;
2023-08-01 17:01:38.299 +07 client backend[295955] pg_regress/rowsecurity ERROR:  infinite recursion detected in policy for relation "rec1"
2023-08-01 17:01:38.299 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  SELECT * FROM rec1;
2023-08-01 17:01:38.301 +07 client backend[295955] pg_regress/rowsecurity ERROR:  infinite recursion detected in policy for relation "rec1"
2023-08-01 17:01:38.301 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  SELECT * FROM rec1;
2023-08-01 17:01:38.303 +07 client backend[295939] pg_regress/brin ERROR:  "brintest" is not an index
2023-08-01 17:01:38.303 +07 client backend[295939] pg_regress/brin STATEMENT:  SELECT brin_summarize_new_values('brintest');
2023-08-01 17:01:38.303 +07 client backend[295939] pg_regress/brin ERROR:  "tenk1_unique1" is not a BRIN index
2023-08-01 17:01:38.303 +07 client backend[295939] pg_regress/brin STATEMENT:  SELECT brin_summarize_new_values('tenk1_unique1');
2023-08-01 17:01:38.303 +07 client backend[295939] pg_regress/brin ERROR:  block number out of range: -1
2023-08-01 17:01:38.303 +07 client backend[295939] pg_regress/brin STATEMENT:  SELECT brin_desummarize_range('brinidx', -1);
2023-08-01 17:01:38.306 +07 client backend[295939] pg_regress/brin ERROR:  block number out of range: -1
2023-08-01 17:01:38.306 +07 client backend[295939] pg_regress/brin STATEMENT:  SELECT brin_summarize_range('brin_summarize_idx', -1);
2023-08-01 17:01:38.306 +07 client backend[295939] pg_regress/brin ERROR:  block number out of range: 4294967296
2023-08-01 17:01:38.306 +07 client backend[295939] pg_regress/brin STATEMENT:  SELECT brin_summarize_range('brin_summarize_idx', 4294967296);
2023-08-01 17:01:38.306 +07 client backend[295956] pg_regress/generated ERROR:  permission denied for table gtest11s
2023-08-01 17:01:38.306 +07 client backend[295956] pg_regress/generated STATEMENT:  SELECT a, b FROM gtest11s;
2023-08-01 17:01:38.306 +07 client backend[295956] pg_regress/generated ERROR:  permission denied for function gf1
2023-08-01 17:01:38.306 +07 client backend[295956] pg_regress/generated STATEMENT:  SELECT gf1(10);
2023-08-01 17:01:38.309 +07 client backend[295956] pg_regress/generated ERROR:  new row for relation "gtest20" violates check constraint "gtest20_b_check"
2023-08-01 17:01:38.309 +07 client backend[295956] pg_regress/generated DETAIL:  Failing row contains (30, 60).
2023-08-01 17:01:38.309 +07 client backend[295956] pg_regress/generated STATEMENT:  INSERT INTO gtest20 (a) VALUES (30);
2023-08-01 17:01:38.311 +07 client backend[295956] pg_regress/generated ERROR:  check constraint "gtest20a_b_check" of relation "gtest20a" is violated by some row
2023-08-01 17:01:38.311 +07 client backend[295956] pg_regress/generated STATEMENT:  ALTER TABLE gtest20a ADD CHECK (b < 50);
2023-08-01 17:01:38.314 +07 client backend[295956] pg_regress/generated ERROR:  check constraint "chk" of relation "gtest20b" is violated by some row
2023-08-01 17:01:38.314 +07 client backend[295956] pg_regress/generated STATEMENT:  ALTER TABLE gtest20b VALIDATE CONSTRAINT chk;
2023-08-01 17:01:38.317 +07 client backend[295946] pg_regress/matview ERROR:  materialized view "mvtest2" has not been populated
2023-08-01 17:01:38.317 +07 client backend[295946] pg_regress/matview HINT:  Use the REFRESH MATERIALIZED VIEW command.
2023-08-01 17:01:38.317 +07 client backend[295946] pg_regress/matview STATEMENT:  SELECT * FROM mvtest2;
2023-08-01 17:01:38.326 +07 client backend[295956] pg_regress/generated ERROR:  null value in column "b" of relation "gtest21a" violates not-null constraint
2023-08-01 17:01:38.326 +07 client backend[295956] pg_regress/generated DETAIL:  Failing row contains (0, null).
2023-08-01 17:01:38.326 +07 client backend[295956] pg_regress/generated STATEMENT:  INSERT INTO gtest21a (a) VALUES (0);
2023-08-01 17:01:38.327 +07 client backend[295956] pg_regress/generated ERROR:  null value in column "b" of relation "gtest21b" violates not-null constraint
2023-08-01 17:01:38.327 +07 client backend[295956] pg_regress/generated DETAIL:  Failing row contains (0, null).
2023-08-01 17:01:38.327 +07 client backend[295956] pg_regress/generated STATEMENT:  INSERT INTO gtest21b (a) VALUES (0);
2023-08-01 17:01:38.329 +07 client backend[295956] pg_regress/generated ERROR:  duplicate key value violates unique constraint "gtest22a_b_key"
2023-08-01 17:01:38.329 +07 client backend[295956] pg_regress/generated DETAIL:  Key (b)=(1) already exists.
2023-08-01 17:01:38.329 +07 client backend[295956] pg_regress/generated STATEMENT:  INSERT INTO gtest22a VALUES (3);
2023-08-01 17:01:38.330 +07 client backend[295956] pg_regress/generated ERROR:  duplicate key value violates unique constraint "gtest22b_pkey"
2023-08-01 17:01:38.330 +07 client backend[295956] pg_regress/generated DETAIL:  Key (a, b)=(2, 1) already exists.
2023-08-01 17:01:38.330 +07 client backend[295956] pg_regress/generated STATEMENT:  INSERT INTO gtest22b VALUES (2);
2023-08-01 17:01:38.337 +07 client backend[295949] pg_regress/groupingsets LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295949.6", size 1720320
2023-08-01 17:01:38.337 +07 client backend[295949] pg_regress/groupingsets STATEMENT:  create table gs_hash_1 as
	select g100, g10, sum(g::numeric), count(*), max(g::text)
	from gs_data_1 group by cube (g1000, g100,g10);
2023-08-01 17:01:38.338 +07 client backend[295955] pg_regress/rowsecurity ERROR:  infinite recursion detected in policy for relation "s1"
2023-08-01 17:01:38.338 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  SELECT * FROM s1 WHERE f_leak(b);
2023-08-01 17:01:38.338 +07 client backend[295955] pg_regress/rowsecurity ERROR:  infinite recursion detected in policy for relation "s1"
2023-08-01 17:01:38.338 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  INSERT INTO s1 VALUES (1, 'foo');
2023-08-01 17:01:38.339 +07 client backend[295956] pg_regress/generated ERROR:  invalid ON UPDATE action for foreign key constraint containing generated column
2023-08-01 17:01:38.339 +07 client backend[295956] pg_regress/generated STATEMENT:  CREATE TABLE gtest23x (a int PRIMARY KEY, b int GENERATED ALWAYS AS (a * 2) STORED REFERENCES gtest23a (x) ON UPDATE CASCADE);
2023-08-01 17:01:38.341 +07 client backend[295956] pg_regress/generated ERROR:  invalid ON DELETE action for foreign key constraint containing generated column
2023-08-01 17:01:38.341 +07 client backend[295956] pg_regress/generated STATEMENT:  CREATE TABLE gtest23x (a int PRIMARY KEY, b int GENERATED ALWAYS AS (a * 2) STORED REFERENCES gtest23a (x) ON DELETE SET NULL);
2023-08-01 17:01:38.347 +07 client backend[295956] pg_regress/generated ERROR:  insert or update on table "gtest23b" violates foreign key constraint "gtest23b_b_fkey"
2023-08-01 17:01:38.347 +07 client backend[295956] pg_regress/generated DETAIL:  Key (b)=(10) is not present in table "gtest23a".
2023-08-01 17:01:38.347 +07 client backend[295956] pg_regress/generated STATEMENT:  INSERT INTO gtest23b VALUES (5);
2023-08-01 17:01:38.348 +07 client backend[295955] pg_regress/rowsecurity ERROR:  infinite recursion detected in policy for relation "s1"
2023-08-01 17:01:38.348 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  SELECT * FROM s1 WHERE f_leak(b);
2023-08-01 17:01:38.350 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest3
2023-08-01 17:01:38.350 +07 client backend[295950] pg_regress/privileges STATEMENT:  SELECT * FROM atest3;
2023-08-01 17:01:38.350 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest3
2023-08-01 17:01:38.350 +07 client backend[295950] pg_regress/privileges STATEMENT:  DELETE FROM atest3;
2023-08-01 17:01:38.352 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest2
2023-08-01 17:01:38.352 +07 client backend[295950] pg_regress/privileges STATEMENT:  SELECT * FROM atestv2;
2023-08-01 17:01:38.353 +07 client backend[295956] pg_regress/generated ERROR:  insert or update on table "gtest23q" violates foreign key constraint "gtest23q_b_fkey"
2023-08-01 17:01:38.353 +07 client backend[295956] pg_regress/generated DETAIL:  Key (b)=(5) is not present in table "gtest23p".
2023-08-01 17:01:38.353 +07 client backend[295956] pg_regress/generated STATEMENT:  INSERT INTO gtest23q VALUES (2, 5);
2023-08-01 17:01:38.353 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for view atestv2
2023-08-01 17:01:38.353 +07 client backend[295950] pg_regress/privileges STATEMENT:  SELECT * FROM atestv2;
2023-08-01 17:01:38.353 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for view atestv0
2023-08-01 17:01:38.353 +07 client backend[295950] pg_regress/privileges STATEMENT:  SELECT * FROM atestv0;
2023-08-01 17:01:38.353 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table int8_tbl
2023-08-01 17:01:38.353 +07 client backend[295950] pg_regress/privileges STATEMENT:  select * from
	  ((select a.q1 as x from int8_tbl a offset 0)
	   union all
	   (select b.q2 as x from int8_tbl b offset 0)) ss
	where false;
2023-08-01 17:01:38.354 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table int8_tbl
2023-08-01 17:01:38.354 +07 client backend[295950] pg_regress/privileges STATEMENT:  select * from
	  ((select a.q1 as x, random() from int8_tbl a where q1 > 0)
	   union all
	   (select b.q2 as x, random() from int8_tbl b where q2 > 0)) ss
	where x < 0;
2023-08-01 17:01:38.355 +07 client backend[295956] pg_regress/generated ERROR:  value for domain gtestdomain1 violates check constraint "gtestdomain1_check"
2023-08-01 17:01:38.355 +07 client backend[295956] pg_regress/generated STATEMENT:  INSERT INTO gtest24 (a) VALUES (6);
2023-08-01 17:01:38.355 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for view atestv3
2023-08-01 17:01:38.355 +07 client backend[295950] pg_regress/privileges STATEMENT:  SELECT * FROM atestv3;
2023-08-01 17:01:38.355 +07 client backend[295956] pg_regress/generated ERROR:  generated columns are not supported on typed tables
2023-08-01 17:01:38.355 +07 client backend[295956] pg_regress/generated STATEMENT:  CREATE TABLE gtest28 OF gtest_type (f1 WITH OPTIONS GENERATED ALWAYS AS (f2 *2) STORED);
2023-08-01 17:01:38.355 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest2
2023-08-01 17:01:38.355 +07 client backend[295950] pg_regress/privileges STATEMENT:  SELECT * FROM atestv2;
2023-08-01 17:01:38.356 +07 client backend[295956] pg_regress/generated ERROR:  generated columns are not supported on partitions
2023-08-01 17:01:38.356 +07 client backend[295956] pg_regress/generated STATEMENT:  CREATE TABLE gtest_child PARTITION OF gtest_parent (
	    f3 WITH OPTIONS GENERATED ALWAYS AS (f2 * 2) STORED
	) FOR VALUES FROM ('2016-07-01') TO ('2016-08-01');
2023-08-01 17:01:38.357 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest5
2023-08-01 17:01:38.357 +07 client backend[295950] pg_regress/privileges STATEMENT:  SELECT * FROM atest5;
2023-08-01 17:01:38.358 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest5
2023-08-01 17:01:38.358 +07 client backend[295950] pg_regress/privileges STATEMENT:  SELECT two FROM atest5;
2023-08-01 17:01:38.358 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest5
2023-08-01 17:01:38.358 +07 client backend[295950] pg_regress/privileges STATEMENT:  COPY atest5 (two) TO stdout;
2023-08-01 17:01:38.358 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest5
2023-08-01 17:01:38.358 +07 client backend[295950] pg_regress/privileges STATEMENT:  SELECT atest5 FROM atest5;
2023-08-01 17:01:38.358 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest5
2023-08-01 17:01:38.358 +07 client backend[295950] pg_regress/privileges STATEMENT:  COPY atest5 (one,two) TO stdout;
2023-08-01 17:01:38.358 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest5
2023-08-01 17:01:38.358 +07 client backend[295950] pg_regress/privileges STATEMENT:  SELECT 1 FROM atest5 a JOIN atest5 b USING (two);
2023-08-01 17:01:38.358 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest5
2023-08-01 17:01:38.358 +07 client backend[295950] pg_regress/privileges STATEMENT:  SELECT 1 FROM atest5 a NATURAL JOIN atest5 b;
2023-08-01 17:01:38.358 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest5
2023-08-01 17:01:38.358 +07 client backend[295950] pg_regress/privileges STATEMENT:  SELECT * FROM (atest5 a JOIN atest5 b USING (one)) j;
2023-08-01 17:01:38.359 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest5
2023-08-01 17:01:38.359 +07 client backend[295950] pg_regress/privileges STATEMENT:  SELECT j.* FROM (atest5 a JOIN atest5 b USING (one)) j;
2023-08-01 17:01:38.359 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest5
2023-08-01 17:01:38.359 +07 client backend[295950] pg_regress/privileges STATEMENT:  SELECT (j.*) IS NULL FROM (atest5 a JOIN atest5 b USING (one)) j;
2023-08-01 17:01:38.359 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest5
2023-08-01 17:01:38.359 +07 client backend[295950] pg_regress/privileges STATEMENT:  SELECT two FROM (atest5 a JOIN atest5 b(one,x,y,z) USING (one)) j;
2023-08-01 17:01:38.359 +07 client backend[295956] pg_regress/generated ERROR:  cannot use generated column in partition key at character 124
2023-08-01 17:01:38.359 +07 client backend[295956] pg_regress/generated DETAIL:  Column "f3" is a generated column.
2023-08-01 17:01:38.359 +07 client backend[295956] pg_regress/generated STATEMENT:  CREATE TABLE gtest_parent (f1 date NOT NULL, f2 bigint, f3 bigint GENERATED ALWAYS AS (f2 * 2) STORED) PARTITION BY RANGE (f3);
2023-08-01 17:01:38.359 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest5
2023-08-01 17:01:38.359 +07 client backend[295950] pg_regress/privileges STATEMENT:  SELECT j.two FROM (atest5 a JOIN atest5 b(one,x,y,z) USING (one)) j;
2023-08-01 17:01:38.359 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest5
2023-08-01 17:01:38.359 +07 client backend[295950] pg_regress/privileges STATEMENT:  SELECT y FROM (atest5 a JOIN atest5 b(one,x,y,z) USING (one)) j;
2023-08-01 17:01:38.359 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest5
2023-08-01 17:01:38.359 +07 client backend[295950] pg_regress/privileges STATEMENT:  SELECT j.y FROM (atest5 a JOIN atest5 b(one,x,y,z) USING (one)) j;
2023-08-01 17:01:38.360 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest5
2023-08-01 17:01:38.360 +07 client backend[295950] pg_regress/privileges STATEMENT:  SELECT * FROM (atest5 a JOIN atest5 b USING (one));
2023-08-01 17:01:38.360 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest5
2023-08-01 17:01:38.360 +07 client backend[295950] pg_regress/privileges STATEMENT:  SELECT a.* FROM (atest5 a JOIN atest5 b USING (one));
2023-08-01 17:01:38.360 +07 client backend[295956] pg_regress/generated ERROR:  cannot use generated column in partition key at character 124
2023-08-01 17:01:38.360 +07 client backend[295956] pg_regress/generated DETAIL:  Column "f3" is a generated column.
2023-08-01 17:01:38.360 +07 client backend[295956] pg_regress/generated STATEMENT:  CREATE TABLE gtest_parent (f1 date NOT NULL, f2 bigint, f3 bigint GENERATED ALWAYS AS (f2 * 2) STORED) PARTITION BY RANGE ((f3 * 3));
2023-08-01 17:01:38.360 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest5
2023-08-01 17:01:38.360 +07 client backend[295950] pg_regress/privileges STATEMENT:  SELECT (a.*) IS NULL FROM (atest5 a JOIN atest5 b USING (one));
2023-08-01 17:01:38.360 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest5
2023-08-01 17:01:38.360 +07 client backend[295950] pg_regress/privileges STATEMENT:  SELECT two FROM (atest5 a JOIN atest5 b(one,x,y,z) USING (one));
2023-08-01 17:01:38.360 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest5
2023-08-01 17:01:38.360 +07 client backend[295950] pg_regress/privileges STATEMENT:  SELECT a.two FROM (atest5 a JOIN atest5 b(one,x,y,z) USING (one));
2023-08-01 17:01:38.360 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest5
2023-08-01 17:01:38.360 +07 client backend[295950] pg_regress/privileges STATEMENT:  SELECT y FROM (atest5 a JOIN atest5 b(one,x,y,z) USING (one));
2023-08-01 17:01:38.360 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest5
2023-08-01 17:01:38.360 +07 client backend[295950] pg_regress/privileges STATEMENT:  SELECT b.y FROM (atest5 a JOIN atest5 b(one,x,y,z) USING (one));
2023-08-01 17:01:38.360 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest5
2023-08-01 17:01:38.360 +07 client backend[295950] pg_regress/privileges STATEMENT:  SELECT y FROM (atest5 a LEFT JOIN atest5 b(one,x,y,z) USING (one));
2023-08-01 17:01:38.360 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest5
2023-08-01 17:01:38.360 +07 client backend[295950] pg_regress/privileges STATEMENT:  SELECT b.y FROM (atest5 a LEFT JOIN atest5 b(one,x,y,z) USING (one));
2023-08-01 17:01:38.360 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest5
2023-08-01 17:01:38.360 +07 client backend[295950] pg_regress/privileges STATEMENT:  SELECT y FROM (atest5 a FULL JOIN atest5 b(one,x,y,z) USING (one));
2023-08-01 17:01:38.361 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest5
2023-08-01 17:01:38.361 +07 client backend[295950] pg_regress/privileges STATEMENT:  SELECT b.y FROM (atest5 a FULL JOIN atest5 b(one,x,y,z) USING (one));
2023-08-01 17:01:38.361 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest5
2023-08-01 17:01:38.361 +07 client backend[295950] pg_regress/privileges STATEMENT:  SELECT 1 FROM atest5 WHERE two = 2;
2023-08-01 17:01:38.361 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest5
2023-08-01 17:01:38.361 +07 client backend[295950] pg_regress/privileges STATEMENT:  SELECT * FROM atest1, atest5;
2023-08-01 17:01:38.361 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest5
2023-08-01 17:01:38.361 +07 client backend[295950] pg_regress/privileges STATEMENT:  SELECT atest1.*,atest5.one FROM atest1 JOIN atest5 ON (atest1.a = atest5.two);
2023-08-01 17:01:38.361 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest5
2023-08-01 17:01:38.361 +07 client backend[295950] pg_regress/privileges STATEMENT:  SELECT one, two FROM atest5;
2023-08-01 17:01:38.362 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest5
2023-08-01 17:01:38.362 +07 client backend[295950] pg_regress/privileges STATEMENT:  SELECT one, two FROM atest5 NATURAL JOIN atest6;
2023-08-01 17:01:38.362 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest5
2023-08-01 17:01:38.362 +07 client backend[295950] pg_regress/privileges STATEMENT:  COPY atest5 FROM stdin;
2023-08-01 17:01:38.363 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest5
2023-08-01 17:01:38.363 +07 client backend[295950] pg_regress/privileges STATEMENT:  INSERT INTO atest5 (three) VALUES (4);
2023-08-01 17:01:38.363 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest5
2023-08-01 17:01:38.363 +07 client backend[295950] pg_regress/privileges STATEMENT:  INSERT INTO atest5 VALUES (5,5,5);
2023-08-01 17:01:38.363 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest5
2023-08-01 17:01:38.363 +07 client backend[295950] pg_regress/privileges STATEMENT:  UPDATE atest5 SET one = 8;
2023-08-01 17:01:38.363 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest5
2023-08-01 17:01:38.363 +07 client backend[295950] pg_regress/privileges STATEMENT:  UPDATE atest5 SET three = 5, one = 2;
2023-08-01 17:01:38.363 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest5
2023-08-01 17:01:38.363 +07 client backend[295950] pg_regress/privileges STATEMENT:  INSERT INTO atest5(two) VALUES (6) ON CONFLICT (two) DO UPDATE set three = 10 RETURNING atest5.three;
2023-08-01 17:01:38.363 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest5
2023-08-01 17:01:38.363 +07 client backend[295950] pg_regress/privileges STATEMENT:  INSERT INTO atest5(two) VALUES (6) ON CONFLICT (two) DO UPDATE set three = EXCLUDED.three;
2023-08-01 17:01:38.364 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest5
2023-08-01 17:01:38.364 +07 client backend[295950] pg_regress/privileges STATEMENT:  INSERT INTO atest5(two) VALUES (6) ON CONFLICT (two) DO UPDATE set one = 8;
2023-08-01 17:01:38.364 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest5
2023-08-01 17:01:38.364 +07 client backend[295950] pg_regress/privileges STATEMENT:  INSERT INTO atest5(three) VALUES (4) ON CONFLICT (two) DO UPDATE set three = 10;
2023-08-01 17:01:38.364 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest5
2023-08-01 17:01:38.364 +07 client backend[295950] pg_regress/privileges STATEMENT:  INSERT INTO atest5(four) VALUES (4);
2023-08-01 17:01:38.364 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest5
2023-08-01 17:01:38.364 +07 client backend[295950] pg_regress/privileges STATEMENT:  INSERT INTO atest5(four) VALUES (4) ON CONFLICT (four) DO UPDATE set three = 3;
2023-08-01 17:01:38.364 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest5
2023-08-01 17:01:38.364 +07 client backend[295950] pg_regress/privileges STATEMENT:  INSERT INTO atest5(four) VALUES (4) ON CONFLICT ON CONSTRAINT atest5_four_key DO UPDATE set three = 3;
2023-08-01 17:01:38.365 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest5
2023-08-01 17:01:38.365 +07 client backend[295950] pg_regress/privileges STATEMENT:  SELECT one FROM atest5;
2023-08-01 17:01:38.365 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest5
2023-08-01 17:01:38.365 +07 client backend[295950] pg_regress/privileges STATEMENT:  UPDATE atest5 SET one = 1;
2023-08-01 17:01:38.366 +07 client backend[295956] pg_regress/generated ERROR:  cannot use generated column "b" in column generation expression
2023-08-01 17:01:38.366 +07 client backend[295956] pg_regress/generated DETAIL:  A generated column cannot reference another generated column.
2023-08-01 17:01:38.366 +07 client backend[295956] pg_regress/generated STATEMENT:  ALTER TABLE gtest25 ADD COLUMN x int GENERATED ALWAYS AS (b * 4) STORED;
2023-08-01 17:01:38.366 +07 client backend[295956] pg_regress/generated ERROR:  column "z" does not exist
2023-08-01 17:01:38.366 +07 client backend[295956] pg_regress/generated STATEMENT:  ALTER TABLE gtest25 ADD COLUMN x int GENERATED ALWAYS AS (z * 4) STORED;
2023-08-01 17:01:38.366 +07 client backend[295955] pg_regress/rowsecurity ERROR:  new row violates row-level security policy for table "b1"
2023-08-01 17:01:38.366 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  INSERT INTO bv1 VALUES (-1, 'xxx');
2023-08-01 17:01:38.366 +07 client backend[295955] pg_regress/rowsecurity ERROR:  new row violates row-level security policy for table "b1"
2023-08-01 17:01:38.366 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  INSERT INTO bv1 VALUES (11, 'xxx');
2023-08-01 17:01:38.368 +07 client backend[295950] pg_regress/privileges ERROR:  duplicate key value violates unique constraint "t1_pkey"
2023-08-01 17:01:38.368 +07 client backend[295950] pg_regress/privileges STATEMENT:  INSERT INTO t1 (c1, c2) VALUES (1, 1);
2023-08-01 17:01:38.368 +07 client backend[295950] pg_regress/privileges ERROR:  duplicate key value violates unique constraint "t1_pkey"
2023-08-01 17:01:38.368 +07 client backend[295950] pg_regress/privileges STATEMENT:  UPDATE t1 SET c2 = 1;
2023-08-01 17:01:38.368 +07 client backend[295950] pg_regress/privileges ERROR:  null value in column "c1" of relation "t1" violates not-null constraint
2023-08-01 17:01:38.368 +07 client backend[295950] pg_regress/privileges DETAIL:  Failing row contains (c1, c2) = (null, null).
2023-08-01 17:01:38.368 +07 client backend[295950] pg_regress/privileges STATEMENT:  INSERT INTO t1 (c1, c2) VALUES (null, null);
2023-08-01 17:01:38.368 +07 client backend[295950] pg_regress/privileges ERROR:  null value in column "c1" of relation "t1" violates not-null constraint
2023-08-01 17:01:38.368 +07 client backend[295950] pg_regress/privileges DETAIL:  Failing row contains (c1, c3) = (null, null).
2023-08-01 17:01:38.368 +07 client backend[295950] pg_regress/privileges STATEMENT:  INSERT INTO t1 (c3) VALUES (null);
2023-08-01 17:01:38.368 +07 client backend[295950] pg_regress/privileges ERROR:  null value in column "c2" of relation "t1" violates not-null constraint
2023-08-01 17:01:38.368 +07 client backend[295950] pg_regress/privileges DETAIL:  Failing row contains (c1) = (5).
2023-08-01 17:01:38.368 +07 client backend[295950] pg_regress/privileges STATEMENT:  INSERT INTO t1 (c1) VALUES (5);
2023-08-01 17:01:38.368 +07 client backend[295950] pg_regress/privileges ERROR:  new row for relation "t1" violates check constraint "t1_c3_check"
2023-08-01 17:01:38.368 +07 client backend[295950] pg_regress/privileges DETAIL:  Failing row contains (c1, c3) = (1, 10).
2023-08-01 17:01:38.368 +07 client backend[295950] pg_regress/privileges STATEMENT:  UPDATE t1 SET c3 = 10;
2023-08-01 17:01:38.369 +07 client backend[295955] pg_regress/rowsecurity ERROR:  new row violates row-level security policy for table "document"
2023-08-01 17:01:38.369 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  INSERT INTO document VALUES (2, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_carol', 'my first novel')
	    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle, dauthor = EXCLUDED.dauthor;
2023-08-01 17:01:38.370 +07 client backend[295955] pg_regress/rowsecurity ERROR:  new row violates row-level security policy (USING expression) for table "document"
2023-08-01 17:01:38.370 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  INSERT INTO document VALUES (33, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_bob', 'Some novel, replaces sci-fi') 
	    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle;
2023-08-01 17:01:38.370 +07 client backend[295943] pg_regress/spgist ERROR:  value 9 out of bounds for option "fillfactor"
2023-08-01 17:01:38.370 +07 client backend[295943] pg_regress/spgist DETAIL:  Valid values are between "10" and "100".
2023-08-01 17:01:38.370 +07 client backend[295943] pg_regress/spgist STATEMENT:  create index spgist_point_idx2 on spgist_point_tbl using spgist(p) with (fillfactor = 9);
2023-08-01 17:01:38.370 +07 client backend[295943] pg_regress/spgist ERROR:  value 101 out of bounds for option "fillfactor"
2023-08-01 17:01:38.370 +07 client backend[295943] pg_regress/spgist DETAIL:  Valid values are between "10" and "100".
2023-08-01 17:01:38.370 +07 client backend[295943] pg_regress/spgist STATEMENT:  create index spgist_point_idx2 on spgist_point_tbl using spgist(p) with (fillfactor = 101);
2023-08-01 17:01:38.371 +07 client backend[295955] pg_regress/rowsecurity ERROR:  new row violates row-level security policy (USING expression) for table "document"
2023-08-01 17:01:38.371 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  INSERT INTO document VALUES (78, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_bob', 'some technology novel')
	    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle, cid = 33 RETURNING *;
2023-08-01 17:01:38.372 +07 client backend[295955] pg_regress/rowsecurity ERROR:  new row violates row-level security policy (USING expression) for table "document"
2023-08-01 17:01:38.372 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  INSERT INTO document VALUES (79, (SELECT cid from category WHERE cname = 'technology'), 1, 'regress_rls_bob', 'technology book, can only insert')
	    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle RETURNING *;
2023-08-01 17:01:38.373 +07 client backend[295955] pg_regress/rowsecurity ERROR:  new row violates row-level security policy for table "document"
2023-08-01 17:01:38.373 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  INSERT INTO document VALUES (79, (SELECT cid from category WHERE cname = 'technology'), 1, 'regress_rls_bob', 'technology book, can only insert')
	    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle RETURNING *;
2023-08-01 17:01:38.373 +07 client backend[295950] pg_regress/privileges ERROR:  null value in column "b" of relation "errtst_part_1" violates not-null constraint
2023-08-01 17:01:38.373 +07 client backend[295950] pg_regress/privileges DETAIL:  Failing row contains (a, b, c) = (aaa, null, null).
2023-08-01 17:01:38.373 +07 client backend[295950] pg_regress/privileges STATEMENT:  INSERT INTO errtst (a, b) VALUES ('aaa', NULL);
2023-08-01 17:01:38.373 +07 client backend[295955] pg_regress/rowsecurity ERROR:  new row violates row-level security policy for table "document"
2023-08-01 17:01:38.373 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  INSERT INTO document VALUES (2, (SELECT cid from category WHERE cname = 'technology'), 1, 'regress_rls_bob', 'my first novel')
	    ON CONFLICT (did) DO UPDATE SET cid = EXCLUDED.cid, dtitle = EXCLUDED.dtitle RETURNING *;
2023-08-01 17:01:38.373 +07 client backend[295950] pg_regress/privileges ERROR:  null value in column "b" of relation "errtst_part_1" violates not-null constraint
2023-08-01 17:01:38.373 +07 client backend[295950] pg_regress/privileges DETAIL:  Failing row contains (b) = (null).
2023-08-01 17:01:38.373 +07 client backend[295950] pg_regress/privileges STATEMENT:  UPDATE errtst SET b = NULL;
2023-08-01 17:01:38.373 +07 client backend[295950] pg_regress/privileges ERROR:  null value in column "b" of relation "errtst_part_1" violates not-null constraint
2023-08-01 17:01:38.373 +07 client backend[295950] pg_regress/privileges DETAIL:  Failing row contains (a, b, c) = (aaa, null, ccc).
2023-08-01 17:01:38.373 +07 client backend[295950] pg_regress/privileges STATEMENT:  UPDATE errtst SET a = 'aaa', b = NULL;
2023-08-01 17:01:38.374 +07 client backend[295950] pg_regress/privileges ERROR:  null value in column "b" of relation "errtst_part_2" violates not-null constraint
2023-08-01 17:01:38.374 +07 client backend[295950] pg_regress/privileges DETAIL:  Failing row contains (a, b, c) = (aaaa, null, ccc).
2023-08-01 17:01:38.374 +07 client backend[295950] pg_regress/privileges STATEMENT:  UPDATE errtst SET a = 'aaaa', b = NULL;
2023-08-01 17:01:38.374 +07 client backend[295950] pg_regress/privileges ERROR:  null value in column "b" of relation "errtst_part_2" violates not-null constraint
2023-08-01 17:01:38.374 +07 client backend[295950] pg_regress/privileges DETAIL:  Failing row contains (a, b, c) = (aaaa, null, ccc).
2023-08-01 17:01:38.374 +07 client backend[295950] pg_regress/privileges STATEMENT:  UPDATE errtst SET a = 'aaaa', b = NULL WHERE a = 'aaa';
2023-08-01 17:01:38.374 +07 client backend[295956] pg_regress/generated ERROR:  cannot alter type of a column used by a generated column
2023-08-01 17:01:38.374 +07 client backend[295956] pg_regress/generated DETAIL:  Column "a" is used by generated column "x".
2023-08-01 17:01:38.374 +07 client backend[295956] pg_regress/generated STATEMENT:  ALTER TABLE gtest27 ALTER COLUMN a TYPE text;
2023-08-01 17:01:38.374 +07 client backend[295955] pg_regress/rowsecurity ERROR:  new row violates row-level security policy for table "document"
2023-08-01 17:01:38.374 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  INSERT INTO document VALUES (80, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_carol', 'my first novel')
	    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle, cid = 33;
2023-08-01 17:01:38.374 +07 client backend[295955] pg_regress/rowsecurity ERROR:  new row violates row-level security policy (USING expression) for table "document"
2023-08-01 17:01:38.374 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  INSERT INTO document VALUES (4, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_bob', 'my first novel')
	    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle;
2023-08-01 17:01:38.375 +07 client backend[295955] pg_regress/rowsecurity ERROR:  new row violates row-level security policy for table "document"
2023-08-01 17:01:38.375 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  INSERT INTO document VALUES (1, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_bob', 'my first novel')
	    ON CONFLICT (did) DO UPDATE SET dauthor = 'regress_rls_carol';
2023-08-01 17:01:38.376 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest6
2023-08-01 17:01:38.376 +07 client backend[295950] pg_regress/privileges STATEMENT:  SELECT atest6 FROM atest6;
2023-08-01 17:01:38.376 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest5
2023-08-01 17:01:38.376 +07 client backend[295950] pg_regress/privileges STATEMENT:  SELECT one FROM atest5 NATURAL JOIN atest6;
2023-08-01 17:01:38.377 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest6
2023-08-01 17:01:38.377 +07 client backend[295950] pg_regress/privileges STATEMENT:  SELECT * FROM atest6;
2023-08-01 17:01:38.377 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest6
2023-08-01 17:01:38.377 +07 client backend[295950] pg_regress/privileges STATEMENT:  SELECT 1 FROM atest6;
2023-08-01 17:01:38.378 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atest5
2023-08-01 17:01:38.378 +07 client backend[295950] pg_regress/privileges STATEMENT:  DELETE FROM atest5 WHERE one = 1;
2023-08-01 17:01:38.379 +07 client backend[295956] pg_regress/generated ERROR:  generation expression for column "x" cannot be cast automatically to type boolean
2023-08-01 17:01:38.379 +07 client backend[295956] pg_regress/generated STATEMENT:  ALTER TABLE gtest27 ALTER COLUMN x TYPE boolean USING x <> 0;
2023-08-01 17:01:38.379 +07 client backend[295956] pg_regress/generated ERROR:  column "x" of relation "gtest27" is a generated column
2023-08-01 17:01:38.379 +07 client backend[295956] pg_regress/generated HINT:  Use ALTER TABLE ... ALTER COLUMN ... DROP EXPRESSION instead.
2023-08-01 17:01:38.379 +07 client backend[295956] pg_regress/generated STATEMENT:  ALTER TABLE gtest27 ALTER COLUMN x DROP DEFAULT;
2023-08-01 17:01:38.380 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atestc
2023-08-01 17:01:38.380 +07 client backend[295950] pg_regress/privileges STATEMENT:  SELECT fy FROM atestc;
2023-08-01 17:01:38.382 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atestc
2023-08-01 17:01:38.382 +07 client backend[295950] pg_regress/privileges STATEMENT:  SELECT f2 FROM atestc;
2023-08-01 17:01:38.382 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atestc
2023-08-01 17:01:38.382 +07 client backend[295950] pg_regress/privileges STATEMENT:  DELETE FROM atestc;
2023-08-01 17:01:38.382 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atestc
2023-08-01 17:01:38.382 +07 client backend[295950] pg_regress/privileges STATEMENT:  UPDATE atestc SET f1 = 1;
2023-08-01 17:01:38.382 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atestc
2023-08-01 17:01:38.382 +07 client backend[295950] pg_regress/privileges STATEMENT:  TRUNCATE atestc;
2023-08-01 17:01:38.383 +07 client backend[295950] pg_regress/privileges ERROR:  permission denied for table atestc
2023-08-01 17:01:38.383 +07 client backend[295950] pg_regress/privileges STATEMENT:  LOCK atestc;
2023-08-01 17:01:38.384 +07 client backend[295956] pg_regress/generated ERROR:  cannot alter type of a column used by a generated column
2023-08-01 17:01:38.384 +07 client backend[295956] pg_regress/generated DETAIL:  Column "a" is used by generated column "x".
2023-08-01 17:01:38.384 +07 client backend[295956] pg_regress/generated STATEMENT:  ALTER TABLE gtest27
	  ALTER COLUMN a TYPE float8,
	  ALTER COLUMN b TYPE float8;
2023-08-01 17:01:38.385 +07 client backend[295974] pg_regress/privileges ERROR:  language "c" is not trusted
2023-08-01 17:01:38.385 +07 client backend[295974] pg_regress/privileges DETAIL:  GRANT and REVOKE are not allowed on untrusted languages, because only superusers can use untrusted languages.
2023-08-01 17:01:38.385 +07 client backend[295974] pg_regress/privileges STATEMENT:  GRANT USAGE ON LANGUAGE c TO PUBLIC;
2023-08-01 17:01:38.385 +07 client backend[295974] pg_regress/privileges WARNING:  no privileges were granted for "sql"
2023-08-01 17:01:38.386 +07 client backend[295955] pg_regress/rowsecurity ERROR:  permission denied for view rls_view
2023-08-01 17:01:38.386 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  SELECT * FROM rls_view;
2023-08-01 17:01:38.386 +07 client backend[295955] pg_regress/rowsecurity ERROR:  permission denied for view rls_view
2023-08-01 17:01:38.386 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
2023-08-01 17:01:38.387 +07 client backend[295974] pg_regress/privileges ERROR:  priv_testproc1(integer) is not a function
2023-08-01 17:01:38.387 +07 client backend[295974] pg_regress/privileges STATEMENT:  REVOKE ALL ON FUNCTION priv_testproc1(int) FROM PUBLIC;
2023-08-01 17:01:38.387 +07 client backend[295974] pg_regress/privileges ERROR:  invalid privilege type USAGE for function
2023-08-01 17:01:38.387 +07 client backend[295974] pg_regress/privileges STATEMENT:  GRANT USAGE ON FUNCTION priv_testfunc1(int) TO regress_priv_user3;
2023-08-01 17:01:38.387 +07 client backend[295974] pg_regress/privileges ERROR:  invalid privilege type USAGE for function
2023-08-01 17:01:38.387 +07 client backend[295974] pg_regress/privileges STATEMENT:  GRANT USAGE ON FUNCTION priv_testagg1(int) TO regress_priv_user3;
2023-08-01 17:01:38.387 +07 client backend[295956] pg_regress/generated ERROR:  column "a" of relation "gtest29" is not a stored generated column
2023-08-01 17:01:38.387 +07 client backend[295956] pg_regress/generated STATEMENT:  ALTER TABLE gtest29 ALTER COLUMN a DROP EXPRESSION;
2023-08-01 17:01:38.387 +07 client backend[295974] pg_regress/privileges ERROR:  invalid privilege type USAGE for procedure
2023-08-01 17:01:38.387 +07 client backend[295974] pg_regress/privileges STATEMENT:  GRANT USAGE ON PROCEDURE priv_testproc1(int) TO regress_priv_user3;
2023-08-01 17:01:38.387 +07 client backend[295974] pg_regress/privileges ERROR:  function priv_testfunc_nosuch(integer) does not exist
2023-08-01 17:01:38.387 +07 client backend[295974] pg_regress/privileges STATEMENT:  GRANT ALL PRIVILEGES ON FUNCTION priv_testfunc_nosuch(int) TO regress_priv_user4;
2023-08-01 17:01:38.388 +07 client backend[295974] pg_regress/privileges ERROR:  permission denied for language sql
2023-08-01 17:01:38.388 +07 client backend[295974] pg_regress/privileges STATEMENT:  CREATE FUNCTION priv_testfunc3(int) RETURNS int AS 'select 2 * $1;' LANGUAGE sql;
2023-08-01 17:01:38.388 +07 client backend[295974] pg_regress/privileges ERROR:  permission denied for function priv_testfunc1
2023-08-01 17:01:38.388 +07 client backend[295974] pg_regress/privileges STATEMENT:  SELECT priv_testfunc1(5);
2023-08-01 17:01:38.388 +07 client backend[295974] pg_regress/privileges ERROR:  permission denied for aggregate priv_testagg1
2023-08-01 17:01:38.388 +07 client backend[295974] pg_regress/privileges STATEMENT:  SELECT priv_testagg1(x) FROM (VALUES (1), (2), (3)) _(x);
2023-08-01 17:01:38.388 +07 client backend[295974] pg_regress/privileges ERROR:  permission denied for procedure priv_testproc1
2023-08-01 17:01:38.388 +07 client backend[295974] pg_regress/privileges STATEMENT:  CALL priv_testproc1(6);
2023-08-01 17:01:38.389 +07 client backend[295974] pg_regress/privileges ERROR:  permission denied for table atest2
2023-08-01 17:01:38.389 +07 client backend[295974] pg_regress/privileges STATEMENT:  SELECT col1 FROM atest2 WHERE col2 = true;
2023-08-01 17:01:38.389 +07 client backend[295974] pg_regress/privileges ERROR:  must be owner of function priv_testfunc1
2023-08-01 17:01:38.389 +07 client backend[295974] pg_regress/privileges STATEMENT:  DROP FUNCTION priv_testfunc1(int);
2023-08-01 17:01:38.389 +07 client backend[295974] pg_regress/privileges ERROR:  must be owner of aggregate priv_testagg1
2023-08-01 17:01:38.389 +07 client backend[295974] pg_regress/privileges STATEMENT:  DROP AGGREGATE priv_testagg1(int);
2023-08-01 17:01:38.389 +07 client backend[295974] pg_regress/privileges ERROR:  must be owner of procedure priv_testproc1
2023-08-01 17:01:38.389 +07 client backend[295974] pg_regress/privileges STATEMENT:  DROP PROCEDURE priv_testproc1(int);
2023-08-01 17:01:38.400 +07 client backend[295955] pg_regress/rowsecurity ERROR:  policy "p1" for table "y1" already exists
2023-08-01 17:01:38.400 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  CREATE POLICY p1 ON y1 FOR SELECT USING (a % 2 = 1);
2023-08-01 17:01:38.402 +07 client backend[295956] pg_regress/generated ERROR:  ALTER TABLE / DROP EXPRESSION must be applied to child tables too
2023-08-01 17:01:38.402 +07 client backend[295956] pg_regress/generated STATEMENT:  ALTER TABLE ONLY gtest30 ALTER COLUMN b DROP EXPRESSION;
2023-08-01 17:01:38.407 +07 client backend[295956] pg_regress/generated ERROR:  cannot drop generation expression from inherited column
2023-08-01 17:01:38.407 +07 client backend[295956] pg_regress/generated STATEMENT:  ALTER TABLE gtest30_1 ALTER COLUMN b DROP EXPRESSION;
2023-08-01 17:01:38.410 +07 client backend[295956] pg_regress/generated ERROR:  BEFORE trigger's WHEN condition cannot reference NEW generated columns at character 82
2023-08-01 17:01:38.410 +07 client backend[295956] pg_regress/generated DETAIL:  Column "b" is a generated column.
2023-08-01 17:01:38.410 +07 client backend[295956] pg_regress/generated STATEMENT:  CREATE TRIGGER gtest2a BEFORE INSERT OR UPDATE ON gtest26
	  FOR EACH ROW
	  WHEN (NEW.b < 0)  
	  EXECUTE PROCEDURE gtest_trigger_func();
2023-08-01 17:01:38.410 +07 client backend[295956] pg_regress/generated ERROR:  BEFORE trigger's WHEN condition cannot reference NEW generated columns at character 82
2023-08-01 17:01:38.410 +07 client backend[295956] pg_regress/generated DETAIL:  A whole-row reference is used and the table contains generated columns.
2023-08-01 17:01:38.410 +07 client backend[295956] pg_regress/generated STATEMENT:  CREATE TRIGGER gtest2b BEFORE INSERT OR UPDATE ON gtest26
	  FOR EACH ROW
	  WHEN (NEW.* IS NOT NULL)  
	  EXECUTE PROCEDURE gtest_trigger_func();
2023-08-01 17:01:38.414 +07 client backend[295955] pg_regress/rowsecurity ERROR:  new row violates row-level security policy for table "t1"
2023-08-01 17:01:38.414 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  WITH cte1 AS (UPDATE t1 SET a = a + 1 RETURNING *) SELECT * FROM cte1;
2023-08-01 17:01:38.414 +07 client backend[295955] pg_regress/rowsecurity ERROR:  new row violates row-level security policy for table "t1"
2023-08-01 17:01:38.414 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  WITH cte1 AS (INSERT INTO t1 VALUES (21, 'Fail') RETURNING *) SELECT * FROM cte1;
2023-08-01 17:01:38.415 +07 client backend[295955] pg_regress/rowsecurity ERROR:  policy "p1" for table "t1" already exists
2023-08-01 17:01:38.415 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  ALTER POLICY p1 ON t1 RENAME TO p1;
2023-08-01 17:01:38.418 +07 client backend[295977] pg_regress/privileges ERROR:  permission denied for function int8
2023-08-01 17:01:38.418 +07 client backend[295977] pg_regress/privileges STATEMENT:  SELECT '{1}'::int4[]::int8[];
2023-08-01 17:01:38.425 +07 client backend[295980] pg_regress/privileges ERROR:  cannot set privileges of array types
2023-08-01 17:01:38.425 +07 client backend[295980] pg_regress/privileges HINT:  Set the privileges of the element type instead.
2023-08-01 17:01:38.425 +07 client backend[295980] pg_regress/privileges STATEMENT:  GRANT USAGE ON TYPE _priv_testtype1 TO regress_priv_user2;
2023-08-01 17:01:38.425 +07 client backend[295980] pg_regress/privileges ERROR:  "priv_testtype1" is not a domain
2023-08-01 17:01:38.425 +07 client backend[295980] pg_regress/privileges STATEMENT:  GRANT USAGE ON DOMAIN priv_testtype1 TO regress_priv_user2;
2023-08-01 17:01:38.428 +07 client backend[295980] pg_regress/privileges ERROR:  permission denied for type priv_testdomain1
2023-08-01 17:01:38.428 +07 client backend[295980] pg_regress/privileges STATEMENT:  CREATE AGGREGATE priv_testagg1a(priv_testdomain1) (sfunc = int4_sum, stype = bigint);
2023-08-01 17:01:38.428 +07 client backend[295980] pg_regress/privileges ERROR:  permission denied for type priv_testdomain1
2023-08-01 17:01:38.428 +07 client backend[295980] pg_regress/privileges STATEMENT:  CREATE DOMAIN priv_testdomain2a AS priv_testdomain1;
2023-08-01 17:01:38.428 +07 client backend[295980] pg_regress/privileges ERROR:  permission denied for type priv_testdomain1
2023-08-01 17:01:38.428 +07 client backend[295980] pg_regress/privileges STATEMENT:  CREATE CAST (priv_testdomain1 AS priv_testdomain3a) WITH FUNCTION castfunc(int);
2023-08-01 17:01:38.429 +07 client backend[295980] pg_regress/privileges ERROR:  permission denied for type priv_testdomain1
2023-08-01 17:01:38.429 +07 client backend[295980] pg_regress/privileges STATEMENT:  CREATE FUNCTION priv_testfunc5a(a priv_testdomain1) RETURNS int LANGUAGE SQL AS $$ SELECT $1 $$;
2023-08-01 17:01:38.429 +07 client backend[295980] pg_regress/privileges ERROR:  permission denied for type priv_testdomain1
2023-08-01 17:01:38.429 +07 client backend[295980] pg_regress/privileges STATEMENT:  CREATE FUNCTION priv_testfunc6a(b int) RETURNS priv_testdomain1 LANGUAGE SQL AS $$ SELECT $1::priv_testdomain1 $$;
2023-08-01 17:01:38.429 +07 client backend[295980] pg_regress/privileges ERROR:  permission denied for type priv_testdomain1
2023-08-01 17:01:38.429 +07 client backend[295980] pg_regress/privileges STATEMENT:  CREATE OPERATOR !+! (PROCEDURE = int4pl, LEFTARG = priv_testdomain1, RIGHTARG = priv_testdomain1);
2023-08-01 17:01:38.429 +07 client backend[295980] pg_regress/privileges ERROR:  permission denied for type priv_testdomain1
2023-08-01 17:01:38.429 +07 client backend[295980] pg_regress/privileges STATEMENT:  CREATE TABLE test5a (a int, b priv_testdomain1);
2023-08-01 17:01:38.429 +07 client backend[295980] pg_regress/privileges ERROR:  permission denied for type priv_testtype1
2023-08-01 17:01:38.429 +07 client backend[295980] pg_regress/privileges STATEMENT:  CREATE TABLE test6a OF priv_testtype1;
2023-08-01 17:01:38.429 +07 client backend[295980] pg_regress/privileges ERROR:  permission denied for type priv_testtype1
2023-08-01 17:01:38.429 +07 client backend[295980] pg_regress/privileges STATEMENT:  CREATE TABLE test10a (a int[], b priv_testtype1[]);
2023-08-01 17:01:38.430 +07 client backend[295980] pg_regress/privileges ERROR:  permission denied for type priv_testdomain1
2023-08-01 17:01:38.430 +07 client backend[295980] pg_regress/privileges STATEMENT:  ALTER TABLE test9a ADD COLUMN c priv_testdomain1;
2023-08-01 17:01:38.430 +07 client backend[295980] pg_regress/privileges ERROR:  permission denied for type priv_testdomain1
2023-08-01 17:01:38.430 +07 client backend[295980] pg_regress/privileges STATEMENT:  ALTER TABLE test9a ALTER COLUMN b TYPE priv_testdomain1;
2023-08-01 17:01:38.430 +07 client backend[295980] pg_regress/privileges ERROR:  permission denied for type priv_testdomain1
2023-08-01 17:01:38.430 +07 client backend[295980] pg_regress/privileges STATEMENT:  CREATE TYPE test7a AS (a int, b priv_testdomain1);
2023-08-01 17:01:38.431 +07 client backend[295980] pg_regress/privileges ERROR:  permission denied for type priv_testdomain1
2023-08-01 17:01:38.431 +07 client backend[295980] pg_regress/privileges STATEMENT:  ALTER TYPE test8a ADD ATTRIBUTE c priv_testdomain1;
2023-08-01 17:01:38.431 +07 client backend[295980] pg_regress/privileges ERROR:  permission denied for type priv_testdomain1
2023-08-01 17:01:38.431 +07 client backend[295980] pg_regress/privileges STATEMENT:  ALTER TYPE test8a ALTER ATTRIBUTE b TYPE priv_testdomain1;
2023-08-01 17:01:38.431 +07 client backend[295980] pg_regress/privileges ERROR:  permission denied for type priv_testdomain1
2023-08-01 17:01:38.431 +07 client backend[295980] pg_regress/privileges STATEMENT:  CREATE TABLE test11a AS (SELECT 1::priv_testdomain1 AS a);
2023-08-01 17:01:38.431 +07 client backend[295980] pg_regress/privileges ERROR:  permission denied for type priv_testtype1
2023-08-01 17:01:38.431 +07 client backend[295980] pg_regress/privileges STATEMENT:  REVOKE ALL ON TYPE priv_testtype1 FROM PUBLIC;
2023-08-01 17:01:38.432 +07 client backend[295980] pg_regress/privileges WARNING:  cast will be ignored because the source data type is a domain
2023-08-01 17:01:38.434 +07 client backend[295955] pg_regress/rowsecurity ERROR:  table "copy_t" does not exist
2023-08-01 17:01:38.434 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  DROP TABLE copy_t CASCADE;
2023-08-01 17:01:38.436 +07 client backend[295955] pg_regress/rowsecurity ERROR:  query would be affected by row-level security policy for table "copy_t"
2023-08-01 17:01:38.436 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ',';
2023-08-01 17:01:38.437 +07 client backend[295955] pg_regress/rowsecurity ERROR:  query would be affected by row-level security policy for table "copy_t"
2023-08-01 17:01:38.437 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ',';
2023-08-01 17:01:38.437 +07 client backend[295955] pg_regress/rowsecurity ERROR:  permission denied for table copy_t
2023-08-01 17:01:38.437 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ',';
2023-08-01 17:01:38.437 +07 client backend[295980] pg_regress/privileges WARNING:  no privileges could be revoked for "priv_testtype1"
2023-08-01 17:01:38.440 +07 client backend[295955] pg_regress/rowsecurity ERROR:  query would be affected by row-level security policy for table "copy_rel_to"
2023-08-01 17:01:38.440 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  COPY copy_rel_to TO STDOUT WITH DELIMITER ',';
2023-08-01 17:01:38.441 +07 client backend[295955] pg_regress/rowsecurity ERROR:  permission denied for table copy_rel_to
2023-08-01 17:01:38.441 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  COPY copy_rel_to TO STDOUT WITH DELIMITER ',';
2023-08-01 17:01:38.441 +07 client backend[295955] pg_regress/rowsecurity ERROR:  permission denied for table copy_rel_to
2023-08-01 17:01:38.441 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  COPY copy_rel_to TO STDOUT WITH DELIMITER ',';
2023-08-01 17:01:38.441 +07 client backend[295955] pg_regress/rowsecurity ERROR:  query would be affected by row-level security policy for table "copy_t"
2023-08-01 17:01:38.441 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  COPY copy_t FROM STDIN;
2023-08-01 17:01:38.441 +07 client backend[295955] pg_regress/rowsecurity ERROR:  COPY FROM not supported with row-level security
2023-08-01 17:01:38.441 +07 client backend[295955] pg_regress/rowsecurity HINT:  Use INSERT statements instead.
2023-08-01 17:01:38.441 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  COPY copy_t FROM STDIN;
2023-08-01 17:01:38.442 +07 client backend[295955] pg_regress/rowsecurity ERROR:  permission denied for table copy_t
2023-08-01 17:01:38.442 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  COPY copy_t FROM STDIN;
2023-08-01 17:01:38.442 +07 client backend[295955] pg_regress/rowsecurity ERROR:  permission denied for table copy_t
2023-08-01 17:01:38.442 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  COPY copy_t FROM STDIN;
2023-08-01 17:01:38.445 +07 client backend[295985] pg_regress/privileges ERROR:  permission denied for table atest3
2023-08-01 17:01:38.445 +07 client backend[295985] pg_regress/privileges STATEMENT:  TRUNCATE atest3;
2023-08-01 17:01:38.445 +07 client backend[295985] pg_regress/privileges ERROR:  relation "pg_shad" does not exist
2023-08-01 17:01:38.445 +07 client backend[295985] pg_regress/privileges STATEMENT:  select has_table_privilege('pg_shad','select');
2023-08-01 17:01:38.445 +07 client backend[295985] pg_regress/privileges ERROR:  role "nosuchuser" does not exist
2023-08-01 17:01:38.445 +07 client backend[295985] pg_regress/privileges STATEMENT:  select has_table_privilege('nosuchuser','pg_authid','select');
2023-08-01 17:01:38.445 +07 client backend[295985] pg_regress/privileges ERROR:  unrecognized privilege type: "sel"
2023-08-01 17:01:38.445 +07 client backend[295985] pg_regress/privileges STATEMENT:  select has_table_privilege('pg_authid','sel');
2023-08-01 17:01:38.459 +07 client backend[295955] pg_regress/rowsecurity ERROR:  role "regress_rls_eve" cannot be dropped because some objects depend on it
2023-08-01 17:01:38.459 +07 client backend[295955] pg_regress/rowsecurity DETAIL:  privileges for table tbl1
	target of policy p on table tbl1
2023-08-01 17:01:38.459 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  DROP ROLE regress_rls_eve;
2023-08-01 17:01:38.460 +07 client backend[295960] pg_regress/join_hash LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295960.127", size 146674
2023-08-01 17:01:38.460 +07 client backend[295960] pg_regress/join_hash STATEMENT:  select count(*) FROM simple r JOIN bigger_than_it_looks s USING (id);
2023-08-01 17:01:38.460 +07 client backend[295955] pg_regress/rowsecurity ERROR:  role "regress_rls_eve" cannot be dropped because some objects depend on it
2023-08-01 17:01:38.460 +07 client backend[295955] pg_regress/rowsecurity DETAIL:  privileges for table tbl1
2023-08-01 17:01:38.460 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  DROP ROLE regress_rls_eve;
2023-08-01 17:01:38.460 +07 client backend[295986] pg_regress/privileges ERROR:  column "nosuchcol" of relation "pg_authid" does not exist
2023-08-01 17:01:38.460 +07 client backend[295986] pg_regress/privileges STATEMENT:  select has_column_privilege('pg_authid','nosuchcol','select');
2023-08-01 17:01:38.461 +07 client backend[295955] pg_regress/rowsecurity ERROR:  role "regress_rls_frank" cannot be dropped because some objects depend on it
2023-08-01 17:01:38.461 +07 client backend[295955] pg_regress/rowsecurity DETAIL:  target of policy p on table tbl1
2023-08-01 17:01:38.461 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  DROP ROLE regress_rls_frank;
2023-08-01 17:01:38.461 +07 client backend[295960] pg_regress/join_hash LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295960.130", size 145199
2023-08-01 17:01:38.461 +07 client backend[295960] pg_regress/join_hash STATEMENT:  select count(*) FROM simple r JOIN bigger_than_it_looks s USING (id);
2023-08-01 17:01:38.461 +07 client backend[295986] pg_regress/privileges ERROR:  column "f2" of relation "mytable" does not exist
2023-08-01 17:01:38.461 +07 client backend[295986] pg_regress/privileges STATEMENT:  select has_column_privilege('mytable','f2','select');
2023-08-01 17:01:38.462 +07 client backend[295960] pg_regress/join_hash LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295960.132", size 149388
2023-08-01 17:01:38.462 +07 client backend[295960] pg_regress/join_hash STATEMENT:  select count(*) FROM simple r JOIN bigger_than_it_looks s USING (id);
2023-08-01 17:01:38.463 +07 client backend[295955] pg_regress/rowsecurity ERROR:  could not convert table "t" to a view because it has row security enabled
2023-08-01 17:01:38.463 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  CREATE RULE "_RETURN" AS ON SELECT TO t DO INSTEAD
	  SELECT * FROM generate_series(1,5) t0(c);
2023-08-01 17:01:38.463 +07 client backend[295960] pg_regress/join_hash LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295960.129", size 149978
2023-08-01 17:01:38.463 +07 client backend[295960] pg_regress/join_hash STATEMENT:  select count(*) FROM simple r JOIN bigger_than_it_looks s USING (id);
2023-08-01 17:01:38.463 +07 client backend[295986] pg_regress/privileges WARNING:  no privileges were granted for "atest4"
2023-08-01 17:01:38.463 +07 client backend[295986] pg_regress/privileges ERROR:  dependent privileges exist
2023-08-01 17:01:38.463 +07 client backend[295986] pg_regress/privileges HINT:  Use CASCADE to revoke them too.
2023-08-01 17:01:38.463 +07 client backend[295986] pg_regress/privileges STATEMENT:  REVOKE SELECT ON atest4 FROM regress_priv_user2;
2023-08-01 17:01:38.463 +07 client backend[295955] pg_regress/rowsecurity ERROR:  could not convert table "t" to a view because it has row security policies
2023-08-01 17:01:38.463 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  CREATE RULE "_RETURN" AS ON SELECT TO t DO INSTEAD
	  SELECT * FROM generate_series(1,5) t0(c);
2023-08-01 17:01:38.464 +07 client backend[295960] pg_regress/join_hash LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295960.128", size 149565
2023-08-01 17:01:38.464 +07 client backend[295960] pg_regress/join_hash STATEMENT:  select count(*) FROM simple r JOIN bigger_than_it_looks s USING (id);
2023-08-01 17:01:38.465 +07 client backend[295960] pg_regress/join_hash LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295960.133", size 145081
2023-08-01 17:01:38.465 +07 client backend[295960] pg_regress/join_hash STATEMENT:  select count(*) FROM simple r JOIN bigger_than_it_looks s USING (id);
2023-08-01 17:01:38.465 +07 client backend[295955] pg_regress/rowsecurity ERROR:  aggregate functions are not allowed in policy expressions
2023-08-01 17:01:38.465 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  CREATE POLICY p ON t USING (max(c));
2023-08-01 17:01:38.466 +07 client backend[295960] pg_regress/join_hash LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295960.131", size 147795
2023-08-01 17:01:38.466 +07 client backend[295960] pg_regress/join_hash STATEMENT:  select count(*) FROM simple r JOIN bigger_than_it_looks s USING (id);
2023-08-01 17:01:38.468 +07 client backend[295987] pg_regress/privileges ERROR:  cannot create a cursor WITH HOLD within security-restricted operation
2023-08-01 17:01:38.468 +07 client backend[295987] pg_regress/privileges CONTEXT:  SQL function "mv_action" statement 1
2023-08-01 17:01:38.468 +07 client backend[295987] pg_regress/privileges STATEMENT:  REFRESH MATERIALIZED VIEW sro_mv;
2023-08-01 17:01:38.469 +07 client backend[295955] pg_regress/rowsecurity ERROR:  new row violates row-level security policy for table "r2"
2023-08-01 17:01:38.469 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  INSERT INTO r2 VALUES (2);
2023-08-01 17:01:38.470 +07 client backend[295988] pg_regress/privileges ERROR:  cannot create a cursor WITH HOLD within security-restricted operation
2023-08-01 17:01:38.470 +07 client backend[295988] pg_regress/privileges CONTEXT:  SQL function "mv_action" statement 1
2023-08-01 17:01:38.470 +07 client backend[295988] pg_regress/privileges STATEMENT:  REFRESH MATERIALIZED VIEW sro_mv;
2023-08-01 17:01:38.472 +07 client backend[295988] pg_regress/privileges ERROR:  cannot fire deferred trigger within security-restricted operation
2023-08-01 17:01:38.472 +07 client backend[295988] pg_regress/privileges CONTEXT:  SQL function "mv_action" statement 1
2023-08-01 17:01:38.472 +07 client backend[295988] pg_regress/privileges STATEMENT:  REFRESH MATERIALIZED VIEW sro_mv;
2023-08-01 17:01:38.474 +07 client backend[295955] pg_regress/rowsecurity ERROR:  new row violates row-level security policy for table "r1"
2023-08-01 17:01:38.474 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  INSERT INTO r1 VALUES (1);
2023-08-01 17:01:38.474 +07 client backend[295989] pg_regress/privileges ERROR:  cannot fire deferred trigger within security-restricted operation
2023-08-01 17:01:38.474 +07 client backend[295989] pg_regress/privileges CONTEXT:  SQL function "mv_action" statement 1
2023-08-01 17:01:38.474 +07 client backend[295989] pg_regress/privileges STATEMENT:  REFRESH MATERIALIZED VIEW sro_mv;
2023-08-01 17:01:38.475 +07 client backend[295955] pg_regress/rowsecurity ERROR:  query would be affected by row-level security policy for table "r1"
2023-08-01 17:01:38.475 +07 client backend[295955] pg_regress/rowsecurity HINT:  To disable the policy for the table's owner, use ALTER TABLE NO FORCE ROW LEVEL SECURITY.
2023-08-01 17:01:38.475 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  TABLE r1;
2023-08-01 17:01:38.475 +07 client backend[295955] pg_regress/rowsecurity ERROR:  query would be affected by row-level security policy for table "r1"
2023-08-01 17:01:38.475 +07 client backend[295955] pg_regress/rowsecurity HINT:  To disable the policy for the table's owner, use ALTER TABLE NO FORCE ROW LEVEL SECURITY.
2023-08-01 17:01:38.475 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  UPDATE r1 SET a = 1;
2023-08-01 17:01:38.475 +07 client backend[295955] pg_regress/rowsecurity ERROR:  query would be affected by row-level security policy for table "r1"
2023-08-01 17:01:38.475 +07 client backend[295955] pg_regress/rowsecurity HINT:  To disable the policy for the table's owner, use ALTER TABLE NO FORCE ROW LEVEL SECURITY.
2023-08-01 17:01:38.475 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  DELETE FROM r1;
2023-08-01 17:01:38.476 +07 client backend[295989] pg_regress/privileges ERROR:  must have admin option on role "regress_priv_group2"
2023-08-01 17:01:38.476 +07 client backend[295989] pg_regress/privileges CONTEXT:  SQL function "unwanted_grant" statement 1
	SQL statement "SELECT unwanted_grant()"
	PL/pgSQL function sro_trojan() line 1 at PERFORM
	SQL function "mv_action" statement 1
2023-08-01 17:01:38.476 +07 client backend[295989] pg_regress/privileges STATEMENT:  REFRESH MATERIALIZED VIEW sro_mv;
2023-08-01 17:01:38.477 +07 client backend[295989] pg_regress/privileges ERROR:  must have admin option on role "regress_priv_group2"
2023-08-01 17:01:38.477 +07 client backend[295989] pg_regress/privileges STATEMENT:  GRANT regress_priv_group2 TO regress_priv_user5;
2023-08-01 17:01:38.477 +07 client backend[295989] pg_regress/privileges ERROR:  must have admin option on role "regress_priv_group2"
2023-08-01 17:01:38.477 +07 client backend[295989] pg_regress/privileges STATEMENT:  GRANT regress_priv_group2 TO regress_priv_user5;
2023-08-01 17:01:38.477 +07 client backend[295989] pg_regress/privileges ERROR:  must have admin option on role "regress_priv_group2"
2023-08-01 17:01:38.477 +07 client backend[295989] pg_regress/privileges STATEMENT:  GRANT regress_priv_group2 TO regress_priv_user5;
2023-08-01 17:01:38.478 +07 client backend[295989] pg_regress/privileges ERROR:  must have admin option on role "regress_priv_group2"
2023-08-01 17:01:38.478 +07 client backend[295989] pg_regress/privileges CONTEXT:  SQL function "dogrant_fails" statement 1
2023-08-01 17:01:38.478 +07 client backend[295989] pg_regress/privileges STATEMENT:  SELECT dogrant_fails();
2023-08-01 17:01:38.479 +07 client backend[295955] pg_regress/rowsecurity ERROR:  update or delete on table "r1" violates foreign key constraint "r2_a_fkey" on table "r2"
2023-08-01 17:01:38.479 +07 client backend[295955] pg_regress/rowsecurity DETAIL:  Key (a)=(10) is still referenced from table "r2".
2023-08-01 17:01:38.479 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  DELETE FROM r1;
2023-08-01 17:01:38.480 +07 client backend[295990] pg_regress/privileges ERROR:  "atest1" is not a sequence
2023-08-01 17:01:38.480 +07 client backend[295990] pg_regress/privileges STATEMENT:  SELECT has_sequence_privilege('regress_priv_user1', 'atest1', 'SELECT');
2023-08-01 17:01:38.480 +07 client backend[295960] pg_regress/join_hash LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295960.141", size 146674
2023-08-01 17:01:38.480 +07 client backend[295960] pg_regress/join_hash CONTEXT:  PL/pgSQL function hash_join_batches(text) line 6 at FOR over EXECUTE statement
2023-08-01 17:01:38.480 +07 client backend[295960] pg_regress/join_hash STATEMENT:  select original > 1 as initially_multibatch, final > original as increased_batches
	  from hash_join_batches(
	$$
	  select count(*) FROM simple r JOIN bigger_than_it_looks s USING (id);
	$$);
2023-08-01 17:01:38.480 +07 client backend[295990] pg_regress/privileges ERROR:  unrecognized privilege type: "INSERT"
2023-08-01 17:01:38.480 +07 client backend[295990] pg_regress/privileges STATEMENT:  SELECT has_sequence_privilege('regress_priv_user1', 'x_seq', 'INSERT');
2023-08-01 17:01:38.482 +07 client backend[295960] pg_regress/join_hash LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295960.144", size 145199
2023-08-01 17:01:38.482 +07 client backend[295960] pg_regress/join_hash CONTEXT:  PL/pgSQL function hash_join_batches(text) line 6 at FOR over EXECUTE statement
2023-08-01 17:01:38.482 +07 client backend[295960] pg_regress/join_hash STATEMENT:  select original > 1 as initially_multibatch, final > original as increased_batches
	  from hash_join_batches(
	$$
	  select count(*) FROM simple r JOIN bigger_than_it_looks s USING (id);
	$$);
2023-08-01 17:01:38.483 +07 client backend[295960] pg_regress/join_hash LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295960.146", size 149388
2023-08-01 17:01:38.483 +07 client backend[295960] pg_regress/join_hash CONTEXT:  PL/pgSQL function hash_join_batches(text) line 6 at FOR over EXECUTE statement
2023-08-01 17:01:38.483 +07 client backend[295960] pg_regress/join_hash STATEMENT:  select original > 1 as initially_multibatch, final > original as increased_batches
	  from hash_join_batches(
	$$
	  select count(*) FROM simple r JOIN bigger_than_it_looks s USING (id);
	$$);
2023-08-01 17:01:38.483 +07 client backend[295991] pg_regress/privileges ERROR:  invalid privilege type INSERT for large object
2023-08-01 17:01:38.483 +07 client backend[295991] pg_regress/privileges STATEMENT:  GRANT SELECT, INSERT ON LARGE OBJECT 1001 TO PUBLIC;
2023-08-01 17:01:38.483 +07 client backend[295991] pg_regress/privileges ERROR:  role "nosuchuser" does not exist
2023-08-01 17:01:38.483 +07 client backend[295991] pg_regress/privileges STATEMENT:  GRANT SELECT, UPDATE ON LARGE OBJECT 1001 TO nosuchuser;
2023-08-01 17:01:38.483 +07 client backend[295991] pg_regress/privileges ERROR:  large object 999 does not exist
2023-08-01 17:01:38.483 +07 client backend[295991] pg_regress/privileges STATEMENT:  GRANT SELECT, UPDATE ON LARGE OBJECT  999 TO PUBLIC;
2023-08-01 17:01:38.484 +07 client backend[295960] pg_regress/join_hash LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295960.143", size 149978
2023-08-01 17:01:38.484 +07 client backend[295960] pg_regress/join_hash CONTEXT:  PL/pgSQL function hash_join_batches(text) line 6 at FOR over EXECUTE statement
2023-08-01 17:01:38.484 +07 client backend[295960] pg_regress/join_hash STATEMENT:  select original > 1 as initially_multibatch, final > original as increased_batches
	  from hash_join_batches(
	$$
	  select count(*) FROM simple r JOIN bigger_than_it_looks s USING (id);
	$$);
2023-08-01 17:01:38.485 +07 client backend[295992] pg_regress/privileges ERROR:  large object descriptor 0 was not opened for writing
2023-08-01 17:01:38.485 +07 client backend[295992] pg_regress/privileges STATEMENT:  SELECT lowrite(lo_open(1001, x'40000'::int), 'abcd');
2023-08-01 17:01:38.485 +07 client backend[295960] pg_regress/join_hash LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295960.142", size 149565
2023-08-01 17:01:38.485 +07 client backend[295960] pg_regress/join_hash CONTEXT:  PL/pgSQL function hash_join_batches(text) line 6 at FOR over EXECUTE statement
2023-08-01 17:01:38.485 +07 client backend[295960] pg_regress/join_hash STATEMENT:  select original > 1 as initially_multibatch, final > original as increased_batches
	  from hash_join_batches(
	$$
	  select count(*) FROM simple r JOIN bigger_than_it_looks s USING (id);
	$$);
2023-08-01 17:01:38.485 +07 client backend[295992] pg_regress/privileges ERROR:  permission denied for large object 1002
2023-08-01 17:01:38.485 +07 client backend[295992] pg_regress/privileges STATEMENT:  SELECT loread(lo_open(1002, x'40000'::int), 32);
2023-08-01 17:01:38.486 +07 client backend[295992] pg_regress/privileges ERROR:  permission denied for large object 1002
2023-08-01 17:01:38.486 +07 client backend[295992] pg_regress/privileges STATEMENT:  SELECT lowrite(lo_open(1002, x'20000'::int), 'abcd');
2023-08-01 17:01:38.486 +07 client backend[295992] pg_regress/privileges ERROR:  permission denied for large object 1003
2023-08-01 17:01:38.486 +07 client backend[295992] pg_regress/privileges STATEMENT:  SELECT lowrite(lo_open(1003, x'20000'::int), 'abcd');
2023-08-01 17:01:38.486 +07 client backend[295992] pg_regress/privileges ERROR:  large object 1006 does not exist
2023-08-01 17:01:38.486 +07 client backend[295992] pg_regress/privileges STATEMENT:  GRANT UPDATE ON LARGE OBJECT 1006 TO regress_priv_user3;
2023-08-01 17:01:38.486 +07 client backend[295992] pg_regress/privileges ERROR:  must be owner of large object 1001
2023-08-01 17:01:38.486 +07 client backend[295992] pg_regress/privileges STATEMENT:  SELECT lo_unlink(1001);
2023-08-01 17:01:38.487 +07 client backend[295960] pg_regress/join_hash LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295960.147", size 145081
2023-08-01 17:01:38.487 +07 client backend[295960] pg_regress/join_hash CONTEXT:  PL/pgSQL function hash_join_batches(text) line 6 at FOR over EXECUTE statement
2023-08-01 17:01:38.487 +07 client backend[295960] pg_regress/join_hash STATEMENT:  select original > 1 as initially_multibatch, final > original as increased_batches
	  from hash_join_batches(
	$$
	  select count(*) FROM simple r JOIN bigger_than_it_looks s USING (id);
	$$);
2023-08-01 17:01:38.488 +07 client backend[295960] pg_regress/join_hash LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295960.145", size 147795
2023-08-01 17:01:38.488 +07 client backend[295960] pg_regress/join_hash CONTEXT:  PL/pgSQL function hash_join_batches(text) line 6 at FOR over EXECUTE statement
2023-08-01 17:01:38.488 +07 client backend[295960] pg_regress/join_hash STATEMENT:  select original > 1 as initially_multibatch, final > original as increased_batches
	  from hash_join_batches(
	$$
	  select count(*) FROM simple r JOIN bigger_than_it_looks s USING (id);
	$$);
2023-08-01 17:01:38.489 +07 client backend[295993] pg_regress/privileges ERROR:  permission denied for large object 1003
2023-08-01 17:01:38.489 +07 client backend[295993] pg_regress/privileges STATEMENT:  SELECT loread(lo_open(1003, x'40000'::int), 32);
2023-08-01 17:01:38.489 +07 client backend[295993] pg_regress/privileges ERROR:  permission denied for large object 1005
2023-08-01 17:01:38.489 +07 client backend[295993] pg_regress/privileges STATEMENT:  SELECT lo_truncate(lo_open(1005, x'20000'::int), 10);
2023-08-01 17:01:38.492 +07 client backend[295996] pg_regress/privileges ERROR:  permission denied for large object 1002
2023-08-01 17:01:38.492 +07 client backend[295996] pg_regress/privileges STATEMENT:  SELECT loread(lo_open(1002, x'40000'::int), 32);
2023-08-01 17:01:38.492 +07 client backend[295996] pg_regress/privileges ERROR:  permission denied for large object 1002
2023-08-01 17:01:38.492 +07 client backend[295996] pg_regress/privileges STATEMENT:  SELECT lowrite(lo_open(1002, x'20000'::int), 'abcd');
2023-08-01 17:01:38.492 +07 client backend[295996] pg_regress/privileges ERROR:  permission denied for large object 1002
2023-08-01 17:01:38.492 +07 client backend[295996] pg_regress/privileges STATEMENT:  SELECT lo_truncate(lo_open(1002, x'20000'::int), 10);
2023-08-01 17:01:38.492 +07 client backend[295996] pg_regress/privileges ERROR:  permission denied for large object 1002
2023-08-01 17:01:38.492 +07 client backend[295996] pg_regress/privileges STATEMENT:  SELECT lo_put(1002, 1, 'abcd');
2023-08-01 17:01:38.492 +07 client backend[295996] pg_regress/privileges ERROR:  must be owner of large object 1002
2023-08-01 17:01:38.492 +07 client backend[295996] pg_regress/privileges STATEMENT:  SELECT lo_unlink(1002);
2023-08-01 17:01:38.492 +07 client backend[295996] pg_regress/privileges ERROR:  permission denied for function lo_export
2023-08-01 17:01:38.492 +07 client backend[295996] pg_regress/privileges STATEMENT:  SELECT lo_export(1001, '/dev/null');
2023-08-01 17:01:38.492 +07 client backend[295996] pg_regress/privileges ERROR:  permission denied for function lo_import
2023-08-01 17:01:38.492 +07 client backend[295996] pg_regress/privileges STATEMENT:  SELECT lo_import('/dev/null');
2023-08-01 17:01:38.493 +07 client backend[295996] pg_regress/privileges ERROR:  permission denied for function lo_import
2023-08-01 17:01:38.493 +07 client backend[295996] pg_regress/privileges STATEMENT:  SELECT lo_import('/dev/null', 2003);
2023-08-01 17:01:38.494 +07 client backend[295955] pg_regress/rowsecurity ERROR:  query would be affected by row-level security policy for table "r1"
2023-08-01 17:01:38.494 +07 client backend[295955] pg_regress/rowsecurity HINT:  To disable the policy for the table's owner, use ALTER TABLE NO FORCE ROW LEVEL SECURITY.
2023-08-01 17:01:38.494 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  TABLE r1;
2023-08-01 17:01:38.495 +07 client backend[295955] pg_regress/rowsecurity ERROR:  new row violates row-level security policy for table "r1"
2023-08-01 17:01:38.495 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  INSERT INTO r1 VALUES (10), (20) RETURNING *;
2023-08-01 17:01:38.496 +07 client backend[295997] pg_regress/privileges ERROR:  permission denied for function lo_export
2023-08-01 17:01:38.496 +07 client backend[295997] pg_regress/privileges STATEMENT:  SELECT lo_export(1001, '/dev/null');
2023-08-01 17:01:38.499 +07 client backend[295955] pg_regress/rowsecurity ERROR:  new row violates row-level security policy for table "r1"
2023-08-01 17:01:38.499 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  UPDATE r1 SET a = 30 RETURNING *;
2023-08-01 17:01:38.499 +07 client backend[295955] pg_regress/rowsecurity ERROR:  new row violates row-level security policy for table "r1"
2023-08-01 17:01:38.499 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  INSERT INTO r1 VALUES (10)
	    ON CONFLICT (a) DO UPDATE SET a = 30 RETURNING *;
2023-08-01 17:01:38.499 +07 client backend[295998] pg_regress/privileges ERROR:  permission denied for table pg_largeobject
2023-08-01 17:01:38.499 +07 client backend[295998] pg_regress/privileges STATEMENT:  SELECT * FROM pg_largeobject LIMIT 0;
2023-08-01 17:01:38.499 +07 client backend[295955] pg_regress/rowsecurity ERROR:  new row violates row-level security policy for table "r1"
2023-08-01 17:01:38.499 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  INSERT INTO r1 VALUES (10)
	    ON CONFLICT (a) DO UPDATE SET a = 30;
2023-08-01 17:01:38.499 +07 client backend[295955] pg_regress/rowsecurity ERROR:  new row violates row-level security policy for table "r1"
2023-08-01 17:01:38.499 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  INSERT INTO r1 VALUES (10)
	    ON CONFLICT ON CONSTRAINT r1_pkey DO UPDATE SET a = 30;
2023-08-01 17:01:38.505 +07 client backend[295999] pg_regress/privileges ERROR:  cannot use IN SCHEMA clause when using GRANT/REVOKE ON SCHEMAS
2023-08-01 17:01:38.505 +07 client backend[295999] pg_regress/privileges STATEMENT:  ALTER DEFAULT PRIVILEGES IN SCHEMA testns GRANT USAGE ON SCHEMAS TO regress_priv_user2;
2023-08-01 17:01:38.507 +07 client backend[295955] pg_regress/rowsecurity ERROR:  policy "p1" for table "dob_t1" does not exist
2023-08-01 17:01:38.507 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  DROP POLICY p1 ON dob_t1;
2023-08-01 17:01:38.511 +07 client backend[295955] pg_regress/rowsecurity ERROR:  permission denied for table ref_tbl
2023-08-01 17:01:38.511 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  SELECT * FROM ref_tbl;
2023-08-01 17:01:38.512 +07 client backend[295955] pg_regress/rowsecurity ERROR:  permission denied for table rls_tbl
2023-08-01 17:01:38.512 +07 client backend[295955] pg_regress/rowsecurity STATEMENT:  SELECT * FROM rls_tbl;
2023-08-01 17:01:38.541 +07 client backend[296008] pg_regress/privileges ERROR:  view "atestv4" does not exist
2023-08-01 17:01:38.541 +07 client backend[296008] pg_regress/privileges STATEMENT:  DROP VIEW atestv4;
2023-08-01 17:01:38.546 +07 client backend[296008] pg_regress/privileges ERROR:  role "regress_priv_user6" does not exist
2023-08-01 17:01:38.546 +07 client backend[296008] pg_regress/privileges STATEMENT:  DROP USER regress_priv_user6;
2023-08-01 17:01:38.547 +07 client backend[296008] pg_regress/privileges ERROR:  permission denied for table lock_table
2023-08-01 17:01:38.547 +07 client backend[296008] pg_regress/privileges STATEMENT:  LOCK TABLE lock_table IN ROW EXCLUSIVE MODE;
2023-08-01 17:01:38.547 +07 client backend[296008] pg_regress/privileges ERROR:  permission denied for table lock_table
2023-08-01 17:01:38.547 +07 client backend[296008] pg_regress/privileges STATEMENT:  LOCK TABLE lock_table IN ACCESS EXCLUSIVE MODE;
2023-08-01 17:01:38.549 +07 client backend[296009] pg_regress/privileges ERROR:  permission denied for table lock_table
2023-08-01 17:01:38.549 +07 client backend[296009] pg_regress/privileges STATEMENT:  LOCK TABLE lock_table IN ACCESS SHARE MODE;
2023-08-01 17:01:38.550 +07 client backend[296009] pg_regress/privileges ERROR:  permission denied for table lock_table
2023-08-01 17:01:38.550 +07 client backend[296009] pg_regress/privileges STATEMENT:  LOCK TABLE lock_table IN ACCESS EXCLUSIVE MODE;
2023-08-01 17:01:38.552 +07 client backend[296010] pg_regress/privileges ERROR:  permission denied for table lock_table
2023-08-01 17:01:38.552 +07 client backend[296010] pg_regress/privileges STATEMENT:  LOCK TABLE lock_table IN ACCESS SHARE MODE;
2023-08-01 17:01:38.553 +07 client backend[296011] pg_regress/privileges ERROR:  permission denied for table lock_table
2023-08-01 17:01:38.553 +07 client backend[296011] pg_regress/privileges STATEMENT:  LOCK TABLE lock_table IN ACCESS SHARE MODE;
2023-08-01 17:01:38.555 +07 client backend[296012] pg_regress/privileges ERROR:  permission denied for table lock_table
2023-08-01 17:01:38.555 +07 client backend[296012] pg_regress/privileges STATEMENT:  LOCK TABLE lock_table IN ACCESS SHARE MODE;
2023-08-01 17:01:38.558 +07 client backend[295960] pg_regress/join_hash LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295960.176", size 480000
2023-08-01 17:01:38.558 +07 client backend[295960] pg_regress/join_hash STATEMENT:  select count(*) from simple r join extremely_skewed s using (id);
2023-08-01 17:01:38.560 +07 client backend[295960] pg_regress/join_hash LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295960.177", size 593422
2023-08-01 17:01:38.560 +07 client backend[295960] pg_regress/join_hash STATEMENT:  select count(*) from simple r join extremely_skewed s using (id);
2023-08-01 17:01:38.569 +07 client backend[295960] pg_regress/join_hash LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295960.178", size 480000
2023-08-01 17:01:38.569 +07 client backend[295960] pg_regress/join_hash CONTEXT:  PL/pgSQL function hash_join_batches(text) line 6 at FOR over EXECUTE statement
2023-08-01 17:01:38.569 +07 client backend[295960] pg_regress/join_hash STATEMENT:  select * from hash_join_batches(
	$$
	  select count(*) from simple r join extremely_skewed s using (id);
	$$);
2023-08-01 17:01:38.573 +07 client backend[295960] pg_regress/join_hash LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295960.179", size 593422
2023-08-01 17:01:38.573 +07 client backend[295960] pg_regress/join_hash CONTEXT:  PL/pgSQL function hash_join_batches(text) line 6 at FOR over EXECUTE statement
2023-08-01 17:01:38.573 +07 client backend[295960] pg_regress/join_hash STATEMENT:  select * from hash_join_batches(
	$$
	  select count(*) from simple r join extremely_skewed s using (id);
	$$);
2023-08-01 17:01:38.581 +07 client backend[295960] pg_regress/join_hash LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295960.180", size 480000
2023-08-01 17:01:38.581 +07 client backend[295960] pg_regress/join_hash STATEMENT:  select count(*) from simple r join extremely_skewed s using (id);
2023-08-01 17:01:38.584 +07 parallel worker[296034] LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp296034.0", size 480000
2023-08-01 17:01:38.584 +07 parallel worker[296034] STATEMENT:  select count(*) from simple r join extremely_skewed s using (id);
2023-08-01 17:01:38.584 +07 parallel worker[296035] LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp296035.0", size 480000
2023-08-01 17:01:38.584 +07 parallel worker[296035] STATEMENT:  select count(*) from simple r join extremely_skewed s using (id);
2023-08-01 17:01:38.584 +07 client backend[295960] pg_regress/join_hash LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295960.181", size 586165
2023-08-01 17:01:38.584 +07 client backend[295960] pg_regress/join_hash STATEMENT:  select count(*) from simple r join extremely_skewed s using (id);
2023-08-01 17:01:38.593 +07 client backend[295960] pg_regress/join_hash LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295960.182", size 480000
2023-08-01 17:01:38.593 +07 client backend[295960] pg_regress/join_hash CONTEXT:  PL/pgSQL function hash_join_batches(text) line 6 at FOR over EXECUTE statement
2023-08-01 17:01:38.593 +07 client backend[295960] pg_regress/join_hash STATEMENT:  select * from hash_join_batches(
	$$
	  select count(*) from simple r join extremely_skewed s using (id);
	$$);
2023-08-01 17:01:38.596 +07 parallel worker[296037] LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp296037.0", size 480000
2023-08-01 17:01:38.596 +07 parallel worker[296037] STATEMENT:  explain (analyze, format 'json') 
	  select count(*) from simple r join extremely_skewed s using (id);
	
2023-08-01 17:01:38.596 +07 parallel worker[296036] LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp296036.0", size 480000
2023-08-01 17:01:38.596 +07 parallel worker[296036] STATEMENT:  explain (analyze, format 'json') 
	  select count(*) from simple r join extremely_skewed s using (id);
	
2023-08-01 17:01:38.598 +07 client backend[295960] pg_regress/join_hash LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295960.183", size 586165
2023-08-01 17:01:38.598 +07 client backend[295960] pg_regress/join_hash CONTEXT:  PL/pgSQL function hash_join_batches(text) line 6 at FOR over EXECUTE statement
2023-08-01 17:01:38.598 +07 client backend[295960] pg_regress/join_hash STATEMENT:  select * from hash_join_batches(
	$$
	  select count(*) from simple r join extremely_skewed s using (id);
	$$);
2023-08-01 17:01:38.607 +07 client backend[295960] pg_regress/join_hash LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295960.14.sharedfileset/o3of4.p0.0", size 163840
2023-08-01 17:01:38.607 +07 client backend[295960] pg_regress/join_hash STATEMENT:  select count(*) from simple r join extremely_skewed s using (id);
2023-08-01 17:01:38.607 +07 client backend[295960] pg_regress/join_hash LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295960.14.sharedfileset/o2of4.p1.0", size 163840
2023-08-01 17:01:38.607 +07 client backend[295960] pg_regress/join_hash STATEMENT:  select count(*) from simple r join extremely_skewed s using (id);
2023-08-01 17:01:38.607 +07 client backend[295960] pg_regress/join_hash LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295960.14.sharedfileset/o2of4.p0.0", size 163840
2023-08-01 17:01:38.607 +07 client backend[295960] pg_regress/join_hash STATEMENT:  select count(*) from simple r join extremely_skewed s using (id);
2023-08-01 17:01:38.607 +07 client backend[295960] pg_regress/join_hash LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295960.14.sharedfileset/o0of4.p1.0", size 163840
2023-08-01 17:01:38.607 +07 client backend[295960] pg_regress/join_hash STATEMENT:  select count(*) from simple r join extremely_skewed s using (id);
2023-08-01 17:01:38.607 +07 client backend[295960] pg_regress/join_hash LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295960.14.sharedfileset/o1of4.p0.0", size 163840
2023-08-01 17:01:38.607 +07 client backend[295960] pg_regress/join_hash STATEMENT:  select count(*) from simple r join extremely_skewed s using (id);
2023-08-01 17:01:38.607 +07 client backend[295960] pg_regress/join_hash LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295960.14.sharedfileset/i3of4.p0.0", size 360448
2023-08-01 17:01:38.607 +07 client backend[295960] pg_regress/join_hash STATEMENT:  select count(*) from simple r join extremely_skewed s using (id);
2023-08-01 17:01:38.607 +07 client backend[295960] pg_regress/join_hash LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295960.14.sharedfileset/o3of4.p1.0", size 163840
2023-08-01 17:01:38.607 +07 client backend[295960] pg_regress/join_hash STATEMENT:  select count(*) from simple r join extremely_skewed s using (id);
2023-08-01 17:01:38.607 +07 client backend[295960] pg_regress/join_hash LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295960.14.sharedfileset/o0of4.p0.0", size 163840
2023-08-01 17:01:38.607 +07 client backend[295960] pg_regress/join_hash STATEMENT:  select count(*) from simple r join extremely_skewed s using (id);
2023-08-01 17:01:38.607 +07 client backend[295960] pg_regress/join_hash LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295960.14.sharedfileset/o1of4.p1.0", size 163840
2023-08-01 17:01:38.607 +07 client backend[295960] pg_regress/join_hash STATEMENT:  select count(*) from simple r join extremely_skewed s using (id);
2023-08-01 17:01:38.607 +07 client backend[295960] pg_regress/join_hash LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295960.14.sharedfileset/i3of4.p1.0", size 163840
2023-08-01 17:01:38.607 +07 client backend[295960] pg_regress/join_hash STATEMENT:  select count(*) from simple r join extremely_skewed s using (id);
2023-08-01 17:01:38.617 +07 client backend[295960] pg_regress/join_hash LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295960.15.sharedfileset/o3of4.p0.0", size 163840
2023-08-01 17:01:38.617 +07 client backend[295960] pg_regress/join_hash CONTEXT:  PL/pgSQL function hash_join_batches(text) line 6 at FOR over EXECUTE statement
2023-08-01 17:01:38.617 +07 client backend[295960] pg_regress/join_hash STATEMENT:  select * from hash_join_batches(
	$$
	  select count(*) from simple r join extremely_skewed s using (id);
	$$);
2023-08-01 17:01:38.617 +07 client backend[295960] pg_regress/join_hash LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295960.15.sharedfileset/o2of4.p1.0", size 163840
2023-08-01 17:01:38.617 +07 client backend[295960] pg_regress/join_hash CONTEXT:  PL/pgSQL function hash_join_batches(text) line 6 at FOR over EXECUTE statement
2023-08-01 17:01:38.617 +07 client backend[295960] pg_regress/join_hash STATEMENT:  select * from hash_join_batches(
	$$
	  select count(*) from simple r join extremely_skewed s using (id);
	$$);
2023-08-01 17:01:38.617 +07 client backend[295960] pg_regress/join_hash LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295960.15.sharedfileset/o2of4.p0.0", size 163840
2023-08-01 17:01:38.617 +07 client backend[295960] pg_regress/join_hash CONTEXT:  PL/pgSQL function hash_join_batches(text) line 6 at FOR over EXECUTE statement
2023-08-01 17:01:38.617 +07 client backend[295960] pg_regress/join_hash STATEMENT:  select * from hash_join_batches(
	$$
	  select count(*) from simple r join extremely_skewed s using (id);
	$$);
2023-08-01 17:01:38.617 +07 client backend[295960] pg_regress/join_hash LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295960.15.sharedfileset/o0of4.p1.0", size 163840
2023-08-01 17:01:38.617 +07 client backend[295960] pg_regress/join_hash CONTEXT:  PL/pgSQL function hash_join_batches(text) line 6 at FOR over EXECUTE statement
2023-08-01 17:01:38.617 +07 client backend[295960] pg_regress/join_hash STATEMENT:  select * from hash_join_batches(
	$$
	  select count(*) from simple r join extremely_skewed s using (id);
	$$);
2023-08-01 17:01:38.617 +07 client backend[295960] pg_regress/join_hash LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295960.15.sharedfileset/o1of4.p0.0", size 163840
2023-08-01 17:01:38.617 +07 client backend[295960] pg_regress/join_hash CONTEXT:  PL/pgSQL function hash_join_batches(text) line 6 at FOR over EXECUTE statement
2023-08-01 17:01:38.617 +07 client backend[295960] pg_regress/join_hash STATEMENT:  select * from hash_join_batches(
	$$
	  select count(*) from simple r join extremely_skewed s using (id);
	$$);
2023-08-01 17:01:38.617 +07 client backend[295960] pg_regress/join_hash LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295960.15.sharedfileset/i3of4.p0.0", size 327680
2023-08-01 17:01:38.617 +07 client backend[295960] pg_regress/join_hash CONTEXT:  PL/pgSQL function hash_join_batches(text) line 6 at FOR over EXECUTE statement
2023-08-01 17:01:38.617 +07 client backend[295960] pg_regress/join_hash STATEMENT:  select * from hash_join_batches(
	$$
	  select count(*) from simple r join extremely_skewed s using (id);
	$$);
2023-08-01 17:01:38.617 +07 client backend[295960] pg_regress/join_hash LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295960.15.sharedfileset/o3of4.p1.0", size 163840
2023-08-01 17:01:38.617 +07 client backend[295960] pg_regress/join_hash CONTEXT:  PL/pgSQL function hash_join_batches(text) line 6 at FOR over EXECUTE statement
2023-08-01 17:01:38.617 +07 client backend[295960] pg_regress/join_hash STATEMENT:  select * from hash_join_batches(
	$$
	  select count(*) from simple r join extremely_skewed s using (id);
	$$);
2023-08-01 17:01:38.617 +07 client backend[295960] pg_regress/join_hash LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295960.15.sharedfileset/o0of4.p0.0", size 163840
2023-08-01 17:01:38.617 +07 client backend[295960] pg_regress/join_hash CONTEXT:  PL/pgSQL function hash_join_batches(text) line 6 at FOR over EXECUTE statement
2023-08-01 17:01:38.617 +07 client backend[295960] pg_regress/join_hash STATEMENT:  select * from hash_join_batches(
	$$
	  select count(*) from simple r join extremely_skewed s using (id);
	$$);
2023-08-01 17:01:38.617 +07 client backend[295960] pg_regress/join_hash LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295960.15.sharedfileset/o1of4.p1.0", size 163840
2023-08-01 17:01:38.617 +07 client backend[295960] pg_regress/join_hash CONTEXT:  PL/pgSQL function hash_join_batches(text) line 6 at FOR over EXECUTE statement
2023-08-01 17:01:38.617 +07 client backend[295960] pg_regress/join_hash STATEMENT:  select * from hash_join_batches(
	$$
	  select count(*) from simple r join extremely_skewed s using (id);
	$$);
2023-08-01 17:01:38.617 +07 client backend[295960] pg_regress/join_hash LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295960.15.sharedfileset/i3of4.p1.0", size 196608
2023-08-01 17:01:38.617 +07 client backend[295960] pg_regress/join_hash CONTEXT:  PL/pgSQL function hash_join_batches(text) line 6 at FOR over EXECUTE statement
2023-08-01 17:01:38.617 +07 client backend[295960] pg_regress/join_hash STATEMENT:  select * from hash_join_batches(
	$$
	  select count(*) from simple r join extremely_skewed s using (id);
	$$);
2023-08-01 17:01:38.855 +07 client backend[295960] pg_regress/join_hash LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295960.25.sharedfileset/i7of8.p0.0", size 327680
2023-08-01 17:01:38.855 +07 client backend[295960] pg_regress/join_hash STATEMENT:  select length(max(s.t))
	from wide left join (select id, coalesce(t, '') || '' as t from wide) s using (id);
2023-08-01 17:01:38.856 +07 client backend[295960] pg_regress/join_hash LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295960.25.sharedfileset/i5of8.p0.0", size 327680
2023-08-01 17:01:38.856 +07 client backend[295960] pg_regress/join_hash STATEMENT:  select length(max(s.t))
	from wide left join (select id, coalesce(t, '') || '' as t from wide) s using (id);
2023-08-01 17:01:38.859 +07 client backend[295960] pg_regress/join_hash LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295960.26.sharedfileset/i7of8.p0.0", size 327680
2023-08-01 17:01:38.859 +07 client backend[295960] pg_regress/join_hash CONTEXT:  PL/pgSQL function hash_join_batches(text) line 6 at FOR over EXECUTE statement
2023-08-01 17:01:38.859 +07 client backend[295960] pg_regress/join_hash STATEMENT:  select final > 1 as multibatch
	  from hash_join_batches(
	$$
	  select length(max(s.t))
	  from wide left join (select id, coalesce(t, '') || '' as t from wide) s using (id);
	$$);
2023-08-01 17:01:38.859 +07 client backend[295960] pg_regress/join_hash LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp295960.26.sharedfileset/i5of8.p0.0", size 327680
2023-08-01 17:01:38.859 +07 client backend[295960] pg_regress/join_hash CONTEXT:  PL/pgSQL function hash_join_batches(text) line 6 at FOR over EXECUTE statement
2023-08-01 17:01:38.859 +07 client backend[295960] pg_regress/join_hash STATEMENT:  select final > 1 as multibatch
	  from hash_join_batches(
	$$
	  select length(max(s.t))
	  from wide left join (select id, coalesce(t, '') || '' as t from wide) s using (id);
	$$);
2023-08-01 17:01:38.897 +07 client backend[296180] pg_regress/async ERROR:  channel name cannot be empty
2023-08-01 17:01:38.897 +07 client backend[296180] pg_regress/async STATEMENT:  SELECT pg_notify('','sample message1');
2023-08-01 17:01:38.897 +07 client backend[296180] pg_regress/async ERROR:  channel name cannot be empty
2023-08-01 17:01:38.897 +07 client backend[296180] pg_regress/async STATEMENT:  SELECT pg_notify(NULL,'sample message1');
2023-08-01 17:01:38.897 +07 client backend[296181] pg_regress/dbsize ERROR:  invalid size: "1 AB"
2023-08-01 17:01:38.897 +07 client backend[296181] pg_regress/dbsize DETAIL:  Invalid size unit: "AB".
2023-08-01 17:01:38.897 +07 client backend[296181] pg_regress/dbsize HINT:  Valid units are "bytes", "kB", "MB", "GB", and "TB".
2023-08-01 17:01:38.897 +07 client backend[296181] pg_regress/dbsize STATEMENT:  SELECT pg_size_bytes('1 AB');
2023-08-01 17:01:38.897 +07 client backend[296181] pg_regress/dbsize ERROR:  invalid size: "1 AB A"
2023-08-01 17:01:38.897 +07 client backend[296181] pg_regress/dbsize DETAIL:  Invalid size unit: "AB A".
2023-08-01 17:01:38.897 +07 client backend[296181] pg_regress/dbsize HINT:  Valid units are "bytes", "kB", "MB", "GB", and "TB".
2023-08-01 17:01:38.897 +07 client backend[296181] pg_regress/dbsize STATEMENT:  SELECT pg_size_bytes('1 AB A');
2023-08-01 17:01:38.897 +07 client backend[296181] pg_regress/dbsize ERROR:  invalid size: "1 AB A    "
2023-08-01 17:01:38.897 +07 client backend[296181] pg_regress/dbsize DETAIL:  Invalid size unit: "AB A".
2023-08-01 17:01:38.897 +07 client backend[296181] pg_regress/dbsize HINT:  Valid units are "bytes", "kB", "MB", "GB", and "TB".
2023-08-01 17:01:38.897 +07 client backend[296181] pg_regress/dbsize STATEMENT:  SELECT pg_size_bytes('1 AB A    ');
2023-08-01 17:01:38.897 +07 client backend[296181] pg_regress/dbsize ERROR:  bigint out of range
2023-08-01 17:01:38.897 +07 client backend[296181] pg_regress/dbsize STATEMENT:  SELECT pg_size_bytes('9223372036854775807.9');
2023-08-01 17:01:38.897 +07 client backend[296181] pg_regress/dbsize ERROR:  bigint out of range
2023-08-01 17:01:38.897 +07 client backend[296181] pg_regress/dbsize STATEMENT:  SELECT pg_size_bytes('1e100');
2023-08-01 17:01:38.897 +07 client backend[296181] pg_regress/dbsize ERROR:  value overflows numeric format
2023-08-01 17:01:38.897 +07 client backend[296181] pg_regress/dbsize STATEMENT:  SELECT pg_size_bytes('1e1000000000000000000');
2023-08-01 17:01:38.897 +07 client backend[296181] pg_regress/dbsize ERROR:  invalid size: "1 byte"
2023-08-01 17:01:38.897 +07 client backend[296181] pg_regress/dbsize DETAIL:  Invalid size unit: "byte".
2023-08-01 17:01:38.897 +07 client backend[296181] pg_regress/dbsize HINT:  Valid units are "bytes", "kB", "MB", "GB", and "TB".
2023-08-01 17:01:38.897 +07 client backend[296181] pg_regress/dbsize STATEMENT:  SELECT pg_size_bytes('1 byte');
2023-08-01 17:01:38.897 +07 client backend[296181] pg_regress/dbsize ERROR:  invalid size: ""
2023-08-01 17:01:38.897 +07 client backend[296181] pg_regress/dbsize STATEMENT:  SELECT pg_size_bytes('');
2023-08-01 17:01:38.897 +07 client backend[296181] pg_regress/dbsize ERROR:  invalid size: "kb"
2023-08-01 17:01:38.897 +07 client backend[296181] pg_regress/dbsize STATEMENT:  SELECT pg_size_bytes('kb');
2023-08-01 17:01:38.897 +07 client backend[296180] pg_regress/async ERROR:  channel name too long
2023-08-01 17:01:38.897 +07 client backend[296180] pg_regress/async STATEMENT:  SELECT pg_notify('notify_async_channel_name_too_long______________________________','sample_message1');
2023-08-01 17:01:38.897 +07 client backend[296181] pg_regress/dbsize ERROR:  invalid size: ".."
2023-08-01 17:01:38.897 +07 client backend[296181] pg_regress/dbsize STATEMENT:  SELECT pg_size_bytes('..');
2023-08-01 17:01:38.898 +07 client backend[296181] pg_regress/dbsize ERROR:  invalid size: "-."
2023-08-01 17:01:38.898 +07 client backend[296181] pg_regress/dbsize STATEMENT:  SELECT pg_size_bytes('-.');
2023-08-01 17:01:38.898 +07 client backend[296181] pg_regress/dbsize ERROR:  invalid size: "-.kb"
2023-08-01 17:01:38.898 +07 client backend[296181] pg_regress/dbsize STATEMENT:  SELECT pg_size_bytes('-.kb');
2023-08-01 17:01:38.898 +07 client backend[296181] pg_regress/dbsize ERROR:  invalid size: "-. kb"
2023-08-01 17:01:38.898 +07 client backend[296181] pg_regress/dbsize STATEMENT:  SELECT pg_size_bytes('-. kb');
2023-08-01 17:01:38.898 +07 client backend[296181] pg_regress/dbsize ERROR:  invalid size: ".+912"
2023-08-01 17:01:38.898 +07 client backend[296181] pg_regress/dbsize STATEMENT:  SELECT pg_size_bytes('.+912');
2023-08-01 17:01:38.898 +07 client backend[296181] pg_regress/dbsize ERROR:  invalid size: "+912+ kB"
2023-08-01 17:01:38.898 +07 client backend[296181] pg_regress/dbsize DETAIL:  Invalid size unit: "+ kB".
2023-08-01 17:01:38.898 +07 client backend[296181] pg_regress/dbsize HINT:  Valid units are "bytes", "kB", "MB", "GB", and "TB".
2023-08-01 17:01:38.898 +07 client backend[296181] pg_regress/dbsize STATEMENT:  SELECT pg_size_bytes('+912+ kB');
2023-08-01 17:01:38.898 +07 client backend[296181] pg_regress/dbsize ERROR:  invalid size: "++123 kB"
2023-08-01 17:01:38.898 +07 client backend[296181] pg_regress/dbsize STATEMENT:  SELECT pg_size_bytes('++123 kB');
2023-08-01 17:01:38.899 +07 client backend[296177] pg_regress/create_table_like ERROR:  relation "nonexistent" does not exist at character 24
2023-08-01 17:01:38.899 +07 client backend[296177] pg_regress/create_table_like STATEMENT:  CREATE TABLE foo (LIKE nonexistent);
2023-08-01 17:01:38.900 +07 client backend[296187] pg_regress/tsrf ERROR:  set-returning functions must appear at top level of FROM at character 34
2023-08-01 17:01:38.900 +07 client backend[296187] pg_regress/tsrf STATEMENT:  SELECT * FROM generate_series(1, generate_series(1, 3));
2023-08-01 17:01:38.900 +07 client backend[296177] pg_regress/create_table_like ERROR:  column "xx" specified more than once
2023-08-01 17:01:38.900 +07 client backend[296177] pg_regress/create_table_like STATEMENT:  /* Has ee entry */
	CREATE TABLE inhf (LIKE inhx, LIKE inhx);
2023-08-01 17:01:38.901 +07 client backend[296182] pg_regress/misc_functions ERROR:  function num_nonnulls() does not exist at character 8
2023-08-01 17:01:38.901 +07 client backend[296182] pg_regress/misc_functions HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:38.901 +07 client backend[296182] pg_regress/misc_functions STATEMENT:  SELECT num_nonnulls();
2023-08-01 17:01:38.901 +07 client backend[296182] pg_regress/misc_functions ERROR:  function num_nulls() does not exist at character 8
2023-08-01 17:01:38.901 +07 client backend[296182] pg_regress/misc_functions HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:38.901 +07 client backend[296182] pg_regress/misc_functions STATEMENT:  SELECT num_nulls();
2023-08-01 17:01:38.902 +07 client backend[296183] pg_regress/alter_generic ERROR:  function alt_func1(integer) is not an aggregate
2023-08-01 17:01:38.902 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER AGGREGATE alt_func1(int) RENAME TO alt_func3;
2023-08-01 17:01:38.902 +07 client backend[296183] pg_regress/alter_generic ERROR:  function alt_func1(integer) is not an aggregate
2023-08-01 17:01:38.902 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER AGGREGATE alt_func1(int) OWNER TO regress_alter_generic_user3;
2023-08-01 17:01:38.903 +07 client backend[296183] pg_regress/alter_generic ERROR:  function alt_func1(integer) is not an aggregate
2023-08-01 17:01:38.903 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER AGGREGATE alt_func1(int) SET SCHEMA alt_nsp2;
2023-08-01 17:01:38.903 +07 client backend[296183] pg_regress/alter_generic ERROR:  function alt_func2(integer) already exists in schema "alt_nsp1"
2023-08-01 17:01:38.903 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER FUNCTION alt_func1(int) RENAME TO alt_func2;
2023-08-01 17:01:38.903 +07 client backend[296183] pg_regress/alter_generic ERROR:  must be member of role "regress_alter_generic_user2"
2023-08-01 17:01:38.903 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER FUNCTION alt_func2(int) OWNER TO regress_alter_generic_user2;
2023-08-01 17:01:38.904 +07 client backend[296184] pg_regress/tid ERROR:  tid (0, 1) is not valid for relation "tid_matview"
2023-08-01 17:01:38.904 +07 client backend[296184] pg_regress/tid STATEMENT:  SELECT currtid('tid_matview'::regclass::oid, '(0,1)'::tid);
2023-08-01 17:01:38.904 +07 client backend[296184] pg_regress/tid ERROR:  tid (0, 1) is not valid for relation "tid_matview"
2023-08-01 17:01:38.904 +07 client backend[296184] pg_regress/tid STATEMENT:  SELECT currtid2('tid_matview'::text, '(0,1)'::tid);
2023-08-01 17:01:38.905 +07 client backend[296178] pg_regress/alter_operator ERROR:  operator attribute "commutator" cannot be changed
2023-08-01 17:01:38.905 +07 client backend[296178] pg_regress/alter_operator STATEMENT:  ALTER OPERATOR === (boolean, boolean) SET (COMMUTATOR = ====);
2023-08-01 17:01:38.905 +07 client backend[296183] pg_regress/alter_generic ERROR:  function alt_agg2(integer) already exists in schema "alt_nsp1"
2023-08-01 17:01:38.905 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER AGGREGATE alt_agg1(int) RENAME TO alt_agg2;
2023-08-01 17:01:38.906 +07 client backend[296183] pg_regress/alter_generic ERROR:  must be member of role "regress_alter_generic_user2"
2023-08-01 17:01:38.906 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER AGGREGATE alt_agg2(int) OWNER TO regress_alter_generic_user2;
2023-08-01 17:01:38.906 +07 client backend[296178] pg_regress/alter_operator ERROR:  operator attribute "negator" cannot be changed
2023-08-01 17:01:38.906 +07 client backend[296178] pg_regress/alter_operator STATEMENT:  ALTER OPERATOR === (boolean, boolean) SET (NEGATOR = ====);
2023-08-01 17:01:38.906 +07 client backend[296178] pg_regress/alter_operator ERROR:  function non_existent_func(internal, oid, internal, integer) does not exist
2023-08-01 17:01:38.906 +07 client backend[296178] pg_regress/alter_operator STATEMENT:  ALTER OPERATOR === (boolean, boolean) SET (RESTRICT = non_existent_func);
2023-08-01 17:01:38.906 +07 client backend[296178] pg_regress/alter_operator ERROR:  function non_existent_func(internal, oid, internal, smallint, internal) does not exist
2023-08-01 17:01:38.906 +07 client backend[296178] pg_regress/alter_operator STATEMENT:  ALTER OPERATOR === (boolean, boolean) SET (JOIN = non_existent_func);
2023-08-01 17:01:38.906 +07 client backend[296178] pg_regress/alter_operator ERROR:  operator attribute "commutator" cannot be changed
2023-08-01 17:01:38.906 +07 client backend[296178] pg_regress/alter_operator STATEMENT:  ALTER OPERATOR === (boolean, boolean) SET (COMMUTATOR = !==);
2023-08-01 17:01:38.906 +07 client backend[296178] pg_regress/alter_operator ERROR:  operator attribute "negator" cannot be changed
2023-08-01 17:01:38.906 +07 client backend[296178] pg_regress/alter_operator STATEMENT:  ALTER OPERATOR === (boolean, boolean) SET (NEGATOR = !==);
2023-08-01 17:01:38.906 +07 client backend[296178] pg_regress/alter_operator ERROR:  operator attribute "Restrict" not recognized
2023-08-01 17:01:38.906 +07 client backend[296178] pg_regress/alter_operator STATEMENT:  ALTER OPERATOR & (bit, bit) SET ("Restrict" = _int_contsel, "Join" = _int_contjoinsel);
2023-08-01 17:01:38.907 +07 client backend[296178] pg_regress/alter_operator ERROR:  must be owner of operator ===
2023-08-01 17:01:38.907 +07 client backend[296178] pg_regress/alter_operator STATEMENT:  ALTER OPERATOR === (boolean, boolean) SET (RESTRICT = NONE);
2023-08-01 17:01:38.908 +07 client backend[296184] pg_regress/tid ERROR:  "tid_ind" is an index
2023-08-01 17:01:38.908 +07 client backend[296184] pg_regress/tid STATEMENT:  SELECT currtid('tid_ind'::regclass::oid, '(0,1)'::tid);
2023-08-01 17:01:38.908 +07 client backend[296184] pg_regress/tid ERROR:  "tid_ind" is an index
2023-08-01 17:01:38.908 +07 client backend[296184] pg_regress/tid STATEMENT:  SELECT currtid2('tid_ind'::text, '(0,1)'::tid);
2023-08-01 17:01:38.908 +07 client backend[296184] pg_regress/tid ERROR:  cannot look at latest visible tid for relation "public.tid_part"
2023-08-01 17:01:38.908 +07 client backend[296184] pg_regress/tid STATEMENT:  SELECT currtid('tid_part'::regclass::oid, '(0,1)'::tid);
2023-08-01 17:01:38.908 +07 client backend[296184] pg_regress/tid ERROR:  cannot look at latest visible tid for relation "public.tid_part"
2023-08-01 17:01:38.908 +07 client backend[296184] pg_regress/tid STATEMENT:  SELECT currtid2('tid_part'::text, '(0,1)'::tid);
2023-08-01 17:01:38.908 +07 client backend[296177] pg_regress/create_table_like ERROR:  new row for relation "inhg" violates check constraint "foo"
2023-08-01 17:01:38.908 +07 client backend[296177] pg_regress/create_table_like DETAIL:  Failing row contains (x, foo, y).
2023-08-01 17:01:38.908 +07 client backend[296177] pg_regress/create_table_like STATEMENT:  /* Succeeds -- Unique constraints not copied */
	INSERT INTO inhg VALUES ('x', 'foo',  'y');
2023-08-01 17:01:38.909 +07 client backend[296188] pg_regress/tidscan ERROR:  cursor "c" is not positioned on a row
2023-08-01 17:01:38.909 +07 client backend[296188] pg_regress/tidscan STATEMENT:  EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF)
	UPDATE tidscan SET id = -id WHERE CURRENT OF c RETURNING *;
2023-08-01 17:01:38.909 +07 client backend[296184] pg_regress/tid ERROR:  currtid cannot handle views with no CTID
2023-08-01 17:01:38.909 +07 client backend[296184] pg_regress/tid STATEMENT:  SELECT currtid('tid_view_no_ctid'::regclass::oid, '(0,1)'::tid);
2023-08-01 17:01:38.909 +07 client backend[296184] pg_regress/tid ERROR:  currtid cannot handle views with no CTID
2023-08-01 17:01:38.909 +07 client backend[296184] pg_regress/tid STATEMENT:  SELECT currtid2('tid_view_no_ctid'::text, '(0,1)'::tid);
2023-08-01 17:01:38.910 +07 client backend[296184] pg_regress/tid ERROR:  tid (0, 1) is not valid for relation "tid_tab"
2023-08-01 17:01:38.910 +07 client backend[296184] pg_regress/tid STATEMENT:  SELECT currtid('tid_view_with_ctid'::regclass::oid, '(0,1)'::tid);
2023-08-01 17:01:38.910 +07 client backend[296184] pg_regress/tid ERROR:  tid (0, 1) is not valid for relation "tid_tab"
2023-08-01 17:01:38.910 +07 client backend[296184] pg_regress/tid STATEMENT:  SELECT currtid2('tid_view_with_ctid'::text, '(0,1)'::tid);
2023-08-01 17:01:38.910 +07 client backend[296187] pg_regress/tsrf ERROR:  set-returning functions are not allowed in CASE at character 34
2023-08-01 17:01:38.910 +07 client backend[296187] pg_regress/tsrf HINT:  You might be able to move the set-returning function into a LATERAL FROM item.
2023-08-01 17:01:38.910 +07 client backend[296187] pg_regress/tsrf STATEMENT:  SELECT q1, case when q1 > 0 then generate_series(1,3) else 0 end FROM int8_tbl;
2023-08-01 17:01:38.910 +07 client backend[296187] pg_regress/tsrf ERROR:  set-returning functions are not allowed in COALESCE at character 21
2023-08-01 17:01:38.910 +07 client backend[296187] pg_regress/tsrf HINT:  You might be able to move the set-returning function into a LATERAL FROM item.
2023-08-01 17:01:38.910 +07 client backend[296187] pg_regress/tsrf STATEMENT:  SELECT q1, coalesce(generate_series(1,3), 0) FROM int8_tbl;
2023-08-01 17:01:38.911 +07 client backend[296187] pg_regress/tsrf ERROR:  aggregate function calls cannot contain set-returning function calls at character 12
2023-08-01 17:01:38.911 +07 client backend[296187] pg_regress/tsrf HINT:  You might be able to move the set-returning function into a LATERAL FROM item.
2023-08-01 17:01:38.911 +07 client backend[296187] pg_regress/tsrf STATEMENT:  SELECT min(generate_series(1, 3)) FROM few;
2023-08-01 17:01:38.911 +07 client backend[296187] pg_regress/tsrf ERROR:  window function calls cannot contain set-returning function calls at character 12
2023-08-01 17:01:38.911 +07 client backend[296187] pg_regress/tsrf HINT:  You might be able to move the set-returning function into a LATERAL FROM item.
2023-08-01 17:01:38.911 +07 client backend[296187] pg_regress/tsrf STATEMENT:  SELECT min(generate_series(1, 3)) OVER() FROM few;
2023-08-01 17:01:38.912 +07 client backend[296184] pg_regress/tid ERROR:  ctid isn't of type TID
2023-08-01 17:01:38.912 +07 client backend[296184] pg_regress/tid STATEMENT:  SELECT currtid('tid_view_fake_ctid'::regclass::oid, '(0,1)'::tid);
2023-08-01 17:01:38.912 +07 client backend[296184] pg_regress/tid ERROR:  ctid isn't of type TID
2023-08-01 17:01:38.912 +07 client backend[296184] pg_regress/tid STATEMENT:  SELECT currtid2('tid_view_fake_ctid'::text, '(0,1)'::tid);
2023-08-01 17:01:38.914 +07 client backend[296183] pg_regress/alter_generic ERROR:  must be owner of function alt_func3
2023-08-01 17:01:38.914 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER FUNCTION alt_func3(int) RENAME TO alt_func4;
2023-08-01 17:01:38.914 +07 client backend[296187] pg_regress/tsrf ERROR:  set-returning functions are not allowed in UPDATE at character 27
2023-08-01 17:01:38.914 +07 client backend[296187] pg_regress/tsrf STATEMENT:  UPDATE fewmore SET data = generate_series(4,9);
2023-08-01 17:01:38.914 +07 client backend[296183] pg_regress/alter_generic ERROR:  must be owner of function alt_func3
2023-08-01 17:01:38.914 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER FUNCTION alt_func3(int) OWNER TO regress_alter_generic_user2;
2023-08-01 17:01:38.914 +07 client backend[296187] pg_regress/tsrf ERROR:  set-returning functions are not allowed in RETURNING at character 41
2023-08-01 17:01:38.914 +07 client backend[296187] pg_regress/tsrf STATEMENT:  INSERT INTO fewmore VALUES(1) RETURNING generate_series(1,3);
2023-08-01 17:01:38.914 +07 client backend[296183] pg_regress/alter_generic ERROR:  must be member of role "regress_alter_generic_user3"
2023-08-01 17:01:38.914 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER FUNCTION alt_func2(int) OWNER TO regress_alter_generic_user3;
2023-08-01 17:01:38.914 +07 client backend[296187] pg_regress/tsrf ERROR:  set-returning functions are not allowed in VALUES at character 11
2023-08-01 17:01:38.914 +07 client backend[296187] pg_regress/tsrf STATEMENT:  VALUES(1, generate_series(1,2));
2023-08-01 17:01:38.914 +07 client backend[296183] pg_regress/alter_generic ERROR:  must be owner of function alt_func3
2023-08-01 17:01:38.914 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER FUNCTION alt_func3(int) SET SCHEMA alt_nsp2;
2023-08-01 17:01:38.915 +07 client backend[296183] pg_regress/alter_generic ERROR:  function alt_func2(integer) already exists in schema "alt_nsp2"
2023-08-01 17:01:38.915 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER FUNCTION alt_func2(int) SET SCHEMA alt_nsp2;
2023-08-01 17:01:38.915 +07 client backend[296183] pg_regress/alter_generic ERROR:  must be owner of function alt_agg3
2023-08-01 17:01:38.915 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER AGGREGATE alt_agg3(int) RENAME TO alt_agg4;
2023-08-01 17:01:38.915 +07 client backend[296187] pg_regress/tsrf ERROR:  set-returning functions must appear at top level of FROM at character 23
2023-08-01 17:01:38.915 +07 client backend[296187] pg_regress/tsrf STATEMENT:  SELECT * FROM int4mul(generate_series(1,2), 10);
2023-08-01 17:01:38.915 +07 client backend[296183] pg_regress/alter_generic ERROR:  must be owner of function alt_agg3
2023-08-01 17:01:38.915 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER AGGREGATE alt_agg3(int) OWNER TO regress_alter_generic_user2;
2023-08-01 17:01:38.915 +07 client backend[296183] pg_regress/alter_generic ERROR:  must be member of role "regress_alter_generic_user3"
2023-08-01 17:01:38.915 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER AGGREGATE alt_agg2(int) OWNER TO regress_alter_generic_user3;
2023-08-01 17:01:38.915 +07 client backend[296183] pg_regress/alter_generic ERROR:  must be owner of function alt_agg3
2023-08-01 17:01:38.915 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER AGGREGATE alt_agg3(int) SET SCHEMA alt_nsp2;
2023-08-01 17:01:38.915 +07 client backend[296183] pg_regress/alter_generic ERROR:  function alt_agg2(integer) already exists in schema "alt_nsp2"
2023-08-01 17:01:38.915 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER AGGREGATE alt_agg2(int) SET SCHEMA alt_nsp2;
2023-08-01 17:01:38.916 +07 client backend[296187] pg_regress/tsrf ERROR:  set-returning functions are not allowed in LIMIT at character 16
2023-08-01 17:01:38.916 +07 client backend[296187] pg_regress/tsrf STATEMENT:  SELECT 1 LIMIT generate_series(1,3);
2023-08-01 17:01:38.917 +07 client backend[296183] pg_regress/alter_generic ERROR:  conversion "alt_conv2" already exists in schema "alt_nsp1"
2023-08-01 17:01:38.917 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER CONVERSION alt_conv1 RENAME TO alt_conv2;
2023-08-01 17:01:38.918 +07 client backend[296183] pg_regress/alter_generic ERROR:  must be member of role "regress_alter_generic_user2"
2023-08-01 17:01:38.918 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER CONVERSION alt_conv2 OWNER TO regress_alter_generic_user2;
2023-08-01 17:01:38.918 +07 client backend[296183] pg_regress/alter_generic ERROR:  must be owner of conversion alt_conv3
2023-08-01 17:01:38.918 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER CONVERSION alt_conv3 RENAME TO alt_conv4;
2023-08-01 17:01:38.919 +07 client backend[296183] pg_regress/alter_generic ERROR:  must be owner of conversion alt_conv3
2023-08-01 17:01:38.919 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER CONVERSION alt_conv3 OWNER TO regress_alter_generic_user2;
2023-08-01 17:01:38.919 +07 client backend[296183] pg_regress/alter_generic ERROR:  must be member of role "regress_alter_generic_user3"
2023-08-01 17:01:38.919 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER CONVERSION alt_conv2 OWNER TO regress_alter_generic_user3;
2023-08-01 17:01:38.919 +07 client backend[296183] pg_regress/alter_generic ERROR:  must be owner of conversion alt_conv3
2023-08-01 17:01:38.919 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER CONVERSION alt_conv3 SET SCHEMA alt_nsp2;
2023-08-01 17:01:38.919 +07 client backend[296183] pg_regress/alter_generic ERROR:  conversion "alt_conv2" already exists in schema "alt_nsp2"
2023-08-01 17:01:38.919 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER CONVERSION alt_conv2 SET SCHEMA alt_nsp2;
2023-08-01 17:01:38.919 +07 client backend[296177] pg_regress/create_table_like ERROR:  null value in column "a" of relation "test_like_id_2" violates not-null constraint
2023-08-01 17:01:38.919 +07 client backend[296177] pg_regress/create_table_like DETAIL:  Failing row contains (null, b2).
2023-08-01 17:01:38.919 +07 client backend[296177] pg_regress/create_table_like STATEMENT:  INSERT INTO test_like_id_2 (b) VALUES ('b2');
2023-08-01 17:01:38.920 +07 client backend[296183] pg_regress/alter_generic ERROR:  foreign-data wrapper "alt_fdw2" already exists
2023-08-01 17:01:38.920 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER FOREIGN DATA WRAPPER alt_fdw1 RENAME TO alt_fdw2;
2023-08-01 17:01:38.920 +07 client backend[296183] pg_regress/alter_generic ERROR:  server "alt_fserv2" already exists
2023-08-01 17:01:38.920 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER SERVER alt_fserv1 RENAME TO alt_fserv2;
2023-08-01 17:01:38.921 +07 client backend[296183] pg_regress/alter_generic ERROR:  language "alt_lang2" already exists
2023-08-01 17:01:38.921 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER LANGUAGE alt_lang1 RENAME TO alt_lang2;
2023-08-01 17:01:38.921 +07 client backend[296183] pg_regress/alter_generic ERROR:  must be owner of language alt_lang2
2023-08-01 17:01:38.921 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER LANGUAGE alt_lang2 RENAME TO alt_lang3;
2023-08-01 17:01:38.921 +07 client backend[296183] pg_regress/alter_generic ERROR:  must be owner of language alt_lang2
2023-08-01 17:01:38.921 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER LANGUAGE alt_lang2 OWNER TO regress_alter_generic_user3;
2023-08-01 17:01:38.922 +07 client backend[296183] pg_regress/alter_generic ERROR:  must be member of role "regress_alter_generic_user2"
2023-08-01 17:01:38.922 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER LANGUAGE alt_lang3 OWNER TO regress_alter_generic_user2;
2023-08-01 17:01:38.922 +07 client backend[296183] pg_regress/alter_generic ERROR:  must be member of role "regress_alter_generic_user2"
2023-08-01 17:01:38.922 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER OPERATOR @+@(int4, int4) OWNER TO regress_alter_generic_user2;
2023-08-01 17:01:38.923 +07 client backend[296183] pg_regress/alter_generic ERROR:  must be owner of operator @+@
2023-08-01 17:01:38.923 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER OPERATOR @+@(int4, int4) OWNER TO regress_alter_generic_user2;
2023-08-01 17:01:38.923 +07 client backend[296183] pg_regress/alter_generic ERROR:  must be member of role "regress_alter_generic_user3"
2023-08-01 17:01:38.923 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER OPERATOR @-@(int4, int4) OWNER TO regress_alter_generic_user3;
2023-08-01 17:01:38.923 +07 client backend[296183] pg_regress/alter_generic ERROR:  must be owner of operator @+@
2023-08-01 17:01:38.923 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER OPERATOR @+@(int4, int4) SET SCHEMA alt_nsp2;
2023-08-01 17:01:38.925 +07 client backend[296183] pg_regress/alter_generic ERROR:  operator family "alt_opf2" for access method "hash" already exists in schema "alt_nsp1"
2023-08-01 17:01:38.925 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER OPERATOR FAMILY alt_opf1 USING hash RENAME TO alt_opf2;
2023-08-01 17:01:38.925 +07 client backend[296183] pg_regress/alter_generic ERROR:  must be member of role "regress_alter_generic_user2"
2023-08-01 17:01:38.925 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER OPERATOR FAMILY alt_opf2 USING hash OWNER TO regress_alter_generic_user2;
2023-08-01 17:01:38.925 +07 client backend[296183] pg_regress/alter_generic ERROR:  operator class "alt_opc2" for access method "hash" already exists in schema "alt_nsp1"
2023-08-01 17:01:38.925 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER OPERATOR CLASS alt_opc1 USING hash RENAME TO alt_opc2;
2023-08-01 17:01:38.925 +07 client backend[296183] pg_regress/alter_generic ERROR:  must be member of role "regress_alter_generic_user2"
2023-08-01 17:01:38.925 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER OPERATOR CLASS alt_opc2 USING hash OWNER TO regress_alter_generic_user2;
2023-08-01 17:01:38.926 +07 client backend[296183] pg_regress/alter_generic ERROR:  must be owner of operator family alt_opf3
2023-08-01 17:01:38.926 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER OPERATOR FAMILY alt_opf3 USING hash RENAME TO alt_opf4;
2023-08-01 17:01:38.927 +07 client backend[296183] pg_regress/alter_generic ERROR:  must be owner of operator family alt_opf3
2023-08-01 17:01:38.927 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER OPERATOR FAMILY alt_opf3 USING hash OWNER TO regress_alter_generic_user2;
2023-08-01 17:01:38.927 +07 client backend[296183] pg_regress/alter_generic ERROR:  must be member of role "regress_alter_generic_user3"
2023-08-01 17:01:38.927 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER OPERATOR FAMILY alt_opf2 USING hash OWNER TO regress_alter_generic_user3;
2023-08-01 17:01:38.927 +07 client backend[296183] pg_regress/alter_generic ERROR:  must be owner of operator family alt_opf3
2023-08-01 17:01:38.927 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER OPERATOR FAMILY alt_opf3 USING hash SET SCHEMA alt_nsp2;
2023-08-01 17:01:38.927 +07 client backend[296183] pg_regress/alter_generic ERROR:  operator family "alt_opf2" for access method "hash" already exists in schema "alt_nsp2"
2023-08-01 17:01:38.927 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER OPERATOR FAMILY alt_opf2 USING hash SET SCHEMA alt_nsp2;
2023-08-01 17:01:38.927 +07 client backend[296183] pg_regress/alter_generic ERROR:  must be owner of operator class alt_opc3
2023-08-01 17:01:38.927 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER OPERATOR CLASS alt_opc3 USING hash RENAME TO alt_opc4;
2023-08-01 17:01:38.927 +07 client backend[296183] pg_regress/alter_generic ERROR:  must be owner of operator class alt_opc3
2023-08-01 17:01:38.927 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER OPERATOR CLASS alt_opc3 USING hash OWNER TO regress_alter_generic_user2;
2023-08-01 17:01:38.927 +07 client backend[296183] pg_regress/alter_generic ERROR:  must be member of role "regress_alter_generic_user3"
2023-08-01 17:01:38.927 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER OPERATOR CLASS alt_opc2 USING hash OWNER TO regress_alter_generic_user3;
2023-08-01 17:01:38.927 +07 client backend[296183] pg_regress/alter_generic ERROR:  must be owner of operator class alt_opc3
2023-08-01 17:01:38.927 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER OPERATOR CLASS alt_opc3 USING hash SET SCHEMA alt_nsp2;
2023-08-01 17:01:38.927 +07 client backend[296183] pg_regress/alter_generic ERROR:  operator class "alt_opc2" for access method "hash" already exists in schema "alt_nsp2"
2023-08-01 17:01:38.927 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER OPERATOR CLASS alt_opc2 USING hash SET SCHEMA alt_nsp2;
2023-08-01 17:01:38.929 +07 client backend[296183] pg_regress/alter_generic ERROR:  access method "invalid_index_method" does not exist
2023-08-01 17:01:38.929 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER OPERATOR FAMILY alt_opf4 USING invalid_index_method ADD  OPERATOR 1 < (int4, int2);
2023-08-01 17:01:38.929 +07 client backend[296183] pg_regress/alter_generic ERROR:  invalid operator number 6, must be between 1 and 5
2023-08-01 17:01:38.929 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER OPERATOR FAMILY alt_opf4 USING btree ADD OPERATOR 6 < (int4, int2);
2023-08-01 17:01:38.929 +07 client backend[296183] pg_regress/alter_generic ERROR:  invalid operator number 0, must be between 1 and 5
2023-08-01 17:01:38.929 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER OPERATOR FAMILY alt_opf4 USING btree ADD OPERATOR 0 < (int4, int2);
2023-08-01 17:01:38.929 +07 client backend[296183] pg_regress/alter_generic ERROR:  operator argument types must be specified in ALTER OPERATOR FAMILY
2023-08-01 17:01:38.929 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER OPERATOR FAMILY alt_opf4 USING btree ADD OPERATOR 1 < ;
2023-08-01 17:01:38.929 +07 client backend[296183] pg_regress/alter_generic ERROR:  invalid function number 0, must be between 1 and 5
2023-08-01 17:01:38.929 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER OPERATOR FAMILY alt_opf4 USING btree ADD FUNCTION 0 btint42cmp(int4, int2);
2023-08-01 17:01:38.930 +07 client backend[296183] pg_regress/alter_generic ERROR:  invalid function number 6, must be between 1 and 5
2023-08-01 17:01:38.930 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER OPERATOR FAMILY alt_opf4 USING btree ADD FUNCTION 6 btint42cmp(int4, int2);
2023-08-01 17:01:38.930 +07 client backend[296183] pg_regress/alter_generic ERROR:  STORAGE cannot be specified in ALTER OPERATOR FAMILY
2023-08-01 17:01:38.930 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER OPERATOR FAMILY alt_opf4 USING btree ADD STORAGE invalid_storage;
2023-08-01 17:01:38.930 +07 client backend[296183] pg_regress/alter_generic ERROR:  must be superuser to alter an operator family
2023-08-01 17:01:38.930 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER OPERATOR FAMILY alt_opf5 USING btree ADD OPERATOR 1 < (int4, int2), FUNCTION 1 btint42cmp(int4, int2);
2023-08-01 17:01:38.930 +07 client backend[296183] pg_regress/alter_generic ERROR:  current transaction is aborted, commands ignored until end of transaction block
2023-08-01 17:01:38.930 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  RESET ROLE;
2023-08-01 17:01:38.930 +07 client backend[296183] pg_regress/alter_generic ERROR:  current transaction is aborted, commands ignored until end of transaction block
2023-08-01 17:01:38.930 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  DROP OPERATOR FAMILY alt_opf5 USING btree;
2023-08-01 17:01:38.930 +07 client backend[296183] pg_regress/alter_generic ERROR:  permission denied for schema alt_nsp6
2023-08-01 17:01:38.930 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER OPERATOR FAMILY alt_nsp6.alt_opf6 USING btree ADD OPERATOR 1 < (int4, int2);
2023-08-01 17:01:38.931 +07 client backend[296183] pg_regress/alter_generic ERROR:  one or two argument types must be specified
2023-08-01 17:01:38.931 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER OPERATOR FAMILY alt_opf7 USING btree DROP OPERATOR 1 (int4, int2, int8);
2023-08-01 17:01:38.932 +07 client backend[296183] pg_regress/alter_generic ERROR:  access method "btree" does not support ordering operators
2023-08-01 17:01:38.932 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER OPERATOR FAMILY alt_opf10 USING btree ADD OPERATOR 1 < (int4, int4) FOR ORDER BY float_ops;
2023-08-01 17:01:38.932 +07 client backend[296183] pg_regress/alter_generic ERROR:  btree comparison functions must return integer
2023-08-01 17:01:38.932 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER OPERATOR FAMILY alt_opf12 USING btree ADD FUNCTION 1 fn_opf12(int4, int2);
2023-08-01 17:01:38.933 +07 client backend[296183] pg_regress/alter_generic ERROR:  current transaction is aborted, commands ignored until end of transaction block
2023-08-01 17:01:38.933 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  DROP OPERATOR FAMILY alt_opf12 USING btree;
2023-08-01 17:01:38.933 +07 client backend[296183] pg_regress/alter_generic ERROR:  hash function 1 must return integer
2023-08-01 17:01:38.933 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER OPERATOR FAMILY alt_opf13 USING hash ADD FUNCTION 1 fn_opf13(int4);
2023-08-01 17:01:38.933 +07 client backend[296183] pg_regress/alter_generic ERROR:  current transaction is aborted, commands ignored until end of transaction block
2023-08-01 17:01:38.933 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  DROP OPERATOR FAMILY alt_opf13 USING hash;
2023-08-01 17:01:38.933 +07 client backend[296183] pg_regress/alter_generic ERROR:  btree comparison functions must have two arguments
2023-08-01 17:01:38.933 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER OPERATOR FAMILY alt_opf14 USING btree ADD FUNCTION 1 fn_opf14(int4);
2023-08-01 17:01:38.933 +07 client backend[296183] pg_regress/alter_generic ERROR:  current transaction is aborted, commands ignored until end of transaction block
2023-08-01 17:01:38.933 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  DROP OPERATOR FAMILY alt_opf14 USING btree;
2023-08-01 17:01:38.934 +07 client backend[296183] pg_regress/alter_generic ERROR:  hash function 1 must have one argument
2023-08-01 17:01:38.934 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER OPERATOR FAMILY alt_opf15 USING hash ADD FUNCTION 1 fn_opf15(int4, int2);
2023-08-01 17:01:38.934 +07 client backend[296183] pg_regress/alter_generic ERROR:  current transaction is aborted, commands ignored until end of transaction block
2023-08-01 17:01:38.934 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  DROP OPERATOR FAMILY alt_opf15 USING hash;
2023-08-01 17:01:38.934 +07 client backend[296183] pg_regress/alter_generic ERROR:  associated data types must be specified for index support function
2023-08-01 17:01:38.934 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER OPERATOR FAMILY alt_opf16 USING gist ADD FUNCTION 1 btint42cmp(int4, int2);
2023-08-01 17:01:38.934 +07 client backend[296183] pg_regress/alter_generic ERROR:  operator number 1 for (integer,integer) appears more than once
2023-08-01 17:01:38.934 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER OPERATOR FAMILY alt_opf17 USING btree ADD OPERATOR 1 < (int4, int4), OPERATOR 1 < (int4, int4);
2023-08-01 17:01:38.944 +07 client backend[296183] pg_regress/alter_generic ERROR:  operator 1(integer,integer) already exists in operator family "alt_opf17"
2023-08-01 17:01:38.944 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER OPERATOR FAMILY alt_opf17 USING btree ADD OPERATOR 1 < (int4, int4);
2023-08-01 17:01:38.944 +07 client backend[296183] pg_regress/alter_generic ERROR:  function number 1 for (integer,smallint) appears more than once
2023-08-01 17:01:38.944 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER OPERATOR FAMILY alt_opf17 USING btree ADD
	  OPERATOR 1 < (int4, int2) ,
	  OPERATOR 2 <= (int4, int2) ,
	  OPERATOR 3 = (int4, int2) ,
	  OPERATOR 4 >= (int4, int2) ,
	  OPERATOR 5 > (int4, int2) ,
	  FUNCTION 1 btint42cmp(int4, int2) ,
	  FUNCTION 1 btint42cmp(int4, int2);
2023-08-01 17:01:38.945 +07 client backend[296183] pg_regress/alter_generic ERROR:  operator 1(integer,smallint) already exists in operator family "alt_opf17"
2023-08-01 17:01:38.945 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER OPERATOR FAMILY alt_opf17 USING btree ADD
	  OPERATOR 1 < (int4, int2) ,
	  OPERATOR 2 <= (int4, int2) ,
	  OPERATOR 3 = (int4, int2) ,
	  OPERATOR 4 >= (int4, int2) ,
	  OPERATOR 5 > (int4, int2) ,
	  FUNCTION 1 btint42cmp(int4, int2);
2023-08-01 17:01:38.945 +07 client backend[296183] pg_regress/alter_generic ERROR:  operator 1(integer,integer) does not exist in operator family "alt_opf18"
2023-08-01 17:01:38.945 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER OPERATOR FAMILY alt_opf18 USING btree DROP OPERATOR 1 (int4, int4);
2023-08-01 17:01:38.946 +07 client backend[296183] pg_regress/alter_generic ERROR:  btree equal image functions must not be cross-type
2023-08-01 17:01:38.946 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER OPERATOR FAMILY alt_opf18 USING btree
	  ADD FUNCTION 4 (int4, int2) btequalimage(oid);
2023-08-01 17:01:38.946 +07 client backend[296183] pg_regress/alter_generic ERROR:  function 2(integer,integer) does not exist in operator family "alt_opf18"
2023-08-01 17:01:38.946 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER OPERATOR FAMILY alt_opf18 USING btree DROP FUNCTION 2 (int4, int4);
2023-08-01 17:01:38.946 +07 client backend[296183] pg_regress/alter_generic ERROR:  function test_opclass_options_func(internal, text[], boolean) does not exist
2023-08-01 17:01:38.946 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER OPERATOR FAMILY alt_opf19 USING btree ADD FUNCTION 5 test_opclass_options_func(internal, text[], bool);
2023-08-01 17:01:38.946 +07 client backend[296183] pg_regress/alter_generic ERROR:  invalid operator class options parsing function
2023-08-01 17:01:38.946 +07 client backend[296183] pg_regress/alter_generic HINT:  Valid signature of operator class options parsing function is (internal) RETURNS void.
2023-08-01 17:01:38.946 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER OPERATOR FAMILY alt_opf19 USING btree ADD FUNCTION 5 (int4) btint42cmp(int4, int2);
2023-08-01 17:01:38.946 +07 client backend[296183] pg_regress/alter_generic ERROR:  left and right associated data types for operator class options parsing functions must match
2023-08-01 17:01:38.946 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER OPERATOR FAMILY alt_opf19 USING btree ADD FUNCTION 5 (int4, int2) btint42cmp(int4, int2);
2023-08-01 17:01:38.948 +07 client backend[296183] pg_regress/alter_generic ERROR:  statistics object "alt_stat2" already exists in schema "alt_nsp1"
2023-08-01 17:01:38.948 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER STATISTICS alt_stat1 RENAME TO alt_stat2;
2023-08-01 17:01:38.948 +07 client backend[296183] pg_regress/alter_generic ERROR:  must be member of role "regress_alter_generic_user2"
2023-08-01 17:01:38.948 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER STATISTICS alt_stat2 OWNER TO regress_alter_generic_user2;
2023-08-01 17:01:38.949 +07 client backend[296183] pg_regress/alter_generic ERROR:  must be owner of statistics object alt_stat3
2023-08-01 17:01:38.949 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER STATISTICS alt_stat3 RENAME TO alt_stat4;
2023-08-01 17:01:38.949 +07 client backend[296183] pg_regress/alter_generic ERROR:  must be owner of statistics object alt_stat3
2023-08-01 17:01:38.949 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER STATISTICS alt_stat3 OWNER TO regress_alter_generic_user2;
2023-08-01 17:01:38.949 +07 client backend[296183] pg_regress/alter_generic ERROR:  must be member of role "regress_alter_generic_user3"
2023-08-01 17:01:38.949 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER STATISTICS alt_stat2 OWNER TO regress_alter_generic_user3;
2023-08-01 17:01:38.949 +07 client backend[296183] pg_regress/alter_generic ERROR:  must be owner of statistics object alt_stat3
2023-08-01 17:01:38.949 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER STATISTICS alt_stat3 SET SCHEMA alt_nsp2;
2023-08-01 17:01:38.949 +07 client backend[296183] pg_regress/alter_generic ERROR:  statistics object "alt_stat2" already exists in schema "alt_nsp2"
2023-08-01 17:01:38.949 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER STATISTICS alt_stat2 SET SCHEMA alt_nsp2;
2023-08-01 17:01:38.950 +07 client backend[296183] pg_regress/alter_generic ERROR:  text search dictionary "alt_ts_dict2" already exists in schema "alt_nsp1"
2023-08-01 17:01:38.950 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER TEXT SEARCH DICTIONARY alt_ts_dict1 RENAME TO alt_ts_dict2;
2023-08-01 17:01:38.950 +07 client backend[296183] pg_regress/alter_generic ERROR:  must be member of role "regress_alter_generic_user2"
2023-08-01 17:01:38.950 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER TEXT SEARCH DICTIONARY alt_ts_dict2 OWNER TO regress_alter_generic_user2;
2023-08-01 17:01:38.950 +07 client backend[296186] pg_regress/incremental_sort LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp296186.0.sharedfileset/0.0", size 204800
2023-08-01 17:01:38.950 +07 client backend[296186] pg_regress/incremental_sort STATEMENT:  create index on t (a);
2023-08-01 17:01:38.950 +07 client backend[296183] pg_regress/alter_generic ERROR:  must be owner of text search dictionary alt_ts_dict3
2023-08-01 17:01:38.950 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER TEXT SEARCH DICTIONARY alt_ts_dict3 RENAME TO alt_ts_dict4;
2023-08-01 17:01:38.950 +07 client backend[296183] pg_regress/alter_generic ERROR:  must be owner of text search dictionary alt_ts_dict3
2023-08-01 17:01:38.950 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER TEXT SEARCH DICTIONARY alt_ts_dict3 OWNER TO regress_alter_generic_user2;
2023-08-01 17:01:38.950 +07 client backend[296183] pg_regress/alter_generic ERROR:  must be member of role "regress_alter_generic_user3"
2023-08-01 17:01:38.950 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER TEXT SEARCH DICTIONARY alt_ts_dict2 OWNER TO regress_alter_generic_user3;
2023-08-01 17:01:38.951 +07 client backend[296183] pg_regress/alter_generic ERROR:  must be owner of text search dictionary alt_ts_dict3
2023-08-01 17:01:38.951 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER TEXT SEARCH DICTIONARY alt_ts_dict3 SET SCHEMA alt_nsp2;
2023-08-01 17:01:38.951 +07 client backend[296183] pg_regress/alter_generic ERROR:  text search dictionary "alt_ts_dict2" already exists in schema "alt_nsp2"
2023-08-01 17:01:38.951 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER TEXT SEARCH DICTIONARY alt_ts_dict2 SET SCHEMA alt_nsp2;
2023-08-01 17:01:38.952 +07 client backend[296183] pg_regress/alter_generic ERROR:  text search configuration "alt_ts_conf2" already exists in schema "alt_nsp1"
2023-08-01 17:01:38.952 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER TEXT SEARCH CONFIGURATION alt_ts_conf1 RENAME TO alt_ts_conf2;
2023-08-01 17:01:38.952 +07 client backend[296183] pg_regress/alter_generic ERROR:  must be member of role "regress_alter_generic_user2"
2023-08-01 17:01:38.952 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER TEXT SEARCH CONFIGURATION alt_ts_conf2 OWNER TO regress_alter_generic_user2;
2023-08-01 17:01:38.952 +07 client backend[296183] pg_regress/alter_generic ERROR:  must be owner of text search configuration alt_ts_conf3
2023-08-01 17:01:38.952 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER TEXT SEARCH CONFIGURATION alt_ts_conf3 RENAME TO alt_ts_conf4;
2023-08-01 17:01:38.952 +07 client backend[296183] pg_regress/alter_generic ERROR:  must be owner of text search configuration alt_ts_conf3
2023-08-01 17:01:38.952 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER TEXT SEARCH CONFIGURATION alt_ts_conf3 OWNER TO regress_alter_generic_user2;
2023-08-01 17:01:38.953 +07 client backend[296183] pg_regress/alter_generic ERROR:  must be member of role "regress_alter_generic_user3"
2023-08-01 17:01:38.953 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER TEXT SEARCH CONFIGURATION alt_ts_conf2 OWNER TO regress_alter_generic_user3;
2023-08-01 17:01:38.953 +07 client backend[296183] pg_regress/alter_generic ERROR:  must be owner of text search configuration alt_ts_conf3
2023-08-01 17:01:38.953 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER TEXT SEARCH CONFIGURATION alt_ts_conf3 SET SCHEMA alt_nsp2;
2023-08-01 17:01:38.953 +07 client backend[296183] pg_regress/alter_generic ERROR:  text search configuration "alt_ts_conf2" already exists in schema "alt_nsp2"
2023-08-01 17:01:38.953 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER TEXT SEARCH CONFIGURATION alt_ts_conf2 SET SCHEMA alt_nsp2;
2023-08-01 17:01:38.953 +07 client backend[296183] pg_regress/alter_generic ERROR:  text search template "alt_ts_temp2" already exists in schema "alt_nsp1"
2023-08-01 17:01:38.953 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER TEXT SEARCH TEMPLATE alt_ts_temp1 RENAME TO alt_ts_temp2;
2023-08-01 17:01:38.954 +07 client backend[296183] pg_regress/alter_generic ERROR:  text search template "alt_ts_temp2" already exists in schema "alt_nsp2"
2023-08-01 17:01:38.954 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER TEXT SEARCH TEMPLATE alt_ts_temp2 SET SCHEMA alt_nsp2;
2023-08-01 17:01:38.954 +07 client backend[296183] pg_regress/alter_generic ERROR:  text search template parameter "Init" not recognized
2023-08-01 17:01:38.954 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  CREATE TEXT SEARCH TEMPLATE tstemp_case ("Init" = init_function);
2023-08-01 17:01:38.954 +07 client backend[296183] pg_regress/alter_generic ERROR:  text search parser "alt_ts_prs2" already exists in schema "alt_nsp1"
2023-08-01 17:01:38.954 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER TEXT SEARCH PARSER alt_ts_prs1 RENAME TO alt_ts_prs2;
2023-08-01 17:01:38.955 +07 client backend[296183] pg_regress/alter_generic ERROR:  text search parser "alt_ts_prs2" already exists in schema "alt_nsp2"
2023-08-01 17:01:38.955 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  ALTER TEXT SEARCH PARSER alt_ts_prs2 SET SCHEMA alt_nsp2;
2023-08-01 17:01:38.955 +07 client backend[296183] pg_regress/alter_generic ERROR:  text search parser parameter "Start" not recognized
2023-08-01 17:01:38.955 +07 client backend[296183] pg_regress/alter_generic STATEMENT:  CREATE TEXT SEARCH PARSER tspars_case ("Start" = start_function);
2023-08-01 17:01:38.968 +07 client backend[296177] pg_regress/create_table_like ERROR:  duplicate key value violates unique constraint "inhg_pkey"
2023-08-01 17:01:38.968 +07 client backend[296177] pg_regress/create_table_like DETAIL:  Key (xx)=(10) already exists.
2023-08-01 17:01:38.968 +07 client backend[296177] pg_regress/create_table_like STATEMENT:  INSERT INTO inhg VALUES (20, 10);
2023-08-01 17:01:38.970 +07 client backend[296177] pg_regress/create_table_like ERROR:  multiple primary keys for table "inhg" are not allowed
2023-08-01 17:01:38.970 +07 client backend[296177] pg_regress/create_table_like STATEMENT:  /* Multiple primary keys creation should fail */
	CREATE TABLE inhg (x text, LIKE inhx INCLUDING INDEXES, PRIMARY KEY(x));
2023-08-01 17:01:38.974 +07 client backend[296177] pg_regress/create_table_like ERROR:  duplicate key value violates unique constraint "inhg_x_key"
2023-08-01 17:01:38.974 +07 client backend[296177] pg_regress/create_table_like DETAIL:  Key (x)=(15) already exists.
2023-08-01 17:01:38.974 +07 client backend[296177] pg_regress/create_table_like STATEMENT:  INSERT INTO inhg (xx, yy, x) VALUES ('foo', 10, 15);
2023-08-01 17:01:39.011 +07 client backend[296177] pg_regress/create_table_like ERROR:  inherited column "a" has a storage parameter conflict
2023-08-01 17:01:39.011 +07 client backend[296177] pg_regress/create_table_like DETAIL:  MAIN versus EXTENDED
2023-08-01 17:01:39.011 +07 client backend[296177] pg_regress/create_table_like STATEMENT:  CREATE TABLE inh_error1 () INHERITS (ctlt1, ctlt4);
2023-08-01 17:01:39.012 +07 client backend[296177] pg_regress/create_table_like ERROR:  column "a" has a storage parameter conflict
2023-08-01 17:01:39.012 +07 client backend[296177] pg_regress/create_table_like DETAIL:  MAIN versus EXTENDED
2023-08-01 17:01:39.012 +07 client backend[296177] pg_regress/create_table_like STATEMENT:  CREATE TABLE inh_error2 (LIKE ctlt4 INCLUDING STORAGE) INHERITS (ctlt1);
2023-08-01 17:01:39.032 +07 client backend[296177] pg_regress/create_table_like ERROR:  cannot add NO INHERIT constraint to partitioned table "noinh_con_copy1_parted"
2023-08-01 17:01:39.032 +07 client backend[296177] pg_regress/create_table_like STATEMENT:  CREATE TABLE noinh_con_copy1_parted (LIKE noinh_con_copy INCLUDING ALL)
	  PARTITION BY LIST (a);
2023-08-01 17:01:39.034 +07 client backend[296177] pg_regress/create_table_like ERROR:  "ctlseq1" is not a table, view, materialized view, composite type, or foreign table at character 27
2023-08-01 17:01:39.034 +07 client backend[296177] pg_regress/create_table_like STATEMENT:  CREATE TABLE ctlt10 (LIKE ctlseq1);
2023-08-01 17:01:39.055 +07 client backend[296229] pg_regress/stats_ext ERROR:  syntax error at or near ";" at character 22
2023-08-01 17:01:39.055 +07 client backend[296229] pg_regress/stats_ext STATEMENT:  CREATE STATISTICS tst;
2023-08-01 17:01:39.055 +07 client backend[296229] pg_regress/stats_ext ERROR:  syntax error at or near ";" at character 30
2023-08-01 17:01:39.055 +07 client backend[296229] pg_regress/stats_ext STATEMENT:  CREATE STATISTICS tst ON a, b;
2023-08-01 17:01:39.055 +07 client backend[296229] pg_regress/stats_ext ERROR:  syntax error at or near "FROM" at character 23
2023-08-01 17:01:39.055 +07 client backend[296229] pg_regress/stats_ext STATEMENT:  CREATE STATISTICS tst FROM sometab;
2023-08-01 17:01:39.055 +07 client backend[296229] pg_regress/stats_ext ERROR:  relation "nonexistent" does not exist
2023-08-01 17:01:39.055 +07 client backend[296229] pg_regress/stats_ext STATEMENT:  CREATE STATISTICS tst ON a, b FROM nonexistent;
2023-08-01 17:01:39.055 +07 client backend[296229] pg_regress/stats_ext ERROR:  column "a" does not exist
2023-08-01 17:01:39.055 +07 client backend[296229] pg_regress/stats_ext STATEMENT:  CREATE STATISTICS tst ON a, b FROM ext_stats_test;
2023-08-01 17:01:39.055 +07 client backend[296229] pg_regress/stats_ext ERROR:  duplicate column name in statistics definition
2023-08-01 17:01:39.055 +07 client backend[296229] pg_regress/stats_ext STATEMENT:  CREATE STATISTICS tst ON x, x, y FROM ext_stats_test;
2023-08-01 17:01:39.055 +07 client backend[296229] pg_regress/stats_ext ERROR:  only simple column references are allowed in CREATE STATISTICS
2023-08-01 17:01:39.055 +07 client backend[296229] pg_regress/stats_ext STATEMENT:  CREATE STATISTICS tst ON x + y FROM ext_stats_test;
2023-08-01 17:01:39.055 +07 client backend[296229] pg_regress/stats_ext ERROR:  only simple column references are allowed in CREATE STATISTICS
2023-08-01 17:01:39.055 +07 client backend[296229] pg_regress/stats_ext STATEMENT:  CREATE STATISTICS tst ON (x, y) FROM ext_stats_test;
2023-08-01 17:01:39.055 +07 client backend[296229] pg_regress/stats_ext ERROR:  unrecognized statistics kind "unrecognized"
2023-08-01 17:01:39.055 +07 client backend[296229] pg_regress/stats_ext STATEMENT:  CREATE STATISTICS tst (unrecognized) ON x, y FROM ext_stats_test;
2023-08-01 17:01:39.056 +07 client backend[296227] pg_regress/rules ERROR:  rule "rtest_v1_bad" for relation "rtest_v1" does not exist
2023-08-01 17:01:39.056 +07 client backend[296227] pg_regress/rules STATEMENT:  COMMENT ON RULE rtest_v1_bad ON rtest_v1 IS 'bad rule';
2023-08-01 17:01:39.057 +07 client backend[296226] pg_regress/psql ERROR:  syntax error at end of input at character 12
2023-08-01 17:01:39.057 +07 client backend[296226] pg_regress/psql STATEMENT:  SELECT 1 + 
2023-08-01 17:01:39.057 +07 client backend[296226] pg_regress/psql ERROR:  relation "bububu" does not exist at character 7
2023-08-01 17:01:39.057 +07 client backend[296226] pg_regress/psql STATEMENT:  TABLE bububu;
2023-08-01 17:01:39.063 +07 client backend[296226] pg_regress/psql ERROR:  table "gexec_test" does not exist
2023-08-01 17:01:39.063 +07 client backend[296226] pg_regress/psql STATEMENT:  drop table gexec_test
2023-08-01 17:01:39.064 +07 client backend[296229] pg_regress/stats_ext WARNING:  statistics object "public.ab1_a_b_stats" could not be computed for relation "public.ab1"
2023-08-01 17:01:39.068 +07 client backend[296229] pg_regress/stats_ext WARNING:  statistics object "public.ab1_a_b_stats" could not be computed for relation "public.ab1"
2023-08-01 17:01:39.069 +07 client backend[296229] pg_regress/stats_ext ERROR:  statistics object "ab1_a_b_stats" does not exist
2023-08-01 17:01:39.069 +07 client backend[296229] pg_regress/stats_ext STATEMENT:  ALTER STATISTICS ab1_a_b_stats SET STATISTICS 0;
2023-08-01 17:01:39.076 +07 client backend[296229] pg_regress/stats_ext ERROR:  relation "ti" is not a table, foreign table, or materialized view
2023-08-01 17:01:39.076 +07 client backend[296229] pg_regress/stats_ext STATEMENT:  CREATE STATISTICS tststats.s2 ON a, b FROM tststats.ti;
2023-08-01 17:01:39.076 +07 client backend[296229] pg_regress/stats_ext ERROR:  relation "s" is not a table, foreign table, or materialized view
2023-08-01 17:01:39.076 +07 client backend[296229] pg_regress/stats_ext STATEMENT:  CREATE STATISTICS tststats.s3 ON a, b FROM tststats.s;
2023-08-01 17:01:39.076 +07 client backend[296229] pg_regress/stats_ext ERROR:  relation "v" is not a table, foreign table, or materialized view
2023-08-01 17:01:39.076 +07 client backend[296229] pg_regress/stats_ext STATEMENT:  CREATE STATISTICS tststats.s4 ON a, b FROM tststats.v;
2023-08-01 17:01:39.076 +07 client backend[296229] pg_regress/stats_ext ERROR:  relation "ty" is not a table, foreign table, or materialized view
2023-08-01 17:01:39.076 +07 client backend[296229] pg_regress/stats_ext STATEMENT:  CREATE STATISTICS tststats.s6 ON a, b FROM tststats.ty;
2023-08-01 17:01:39.112 +07 client backend[296227] pg_regress/rules ERROR:  INSERT with ON CONFLICT clause cannot be used with table that has INSERT or UPDATE rules
2023-08-01 17:01:39.112 +07 client backend[296227] pg_regress/rules STATEMENT:  insert into shoelace values ('sl10', 1000, 'magenta', 40.0, 'inch', 0.0)
	  on conflict do nothing;
2023-08-01 17:01:39.114 +07 client backend[296227] pg_regress/rules ERROR:  column "f1" does not exist at character 110
2023-08-01 17:01:39.114 +07 client backend[296227] pg_regress/rules HINT:  There is a column named "f1" in table "old", but it cannot be referenced from this part of the query.
2023-08-01 17:01:39.114 +07 client backend[296227] pg_regress/rules STATEMENT:  create rule rules_foorule as on insert to rules_foo where f1 < 100
	do instead insert into rules_foo2 values (f1);
2023-08-01 17:01:39.124 +07 client backend[296226] pg_regress/psql ERROR:  bar
2023-08-01 17:01:39.124 +07 client backend[296226] pg_regress/psql CONTEXT:  PL/pgSQL function inline_code_block line 4 at RAISE
2023-08-01 17:01:39.124 +07 client backend[296226] pg_regress/psql STATEMENT:  do $$
	begin
	  raise notice 'foo';
	  raise exception 'bar';
	end $$;
2023-08-01 17:01:39.124 +07 client backend[296226] pg_regress/psql ERROR:  bar
2023-08-01 17:01:39.124 +07 client backend[296226] pg_regress/psql CONTEXT:  PL/pgSQL function inline_code_block line 4 at RAISE
2023-08-01 17:01:39.124 +07 client backend[296226] pg_regress/psql STATEMENT:  do $$
	begin
	  raise notice 'foo';
	  raise exception 'bar';
	end $$;
2023-08-01 17:01:39.124 +07 client backend[296226] pg_regress/psql ERROR:  bar
2023-08-01 17:01:39.124 +07 client backend[296226] pg_regress/psql CONTEXT:  PL/pgSQL function inline_code_block line 4 at RAISE
2023-08-01 17:01:39.124 +07 client backend[296226] pg_regress/psql STATEMENT:  do $$
	begin
	  raise notice 'foo';
	  raise exception 'bar';
	end $$;
2023-08-01 17:01:39.124 +07 client backend[296226] pg_regress/psql ERROR:  syntax error at or near ";" at character 15
2023-08-01 17:01:39.124 +07 client backend[296226] pg_regress/psql STATEMENT:  SELECT 1 UNION;
2023-08-01 17:01:39.125 +07 client backend[296226] pg_regress/psql ERROR:  table "this_table_does_not_exist" does not exist
2023-08-01 17:01:39.125 +07 client backend[296226] pg_regress/psql STATEMENT:  DROP TABLE this_table_does_not_exist;
2023-08-01 17:01:39.125 +07 client backend[296226] pg_regress/psql ERROR:  syntax error at or near ";" at character 15
2023-08-01 17:01:39.125 +07 client backend[296226] pg_regress/psql STATEMENT:  SELECT 1 UNION;
2023-08-01 17:01:39.125 +07 client backend[296226] pg_regress/psql ERROR:  division by zero
2023-08-01 17:01:39.125 +07 client backend[296226] pg_regress/psql STATEMENT:  SELECT 1/0;
2023-08-01 17:01:39.125 +07 client backend[296226] pg_regress/psql ERROR:  syntax error at end of input at character 13
2023-08-01 17:01:39.125 +07 client backend[296226] pg_regress/psql STATEMENT:  SELECT 4 AS 
2023-08-01 17:01:39.126 +07 client backend[296226] pg_regress/psql ERROR:  division by zero
2023-08-01 17:01:39.126 +07 client backend[296226] pg_regress/psql STATEMENT:  FETCH FORWARD 10 FROM _psql_cursor
2023-08-01 17:01:39.126 +07 client backend[296226] pg_regress/psql ERROR:  current transaction is aborted, commands ignored until end of transaction block
2023-08-01 17:01:39.126 +07 client backend[296226] pg_regress/psql STATEMENT:  CLOSE _psql_cursor
2023-08-01 17:01:39.148 +07 client backend[296227] pg_regress/rules ERROR:  insert or update on table "rule_and_refint_t3" violates foreign key constraint "rule_and_refint_t3_id3a_id3c_fkey"
2023-08-01 17:01:39.148 +07 client backend[296227] pg_regress/rules DETAIL:  Key (id3a, id3c)=(1, 13) is not present in table "rule_and_refint_t2".
2023-08-01 17:01:39.148 +07 client backend[296227] pg_regress/rules STATEMENT:  insert into rule_and_refint_t3 values (1, 11, 13, 'row5');
2023-08-01 17:01:39.148 +07 client backend[296227] pg_regress/rules ERROR:  insert or update on table "rule_and_refint_t3" violates foreign key constraint "rule_and_refint_t3_id3a_id3b_fkey"
2023-08-01 17:01:39.148 +07 client backend[296227] pg_regress/rules DETAIL:  Key (id3a, id3b)=(1, 13) is not present in table "rule_and_refint_t1".
2023-08-01 17:01:39.148 +07 client backend[296227] pg_regress/rules STATEMENT:  insert into rule_and_refint_t3 values (1, 13, 11, 'row6');
2023-08-01 17:01:39.148 +07 client backend[296227] pg_regress/rules ERROR:  insert or update on table "rule_and_refint_t3" violates foreign key constraint "rule_and_refint_t3_id3a_id3b_fkey"
2023-08-01 17:01:39.148 +07 client backend[296227] pg_regress/rules DETAIL:  Key (id3a, id3b)=(1, 13) is not present in table "rule_and_refint_t1".
2023-08-01 17:01:39.148 +07 client backend[296227] pg_regress/rules STATEMENT:  insert into rule_and_refint_t3 values (1, 13, 11, 'row6')
	  on conflict do nothing;
2023-08-01 17:01:39.148 +07 client backend[296227] pg_regress/rules ERROR:  insert or update on table "rule_and_refint_t3" violates foreign key constraint "rule_and_refint_t3_id3a_id3b_fkey"
2023-08-01 17:01:39.148 +07 client backend[296227] pg_regress/rules DETAIL:  Key (id3a, id3b)=(1, 13) is not present in table "rule_and_refint_t1".
2023-08-01 17:01:39.148 +07 client backend[296227] pg_regress/rules STATEMENT:  insert into rule_and_refint_t3 values (1, 13, 11, 'row6')
	  on conflict (id3a, id3b, id3c) do update
	  set id3b = excluded.id3b;
2023-08-01 17:01:39.148 +07 client backend[296227] pg_regress/rules ERROR:  INSERT with ON CONFLICT clause cannot be used with table that has INSERT or UPDATE rules
2023-08-01 17:01:39.148 +07 client backend[296227] pg_regress/rules STATEMENT:  insert into shoelace values ('sl9', 0, 'pink', 35.0, 'inch', 0.0)
	  on conflict (sl_name) do update
	  set sl_avail = excluded.sl_avail;
2023-08-01 17:01:39.149 +07 client backend[296227] pg_regress/rules ERROR:  insert or update on table "rule_and_refint_t3" violates foreign key constraint "rule_and_refint_t3_id3a_id3c_fkey"
2023-08-01 17:01:39.149 +07 client backend[296227] pg_regress/rules DETAIL:  Key (id3a, id3c)=(1, 13) is not present in table "rule_and_refint_t2".
2023-08-01 17:01:39.149 +07 client backend[296227] pg_regress/rules STATEMENT:  insert into rule_and_refint_t3 values (1, 11, 13, 'row7');
2023-08-01 17:01:39.149 +07 client backend[296227] pg_regress/rules ERROR:  insert or update on table "rule_and_refint_t3" violates foreign key constraint "rule_and_refint_t3_id3a_id3b_fkey"
2023-08-01 17:01:39.149 +07 client backend[296227] pg_regress/rules DETAIL:  Key (id3a, id3b)=(1, 13) is not present in table "rule_and_refint_t1".
2023-08-01 17:01:39.149 +07 client backend[296227] pg_regress/rules STATEMENT:  insert into rule_and_refint_t3 values (1, 13, 11, 'row8');
2023-08-01 17:01:39.150 +07 client backend[296227] pg_regress/rules ERROR:  cannot drop rule _RETURN on view rules_fooview because view rules_fooview requires it
2023-08-01 17:01:39.150 +07 client backend[296227] pg_regress/rules HINT:  You can drop view rules_fooview instead.
2023-08-01 17:01:39.150 +07 client backend[296227] pg_regress/rules STATEMENT:  drop rule "_RETURN" on rules_fooview;
2023-08-01 17:01:39.152 +07 client backend[296227] pg_regress/rules ERROR:  column "xmin" does not exist at character 8
2023-08-01 17:01:39.152 +07 client backend[296227] pg_regress/rules STATEMENT:  select xmin, * from rules_fooview;
2023-08-01 17:01:39.154 +07 client backend[296227] pg_regress/rules ERROR:  could not convert table "rules_fooview" to a view because it has child tables
2023-08-01 17:01:39.154 +07 client backend[296227] pg_regress/rules STATEMENT:  create rule "_RETURN" as on select to rules_fooview do instead
	  select 1 as x, 'aaa'::text as y;
2023-08-01 17:01:39.155 +07 client backend[296227] pg_regress/rules ERROR:  could not convert table "rules_fooview_child" to a view because it has parent tables
2023-08-01 17:01:39.155 +07 client backend[296227] pg_regress/rules STATEMENT:  create rule "_RETURN" as on select to rules_fooview_child do instead
	  select 1 as x, 'aaa'::text as y;
2023-08-01 17:01:39.156 +07 client backend[296227] pg_regress/rules ERROR:  cannot convert partitioned table "rules_fooview" to a view
2023-08-01 17:01:39.156 +07 client backend[296227] pg_regress/rules STATEMENT:  create rule "_RETURN" as on select to rules_fooview do instead
	  select 1 as x, 'aaa'::text as y;
2023-08-01 17:01:39.157 +07 client backend[296227] pg_regress/rules ERROR:  cannot convert partition "rules_fooview_part" to a view
2023-08-01 17:01:39.157 +07 client backend[296227] pg_regress/rules STATEMENT:  create rule "_RETURN" as on select to rules_fooview_part do instead
	  select 1 as x, 'aaa'::text as y;
2023-08-01 17:01:39.198 +07 client backend[296227] pg_regress/rules ERROR:  rule "insertrule" for relation "rule_v1" does not exist
2023-08-01 17:01:39.198 +07 client backend[296227] pg_regress/rules STATEMENT:  ALTER RULE InsertRule ON rule_v1 RENAME TO NewInsertRule;
2023-08-01 17:01:39.198 +07 client backend[296227] pg_regress/rules ERROR:  rule "_RETURN" for relation "rule_v1" already exists
2023-08-01 17:01:39.198 +07 client backend[296227] pg_regress/rules STATEMENT:  ALTER RULE NewInsertRule ON rule_v1 RENAME TO "_RETURN";
2023-08-01 17:01:39.198 +07 client backend[296227] pg_regress/rules ERROR:  renaming an ON SELECT rule is not allowed
2023-08-01 17:01:39.198 +07 client backend[296227] pg_regress/rules STATEMENT:  ALTER RULE "_RETURN" ON rule_v1 RENAME TO abc;
2023-08-01 17:01:39.584 +07 client backend[296229] pg_regress/stats_ext ERROR:  permission denied for table priv_test_tbl
2023-08-01 17:01:39.584 +07 client backend[296229] pg_regress/stats_ext STATEMENT:  SELECT * FROM tststats.priv_test_tbl;
2023-08-01 17:01:39.584 +07 client backend[296229] pg_regress/stats_ext ERROR:  permission denied for table priv_test_tbl
2023-08-01 17:01:39.584 +07 client backend[296229] pg_regress/stats_ext STATEMENT:  SELECT * FROM tststats.priv_test_tbl WHERE a <<< 0 AND b <<< 0;
2023-08-01 17:01:39.585 +07 client backend[296229] pg_regress/stats_ext ERROR:  permission denied for table priv_test_tbl
2023-08-01 17:01:39.585 +07 client backend[296229] pg_regress/stats_ext STATEMENT:  DELETE FROM tststats.priv_test_tbl WHERE a <<< 0 AND b <<< 0;
2023-08-01 17:01:39.794 +07 client backend[296246] pg_regress/select_parallel LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp296246.0", size 1400000
2023-08-01 17:01:39.794 +07 client backend[296246] pg_regress/select_parallel STATEMENT:  insert into bmscantest select r, 'fooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo' FROM generate_series(1,100000) r;
2023-08-01 17:01:39.819 +07 client backend[296246] pg_regress/select_parallel LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp296246.2.sharedfileset/0.0", size 1138688
2023-08-01 17:01:39.819 +07 client backend[296246] pg_regress/select_parallel STATEMENT:  create index i_bmtest ON bmscantest(a);
2023-08-01 17:01:39.819 +07 client backend[296246] pg_regress/select_parallel LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp296246.2.sharedfileset/1.0", size 876544
2023-08-01 17:01:39.819 +07 client backend[296246] pg_regress/select_parallel STATEMENT:  create index i_bmtest ON bmscantest(a);
2023-08-01 17:01:39.912 +07 parallel worker[296456] ERROR:  invalid input syntax for type smallint: "BAAAAAabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcd"
2023-08-01 17:01:39.912 +07 parallel worker[296456] STATEMENT:  select (stringu1 || repeat('abcd', 5000))::int2 from tenk1 where unique1 = 1;
2023-08-01 17:01:39.912 +07 client backend[296246] pg_regress/select_parallel ERROR:  invalid input syntax for type smallint: "BAAAAAabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcd"
2023-08-01 17:01:39.912 +07 client backend[296246] pg_regress/select_parallel CONTEXT:  parallel worker
2023-08-01 17:01:39.912 +07 client backend[296246] pg_regress/select_parallel STATEMENT:  select (stringu1 || repeat('abcd', 5000))::int2 from tenk1 where unique1 = 1;
2023-08-01 17:01:39.912 +07 postmaster[295405] LOG:  background worker "parallel worker" (PID 296456) exited with exit code 1
2023-08-01 17:01:39.948 +07 client backend[296489] pg_regress/subscription ERROR:  syntax error at or near ";" at character 53
2023-08-01 17:01:39.948 +07 client backend[296489] pg_regress/subscription STATEMENT:  CREATE SUBSCRIPTION regress_testsub CONNECTION 'foo';
2023-08-01 17:01:39.948 +07 client backend[296489] pg_regress/subscription ERROR:  syntax error at or near "PUBLICATION" at character 37
2023-08-01 17:01:39.948 +07 client backend[296489] pg_regress/subscription STATEMENT:  CREATE SUBSCRIPTION regress_testsub PUBLICATION foo;
2023-08-01 17:01:39.948 +07 client backend[296488] pg_regress/publication WARNING:  wal_level is insufficient to publish logical changes
2023-08-01 17:01:39.948 +07 client backend[296488] pg_regress/publication HINT:  Set wal_level to logical before creating subscriptions.
2023-08-01 17:01:39.948 +07 client backend[296489] pg_regress/subscription ERROR:  CREATE SUBSCRIPTION ... WITH (create_slot = true) cannot run inside a transaction block
2023-08-01 17:01:39.948 +07 client backend[296489] pg_regress/subscription STATEMENT:  CREATE SUBSCRIPTION regress_testsub CONNECTION 'testconn' PUBLICATION testpub WITH (create_slot);
2023-08-01 17:01:39.949 +07 client backend[296489] pg_regress/subscription ERROR:  invalid connection string syntax: missing "=" after "testconn" in connection info string
	
2023-08-01 17:01:39.949 +07 client backend[296489] pg_regress/subscription STATEMENT:  CREATE SUBSCRIPTION regress_testsub CONNECTION 'testconn' PUBLICATION testpub;
2023-08-01 17:01:39.949 +07 client backend[296489] pg_regress/subscription ERROR:  publication name "foo" used more than once
2023-08-01 17:01:39.949 +07 client backend[296489] pg_regress/subscription STATEMENT:  CREATE SUBSCRIPTION regress_testsub CONNECTION 'dbname=regress_doesnotexist' PUBLICATION foo, testpub, foo WITH (connect = false);
2023-08-01 17:01:39.949 +07 client backend[296489] pg_regress/subscription WARNING:  tables were not subscribed, you will have to run ALTER SUBSCRIPTION ... REFRESH PUBLICATION to subscribe the tables
2023-08-01 17:01:39.950 +07 client backend[296488] pg_regress/publication WARNING:  wal_level is insufficient to publish logical changes
2023-08-01 17:01:39.950 +07 client backend[296488] pg_regress/publication HINT:  Set wal_level to logical before creating subscriptions.
2023-08-01 17:01:39.950 +07 client backend[296488] pg_regress/publication ERROR:  unrecognized publication parameter: "foo"
2023-08-01 17:01:39.950 +07 client backend[296488] pg_regress/publication STATEMENT:  CREATE PUBLICATION testpub_xxx WITH (foo);
2023-08-01 17:01:39.950 +07 client backend[296488] pg_regress/publication ERROR:  unrecognized "publish" value: "cluster"
2023-08-01 17:01:39.950 +07 client backend[296488] pg_regress/publication STATEMENT:  CREATE PUBLICATION testpub_xxx WITH (publish = 'cluster, vacuum');
2023-08-01 17:01:39.950 +07 client backend[296488] pg_regress/publication ERROR:  conflicting or redundant options
2023-08-01 17:01:39.950 +07 client backend[296488] pg_regress/publication STATEMENT:  CREATE PUBLICATION testpub_xxx WITH (publish_via_partition_root = 'true', publish_via_partition_root = '0');
2023-08-01 17:01:39.950 +07 client backend[296489] pg_regress/subscription ERROR:  subscription "regress_testsub" already exists
2023-08-01 17:01:39.950 +07 client backend[296489] pg_regress/subscription STATEMENT:  CREATE SUBSCRIPTION regress_testsub CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (connect = false);
2023-08-01 17:01:39.950 +07 client backend[296489] pg_regress/subscription ERROR:  must be superuser to create subscriptions
2023-08-01 17:01:39.950 +07 client backend[296489] pg_regress/subscription STATEMENT:  CREATE SUBSCRIPTION regress_testsub2 CONNECTION 'dbname=regress_doesnotexist' PUBLICATION foo WITH (connect = false);
2023-08-01 17:01:39.951 +07 client backend[296489] pg_regress/subscription ERROR:  connect = false and copy_data = true are mutually exclusive options
2023-08-01 17:01:39.951 +07 client backend[296489] pg_regress/subscription STATEMENT:  CREATE SUBSCRIPTION regress_testsub2 CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (connect = false, copy_data = true);
2023-08-01 17:01:39.951 +07 client backend[296489] pg_regress/subscription ERROR:  connect = false and enabled = true are mutually exclusive options
2023-08-01 17:01:39.951 +07 client backend[296489] pg_regress/subscription STATEMENT:  CREATE SUBSCRIPTION regress_testsub2 CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (connect = false, enabled = true);
2023-08-01 17:01:39.951 +07 client backend[296489] pg_regress/subscription ERROR:  connect = false and create_slot = true are mutually exclusive options
2023-08-01 17:01:39.951 +07 client backend[296489] pg_regress/subscription STATEMENT:  CREATE SUBSCRIPTION regress_testsub2 CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (connect = false, create_slot = true);
2023-08-01 17:01:39.951 +07 client backend[296489] pg_regress/subscription ERROR:  slot_name = NONE and enabled = true are mutually exclusive options
2023-08-01 17:01:39.951 +07 client backend[296489] pg_regress/subscription STATEMENT:  CREATE SUBSCRIPTION regress_testsub2 CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (slot_name = NONE, enabled = true);
2023-08-01 17:01:39.951 +07 client backend[296489] pg_regress/subscription ERROR:  slot_name = NONE and create_slot = true are mutually exclusive options
2023-08-01 17:01:39.951 +07 client backend[296489] pg_regress/subscription STATEMENT:  CREATE SUBSCRIPTION regress_testsub2 CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (slot_name = NONE, create_slot = true);
2023-08-01 17:01:39.951 +07 client backend[296489] pg_regress/subscription ERROR:  subscription with slot_name = NONE must also set enabled = false
2023-08-01 17:01:39.951 +07 client backend[296489] pg_regress/subscription STATEMENT:  CREATE SUBSCRIPTION regress_testsub2 CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (slot_name = NONE);
2023-08-01 17:01:39.951 +07 client backend[296489] pg_regress/subscription ERROR:  subscription with slot_name = NONE must also set create_slot = false
2023-08-01 17:01:39.951 +07 client backend[296489] pg_regress/subscription STATEMENT:  CREATE SUBSCRIPTION regress_testsub2 CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (slot_name = NONE, enabled = false);
2023-08-01 17:01:39.951 +07 client backend[296489] pg_regress/subscription ERROR:  subscription with slot_name = NONE must also set enabled = false
2023-08-01 17:01:39.951 +07 client backend[296489] pg_regress/subscription STATEMENT:  CREATE SUBSCRIPTION regress_testsub2 CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (slot_name = NONE, create_slot = false);
2023-08-01 17:01:39.951 +07 client backend[296489] pg_regress/subscription WARNING:  tables were not subscribed, you will have to run ALTER SUBSCRIPTION ... REFRESH PUBLICATION to subscribe the tables
2023-08-01 17:01:39.951 +07 client backend[296489] pg_regress/subscription ERROR:  cannot enable subscription that does not have a slot name
2023-08-01 17:01:39.951 +07 client backend[296489] pg_regress/subscription STATEMENT:  ALTER SUBSCRIPTION regress_testsub3 ENABLE;
2023-08-01 17:01:39.951 +07 client backend[296489] pg_regress/subscription ERROR:  ALTER SUBSCRIPTION ... REFRESH is not allowed for disabled subscriptions
2023-08-01 17:01:39.951 +07 client backend[296489] pg_regress/subscription STATEMENT:  ALTER SUBSCRIPTION regress_testsub3 REFRESH PUBLICATION;
2023-08-01 17:01:39.951 +07 client backend[296489] pg_regress/subscription ERROR:  invalid connection string syntax: missing "=" after "foobar" in connection info string
	
2023-08-01 17:01:39.951 +07 client backend[296489] pg_regress/subscription STATEMENT:  ALTER SUBSCRIPTION regress_testsub CONNECTION 'foobar';
2023-08-01 17:01:39.952 +07 client backend[296489] pg_regress/subscription ERROR:  subscription "regress_doesnotexist" does not exist
2023-08-01 17:01:39.952 +07 client backend[296489] pg_regress/subscription STATEMENT:  ALTER SUBSCRIPTION regress_doesnotexist CONNECTION 'dbname=regress_doesnotexist2';
2023-08-01 17:01:39.952 +07 client backend[296489] pg_regress/subscription ERROR:  unrecognized subscription parameter: "create_slot"
2023-08-01 17:01:39.952 +07 client backend[296489] pg_regress/subscription STATEMENT:  ALTER SUBSCRIPTION regress_testsub SET (create_slot = false);
2023-08-01 17:01:39.953 +07 client backend[296489] pg_regress/subscription ERROR:  must be owner of subscription regress_testsub
2023-08-01 17:01:39.953 +07 client backend[296489] pg_regress/subscription STATEMENT:  ALTER SUBSCRIPTION regress_testsub RENAME TO regress_testsub_dummy;
2023-08-01 17:01:39.953 +07 client backend[296489] pg_regress/subscription ERROR:  invalid value for parameter "synchronous_commit": "foobar"
2023-08-01 17:01:39.953 +07 client backend[296489] pg_regress/subscription HINT:  Available values: local, remote_write, remote_apply, on, off.
2023-08-01 17:01:39.953 +07 client backend[296489] pg_regress/subscription STATEMENT:  ALTER SUBSCRIPTION regress_testsub_foo SET (synchronous_commit = foobar);
2023-08-01 17:01:39.954 +07 client backend[296489] pg_regress/subscription ERROR:  permission denied to change owner of subscription "regress_testsub"
2023-08-01 17:01:39.954 +07 client backend[296489] pg_regress/subscription HINT:  The owner of a subscription must be a superuser.
2023-08-01 17:01:39.954 +07 client backend[296489] pg_regress/subscription STATEMENT:  ALTER SUBSCRIPTION regress_testsub OWNER TO regress_subscription_user2;
2023-08-01 17:01:39.954 +07 client backend[296489] pg_regress/subscription ERROR:  DROP SUBSCRIPTION cannot run inside a transaction block
2023-08-01 17:01:39.954 +07 client backend[296489] pg_regress/subscription STATEMENT:  DROP SUBSCRIPTION regress_testsub;
2023-08-01 17:01:39.954 +07 client backend[296488] pg_regress/publication WARNING:  wal_level is insufficient to publish logical changes
2023-08-01 17:01:39.954 +07 client backend[296488] pg_regress/publication HINT:  Set wal_level to logical before creating subscriptions.
2023-08-01 17:01:39.955 +07 client backend[296489] pg_regress/subscription ERROR:  subscription "regress_testsub" does not exist
2023-08-01 17:01:39.955 +07 client backend[296489] pg_regress/subscription STATEMENT:  DROP SUBSCRIPTION regress_testsub;
2023-08-01 17:01:39.956 +07 client backend[296488] pg_regress/publication ERROR:  publication "testpub_foralltables" is defined as FOR ALL TABLES
2023-08-01 17:01:39.956 +07 client backend[296488] pg_regress/publication DETAIL:  Tables cannot be added to or dropped from FOR ALL TABLES publications.
2023-08-01 17:01:39.956 +07 client backend[296488] pg_regress/publication STATEMENT:  ALTER PUBLICATION testpub_foralltables ADD TABLE testpub_tbl2;
2023-08-01 17:01:39.956 +07 client backend[296488] pg_regress/publication ERROR:  publication "testpub_foralltables" is defined as FOR ALL TABLES
2023-08-01 17:01:39.956 +07 client backend[296488] pg_regress/publication DETAIL:  Tables cannot be added to or dropped from FOR ALL TABLES publications.
2023-08-01 17:01:39.956 +07 client backend[296488] pg_regress/publication STATEMENT:  ALTER PUBLICATION testpub_foralltables DROP TABLE testpub_tbl2;
2023-08-01 17:01:39.956 +07 client backend[296488] pg_regress/publication ERROR:  publication "testpub_foralltables" is defined as FOR ALL TABLES
2023-08-01 17:01:39.956 +07 client backend[296488] pg_regress/publication DETAIL:  Tables cannot be added to or dropped from FOR ALL TABLES publications.
2023-08-01 17:01:39.956 +07 client backend[296488] pg_regress/publication STATEMENT:  ALTER PUBLICATION testpub_foralltables SET TABLE pub_test.testpub_nopk;
2023-08-01 17:01:39.964 +07 client backend[296488] pg_regress/publication WARNING:  wal_level is insufficient to publish logical changes
2023-08-01 17:01:39.964 +07 client backend[296488] pg_regress/publication HINT:  Set wal_level to logical before creating subscriptions.
2023-08-01 17:01:39.964 +07 client backend[296488] pg_regress/publication WARNING:  wal_level is insufficient to publish logical changes
2023-08-01 17:01:39.964 +07 client backend[296488] pg_regress/publication HINT:  Set wal_level to logical before creating subscriptions.
2023-08-01 17:01:39.965 +07 client backend[296488] pg_regress/publication WARNING:  wal_level is insufficient to publish logical changes
2023-08-01 17:01:39.965 +07 client backend[296488] pg_regress/publication HINT:  Set wal_level to logical before creating subscriptions.
2023-08-01 17:01:39.965 +07 client backend[296488] pg_regress/publication WARNING:  wal_level is insufficient to publish logical changes
2023-08-01 17:01:39.965 +07 client backend[296488] pg_regress/publication HINT:  Set wal_level to logical before creating subscriptions.
2023-08-01 17:01:39.967 +07 client backend[296488] pg_regress/publication ERROR:  cannot update table "testpub_parted1" because it does not have a replica identity and publishes updates
2023-08-01 17:01:39.967 +07 client backend[296488] pg_regress/publication HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.
2023-08-01 17:01:39.967 +07 client backend[296488] pg_regress/publication STATEMENT:  UPDATE testpub_parted1 SET a = 1;
2023-08-01 17:01:39.968 +07 client backend[296488] pg_regress/publication ERROR:  "testpub_view" is not a table
2023-08-01 17:01:39.968 +07 client backend[296488] pg_regress/publication DETAIL:  Only tables can be added to publications.
2023-08-01 17:01:39.968 +07 client backend[296488] pg_regress/publication STATEMENT:  CREATE PUBLICATION testpub_fortbl FOR TABLE testpub_view;
2023-08-01 17:01:39.968 +07 client backend[296488] pg_regress/publication WARNING:  wal_level is insufficient to publish logical changes
2023-08-01 17:01:39.968 +07 client backend[296488] pg_regress/publication HINT:  Set wal_level to logical before creating subscriptions.
2023-08-01 17:01:39.968 +07 client backend[296488] pg_regress/publication ERROR:  relation "testpub_tbl1" is already member of publication "testpub_fortbl"
2023-08-01 17:01:39.968 +07 client backend[296488] pg_regress/publication STATEMENT:  ALTER PUBLICATION testpub_fortbl ADD TABLE testpub_tbl1;
2023-08-01 17:01:39.968 +07 client backend[296488] pg_regress/publication ERROR:  publication "testpub_fortbl" already exists
2023-08-01 17:01:39.968 +07 client backend[296488] pg_regress/publication STATEMENT:  CREATE PUBLICATION testpub_fortbl FOR TABLE testpub_tbl1;
2023-08-01 17:01:39.969 +07 client backend[296488] pg_regress/publication ERROR:  "testpub_view" is not a table
2023-08-01 17:01:39.969 +07 client backend[296488] pg_regress/publication DETAIL:  Only tables can be added to publications.
2023-08-01 17:01:39.969 +07 client backend[296488] pg_regress/publication STATEMENT:  ALTER PUBLICATION testpub_default ADD TABLE testpub_view;
2023-08-01 17:01:39.974 +07 client backend[296488] pg_regress/publication ERROR:  relation "testpub_nopk" is not part of the publication
2023-08-01 17:01:39.974 +07 client backend[296488] pg_regress/publication STATEMENT:  ALTER PUBLICATION testpub_default DROP TABLE pub_test.testpub_nopk;
2023-08-01 17:01:39.976 +07 client backend[296488] pg_regress/publication ERROR:  permission denied for database regression
2023-08-01 17:01:39.976 +07 client backend[296488] pg_regress/publication STATEMENT:  CREATE PUBLICATION testpub2;
2023-08-01 17:01:39.976 +07 client backend[296488] pg_regress/publication WARNING:  wal_level is insufficient to publish logical changes
2023-08-01 17:01:39.976 +07 client backend[296488] pg_regress/publication HINT:  Set wal_level to logical before creating subscriptions.
2023-08-01 17:01:39.977 +07 client backend[296488] pg_regress/publication ERROR:  must be owner of table testpub_tbl1
2023-08-01 17:01:39.977 +07 client backend[296488] pg_regress/publication STATEMENT:  ALTER PUBLICATION testpub2 ADD TABLE testpub_tbl1;
2023-08-01 17:01:39.979 +07 client backend[296488] pg_regress/publication ERROR:  must be owner of publication testpub_default
2023-08-01 17:01:39.979 +07 client backend[296488] pg_regress/publication STATEMENT:  ALTER PUBLICATION testpub_default RENAME TO testpub_dummy;
2023-08-01 17:01:39.995 +07 client backend[296516] pg_regress/guc WARNING:  SET LOCAL can only be used in transaction blocks
2023-08-01 17:01:39.995 +07 client backend[296516] pg_regress/guc WARNING:  SET LOCAL can only be used in transaction blocks
2023-08-01 17:01:40.000 +07 client backend[296527] pg_regress/advisory_lock WARNING:  you don't own a lock of type ExclusiveLock
2023-08-01 17:01:40.000 +07 client backend[296527] pg_regress/advisory_lock WARNING:  you don't own a lock of type ShareLock
2023-08-01 17:01:40.000 +07 client backend[296527] pg_regress/advisory_lock WARNING:  you don't own a lock of type ExclusiveLock
2023-08-01 17:01:40.000 +07 client backend[296527] pg_regress/advisory_lock WARNING:  you don't own a lock of type ShareLock
2023-08-01 17:01:40.000 +07 client backend[296515] pg_regress/dependency ERROR:  role "regress_dep_user" cannot be dropped because some objects depend on it
2023-08-01 17:01:40.000 +07 client backend[296515] pg_regress/dependency DETAIL:  privileges for table deptest
2023-08-01 17:01:40.000 +07 client backend[296515] pg_regress/dependency STATEMENT:  DROP USER regress_dep_user;
2023-08-01 17:01:40.000 +07 client backend[296524] pg_regress/xmlmap ERROR:  unsupported XML feature
2023-08-01 17:01:40.000 +07 client backend[296524] pg_regress/xmlmap DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.000 +07 client backend[296524] pg_regress/xmlmap HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.000 +07 client backend[296524] pg_regress/xmlmap STATEMENT:  SELECT table_to_xml('testxmlschema.test1', false, false, '');
2023-08-01 17:01:40.000 +07 client backend[296515] pg_regress/dependency ERROR:  role "regress_dep_group" cannot be dropped because some objects depend on it
2023-08-01 17:01:40.000 +07 client backend[296515] pg_regress/dependency DETAIL:  privileges for table deptest
2023-08-01 17:01:40.000 +07 client backend[296515] pg_regress/dependency STATEMENT:  DROP GROUP regress_dep_group;
2023-08-01 17:01:40.000 +07 client backend[296524] pg_regress/xmlmap ERROR:  unsupported XML feature
2023-08-01 17:01:40.000 +07 client backend[296524] pg_regress/xmlmap DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.000 +07 client backend[296524] pg_regress/xmlmap HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.000 +07 client backend[296524] pg_regress/xmlmap STATEMENT:  SELECT table_to_xml('testxmlschema.test1', true, false, 'foo');
2023-08-01 17:01:40.001 +07 client backend[296524] pg_regress/xmlmap ERROR:  unsupported XML feature
2023-08-01 17:01:40.001 +07 client backend[296524] pg_regress/xmlmap DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.001 +07 client backend[296524] pg_regress/xmlmap HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.001 +07 client backend[296524] pg_regress/xmlmap STATEMENT:  SELECT table_to_xml('testxmlschema.test1', false, true, '');
2023-08-01 17:01:40.001 +07 client backend[296524] pg_regress/xmlmap ERROR:  unsupported XML feature
2023-08-01 17:01:40.001 +07 client backend[296524] pg_regress/xmlmap DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.001 +07 client backend[296524] pg_regress/xmlmap HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.001 +07 client backend[296524] pg_regress/xmlmap STATEMENT:  SELECT table_to_xml('testxmlschema.test1', true, true, '');
2023-08-01 17:01:40.001 +07 client backend[296524] pg_regress/xmlmap ERROR:  unsupported XML feature
2023-08-01 17:01:40.001 +07 client backend[296524] pg_regress/xmlmap DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.001 +07 client backend[296524] pg_regress/xmlmap HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.001 +07 client backend[296524] pg_regress/xmlmap STATEMENT:  SELECT table_to_xml('testxmlschema.test2', false, false, '');
2023-08-01 17:01:40.001 +07 client backend[296515] pg_regress/dependency ERROR:  role "regress_dep_user" cannot be dropped because some objects depend on it
2023-08-01 17:01:40.001 +07 client backend[296515] pg_regress/dependency DETAIL:  privileges for table deptest
2023-08-01 17:01:40.001 +07 client backend[296515] pg_regress/dependency STATEMENT:  DROP USER regress_dep_user;
2023-08-01 17:01:40.001 +07 client backend[296524] pg_regress/xmlmap ERROR:  unsupported XML feature
2023-08-01 17:01:40.001 +07 client backend[296524] pg_regress/xmlmap DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.001 +07 client backend[296524] pg_regress/xmlmap HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.001 +07 client backend[296524] pg_regress/xmlmap STATEMENT:  SELECT table_to_xmlschema('testxmlschema.test1', false, false, '');
2023-08-01 17:01:40.001 +07 client backend[296523] pg_regress/foreign_data ERROR:  function bar(text[], oid) does not exist
2023-08-01 17:01:40.001 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  CREATE FOREIGN DATA WRAPPER foo VALIDATOR bar;
2023-08-01 17:01:40.001 +07 client backend[296527] pg_regress/advisory_lock WARNING:  you don't own a lock of type ExclusiveLock
2023-08-01 17:01:40.001 +07 client backend[296524] pg_regress/xmlmap ERROR:  unsupported XML feature
2023-08-01 17:01:40.001 +07 client backend[296524] pg_regress/xmlmap DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.001 +07 client backend[296524] pg_regress/xmlmap HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.001 +07 client backend[296524] pg_regress/xmlmap STATEMENT:  SELECT table_to_xmlschema('testxmlschema.test1', true, false, '');
2023-08-01 17:01:40.001 +07 client backend[296527] pg_regress/advisory_lock WARNING:  you don't own a lock of type ShareLock
2023-08-01 17:01:40.001 +07 client backend[296527] pg_regress/advisory_lock WARNING:  you don't own a lock of type ExclusiveLock
2023-08-01 17:01:40.001 +07 client backend[296527] pg_regress/advisory_lock WARNING:  you don't own a lock of type ShareLock
2023-08-01 17:01:40.002 +07 client backend[296524] pg_regress/xmlmap ERROR:  unsupported XML feature
2023-08-01 17:01:40.002 +07 client backend[296524] pg_regress/xmlmap DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.002 +07 client backend[296524] pg_regress/xmlmap HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.002 +07 client backend[296524] pg_regress/xmlmap STATEMENT:  SELECT table_to_xmlschema('testxmlschema.test1', false, true, 'foo');
2023-08-01 17:01:40.002 +07 client backend[296524] pg_regress/xmlmap ERROR:  unsupported XML feature
2023-08-01 17:01:40.002 +07 client backend[296524] pg_regress/xmlmap DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.002 +07 client backend[296524] pg_regress/xmlmap HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.002 +07 client backend[296524] pg_regress/xmlmap STATEMENT:  SELECT table_to_xmlschema('testxmlschema.test1', true, true, '');
2023-08-01 17:01:40.002 +07 client backend[296524] pg_regress/xmlmap ERROR:  unsupported XML feature
2023-08-01 17:01:40.002 +07 client backend[296524] pg_regress/xmlmap DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.002 +07 client backend[296524] pg_regress/xmlmap HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.002 +07 client backend[296524] pg_regress/xmlmap STATEMENT:  SELECT table_to_xmlschema('testxmlschema.test2', false, false, '');
2023-08-01 17:01:40.003 +07 client backend[296523] pg_regress/foreign_data ERROR:  foreign-data wrapper "foo" already exists
2023-08-01 17:01:40.003 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  CREATE FOREIGN DATA WRAPPER foo;
2023-08-01 17:01:40.003 +07 client backend[296515] pg_regress/dependency ERROR:  role "regress_dep_user3" cannot be dropped because some objects depend on it
2023-08-01 17:01:40.003 +07 client backend[296515] pg_regress/dependency DETAIL:  owner of sequence deptest_f1_seq
	owner of table deptest
2023-08-01 17:01:40.003 +07 client backend[296515] pg_regress/dependency STATEMENT:  DROP USER regress_dep_user3;
2023-08-01 17:01:40.003 +07 client backend[296524] pg_regress/xmlmap ERROR:  unsupported XML feature
2023-08-01 17:01:40.003 +07 client backend[296524] pg_regress/xmlmap DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.003 +07 client backend[296524] pg_regress/xmlmap HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.003 +07 client backend[296524] pg_regress/xmlmap STATEMENT:  SELECT table_to_xml_and_xmlschema('testxmlschema.test1', false, false, '');
2023-08-01 17:01:40.004 +07 client backend[296524] pg_regress/xmlmap ERROR:  unsupported XML feature
2023-08-01 17:01:40.004 +07 client backend[296524] pg_regress/xmlmap DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.004 +07 client backend[296524] pg_regress/xmlmap HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.004 +07 client backend[296524] pg_regress/xmlmap STATEMENT:  SELECT table_to_xml_and_xmlschema('testxmlschema.test1', true, false, '');
2023-08-01 17:01:40.004 +07 client backend[296524] pg_regress/xmlmap ERROR:  unsupported XML feature
2023-08-01 17:01:40.004 +07 client backend[296524] pg_regress/xmlmap DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.004 +07 client backend[296524] pg_regress/xmlmap HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.004 +07 client backend[296524] pg_regress/xmlmap STATEMENT:  SELECT table_to_xml_and_xmlschema('testxmlschema.test1', false, true, '');
2023-08-01 17:01:40.004 +07 client backend[296524] pg_regress/xmlmap ERROR:  unsupported XML feature
2023-08-01 17:01:40.004 +07 client backend[296524] pg_regress/xmlmap DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.004 +07 client backend[296524] pg_regress/xmlmap HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.004 +07 client backend[296524] pg_regress/xmlmap STATEMENT:  SELECT table_to_xml_and_xmlschema('testxmlschema.test1', true, true, 'foo');
2023-08-01 17:01:40.005 +07 client backend[296516] pg_regress/guc ERROR:  invalid value for parameter "seq_page_cost": "NaN"
2023-08-01 17:01:40.005 +07 client backend[296516] pg_regress/guc STATEMENT:  SET seq_page_cost TO 'NaN';
2023-08-01 17:01:40.005 +07 client backend[296516] pg_regress/guc ERROR:  10000 ms is outside the valid range for parameter "vacuum_cost_delay" (0 .. 100)
2023-08-01 17:01:40.005 +07 client backend[296516] pg_regress/guc STATEMENT:  SET vacuum_cost_delay TO '10s';
2023-08-01 17:01:40.005 +07 client backend[296524] pg_regress/xmlmap ERROR:  unsupported XML feature
2023-08-01 17:01:40.005 +07 client backend[296524] pg_regress/xmlmap DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.005 +07 client backend[296524] pg_regress/xmlmap HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.005 +07 client backend[296524] pg_regress/xmlmap STATEMENT:  SELECT query_to_xml('SELECT * FROM testxmlschema.test1', false, false, '');
2023-08-01 17:01:40.005 +07 client backend[296524] pg_regress/xmlmap ERROR:  unsupported XML feature
2023-08-01 17:01:40.005 +07 client backend[296524] pg_regress/xmlmap DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.005 +07 client backend[296524] pg_regress/xmlmap HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.005 +07 client backend[296524] pg_regress/xmlmap STATEMENT:  SELECT query_to_xmlschema('SELECT * FROM testxmlschema.test1', false, false, '');
2023-08-01 17:01:40.005 +07 client backend[296515] pg_regress/dependency ERROR:  permission denied to drop objects
2023-08-01 17:01:40.005 +07 client backend[296515] pg_regress/dependency STATEMENT:  DROP OWNED BY regress_dep_user1;
2023-08-01 17:01:40.005 +07 client backend[296524] pg_regress/xmlmap ERROR:  unsupported XML feature
2023-08-01 17:01:40.005 +07 client backend[296524] pg_regress/xmlmap DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.005 +07 client backend[296524] pg_regress/xmlmap HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.005 +07 client backend[296524] pg_regress/xmlmap STATEMENT:  SELECT query_to_xml_and_xmlschema('SELECT * FROM testxmlschema.test1', true, true, '');
2023-08-01 17:01:40.005 +07 client backend[296515] pg_regress/dependency ERROR:  permission denied to drop objects
2023-08-01 17:01:40.005 +07 client backend[296515] pg_regress/dependency STATEMENT:  DROP OWNED BY regress_dep_user0, regress_dep_user2;
2023-08-01 17:01:40.006 +07 client backend[296515] pg_regress/dependency ERROR:  permission denied to reassign objects
2023-08-01 17:01:40.006 +07 client backend[296515] pg_regress/dependency STATEMENT:  REASSIGN OWNED BY regress_dep_user0 TO regress_dep_user1;
2023-08-01 17:01:40.006 +07 client backend[296524] pg_regress/xmlmap ERROR:  unsupported XML feature
2023-08-01 17:01:40.006 +07 client backend[296524] pg_regress/xmlmap DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.006 +07 client backend[296524] pg_regress/xmlmap HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.006 +07 client backend[296524] pg_regress/xmlmap STATEMENT:  SELECT cursor_to_xml('xc'::refcursor, 5, false, true, '');
2023-08-01 17:01:40.006 +07 client backend[296515] pg_regress/dependency ERROR:  permission denied to reassign objects
2023-08-01 17:01:40.006 +07 client backend[296515] pg_regress/dependency STATEMENT:  REASSIGN OWNED BY regress_dep_user1 TO regress_dep_user0;
2023-08-01 17:01:40.006 +07 client backend[296524] pg_regress/xmlmap ERROR:  unsupported XML feature
2023-08-01 17:01:40.006 +07 client backend[296524] pg_regress/xmlmap DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.006 +07 client backend[296524] pg_regress/xmlmap HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.006 +07 client backend[296524] pg_regress/xmlmap STATEMENT:  SELECT cursor_to_xmlschema('xc'::refcursor, false, true, '');
2023-08-01 17:01:40.007 +07 client backend[296524] pg_regress/xmlmap ERROR:  unsupported XML feature
2023-08-01 17:01:40.007 +07 client backend[296524] pg_regress/xmlmap DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.007 +07 client backend[296524] pg_regress/xmlmap HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.007 +07 client backend[296524] pg_regress/xmlmap STATEMENT:  SELECT cursor_to_xml('xc'::refcursor, 5, true, false, '');
2023-08-01 17:01:40.007 +07 client backend[296524] pg_regress/xmlmap ERROR:  unsupported XML feature
2023-08-01 17:01:40.007 +07 client backend[296524] pg_regress/xmlmap DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.007 +07 client backend[296524] pg_regress/xmlmap HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.007 +07 client backend[296524] pg_regress/xmlmap STATEMENT:  SELECT cursor_to_xmlschema('xc'::refcursor, true, false, '');
2023-08-01 17:01:40.007 +07 client backend[296524] pg_regress/xmlmap ERROR:  unsupported XML feature
2023-08-01 17:01:40.007 +07 client backend[296524] pg_regress/xmlmap DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.007 +07 client backend[296524] pg_regress/xmlmap HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.007 +07 client backend[296524] pg_regress/xmlmap STATEMENT:  SELECT schema_to_xml('testxmlschema', false, true, '');
2023-08-01 17:01:40.007 +07 client backend[296524] pg_regress/xmlmap ERROR:  unsupported XML feature
2023-08-01 17:01:40.007 +07 client backend[296524] pg_regress/xmlmap DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.007 +07 client backend[296524] pg_regress/xmlmap HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.007 +07 client backend[296524] pg_regress/xmlmap STATEMENT:  SELECT schema_to_xml('testxmlschema', true, false, '');
2023-08-01 17:01:40.008 +07 client backend[296523] pg_regress/foreign_data ERROR:  option "testing" provided more than once
2023-08-01 17:01:40.008 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  CREATE FOREIGN DATA WRAPPER foo OPTIONS (testing '1', testing '2');
2023-08-01 17:01:40.008 +07 client backend[296524] pg_regress/xmlmap ERROR:  unsupported XML feature
2023-08-01 17:01:40.008 +07 client backend[296524] pg_regress/xmlmap DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.008 +07 client backend[296524] pg_regress/xmlmap HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.008 +07 client backend[296524] pg_regress/xmlmap STATEMENT:  SELECT schema_to_xmlschema('testxmlschema', false, true, '');
2023-08-01 17:01:40.013 +07 client backend[296524] pg_regress/xmlmap ERROR:  unsupported XML feature
2023-08-01 17:01:40.013 +07 client backend[296524] pg_regress/xmlmap DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.013 +07 client backend[296524] pg_regress/xmlmap HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.013 +07 client backend[296524] pg_regress/xmlmap STATEMENT:  SELECT schema_to_xmlschema('testxmlschema', true, false, '');
2023-08-01 17:01:40.014 +07 client backend[296524] pg_regress/xmlmap ERROR:  unsupported XML feature
2023-08-01 17:01:40.014 +07 client backend[296524] pg_regress/xmlmap DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.014 +07 client backend[296524] pg_regress/xmlmap HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.014 +07 client backend[296524] pg_regress/xmlmap STATEMENT:  SELECT schema_to_xml_and_xmlschema('testxmlschema', true, true, 'foo');
2023-08-01 17:01:40.017 +07 client backend[296516] pg_regress/guc ERROR:  division by zero
2023-08-01 17:01:40.017 +07 client backend[296516] pg_regress/guc CONTEXT:  SQL statement "SELECT 1/$1"
	PL/pgSQL function myfunc(integer) line 4 at PERFORM
2023-08-01 17:01:40.017 +07 client backend[296516] pg_regress/guc STATEMENT:  select myfunc(0);
2023-08-01 17:01:40.017 +07 client backend[296525] pg_regress/tsdicts ERROR:  invalid affix alias "GJUS"
2023-08-01 17:01:40.017 +07 client backend[296525] pg_regress/tsdicts STATEMENT:  CREATE TEXT SEARCH DICTIONARY hunspell_err (
							Template=ispell,
							DictFile=ispell_sample,
							AffFile=hunspell_sample_long
	);
2023-08-01 17:01:40.017 +07 client backend[296525] pg_regress/tsdicts ERROR:  invalid affix flag "SZ\"
2023-08-01 17:01:40.017 +07 client backend[296525] pg_regress/tsdicts STATEMENT:  CREATE TEXT SEARCH DICTIONARY hunspell_err (
							Template=ispell,
							DictFile=ispell_sample,
							AffFile=hunspell_sample_num
	);
2023-08-01 17:01:40.017 +07 client backend[296516] pg_regress/guc ERROR:  unrecognized configuration parameter "nosuch.setting"
2023-08-01 17:01:40.017 +07 client backend[296516] pg_regress/guc STATEMENT:  select current_setting('nosuch.setting');
2023-08-01 17:01:40.017 +07 client backend[296516] pg_regress/guc ERROR:  unrecognized configuration parameter "nosuch.setting"
2023-08-01 17:01:40.017 +07 client backend[296516] pg_regress/guc STATEMENT:  select current_setting('nosuch.setting', false);
2023-08-01 17:01:40.018 +07 client backend[296516] pg_regress/guc ERROR:  invalid value for parameter "default_text_search_config": "no_such_config"
2023-08-01 17:01:40.018 +07 client backend[296516] pg_regress/guc STATEMENT:  create function func_with_bad_set() returns int as $$ select 1 $$
	language sql
	set default_text_search_config = no_such_config;
2023-08-01 17:01:40.018 +07 client backend[296525] pg_regress/tsdicts ERROR:  invalid affix alias "302,301,202,303"
2023-08-01 17:01:40.018 +07 client backend[296525] pg_regress/tsdicts STATEMENT:  CREATE TEXT SEARCH DICTIONARY hunspell_err (
							Template=ispell,
							DictFile=hunspell_sample_num,
							AffFile=hunspell_sample_long
	);
2023-08-01 17:01:40.018 +07 client backend[296516] pg_regress/guc ERROR:  invalid value for parameter "default_text_search_config": "no_such_config"
2023-08-01 17:01:40.018 +07 client backend[296516] pg_regress/guc STATEMENT:  select func_with_bad_set();
2023-08-01 17:01:40.018 +07 client backend[296516] pg_regress/guc ERROR:  tables declared WITH OIDS are not supported
2023-08-01 17:01:40.018 +07 client backend[296516] pg_regress/guc STATEMENT:  set default_with_oids to t;
2023-08-01 17:01:40.019 +07 client backend[296525] pg_regress/tsdicts ERROR:  casesensitive requires a Boolean value
2023-08-01 17:01:40.019 +07 client backend[296525] pg_regress/tsdicts STATEMENT:  ALTER TEXT SEARCH DICTIONARY synonym (CaseSensitive = 2);
2023-08-01 17:01:40.020 +07 client backend[296523] pg_regress/foreign_data ERROR:  permission denied to create foreign-data wrapper "foo"
2023-08-01 17:01:40.020 +07 client backend[296523] pg_regress/foreign_data HINT:  Must be superuser to create a foreign-data wrapper.
2023-08-01 17:01:40.020 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  CREATE FOREIGN DATA WRAPPER foo;
2023-08-01 17:01:40.021 +07 client backend[296524] pg_regress/xmlmap ERROR:  unsupported XML feature
2023-08-01 17:01:40.021 +07 client backend[296524] pg_regress/xmlmap DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.021 +07 client backend[296524] pg_regress/xmlmap HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.021 +07 client backend[296524] pg_regress/xmlmap STATEMENT:  SELECT xmlforest(c1, c2, c3, c4) FROM testxmlschema.test3;
2023-08-01 17:01:40.021 +07 client backend[296524] pg_regress/xmlmap ERROR:  unsupported XML feature
2023-08-01 17:01:40.021 +07 client backend[296524] pg_regress/xmlmap DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.021 +07 client backend[296524] pg_regress/xmlmap HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.021 +07 client backend[296524] pg_regress/xmlmap STATEMENT:  SELECT table_to_xml('testxmlschema.test3', true, true, '');
2023-08-01 17:01:40.021 +07 client backend[296522] pg_regress/functional_deps ERROR:  column "articles.id" must appear in the GROUP BY clause or be used in an aggregate function at character 8
2023-08-01 17:01:40.021 +07 client backend[296522] pg_regress/functional_deps STATEMENT:  SELECT id, keywords, title, body, created
	FROM articles
	GROUP BY title;
2023-08-01 17:01:40.022 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_ftest1_fkey"
2023-08-01 17:01:40.022 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (ftest1)=(100) is not present in table "pktable".
2023-08-01 17:01:40.022 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  INSERT INTO FKTABLE VALUES (100, 2);
2023-08-01 17:01:40.023 +07 client backend[296522] pg_regress/functional_deps ERROR:  column "articles.id" must appear in the GROUP BY clause or be used in an aggregate function at character 8
2023-08-01 17:01:40.023 +07 client backend[296522] pg_regress/functional_deps STATEMENT:  SELECT id, keywords, title, body, created
	FROM articles
	GROUP BY body;
2023-08-01 17:01:40.023 +07 client backend[296523] pg_regress/foreign_data ERROR:  function invalid_fdw_handler must return type fdw_handler
2023-08-01 17:01:40.023 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  CREATE FOREIGN DATA WRAPPER test_fdw HANDLER invalid_fdw_handler;
2023-08-01 17:01:40.023 +07 client backend[296523] pg_regress/foreign_data ERROR:  conflicting or redundant options
2023-08-01 17:01:40.023 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  CREATE FOREIGN DATA WRAPPER test_fdw HANDLER test_fdw_handler HANDLER invalid_fdw_handler;
2023-08-01 17:01:40.023 +07 client backend[296523] pg_regress/foreign_data ERROR:  syntax error at or near ";" at character 31
2023-08-01 17:01:40.023 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  ALTER FOREIGN DATA WRAPPER foo;
2023-08-01 17:01:40.023 +07 client backend[296523] pg_regress/foreign_data ERROR:  function bar(text[], oid) does not exist
2023-08-01 17:01:40.023 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  ALTER FOREIGN DATA WRAPPER foo VALIDATOR bar;
2023-08-01 17:01:40.025 +07 client backend[296523] pg_regress/foreign_data ERROR:  option "c" not found
2023-08-01 17:01:40.025 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  ALTER FOREIGN DATA WRAPPER foo OPTIONS (SET c '4');
2023-08-01 17:01:40.025 +07 client backend[296523] pg_regress/foreign_data ERROR:  option "c" not found
2023-08-01 17:01:40.025 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  ALTER FOREIGN DATA WRAPPER foo OPTIONS (DROP c);
2023-08-01 17:01:40.027 +07 client backend[296512] pg_regress/foreign_key ERROR:  constraint "constrname_wrong" for table "fktable" does not exist
2023-08-01 17:01:40.027 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  COMMENT ON CONSTRAINT constrname_wrong ON FKTABLE IS 'fk constraint comment';
2023-08-01 17:01:40.027 +07 client backend[296523] pg_regress/foreign_data ERROR:  option "b" provided more than once
2023-08-01 17:01:40.027 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  ALTER FOREIGN DATA WRAPPER foo OPTIONS (b '4');
2023-08-01 17:01:40.028 +07 client backend[296522] pg_regress/functional_deps ERROR:  column "articles.id" must appear in the GROUP BY clause or be used in an aggregate function at character 8
2023-08-01 17:01:40.028 +07 client backend[296522] pg_regress/functional_deps STATEMENT:  SELECT id, keywords, title, body, created
	FROM articles
	GROUP BY keywords;
2023-08-01 17:01:40.028 +07 client backend[296525] pg_regress/tsdicts ERROR:  unrecognized Ispell parameter: "DictFile"
2023-08-01 17:01:40.028 +07 client backend[296525] pg_regress/tsdicts STATEMENT:  CREATE TEXT SEARCH DICTIONARY tsdict_case
	(
		Template = ispell,
		"DictFile" = ispell_sample,
		"AffFile" = ispell_sample
	);
2023-08-01 17:01:40.029 +07 client backend[296523] pg_regress/foreign_data ERROR:  permission denied to alter foreign-data wrapper "foo"
2023-08-01 17:01:40.029 +07 client backend[296523] pg_regress/foreign_data HINT:  Must be superuser to alter a foreign-data wrapper.
2023-08-01 17:01:40.029 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  ALTER FOREIGN DATA WRAPPER foo OPTIONS (ADD d '5');
2023-08-01 17:01:40.029 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname"
2023-08-01 17:01:40.029 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (ftest1, ftest2)=(100, 2) is not present in table "pktable".
2023-08-01 17:01:40.029 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  INSERT INTO FKTABLE VALUES (100, 2, 4);
2023-08-01 17:01:40.030 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname"
2023-08-01 17:01:40.030 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (ftest1, ftest2)=(2, 2) is not present in table "pktable".
2023-08-01 17:01:40.030 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  INSERT INTO FKTABLE VALUES (2, 2, 4);
2023-08-01 17:01:40.030 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname"
2023-08-01 17:01:40.030 +07 client backend[296512] pg_regress/foreign_key DETAIL:  MATCH FULL does not allow mixing of null and nonnull key values.
2023-08-01 17:01:40.030 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  INSERT INTO FKTABLE VALUES (NULL, 2, 4);
2023-08-01 17:01:40.030 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname"
2023-08-01 17:01:40.030 +07 client backend[296512] pg_regress/foreign_key DETAIL:  MATCH FULL does not allow mixing of null and nonnull key values.
2023-08-01 17:01:40.030 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  INSERT INTO FKTABLE VALUES (1, NULL, 4);
2023-08-01 17:01:40.030 +07 client backend[296522] pg_regress/functional_deps ERROR:  column "a.id" must appear in the GROUP BY clause or be used in an aggregate function at character 8
2023-08-01 17:01:40.030 +07 client backend[296522] pg_regress/functional_deps STATEMENT:  SELECT a.id, a.keywords, a.title, a.body, a.created
	FROM articles AS a, articles_in_category AS aic
	WHERE a.id = aic.article_id AND aic.category_id in (14,62,70,53,138)
	GROUP BY aic.article_id, aic.category_id;
2023-08-01 17:01:40.030 +07 client backend[296523] pg_regress/foreign_data ERROR:  permission denied to change owner of foreign-data wrapper "foo"
2023-08-01 17:01:40.030 +07 client backend[296523] pg_regress/foreign_data HINT:  The owner of a foreign-data wrapper must be a superuser.
2023-08-01 17:01:40.030 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  ALTER FOREIGN DATA WRAPPER foo OWNER TO regress_test_role;
2023-08-01 17:01:40.031 +07 client backend[296522] pg_regress/functional_deps ERROR:  column "a.id" must appear in the GROUP BY clause or be used in an aggregate function at character 8
2023-08-01 17:01:40.031 +07 client backend[296522] pg_regress/functional_deps STATEMENT:  SELECT a.id, a.keywords, a.title, a.body, a.created
	FROM articles AS a JOIN articles_in_category AS aic ON a.id = aic.article_id
	WHERE aic.category_id in (14,62,70,53,138)
	GROUP BY aic.article_id, aic.category_id;
2023-08-01 17:01:40.032 +07 client backend[296523] pg_regress/foreign_data ERROR:  permission denied to alter foreign-data wrapper "foo"
2023-08-01 17:01:40.032 +07 client backend[296523] pg_regress/foreign_data HINT:  Must be superuser to alter a foreign-data wrapper.
2023-08-01 17:01:40.032 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  ALTER FOREIGN DATA WRAPPER foo OPTIONS (ADD e '6');
2023-08-01 17:01:40.032 +07 client backend[296522] pg_regress/functional_deps ERROR:  column "aic.changed" must appear in the GROUP BY clause or be used in an aggregate function at character 8
2023-08-01 17:01:40.032 +07 client backend[296522] pg_regress/functional_deps STATEMENT:  SELECT aic.changed
	FROM articles AS a JOIN articles_in_category AS aic ON a.id = aic.article_id
	WHERE aic.category_id in (14,62,70,53,138)
	GROUP BY aic.article_id;
2023-08-01 17:01:40.033 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname"
2023-08-01 17:01:40.033 +07 client backend[296512] pg_regress/foreign_key DETAIL:  MATCH FULL does not allow mixing of null and nonnull key values.
2023-08-01 17:01:40.033 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  UPDATE FKTABLE SET ftest1 = NULL WHERE ftest1 = 1;
2023-08-01 17:01:40.035 +07 client backend[296523] pg_regress/foreign_data ERROR:  function invalid_fdw_handler must return type fdw_handler
2023-08-01 17:01:40.035 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  ALTER FOREIGN DATA WRAPPER foo HANDLER invalid_fdw_handler;
2023-08-01 17:01:40.035 +07 client backend[296523] pg_regress/foreign_data ERROR:  conflicting or redundant options
2023-08-01 17:01:40.035 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  ALTER FOREIGN DATA WRAPPER foo HANDLER test_fdw_handler HANDLER anything;
2023-08-01 17:01:40.035 +07 client backend[296523] pg_regress/foreign_data WARNING:  changing the foreign-data wrapper handler can change behavior of existing foreign tables
2023-08-01 17:01:40.036 +07 client backend[296523] pg_regress/foreign_data ERROR:  foreign-data wrapper "nonexistent" does not exist
2023-08-01 17:01:40.036 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  DROP FOREIGN DATA WRAPPER nonexistent;
2023-08-01 17:01:40.038 +07 client backend[296522] pg_regress/functional_deps ERROR:  column "p.name" must appear in the GROUP BY clause or be used in an aggregate function at character 20
2023-08-01 17:01:40.038 +07 client backend[296522] pg_regress/functional_deps STATEMENT:  SELECT product_id, p.name, (sum(s.units) * p.price) AS sales
	    FROM products p LEFT JOIN sales s USING (product_id)
	    GROUP BY product_id;
2023-08-01 17:01:40.038 +07 client backend[296523] pg_regress/foreign_data ERROR:  role "regress_test_role_super" cannot be dropped because some objects depend on it
2023-08-01 17:01:40.038 +07 client backend[296523] pg_regress/foreign_data DETAIL:  owner of foreign-data wrapper foo
2023-08-01 17:01:40.038 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  DROP ROLE regress_test_role_super;
2023-08-01 17:01:40.039 +07 client backend[296515] pg_regress/dependency ERROR:  role "regress_dep_user1" cannot be dropped because some objects depend on it
2023-08-01 17:01:40.039 +07 client backend[296515] pg_regress/dependency DETAIL:  privileges for database regression
	privileges for table deptest1
	owner of default privileges on new relations belonging to role regress_dep_user1 in schema deptest
2023-08-01 17:01:40.039 +07 client backend[296515] pg_regress/dependency STATEMENT:  DROP USER regress_dep_user1;
2023-08-01 17:01:40.041 +07 client backend[296515] pg_regress/dependency ERROR:  role "regress_dep_user2" cannot be dropped because some objects depend on it
2023-08-01 17:01:40.041 +07 client backend[296515] pg_regress/dependency DETAIL:  owner of schema deptest
	owner of sequence deptest_a_seq
	owner of table deptest
	owner of function deptest_func()
	owner of type deptest_enum
	owner of type deptest_range
	owner of table deptest2
	owner of sequence ss1
	owner of type deptest_t
2023-08-01 17:01:40.041 +07 client backend[296515] pg_regress/dependency STATEMENT:  DROP USER regress_dep_user2;
2023-08-01 17:01:40.043 +07 client backend[296522] pg_regress/functional_deps ERROR:  column "articles.id" must appear in the GROUP BY clause or be used in an aggregate function at character 33
2023-08-01 17:01:40.043 +07 client backend[296522] pg_regress/functional_deps STATEMENT:  CREATE TEMP VIEW fdv1 AS
	SELECT id, keywords, title, body, created
	FROM articles
	GROUP BY body;
2023-08-01 17:01:40.044 +07 client backend[296523] pg_regress/foreign_data ERROR:  user mapping for "regress_foreign_data_user" already exists for server "s1"
2023-08-01 17:01:40.044 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  CREATE USER MAPPING FOR current_user SERVER s1;
2023-08-01 17:01:40.044 +07 client backend[296522] pg_regress/functional_deps ERROR:  cannot drop constraint articles_pkey on table articles because other objects depend on it
2023-08-01 17:01:40.044 +07 client backend[296522] pg_regress/functional_deps DETAIL:  view fdv1 depends on constraint articles_pkey on table articles
2023-08-01 17:01:40.044 +07 client backend[296522] pg_regress/functional_deps HINT:  Use DROP ... CASCADE to drop the dependent objects too.
2023-08-01 17:01:40.044 +07 client backend[296522] pg_regress/functional_deps STATEMENT:  ALTER TABLE articles DROP CONSTRAINT articles_pkey RESTRICT;
2023-08-01 17:01:40.046 +07 client backend[296522] pg_regress/functional_deps ERROR:  cannot drop constraint articles_pkey on table articles because other objects depend on it
2023-08-01 17:01:40.046 +07 client backend[296522] pg_regress/functional_deps DETAIL:  view fdv2 depends on constraint articles_pkey on table articles
2023-08-01 17:01:40.046 +07 client backend[296522] pg_regress/functional_deps HINT:  Use DROP ... CASCADE to drop the dependent objects too.
2023-08-01 17:01:40.046 +07 client backend[296522] pg_regress/functional_deps STATEMENT:  ALTER TABLE articles DROP CONSTRAINT articles_pkey RESTRICT;
2023-08-01 17:01:40.046 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname2"
2023-08-01 17:01:40.046 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (ftest1, ftest2)=(100, 2) is not present in table "pktable".
2023-08-01 17:01:40.046 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  INSERT INTO FKTABLE VALUES (100, 2, 4);
2023-08-01 17:01:40.046 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname2"
2023-08-01 17:01:40.046 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (ftest1, ftest2)=(2, 2) is not present in table "pktable".
2023-08-01 17:01:40.046 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  INSERT INTO FKTABLE VALUES (2, 2, 4);
2023-08-01 17:01:40.046 +07 client backend[296522] pg_regress/functional_deps ERROR:  cannot drop constraint articles_in_category_pkey on table articles_in_category because other objects depend on it
2023-08-01 17:01:40.046 +07 client backend[296522] pg_regress/functional_deps DETAIL:  view fdv2 depends on constraint articles_in_category_pkey on table articles_in_category
2023-08-01 17:01:40.046 +07 client backend[296522] pg_regress/functional_deps HINT:  Use DROP ... CASCADE to drop the dependent objects too.
2023-08-01 17:01:40.046 +07 client backend[296522] pg_regress/functional_deps STATEMENT:  ALTER TABLE articles_in_category DROP CONSTRAINT articles_in_category_pkey RESTRICT;
2023-08-01 17:01:40.046 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname2"
2023-08-01 17:01:40.046 +07 client backend[296512] pg_regress/foreign_key DETAIL:  MATCH FULL does not allow mixing of null and nonnull key values.
2023-08-01 17:01:40.046 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  INSERT INTO FKTABLE VALUES (NULL, 2, 4);
2023-08-01 17:01:40.046 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname2"
2023-08-01 17:01:40.046 +07 client backend[296512] pg_regress/foreign_key DETAIL:  MATCH FULL does not allow mixing of null and nonnull key values.
2023-08-01 17:01:40.046 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  INSERT INTO FKTABLE VALUES (1, NULL, 4);
2023-08-01 17:01:40.048 +07 client backend[296520] pg_regress/tsearch ERROR:  unrecognized parameter "foo"
2023-08-01 17:01:40.048 +07 client backend[296520] pg_regress/tsearch STATEMENT:  CREATE INDEX wowidx1 ON test_tsvector USING gist (a tsvector_ops(foo=1));
2023-08-01 17:01:40.048 +07 client backend[296520] pg_regress/tsearch ERROR:  value 0 out of bounds for option "siglen"
2023-08-01 17:01:40.048 +07 client backend[296520] pg_regress/tsearch DETAIL:  Valid values are between "1" and "2024".
2023-08-01 17:01:40.048 +07 client backend[296520] pg_regress/tsearch STATEMENT:  CREATE INDEX wowidx1 ON test_tsvector USING gist (a tsvector_ops(siglen=0));
2023-08-01 17:01:40.048 +07 client backend[296523] pg_regress/foreign_data ERROR:  cannot drop foreign-data wrapper foo because other objects depend on it
2023-08-01 17:01:40.048 +07 client backend[296523] pg_regress/foreign_data DETAIL:  server s1 depends on foreign-data wrapper foo
	user mapping for regress_foreign_data_user on server s1 depends on server s1
2023-08-01 17:01:40.048 +07 client backend[296523] pg_regress/foreign_data HINT:  Use DROP ... CASCADE to drop the dependent objects too.
2023-08-01 17:01:40.048 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  DROP FOREIGN DATA WRAPPER foo;
2023-08-01 17:01:40.048 +07 client backend[296520] pg_regress/tsearch ERROR:  value 2048 out of bounds for option "siglen"
2023-08-01 17:01:40.048 +07 client backend[296520] pg_regress/tsearch DETAIL:  Valid values are between "1" and "2024".
2023-08-01 17:01:40.048 +07 client backend[296520] pg_regress/tsearch STATEMENT:  CREATE INDEX wowidx1 ON test_tsvector USING gist (a tsvector_ops(siglen=2048));
2023-08-01 17:01:40.048 +07 client backend[296523] pg_regress/foreign_data ERROR:  must be owner of foreign-data wrapper foo
2023-08-01 17:01:40.048 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  DROP FOREIGN DATA WRAPPER foo CASCADE;
2023-08-01 17:01:40.049 +07 client backend[296520] pg_regress/tsearch ERROR:  unrecognized parameter "foo"
2023-08-01 17:01:40.049 +07 client backend[296520] pg_regress/tsearch STATEMENT:  CREATE INDEX wowidx1 ON test_tsvector USING gist (a tsvector_ops(siglen=100,foo='bar'));
2023-08-01 17:01:40.049 +07 client backend[296520] pg_regress/tsearch ERROR:  parameter "siglen" specified more than once
2023-08-01 17:01:40.049 +07 client backend[296520] pg_regress/tsearch STATEMENT:  CREATE INDEX wowidx1 ON test_tsvector USING gist (a tsvector_ops(siglen=100, siglen = 200));
2023-08-01 17:01:40.057 +07 client backend[296522] pg_regress/functional_deps ERROR:  cannot drop constraint articles_pkey on table articles because other objects depend on it
2023-08-01 17:01:40.057 +07 client backend[296522] pg_regress/functional_deps DETAIL:  view fdv3 depends on constraint articles_pkey on table articles
2023-08-01 17:01:40.057 +07 client backend[296522] pg_regress/functional_deps HINT:  Use DROP ... CASCADE to drop the dependent objects too.
2023-08-01 17:01:40.057 +07 client backend[296522] pg_regress/functional_deps STATEMENT:  ALTER TABLE articles DROP CONSTRAINT articles_pkey RESTRICT;
2023-08-01 17:01:40.058 +07 client backend[296512] pg_regress/foreign_key ERROR:  cannot drop table pktable because other objects depend on it
2023-08-01 17:01:40.058 +07 client backend[296512] pg_regress/foreign_key DETAIL:  constraint constrname2 on table fktable depends on table pktable
2023-08-01 17:01:40.058 +07 client backend[296512] pg_regress/foreign_key HINT:  Use DROP ... CASCADE to drop the dependent objects too.
2023-08-01 17:01:40.058 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  DROP TABLE PKTABLE;
2023-08-01 17:01:40.058 +07 client backend[296522] pg_regress/functional_deps ERROR:  cannot drop constraint articles_pkey on table articles because other objects depend on it
2023-08-01 17:01:40.058 +07 client backend[296522] pg_regress/functional_deps DETAIL:  view fdv4 depends on constraint articles_pkey on table articles
2023-08-01 17:01:40.058 +07 client backend[296522] pg_regress/functional_deps HINT:  Use DROP ... CASCADE to drop the dependent objects too.
2023-08-01 17:01:40.058 +07 client backend[296522] pg_regress/functional_deps STATEMENT:  ALTER TABLE articles DROP CONSTRAINT articles_pkey RESTRICT;
2023-08-01 17:01:40.059 +07 client backend[296523] pg_regress/foreign_data ERROR:  foreign-data wrapper "foo" does not exist
2023-08-01 17:01:40.059 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  CREATE SERVER s1 FOREIGN DATA WRAPPER foo;
2023-08-01 17:01:40.059 +07 client backend[296523] pg_regress/foreign_data ERROR:  server "s1" already exists
2023-08-01 17:01:40.059 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  CREATE SERVER s1 FOREIGN DATA WRAPPER foo;
2023-08-01 17:01:40.059 +07 client backend[296522] pg_regress/functional_deps ERROR:  column "articles.keywords" must appear in the GROUP BY clause or be used in an aggregate function at character 29
2023-08-01 17:01:40.059 +07 client backend[296522] pg_regress/functional_deps STATEMENT:  EXECUTE foo;
2023-08-01 17:01:40.060 +07 client backend[296523] pg_regress/foreign_data ERROR:  invalid option "foo"
2023-08-01 17:01:40.060 +07 client backend[296523] pg_regress/foreign_data HINT:  Valid options in this context are: authtype, service, connect_timeout, dbname, host, hostaddr, port, tty, options, requiressl, sslmode, gsslib
2023-08-01 17:01:40.060 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  CREATE SERVER s8 FOREIGN DATA WRAPPER postgresql OPTIONS (foo '1');
2023-08-01 17:01:40.061 +07 client backend[296523] pg_regress/foreign_data ERROR:  permission denied for foreign-data wrapper foo
2023-08-01 17:01:40.061 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  CREATE SERVER t1 FOREIGN DATA WRAPPER foo;
2023-08-01 17:01:40.063 +07 client backend[296523] pg_regress/foreign_data ERROR:  permission denied for foreign-data wrapper foo
2023-08-01 17:01:40.063 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  CREATE SERVER t2 FOREIGN DATA WRAPPER foo;
2023-08-01 17:01:40.063 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_ftest1_fkey"
2023-08-01 17:01:40.063 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (ftest1)=(100) is not present in table "pktable".
2023-08-01 17:01:40.063 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  INSERT INTO FKTABLE VALUES (100, 2);
2023-08-01 17:01:40.064 +07 client backend[296512] pg_regress/foreign_key ERROR:  update or delete on table "pktable" violates foreign key constraint "fktable_ftest1_fkey" on table "fktable"
2023-08-01 17:01:40.064 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (ptest1)=(1) is still referenced from table "fktable".
2023-08-01 17:01:40.064 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  DELETE FROM PKTABLE WHERE ptest1=1;
2023-08-01 17:01:40.064 +07 client backend[296512] pg_regress/foreign_key ERROR:  update or delete on table "pktable" violates foreign key constraint "fktable_ftest1_fkey" on table "fktable"
2023-08-01 17:01:40.064 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (ptest1)=(2) is still referenced from table "fktable".
2023-08-01 17:01:40.064 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  UPDATE PKTABLE SET ptest1=0 WHERE ptest1=2;
2023-08-01 17:01:40.066 +07 client backend[296523] pg_regress/foreign_data ERROR:  syntax error at or near ";" at character 16
2023-08-01 17:01:40.066 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  ALTER SERVER s0;
2023-08-01 17:01:40.066 +07 client backend[296523] pg_regress/foreign_data ERROR:  server "s0" does not exist
2023-08-01 17:01:40.066 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  ALTER SERVER s0 OPTIONS (a '1');
2023-08-01 17:01:40.068 +07 client backend[296523] pg_regress/foreign_data ERROR:  must be owner of foreign server s1
2023-08-01 17:01:40.068 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  ALTER SERVER s1 VERSION '1.1';
2023-08-01 17:01:40.068 +07 client backend[296523] pg_regress/foreign_data ERROR:  must be owner of foreign server s1
2023-08-01 17:01:40.068 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  ALTER SERVER s1 OWNER TO regress_test_role;
2023-08-01 17:01:40.068 +07 client backend[296523] pg_regress/foreign_data ERROR:  permission denied for foreign-data wrapper foo
2023-08-01 17:01:40.068 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  ALTER SERVER s1 OWNER TO regress_test_role2;
2023-08-01 17:01:40.068 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_ftest1_ftest2_fkey"
2023-08-01 17:01:40.068 +07 client backend[296512] pg_regress/foreign_key DETAIL:  MATCH FULL does not allow mixing of null and nonnull key values.
2023-08-01 17:01:40.068 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1, ftest2) REFERENCES PKTABLE MATCH FULL;
2023-08-01 17:01:40.069 +07 client backend[296523] pg_regress/foreign_data ERROR:  invalid option "foo"
2023-08-01 17:01:40.069 +07 client backend[296523] pg_regress/foreign_data HINT:  Valid options in this context are: authtype, service, connect_timeout, dbname, host, hostaddr, port, tty, options, requiressl, sslmode, gsslib
2023-08-01 17:01:40.069 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  ALTER SERVER s8 OPTIONS (foo '1');
2023-08-01 17:01:40.069 +07 client backend[296523] pg_regress/foreign_data ERROR:  must be member of role "regress_test_indirect"
2023-08-01 17:01:40.069 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  ALTER SERVER s1 OWNER TO regress_test_indirect;
2023-08-01 17:01:40.070 +07 client backend[296523] pg_regress/foreign_data ERROR:  role "regress_test_indirect" cannot be dropped because some objects depend on it
2023-08-01 17:01:40.070 +07 client backend[296523] pg_regress/foreign_data DETAIL:  privileges for foreign-data wrapper foo
	owner of server s1
2023-08-01 17:01:40.070 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  DROP ROLE regress_test_indirect;
2023-08-01 17:01:40.071 +07 client backend[296514] pg_regress/cluster ERROR:  insert or update on table "clstr_tst" violates foreign key constraint "clstr_tst_con"
2023-08-01 17:01:40.071 +07 client backend[296514] pg_regress/cluster DETAIL:  Key (b)=(1111) is not present in table "clstr_tst_s".
2023-08-01 17:01:40.071 +07 client backend[296514] pg_regress/cluster STATEMENT:  INSERT INTO clstr_tst (b, c) VALUES (1111, 'this should fail');
2023-08-01 17:01:40.072 +07 client backend[296523] pg_regress/foreign_data ERROR:  server "nonexistent" does not exist
2023-08-01 17:01:40.072 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  DROP SERVER nonexistent;
2023-08-01 17:01:40.072 +07 client backend[296523] pg_regress/foreign_data ERROR:  must be owner of foreign server s2
2023-08-01 17:01:40.072 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  DROP SERVER s2;
2023-08-01 17:01:40.073 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname3"
2023-08-01 17:01:40.073 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (ftest1, ftest2, ftest3)=(1, 2, 7) is not present in table "pktable".
2023-08-01 17:01:40.073 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  INSERT INTO FKTABLE VALUES (1, 2, 7, 6);
2023-08-01 17:01:40.073 +07 client backend[296512] pg_regress/foreign_key ERROR:  update or delete on table "pktable" violates foreign key constraint "constrname3" on table "fktable"
2023-08-01 17:01:40.073 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (ptest1, ptest2, ptest3)=(1, 2, 3) is still referenced from table "fktable".
2023-08-01 17:01:40.073 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  UPDATE PKTABLE set ptest2=5 where ptest2=2;
2023-08-01 17:01:40.074 +07 client backend[296512] pg_regress/foreign_key ERROR:  update or delete on table "pktable" violates foreign key constraint "constrname3" on table "fktable"
2023-08-01 17:01:40.074 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (ptest1, ptest2, ptest3)=(1, 2, 3) is still referenced from table "fktable".
2023-08-01 17:01:40.074 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  DELETE FROM PKTABLE where ptest1=1 and ptest2=2 and ptest3=3;
2023-08-01 17:01:40.074 +07 client backend[296523] pg_regress/foreign_data ERROR:  cannot drop server s3 because other objects depend on it
2023-08-01 17:01:40.074 +07 client backend[296523] pg_regress/foreign_data DETAIL:  user mapping for regress_foreign_data_user on server s3 depends on server s3
2023-08-01 17:01:40.074 +07 client backend[296523] pg_regress/foreign_data HINT:  Use DROP ... CASCADE to drop the dependent objects too.
2023-08-01 17:01:40.074 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  DROP SERVER s3;
2023-08-01 17:01:40.075 +07 client backend[296523] pg_regress/foreign_data ERROR:  role "regress_test_missing_role" does not exist
2023-08-01 17:01:40.075 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  CREATE USER MAPPING FOR regress_test_missing_role SERVER s1;
2023-08-01 17:01:40.075 +07 client backend[296523] pg_regress/foreign_data ERROR:  server "s1" does not exist
2023-08-01 17:01:40.075 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  CREATE USER MAPPING FOR current_user SERVER s1;
2023-08-01 17:01:40.075 +07 client backend[296523] pg_regress/foreign_data ERROR:  user mapping for "regress_foreign_data_user" already exists for server "s4"
2023-08-01 17:01:40.075 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  CREATE USER MAPPING FOR user SERVER s4;
2023-08-01 17:01:40.075 +07 client backend[296523] pg_regress/foreign_data ERROR:  invalid option "username"
2023-08-01 17:01:40.075 +07 client backend[296523] pg_regress/foreign_data HINT:  Valid options in this context are: user, password
2023-08-01 17:01:40.075 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  CREATE USER MAPPING FOR user SERVER s8 OPTIONS (username 'test', password 'secret');
2023-08-01 17:01:40.076 +07 client backend[296523] pg_regress/foreign_data ERROR:  permission denied for foreign server s7
2023-08-01 17:01:40.076 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  CREATE USER MAPPING FOR current_user SERVER s7;
2023-08-01 17:01:40.076 +07 client backend[296523] pg_regress/foreign_data ERROR:  must be owner of foreign server s8
2023-08-01 17:01:40.076 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  CREATE USER MAPPING FOR public SERVER s8;
2023-08-01 17:01:40.077 +07 client backend[296523] pg_regress/foreign_data ERROR:  role "regress_test_missing_role" does not exist
2023-08-01 17:01:40.077 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  ALTER USER MAPPING FOR regress_test_missing_role SERVER s4 OPTIONS (gotcha 'true');
2023-08-01 17:01:40.077 +07 client backend[296523] pg_regress/foreign_data ERROR:  server "ss4" does not exist
2023-08-01 17:01:40.077 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  ALTER USER MAPPING FOR user SERVER ss4 OPTIONS (gotcha 'true');
2023-08-01 17:01:40.077 +07 client backend[296523] pg_regress/foreign_data ERROR:  user mapping for "public" does not exist for server "s5"
2023-08-01 17:01:40.077 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  ALTER USER MAPPING FOR public SERVER s5 OPTIONS (gotcha 'true');
2023-08-01 17:01:40.077 +07 client backend[296523] pg_regress/foreign_data ERROR:  invalid option "username"
2023-08-01 17:01:40.077 +07 client backend[296523] pg_regress/foreign_data HINT:  Valid options in this context are: user, password
2023-08-01 17:01:40.077 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  ALTER USER MAPPING FOR current_user SERVER s8 OPTIONS (username 'test');
2023-08-01 17:01:40.077 +07 client backend[296523] pg_regress/foreign_data ERROR:  must be owner of foreign server s4
2023-08-01 17:01:40.077 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  ALTER USER MAPPING FOR public SERVER s4 OPTIONS (ADD modified '1');
2023-08-01 17:01:40.078 +07 client backend[296523] pg_regress/foreign_data ERROR:  role "regress_test_missing_role" does not exist
2023-08-01 17:01:40.078 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  DROP USER MAPPING FOR regress_test_missing_role SERVER s4;
2023-08-01 17:01:40.078 +07 client backend[296523] pg_regress/foreign_data ERROR:  server "ss4" does not exist
2023-08-01 17:01:40.078 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  DROP USER MAPPING FOR user SERVER ss4;
2023-08-01 17:01:40.078 +07 client backend[296514] pg_regress/cluster ERROR:  there is no previously clustered index for table "clstr_2"
2023-08-01 17:01:40.078 +07 client backend[296514] pg_regress/cluster STATEMENT:  CLUSTER clstr_2;
2023-08-01 17:01:40.078 +07 client backend[296523] pg_regress/foreign_data ERROR:  user mapping for "public" does not exist for server "s7"
2023-08-01 17:01:40.078 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  DROP USER MAPPING FOR public SERVER s7;
2023-08-01 17:01:40.079 +07 client backend[296523] pg_regress/foreign_data ERROR:  must be owner of foreign server s8
2023-08-01 17:01:40.079 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  DROP USER MAPPING FOR public SERVER s8;
2023-08-01 17:01:40.080 +07 client backend[296523] pg_regress/foreign_data ERROR:  syntax error at or near ";" at character 28
2023-08-01 17:01:40.080 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  CREATE FOREIGN TABLE ft1 ();
2023-08-01 17:01:40.080 +07 client backend[296523] pg_regress/foreign_data ERROR:  server "no_server" does not exist
2023-08-01 17:01:40.080 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  CREATE FOREIGN TABLE ft1 () SERVER no_server;
2023-08-01 17:01:40.080 +07 client backend[296523] pg_regress/foreign_data ERROR:  primary key constraints are not supported on foreign tables at character 67
2023-08-01 17:01:40.080 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  CREATE FOREIGN TABLE ft1 (
		c1 integer OPTIONS ("param 1" 'val1') PRIMARY KEY,
		c2 text OPTIONS (param2 'val2', param3 'val3'),
		c3 date
	) SERVER s0 OPTIONS (delimiter ',', quote '"', "be quoted" 'value');
2023-08-01 17:01:40.081 +07 client backend[296523] pg_regress/foreign_data ERROR:  foreign key constraints are not supported on foreign tables at character 67
2023-08-01 17:01:40.081 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  CREATE FOREIGN TABLE ft1 (
		c1 integer OPTIONS ("param 1" 'val1') REFERENCES ref_table (id),
		c2 text OPTIONS (param2 'val2', param3 'val3'),
		c3 date
	) SERVER s0 OPTIONS (delimiter ',', quote '"', "be quoted" 'value');
2023-08-01 17:01:40.082 +07 client backend[296523] pg_regress/foreign_data ERROR:  unique constraints are not supported on foreign tables at character 137
2023-08-01 17:01:40.082 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  CREATE FOREIGN TABLE ft1 (
		c1 integer OPTIONS ("param 1" 'val1') NOT NULL,
		c2 text OPTIONS (param2 'val2', param3 'val3'),
		c3 date,
		UNIQUE (c3)
	) SERVER s0 OPTIONS (delimiter ',', quote '"', "be quoted" 'value');
2023-08-01 17:01:40.084 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname3"
2023-08-01 17:01:40.084 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (ftest1, ftest2, ftest3)=(1, 2, 7) is not present in table "pktable".
2023-08-01 17:01:40.084 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  INSERT INTO FKTABLE VALUES (1, 2, 7, 6);
2023-08-01 17:01:40.091 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname3"
2023-08-01 17:01:40.091 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (ftest1, ftest2, ftest3)=(1, 2, 7) is not present in table "pktable".
2023-08-01 17:01:40.091 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  INSERT INTO FKTABLE VALUES (1, 2, 7, 6);
2023-08-01 17:01:40.094 +07 client backend[296514] pg_regress/cluster ERROR:  cannot mark index clustered in partitioned table
2023-08-01 17:01:40.094 +07 client backend[296514] pg_regress/cluster STATEMENT:  ALTER TABLE clstrpart CLUSTER ON clstrpart_idx;
2023-08-01 17:01:40.094 +07 client backend[296514] pg_regress/cluster ERROR:  cannot cluster a partitioned table
2023-08-01 17:01:40.094 +07 client backend[296514] pg_regress/cluster STATEMENT:  CLUSTER clstrpart USING clstrpart_idx;
2023-08-01 17:01:40.096 +07 client backend[296517] pg_regress/bitmapops LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp296517.0", size 980000
2023-08-01 17:01:40.096 +07 client backend[296517] pg_regress/bitmapops STATEMENT:  INSERT INTO bmscantest
	  SELECT (r%53), (r%59), 'foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo'
	  FROM generate_series(1,70000) r;
2023-08-01 17:01:40.097 +07 client backend[296523] pg_regress/foreign_data ERROR:  cannot create index on foreign table "ft1"
2023-08-01 17:01:40.097 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  CREATE INDEX id_ft1_c2 ON ft1 (c2);
2023-08-01 17:01:40.097 +07 client backend[296523] pg_regress/foreign_data ERROR:  foreign-data wrapper "dummy" has no handler
2023-08-01 17:01:40.097 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  SELECT * FROM ft1;
2023-08-01 17:01:40.097 +07 client backend[296523] pg_regress/foreign_data ERROR:  foreign-data wrapper "dummy" has no handler
2023-08-01 17:01:40.097 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  EXPLAIN SELECT * FROM ft1;
2023-08-01 17:01:40.098 +07 client backend[296523] pg_regress/foreign_data ERROR:  cannot create unique index on partitioned table "lt1"
2023-08-01 17:01:40.098 +07 client backend[296523] pg_regress/foreign_data DETAIL:  Table "lt1" contains partitions that are foreign tables.
2023-08-01 17:01:40.098 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  CREATE UNIQUE INDEX ON lt1 (a);
2023-08-01 17:01:40.098 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname3"
2023-08-01 17:01:40.098 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (ftest1, ftest2, ftest3)=(1, 2, 7) is not present in table "pktable".
2023-08-01 17:01:40.098 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  INSERT INTO FKTABLE VALUES (1, 2, 7, 6);
2023-08-01 17:01:40.099 +07 client backend[296523] pg_regress/foreign_data ERROR:  cannot create unique index on partitioned table "lt1"
2023-08-01 17:01:40.099 +07 client backend[296523] pg_regress/foreign_data DETAIL:  Table "lt1" contains partitions that are foreign tables.
2023-08-01 17:01:40.099 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  ALTER TABLE lt1 ADD PRIMARY KEY (a);
2023-08-01 17:01:40.099 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fktable" violates foreign key constraint "constrname3"
2023-08-01 17:01:40.099 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (ftest1, ftest2, ftest3)=(0, -1, -2) is not present in table "pktable".
2023-08-01 17:01:40.099 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  UPDATE PKTABLE set ptest2=5 where ptest2=2;
2023-08-01 17:01:40.100 +07 client backend[296519] pg_regress/window ERROR:  invalid preceding or following size in window function
2023-08-01 17:01:40.100 +07 client backend[296519] pg_regress/window STATEMENT:  select id, f_float4, first_value(id) over w, last_value(id) over w
	from numerics
	window w as (order by f_float4 range between
	             1.1 preceding and 'NaN' following);
2023-08-01 17:01:40.101 +07 client backend[296519] pg_regress/window ERROR:  invalid preceding or following size in window function
2023-08-01 17:01:40.101 +07 client backend[296519] pg_regress/window STATEMENT:  select id, f_float8, first_value(id) over w, last_value(id) over w
	from numerics
	window w as (order by f_float8 range between
	             1.1 preceding and 'NaN' following);
2023-08-01 17:01:40.101 +07 client backend[296519] pg_regress/window ERROR:  RANGE with offset PRECEDING/FOLLOWING is not supported for column type numeric and offset type double precision at character 158
2023-08-01 17:01:40.101 +07 client backend[296519] pg_regress/window HINT:  Cast the offset value to an appropriate type.
2023-08-01 17:01:40.101 +07 client backend[296519] pg_regress/window STATEMENT:  select id, f_numeric, first_value(id) over w, last_value(id) over w
	from numerics
	window w as (order by f_numeric range between
	             1 preceding and 1.1::float8 following);
2023-08-01 17:01:40.101 +07 client backend[296519] pg_regress/window ERROR:  invalid preceding or following size in window function
2023-08-01 17:01:40.101 +07 client backend[296519] pg_regress/window STATEMENT:  select id, f_numeric, first_value(id) over w, last_value(id) over w
	from numerics
	window w as (order by f_numeric range between
	             1.1 preceding and 'NaN' following);
2023-08-01 17:01:40.103 +07 client backend[296523] pg_regress/foreign_data ERROR:  cannot create foreign partition of partitioned table "lt1"
2023-08-01 17:01:40.103 +07 client backend[296523] pg_regress/foreign_data DETAIL:  Table "lt1" contains indexes that are unique.
2023-08-01 17:01:40.103 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  CREATE FOREIGN TABLE ft_part1
	  PARTITION OF lt1 FOR VALUES FROM (0) TO (1000) SERVER s0;
2023-08-01 17:01:40.103 +07 client backend[296523] pg_regress/foreign_data ERROR:  cannot attach foreign table "ft_part2" as partition of partitioned table "lt1"
2023-08-01 17:01:40.103 +07 client backend[296523] pg_regress/foreign_data DETAIL:  Table "lt1" contains unique indexes.
2023-08-01 17:01:40.103 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  ALTER TABLE lt1 ATTACH PARTITION ft_part2
	  FOR VALUES FROM (1000) TO (2000);
2023-08-01 17:01:40.104 +07 client backend[296512] pg_regress/foreign_key ERROR:  column "ftest2" referenced in foreign key constraint does not exist
2023-08-01 17:01:40.104 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  CREATE TABLE FKTABLE_FAIL1 ( ftest1 int, CONSTRAINT fkfail1 FOREIGN KEY (ftest2) REFERENCES PKTABLE);
2023-08-01 17:01:40.104 +07 client backend[296512] pg_regress/foreign_key ERROR:  column "ptest2" referenced in foreign key constraint does not exist
2023-08-01 17:01:40.104 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  CREATE TABLE FKTABLE_FAIL2 ( ftest1 int, CONSTRAINT fkfail1 FOREIGN KEY (ftest1) REFERENCES PKTABLE(ptest2));
2023-08-01 17:01:40.104 +07 client backend[296512] pg_regress/foreign_key ERROR:  table "fktable_fail1" does not exist
2023-08-01 17:01:40.104 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  DROP TABLE FKTABLE_FAIL1;
2023-08-01 17:01:40.104 +07 client backend[296512] pg_regress/foreign_key ERROR:  table "fktable_fail2" does not exist
2023-08-01 17:01:40.104 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  DROP TABLE FKTABLE_FAIL2;
2023-08-01 17:01:40.105 +07 client backend[296519] pg_regress/window ERROR:  RANGE with offset PRECEDING/FOLLOWING requires exactly one ORDER BY column at character 25
2023-08-01 17:01:40.105 +07 client backend[296519] pg_regress/window STATEMENT:  select sum(salary) over (order by enroll_date, salary range between '1 year'::interval preceding and '2 years'::interval following
		exclude ties), salary, enroll_date from empsalary;
2023-08-01 17:01:40.105 +07 client backend[296519] pg_regress/window ERROR:  RANGE with offset PRECEDING/FOLLOWING requires exactly one ORDER BY column at character 25
2023-08-01 17:01:40.105 +07 client backend[296519] pg_regress/window STATEMENT:  select sum(salary) over (range between '1 year'::interval preceding and '2 years'::interval following
		exclude ties), salary, enroll_date from empsalary;
2023-08-01 17:01:40.105 +07 client backend[296519] pg_regress/window ERROR:  RANGE with offset PRECEDING/FOLLOWING is not supported for column type text at character 57
2023-08-01 17:01:40.105 +07 client backend[296519] pg_regress/window STATEMENT:  select sum(salary) over (order by depname range between '1 year'::interval preceding and '2 years'::interval following
		exclude ties), salary, enroll_date from empsalary;
2023-08-01 17:01:40.105 +07 client backend[296519] pg_regress/window ERROR:  RANGE with offset PRECEDING/FOLLOWING is not supported for column type date and offset type integer at character 66
2023-08-01 17:01:40.105 +07 client backend[296519] pg_regress/window HINT:  Cast the offset value to an appropriate type.
2023-08-01 17:01:40.105 +07 client backend[296519] pg_regress/window STATEMENT:  select max(enroll_date) over (order by enroll_date range between 1 preceding and 2 following
		exclude ties), salary, enroll_date from empsalary;
2023-08-01 17:01:40.105 +07 client backend[296519] pg_regress/window ERROR:  invalid preceding or following size in window function
2023-08-01 17:01:40.105 +07 client backend[296519] pg_regress/window STATEMENT:  select max(enroll_date) over (order by salary range between -1 preceding and 2 following
		exclude ties), salary, enroll_date from empsalary;
2023-08-01 17:01:40.106 +07 client backend[296519] pg_regress/window ERROR:  invalid preceding or following size in window function
2023-08-01 17:01:40.106 +07 client backend[296519] pg_regress/window STATEMENT:  select max(enroll_date) over (order by salary range between 1 preceding and -2 following
		exclude ties), salary, enroll_date from empsalary;
2023-08-01 17:01:40.106 +07 client backend[296519] pg_regress/window ERROR:  RANGE with offset PRECEDING/FOLLOWING is not supported for column type integer and offset type interval at character 61
2023-08-01 17:01:40.106 +07 client backend[296519] pg_regress/window HINT:  Cast the offset value to an appropriate type.
2023-08-01 17:01:40.106 +07 client backend[296519] pg_regress/window STATEMENT:  select max(enroll_date) over (order by salary range between '1 year'::interval preceding and '2 years'::interval following
		exclude ties), salary, enroll_date from empsalary;
2023-08-01 17:01:40.106 +07 client backend[296519] pg_regress/window ERROR:  invalid preceding or following size in window function
2023-08-01 17:01:40.106 +07 client backend[296519] pg_regress/window STATEMENT:  select max(enroll_date) over (order by enroll_date range between '1 year'::interval preceding and '-2 years'::interval following
		exclude ties), salary, enroll_date from empsalary;
2023-08-01 17:01:40.106 +07 client backend[296512] pg_regress/foreign_key ERROR:  there is no unique constraint matching given keys for referenced table "pktable"
2023-08-01 17:01:40.106 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  CREATE TABLE FKTABLE_FAIL1 (ftest1 int REFERENCES pktable(ptest1));
2023-08-01 17:01:40.106 +07 client backend[296512] pg_regress/foreign_key ERROR:  table "fktable_fail1" does not exist
2023-08-01 17:01:40.106 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  DROP TABLE FKTABLE_FAIL1;
2023-08-01 17:01:40.107 +07 client backend[296523] pg_regress/foreign_data ERROR:  cannot create unique index on partitioned table "lt1"
2023-08-01 17:01:40.107 +07 client backend[296523] pg_regress/foreign_data DETAIL:  Table "lt1" contains partitions that are foreign tables.
2023-08-01 17:01:40.107 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  CREATE UNIQUE INDEX ON lt1 (a);
2023-08-01 17:01:40.108 +07 client backend[296523] pg_regress/foreign_data ERROR:  cannot create unique index on partitioned table "lt1_part1"
2023-08-01 17:01:40.108 +07 client backend[296523] pg_regress/foreign_data DETAIL:  Table "lt1_part1" contains partitions that are foreign tables.
2023-08-01 17:01:40.108 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  ALTER TABLE lt1 ADD PRIMARY KEY (a);
2023-08-01 17:01:40.109 +07 client backend[296512] pg_regress/foreign_key ERROR:  foreign key constraint "fktable_ftest1_fkey" cannot be implemented
2023-08-01 17:01:40.109 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: inet and integer.
2023-08-01 17:01:40.109 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  CREATE TABLE FKTABLE (ftest1 inet REFERENCES pktable);
2023-08-01 17:01:40.110 +07 client backend[296512] pg_regress/foreign_key ERROR:  foreign key constraint "fktable_ftest1_fkey" cannot be implemented
2023-08-01 17:01:40.110 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: inet and integer.
2023-08-01 17:01:40.110 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  CREATE TABLE FKTABLE (ftest1 inet REFERENCES pktable(ptest1));
2023-08-01 17:01:40.110 +07 client backend[296523] pg_regress/foreign_data ERROR:  cannot create foreign partition of partitioned table "lt1_part1"
2023-08-01 17:01:40.110 +07 client backend[296523] pg_regress/foreign_data DETAIL:  Table "lt1_part1" contains indexes that are unique.
2023-08-01 17:01:40.110 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  CREATE FOREIGN TABLE ft_part_1_1
	  PARTITION OF lt1_part1 FOR VALUES FROM (0) TO (100) SERVER s0;
2023-08-01 17:01:40.111 +07 client backend[296523] pg_regress/foreign_data ERROR:  cannot attach foreign table "ft_part_1_2" as partition of partitioned table "lt1_part1"
2023-08-01 17:01:40.111 +07 client backend[296523] pg_regress/foreign_data DETAIL:  Table "lt1_part1" contains unique indexes.
2023-08-01 17:01:40.111 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  ALTER TABLE lt1_part1 ATTACH PARTITION ft_part_1_2 FOR VALUES FROM (100) TO (200);
2023-08-01 17:01:40.111 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_ftest1_fkey"
2023-08-01 17:01:40.111 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (ftest1)=(43) is not present in table "pktable".
2023-08-01 17:01:40.111 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  INSERT INTO FKTABLE VALUES(43);
2023-08-01 17:01:40.111 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_ftest1_fkey"
2023-08-01 17:01:40.111 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (ftest1)=(43) is not present in table "pktable".
2023-08-01 17:01:40.111 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  UPDATE FKTABLE SET ftest1 = ftest1 + 1;
2023-08-01 17:01:40.113 +07 client backend[296512] pg_regress/foreign_key ERROR:  foreign key constraint "fktable_ftest1_fkey" cannot be implemented
2023-08-01 17:01:40.113 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: numeric and integer.
2023-08-01 17:01:40.113 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  CREATE TABLE FKTABLE (ftest1 numeric REFERENCES pktable);
2023-08-01 17:01:40.114 +07 client backend[296519] pg_regress/window ERROR:  RANGE with offset PRECEDING/FOLLOWING requires exactly one ORDER BY column at character 25
2023-08-01 17:01:40.114 +07 client backend[296519] pg_regress/window STATEMENT:  select f1, sum(f1) over (partition by f1
	                         range between 1 preceding and 1 following)
	from t1 where f1 = f2;
2023-08-01 17:01:40.114 +07 client backend[296519] pg_regress/window ERROR:  GROUPS mode requires an ORDER BY clause at character 25
2023-08-01 17:01:40.114 +07 client backend[296519] pg_regress/window STATEMENT:  select f1, sum(f1) over (partition by f1
	                         groups between 1 preceding and 1 following)
	from t1 where f1 = f2;
2023-08-01 17:01:40.114 +07 client backend[296523] pg_regress/foreign_data ERROR:  "ft1" is not a table
2023-08-01 17:01:40.114 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  ALTER FOREIGN TABLE ft1 ALTER COLUMN c8 TYPE char(10) USING '0';
2023-08-01 17:01:40.115 +07 client backend[296523] pg_regress/foreign_data ERROR:  cannot alter system column "xmin"
2023-08-01 17:01:40.115 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  ALTER FOREIGN TABLE ft1 ALTER COLUMN xmin OPTIONS (ADD p1 'v1');
2023-08-01 17:01:40.115 +07 client backend[296519] pg_regress/window ERROR:  window functions are not allowed in window definitions at character 30
2023-08-01 17:01:40.115 +07 client backend[296519] pg_regress/window STATEMENT:  SELECT rank() OVER (ORDER BY rank() OVER (ORDER BY random()));
2023-08-01 17:01:40.115 +07 client backend[296519] pg_regress/window ERROR:  window functions are not allowed in WHERE at character 31
2023-08-01 17:01:40.115 +07 client backend[296519] pg_regress/window STATEMENT:  SELECT * FROM empsalary WHERE row_number() OVER (ORDER BY salary) < 10;
2023-08-01 17:01:40.115 +07 client backend[296519] pg_regress/window ERROR:  window functions are not allowed in JOIN conditions at character 45
2023-08-01 17:01:40.115 +07 client backend[296519] pg_regress/window STATEMENT:  SELECT * FROM empsalary INNER JOIN tenk1 ON row_number() OVER (ORDER BY salary) < 10;
2023-08-01 17:01:40.115 +07 client backend[296519] pg_regress/window ERROR:  window functions are not allowed in GROUP BY at character 8
2023-08-01 17:01:40.115 +07 client backend[296519] pg_regress/window STATEMENT:  SELECT rank() OVER (ORDER BY 1), count(*) FROM empsalary GROUP BY 1;
2023-08-01 17:01:40.115 +07 client backend[296519] pg_regress/window ERROR:  syntax error at or near "ORDER" at character 28
2023-08-01 17:01:40.115 +07 client backend[296519] pg_regress/window STATEMENT:  SELECT * FROM rank() OVER (ORDER BY random());
2023-08-01 17:01:40.116 +07 client backend[296519] pg_regress/window ERROR:  window functions are not allowed in WHERE at character 30
2023-08-01 17:01:40.116 +07 client backend[296519] pg_regress/window STATEMENT:  DELETE FROM empsalary WHERE (rank() OVER (ORDER BY random())) > 10;
2023-08-01 17:01:40.116 +07 client backend[296519] pg_regress/window ERROR:  window functions are not allowed in RETURNING at character 33
2023-08-01 17:01:40.116 +07 client backend[296519] pg_regress/window STATEMENT:  DELETE FROM empsalary RETURNING rank() OVER (ORDER BY random());
2023-08-01 17:01:40.116 +07 client backend[296519] pg_regress/window ERROR:  window "w" is already defined at character 72
2023-08-01 17:01:40.116 +07 client backend[296519] pg_regress/window STATEMENT:  SELECT count(*) OVER w FROM tenk1 WINDOW w AS (ORDER BY unique1), w AS (ORDER BY unique1);
2023-08-01 17:01:40.116 +07 client backend[296519] pg_regress/window ERROR:  syntax error at or near "ORDER" at character 40
2023-08-01 17:01:40.116 +07 client backend[296519] pg_regress/window STATEMENT:  SELECT rank() OVER (PARTITION BY four, ORDER BY ten) FROM tenk1;
2023-08-01 17:01:40.116 +07 client backend[296519] pg_regress/window ERROR:  count(*) must be used to call a parameterless aggregate function at character 8
2023-08-01 17:01:40.116 +07 client backend[296519] pg_regress/window STATEMENT:  SELECT count() OVER () FROM tenk1;
2023-08-01 17:01:40.116 +07 client backend[296519] pg_regress/window ERROR:  OVER specified, but generate_series is not a window function nor an aggregate function at character 8
2023-08-01 17:01:40.116 +07 client backend[296519] pg_regress/window STATEMENT:  SELECT generate_series(1, 100) OVER () FROM empsalary;
2023-08-01 17:01:40.116 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_ftest1_fkey"
2023-08-01 17:01:40.116 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (ftest1)=(43) is not present in table "pktable".
2023-08-01 17:01:40.116 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  INSERT INTO FKTABLE VALUES(43);
2023-08-01 17:01:40.116 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_ftest1_fkey"
2023-08-01 17:01:40.116 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (ftest1)=(43) is not present in table "pktable".
2023-08-01 17:01:40.116 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  UPDATE FKTABLE SET ftest1 = ftest1 + 1;
2023-08-01 17:01:40.119 +07 client backend[296519] pg_regress/window ERROR:  argument of ntile must be greater than zero
2023-08-01 17:01:40.119 +07 client backend[296519] pg_regress/window STATEMENT:  SELECT ntile(0) OVER (ORDER BY ten), ten, four FROM tenk1;
2023-08-01 17:01:40.120 +07 client backend[296523] pg_regress/foreign_data ERROR:  cannot alter foreign table "ft1" because column "use_ft1_column_type.x" uses its row type
2023-08-01 17:01:40.120 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  ALTER FOREIGN TABLE ft1 ALTER COLUMN c8 SET DATA TYPE integer;
2023-08-01 17:01:40.120 +07 client backend[296512] pg_regress/foreign_key ERROR:  foreign key constraint "fktable_ftest1_ftest2_fkey" cannot be implemented
2023-08-01 17:01:40.120 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: cidr and integer.
2023-08-01 17:01:40.120 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  CREATE TABLE FKTABLE (ftest1 cidr, ftest2 timestamp, FOREIGN KEY(ftest1, ftest2) REFERENCES pktable);
2023-08-01 17:01:40.121 +07 client backend[296523] pg_regress/foreign_data ERROR:  primary key constraints are not supported on foreign tables at character 29
2023-08-01 17:01:40.121 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  ALTER FOREIGN TABLE ft1 ADD PRIMARY KEY (c7);
2023-08-01 17:01:40.121 +07 client backend[296523] pg_regress/foreign_data ERROR:  "ft1" is not a table
2023-08-01 17:01:40.121 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  ALTER FOREIGN TABLE ft1 ALTER CONSTRAINT ft1_c9_check DEFERRABLE;
2023-08-01 17:01:40.121 +07 client backend[296512] pg_regress/foreign_key ERROR:  foreign key constraint "fktable_ftest1_ftest2_fkey" cannot be implemented
2023-08-01 17:01:40.121 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: cidr and integer.
2023-08-01 17:01:40.121 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  CREATE TABLE FKTABLE (ftest1 cidr, ftest2 timestamp, FOREIGN KEY(ftest1, ftest2) REFERENCES pktable(ptest1, ptest2));
2023-08-01 17:01:40.121 +07 client backend[296523] pg_regress/foreign_data ERROR:  constraint "no_const" of relation "ft1" does not exist
2023-08-01 17:01:40.121 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  ALTER FOREIGN TABLE ft1 DROP CONSTRAINT no_const;
2023-08-01 17:01:40.122 +07 client backend[296523] pg_regress/foreign_data ERROR:  column "no_column" of relation "ft1" does not exist
2023-08-01 17:01:40.122 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  ALTER FOREIGN TABLE ft1 DROP COLUMN no_column;
2023-08-01 17:01:40.122 +07 client backend[296523] pg_regress/foreign_data ERROR:  relation "ft1" does not exist
2023-08-01 17:01:40.122 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  ALTER FOREIGN TABLE ft1 SET TABLESPACE ts;
2023-08-01 17:01:40.122 +07 client backend[296512] pg_regress/foreign_key ERROR:  foreign key constraint "fktable_ftest2_ftest1_fkey" cannot be implemented
2023-08-01 17:01:40.122 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key columns "ftest2" and "ptest1" are of incompatible types: inet and integer.
2023-08-01 17:01:40.122 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  CREATE TABLE FKTABLE (ftest1 int, ftest2 inet, FOREIGN KEY(ftest2, ftest1) REFERENCES pktable);
2023-08-01 17:01:40.123 +07 client backend[296519] pg_regress/window ERROR:  argument of nth_value must be greater than zero
2023-08-01 17:01:40.123 +07 client backend[296519] pg_regress/window STATEMENT:  SELECT nth_value(four, 0) OVER (ORDER BY ten), ten, four FROM tenk1;
2023-08-01 17:01:40.123 +07 client backend[296512] pg_regress/foreign_key ERROR:  foreign key constraint "fktable_ftest2_ftest1_fkey" cannot be implemented
2023-08-01 17:01:40.123 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key columns "ftest2" and "ptest1" are of incompatible types: inet and integer.
2023-08-01 17:01:40.123 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  CREATE TABLE FKTABLE (ftest1 int, ftest2 inet, FOREIGN KEY(ftest2, ftest1) REFERENCES pktable(ptest1, ptest2));
2023-08-01 17:01:40.124 +07 client backend[296512] pg_regress/foreign_key ERROR:  foreign key constraint "fktable_ftest1_ftest2_fkey" cannot be implemented
2023-08-01 17:01:40.124 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key columns "ftest1" and "ptest2" are of incompatible types: integer and inet.
2023-08-01 17:01:40.124 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  CREATE TABLE FKTABLE (ftest1 int, ftest2 inet, FOREIGN KEY(ftest1, ftest2) REFERENCES pktable(ptest2, ptest1));
2023-08-01 17:01:40.132 +07 client backend[296517] pg_regress/bitmapops LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp296517.0.sharedfileset/0.0", size 753664
2023-08-01 17:01:40.132 +07 client backend[296517] pg_regress/bitmapops STATEMENT:  CREATE INDEX i_bmtest_a ON bmscantest(a);
2023-08-01 17:01:40.132 +07 client backend[296517] pg_regress/bitmapops LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp296517.0.sharedfileset/1.0", size 655360
2023-08-01 17:01:40.132 +07 client backend[296517] pg_regress/bitmapops STATEMENT:  CREATE INDEX i_bmtest_a ON bmscantest(a);
2023-08-01 17:01:40.136 +07 client backend[296512] pg_regress/foreign_key ERROR:  foreign key constraint "pktable_ptest3_ptest4_fkey" cannot be implemented
2023-08-01 17:01:40.136 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key columns "ptest3" and "ptest2" are of incompatible types: integer and inet.
2023-08-01 17:01:40.136 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  CREATE TABLE PKTABLE (ptest1 int, ptest2 inet, ptest3 int, ptest4 inet, PRIMARY KEY(ptest1, ptest2), FOREIGN KEY(ptest3,
	ptest4) REFERENCES pktable(ptest2, ptest1));
2023-08-01 17:01:40.137 +07 client backend[296514] pg_regress/cluster LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp296514.0", size 2826240
2023-08-01 17:01:40.137 +07 client backend[296514] pg_regress/cluster STATEMENT:  cluster clstr_4 using cluster_sort;
2023-08-01 17:01:40.138 +07 client backend[296512] pg_regress/foreign_key ERROR:  foreign key constraint "pktable_ptest4_ptest3_fkey" cannot be implemented
2023-08-01 17:01:40.138 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key columns "ptest4" and "ptest1" are of incompatible types: inet and integer.
2023-08-01 17:01:40.138 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  CREATE TABLE PKTABLE (ptest1 int, ptest2 inet, ptest3 int, ptest4 inet, PRIMARY KEY(ptest1, ptest2), FOREIGN KEY(ptest4,
	ptest3) REFERENCES pktable(ptest1, ptest2));
2023-08-01 17:01:40.139 +07 client backend[296512] pg_regress/foreign_key ERROR:  foreign key constraint "pktable_ptest4_ptest3_fkey" cannot be implemented
2023-08-01 17:01:40.139 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key columns "ptest4" and "ptest1" are of incompatible types: inet and integer.
2023-08-01 17:01:40.139 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  CREATE TABLE PKTABLE (ptest1 int, ptest2 inet, ptest3 int, ptest4 inet, PRIMARY KEY(ptest1, ptest2), FOREIGN KEY(ptest4,
	ptest3) REFERENCES pktable);
2023-08-01 17:01:40.143 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_ftest1_fkey"
2023-08-01 17:01:40.143 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (ftest1)=(3) is not present in table "pktable".
2023-08-01 17:01:40.143 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  insert into fktable(ftest1) values (3);
2023-08-01 17:01:40.143 +07 client backend[296512] pg_regress/foreign_key ERROR:  update or delete on table "pktable" violates foreign key constraint "fktable_ftest1_fkey" on table "fktable"
2023-08-01 17:01:40.143 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (base1)=(3) is still referenced from table "fktable".
2023-08-01 17:01:40.143 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  delete from pktable where base1>2;
2023-08-01 17:01:40.144 +07 client backend[296512] pg_regress/foreign_key ERROR:  update or delete on table "pktable" violates foreign key constraint "fktable_ftest1_fkey" on table "fktable"
2023-08-01 17:01:40.144 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (base1)=(3) is still referenced from table "fktable".
2023-08-01 17:01:40.144 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  update pktable set base1=base1*4;
2023-08-01 17:01:40.146 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_ftest1_ftest2_fkey"
2023-08-01 17:01:40.146 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (ftest1, ftest2)=(3, 1) is not present in table "pktable".
2023-08-01 17:01:40.146 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  insert into fktable(ftest1, ftest2) values (3, 1);
2023-08-01 17:01:40.147 +07 client backend[296512] pg_regress/foreign_key ERROR:  update or delete on table "pktable" violates foreign key constraint "fktable_ftest1_ftest2_fkey" on table "fktable"
2023-08-01 17:01:40.147 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (base1, ptest1)=(3, 1) is still referenced from table "fktable".
2023-08-01 17:01:40.147 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  delete from pktable where base1>2;
2023-08-01 17:01:40.147 +07 client backend[296512] pg_regress/foreign_key ERROR:  update or delete on table "pktable" violates foreign key constraint "fktable_ftest1_ftest2_fkey" on table "fktable"
2023-08-01 17:01:40.147 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (base1, ptest1)=(3, 1) is still referenced from table "fktable".
2023-08-01 17:01:40.147 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  update pktable set base1=base1*4;
2023-08-01 17:01:40.148 +07 client backend[296523] pg_regress/foreign_data WARNING:  changing the foreign-data wrapper validator can cause the options for dependent objects to become invalid
2023-08-01 17:01:40.148 +07 client backend[296523] pg_regress/foreign_data ERROR:  permission denied to create foreign-data wrapper "foobar"
2023-08-01 17:01:40.148 +07 client backend[296523] pg_regress/foreign_data HINT:  Must be superuser to create a foreign-data wrapper.
2023-08-01 17:01:40.148 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  CREATE FOREIGN DATA WRAPPER foobar;
2023-08-01 17:01:40.148 +07 client backend[296523] pg_regress/foreign_data ERROR:  permission denied to alter foreign-data wrapper "foo"
2023-08-01 17:01:40.148 +07 client backend[296523] pg_regress/foreign_data HINT:  Must be superuser to alter a foreign-data wrapper.
2023-08-01 17:01:40.148 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  ALTER FOREIGN DATA WRAPPER foo OPTIONS (gotcha 'true');
2023-08-01 17:01:40.148 +07 client backend[296523] pg_regress/foreign_data ERROR:  permission denied to change owner of foreign-data wrapper "foo"
2023-08-01 17:01:40.148 +07 client backend[296523] pg_regress/foreign_data HINT:  Must be superuser to change owner of a foreign-data wrapper.
2023-08-01 17:01:40.148 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  ALTER FOREIGN DATA WRAPPER foo OWNER TO regress_unprivileged_role;
2023-08-01 17:01:40.149 +07 client backend[296523] pg_regress/foreign_data ERROR:  must be owner of foreign-data wrapper foo
2023-08-01 17:01:40.149 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  DROP FOREIGN DATA WRAPPER foo;
2023-08-01 17:01:40.149 +07 client backend[296523] pg_regress/foreign_data ERROR:  permission denied for foreign-data wrapper foo
2023-08-01 17:01:40.149 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  GRANT USAGE ON FOREIGN DATA WRAPPER foo TO regress_test_role;
2023-08-01 17:01:40.149 +07 client backend[296523] pg_regress/foreign_data ERROR:  permission denied for foreign-data wrapper foo
2023-08-01 17:01:40.149 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  CREATE SERVER s9 FOREIGN DATA WRAPPER foo;
2023-08-01 17:01:40.149 +07 client backend[296523] pg_regress/foreign_data ERROR:  must be owner of foreign server s4
2023-08-01 17:01:40.149 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  ALTER SERVER s4 VERSION '0.5';
2023-08-01 17:01:40.149 +07 client backend[296523] pg_regress/foreign_data ERROR:  must be owner of foreign server s4
2023-08-01 17:01:40.149 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  ALTER SERVER s4 OWNER TO regress_unprivileged_role;
2023-08-01 17:01:40.149 +07 client backend[296523] pg_regress/foreign_data ERROR:  must be owner of foreign server s4
2023-08-01 17:01:40.149 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  DROP SERVER s4;
2023-08-01 17:01:40.149 +07 client backend[296523] pg_regress/foreign_data ERROR:  permission denied for foreign server s4
2023-08-01 17:01:40.149 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  GRANT USAGE ON FOREIGN SERVER s4 TO regress_test_role;
2023-08-01 17:01:40.149 +07 client backend[296523] pg_regress/foreign_data ERROR:  must be owner of foreign server s4
2023-08-01 17:01:40.149 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  CREATE USER MAPPING FOR public SERVER s4;
2023-08-01 17:01:40.149 +07 client backend[296523] pg_regress/foreign_data ERROR:  must be owner of foreign server s6
2023-08-01 17:01:40.149 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  ALTER USER MAPPING FOR regress_test_role SERVER s6 OPTIONS (gotcha 'true');
2023-08-01 17:01:40.149 +07 client backend[296523] pg_regress/foreign_data ERROR:  must be owner of foreign server s6
2023-08-01 17:01:40.149 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  DROP USER MAPPING FOR regress_test_role SERVER s6;
2023-08-01 17:01:40.150 +07 client backend[296523] pg_regress/foreign_data ERROR:  permission denied to create foreign-data wrapper "foobar"
2023-08-01 17:01:40.150 +07 client backend[296523] pg_regress/foreign_data HINT:  Must be superuser to create a foreign-data wrapper.
2023-08-01 17:01:40.150 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  CREATE FOREIGN DATA WRAPPER foobar;
2023-08-01 17:01:40.150 +07 client backend[296523] pg_regress/foreign_data ERROR:  permission denied to alter foreign-data wrapper "foo"
2023-08-01 17:01:40.150 +07 client backend[296523] pg_regress/foreign_data HINT:  Must be superuser to alter a foreign-data wrapper.
2023-08-01 17:01:40.150 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  ALTER FOREIGN DATA WRAPPER foo OPTIONS (gotcha 'true');
2023-08-01 17:01:40.150 +07 client backend[296523] pg_regress/foreign_data ERROR:  must be owner of foreign-data wrapper foo
2023-08-01 17:01:40.150 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  DROP FOREIGN DATA WRAPPER foo;
2023-08-01 17:01:40.150 +07 client backend[296523] pg_regress/foreign_data WARNING:  no privileges were granted for "postgresql"
2023-08-01 17:01:40.150 +07 client backend[296523] pg_regress/foreign_data ERROR:  must be owner of foreign server s6
2023-08-01 17:01:40.150 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  ALTER SERVER s6 VERSION '0.5';
2023-08-01 17:01:40.150 +07 client backend[296523] pg_regress/foreign_data ERROR:  must be owner of foreign server s6
2023-08-01 17:01:40.150 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  DROP SERVER s6;
2023-08-01 17:01:40.150 +07 client backend[296523] pg_regress/foreign_data ERROR:  permission denied for foreign server s6
2023-08-01 17:01:40.150 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  GRANT USAGE ON FOREIGN SERVER s6 TO regress_test_role;
2023-08-01 17:01:40.150 +07 client backend[296523] pg_regress/foreign_data ERROR:  must be owner of foreign server s6
2023-08-01 17:01:40.150 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  CREATE USER MAPPING FOR public SERVER s6;
2023-08-01 17:01:40.151 +07 client backend[296523] pg_regress/foreign_data ERROR:  must be owner of foreign server s6
2023-08-01 17:01:40.151 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  ALTER USER MAPPING FOR regress_test_role SERVER s6 OPTIONS (gotcha 'true');
2023-08-01 17:01:40.151 +07 client backend[296523] pg_regress/foreign_data ERROR:  must be owner of foreign server s6
2023-08-01 17:01:40.151 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  DROP USER MAPPING FOR regress_test_role SERVER s6;
2023-08-01 17:01:40.151 +07 client backend[296523] pg_regress/foreign_data ERROR:  dependent privileges exist
2023-08-01 17:01:40.151 +07 client backend[296523] pg_regress/foreign_data HINT:  Use CASCADE to revoke them too.
2023-08-01 17:01:40.151 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  REVOKE USAGE ON FOREIGN DATA WRAPPER foo FROM regress_unprivileged_role;
2023-08-01 17:01:40.151 +07 client backend[296523] pg_regress/foreign_data ERROR:  permission denied for foreign-data wrapper foo
2023-08-01 17:01:40.151 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  GRANT USAGE ON FOREIGN DATA WRAPPER foo TO regress_test_role;
2023-08-01 17:01:40.151 +07 client backend[296523] pg_regress/foreign_data ERROR:  permission denied for foreign-data wrapper foo
2023-08-01 17:01:40.151 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  CREATE SERVER s10 FOREIGN DATA WRAPPER foo;
2023-08-01 17:01:40.152 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "pktable" violates foreign key constraint "pktable_base2_ptest2_fkey"
2023-08-01 17:01:40.152 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (base2, ptest2)=(3, 2) is not present in table "pktable".
2023-08-01 17:01:40.152 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  insert into pktable (base1, ptest1, base2, ptest2) values (2, 3, 3, 2);
2023-08-01 17:01:40.152 +07 client backend[296523] pg_regress/foreign_data ERROR:  must be owner of foreign server s9
2023-08-01 17:01:40.152 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  ALTER SERVER s9 VERSION '1.2';
2023-08-01 17:01:40.152 +07 client backend[296512] pg_regress/foreign_key ERROR:  update or delete on table "pktable" violates foreign key constraint "pktable_base2_ptest2_fkey" on table "pktable"
2023-08-01 17:01:40.152 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (base1, ptest1)=(2, 2) is still referenced from table "pktable".
2023-08-01 17:01:40.152 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  delete from pktable where base1=2;
2023-08-01 17:01:40.152 +07 client backend[296523] pg_regress/foreign_data WARNING:  no privileges were granted for "s9"
2023-08-01 17:01:40.153 +07 client backend[296512] pg_regress/foreign_key ERROR:  update or delete on table "pktable" violates foreign key constraint "pktable_base2_ptest2_fkey" on table "pktable"
2023-08-01 17:01:40.153 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (base1, ptest1)=(1, 1) is still referenced from table "pktable".
2023-08-01 17:01:40.153 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  update pktable set base1=3 where base1=1;
2023-08-01 17:01:40.153 +07 client backend[296523] pg_regress/foreign_data ERROR:  must be owner of foreign server s9
2023-08-01 17:01:40.153 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  DROP SERVER s9 CASCADE;
2023-08-01 17:01:40.157 +07 client backend[296512] pg_regress/foreign_key ERROR:  foreign key constraint "fktable_ftest1_ftest2_fkey" cannot be implemented
2023-08-01 17:01:40.157 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key columns "ftest1" and "base1" are of incompatible types: cidr and integer.
2023-08-01 17:01:40.157 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  create table fktable(ftest1 cidr, ftest2 int[], foreign key (ftest1, ftest2) references pktable);
2023-08-01 17:01:40.157 +07 client backend[296523] pg_regress/foreign_data ERROR:  "foreign_table_1" is a foreign table
2023-08-01 17:01:40.157 +07 client backend[296523] pg_regress/foreign_data DETAIL:  Triggers on foreign tables cannot have transition tables.
2023-08-01 17:01:40.157 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  CREATE TRIGGER trigtest_after_stmt_tt AFTER INSERT OR UPDATE OR DELETE 
	ON foreign_schema.foreign_table_1
	REFERENCING NEW TABLE AS new_table
	FOR EACH STATEMENT
	EXECUTE PROCEDURE dummy_trigger();
2023-08-01 17:01:40.158 +07 client backend[296523] pg_regress/foreign_data ERROR:  "foreign_table_1" is a foreign table
2023-08-01 17:01:40.158 +07 client backend[296523] pg_regress/foreign_data DETAIL:  Foreign tables cannot have constraint triggers.
2023-08-01 17:01:40.158 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  CREATE CONSTRAINT TRIGGER trigtest_constraint AFTER INSERT OR UPDATE OR DELETE
	ON foreign_schema.foreign_table_1
	FOR EACH ROW
	EXECUTE PROCEDURE dummy_trigger();
2023-08-01 17:01:40.158 +07 client backend[296512] pg_regress/foreign_key ERROR:  foreign key constraint "fktable_ftest1_ftest2_fkey" cannot be implemented
2023-08-01 17:01:40.158 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key columns "ftest1" and "base1" are of incompatible types: cidr and integer.
2023-08-01 17:01:40.158 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  create table fktable(ftest1 cidr, ftest2 int[], foreign key (ftest1, ftest2) references pktable(base1, ptest1));
2023-08-01 17:01:40.159 +07 client backend[296512] pg_regress/foreign_key ERROR:  foreign key constraint "fktable_ftest2_ftest1_fkey" cannot be implemented
2023-08-01 17:01:40.159 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key columns "ftest2" and "base1" are of incompatible types: inet and integer.
2023-08-01 17:01:40.159 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  create table fktable(ftest1 int, ftest2 inet, foreign key(ftest2, ftest1) references pktable);
2023-08-01 17:01:40.160 +07 client backend[296512] pg_regress/foreign_key ERROR:  foreign key constraint "fktable_ftest2_ftest1_fkey" cannot be implemented
2023-08-01 17:01:40.160 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key columns "ftest2" and "base1" are of incompatible types: inet and integer.
2023-08-01 17:01:40.160 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  create table fktable(ftest1 int, ftest2 inet, foreign key(ftest2, ftest1) references pktable(base1, ptest1));
2023-08-01 17:01:40.161 +07 client backend[296512] pg_regress/foreign_key ERROR:  foreign key constraint "fktable_ftest1_ftest2_fkey" cannot be implemented
2023-08-01 17:01:40.161 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: integer and inet.
2023-08-01 17:01:40.161 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  create table fktable(ftest1 int, ftest2 inet, foreign key(ftest1, ftest2) references pktable(ptest1, base1));
2023-08-01 17:01:40.164 +07 client backend[296512] pg_regress/foreign_key ERROR:  foreign key constraint "pktable_base2_ptest2_fkey" cannot be implemented
2023-08-01 17:01:40.164 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key columns "ptest2" and "ptest1" are of incompatible types: inet[] and inet.
2023-08-01 17:01:40.164 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  create table pktable(ptest1 inet, ptest2 inet[], primary key(base1, ptest1), foreign key(base2, ptest2) references
	                                             pktable(base1, ptest1)) inherits (pktable_base);
2023-08-01 17:01:40.166 +07 client backend[296512] pg_regress/foreign_key ERROR:  foreign key constraint "pktable_base2_ptest2_fkey" cannot be implemented
2023-08-01 17:01:40.166 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key columns "base2" and "ptest1" are of incompatible types: integer and inet.
2023-08-01 17:01:40.166 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  create table pktable(ptest1 inet, ptest2 inet, primary key(base1, ptest1), foreign key(base2, ptest2) references
	                                             pktable(ptest1, base1)) inherits (pktable_base);
2023-08-01 17:01:40.167 +07 client backend[296512] pg_regress/foreign_key ERROR:  foreign key constraint "pktable_ptest2_base2_fkey" cannot be implemented
2023-08-01 17:01:40.167 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key columns "ptest2" and "base1" are of incompatible types: inet and integer.
2023-08-01 17:01:40.167 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  create table pktable(ptest1 inet, ptest2 inet, primary key(base1, ptest1), foreign key(ptest2, base2) references
	                                             pktable(base1, ptest1)) inherits (pktable_base);
2023-08-01 17:01:40.169 +07 client backend[296512] pg_regress/foreign_key ERROR:  foreign key constraint "pktable_ptest2_base2_fkey" cannot be implemented
2023-08-01 17:01:40.169 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key columns "ptest2" and "base1" are of incompatible types: inet and integer.
2023-08-01 17:01:40.169 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  create table pktable(ptest1 inet, ptest2 inet, primary key(base1, ptest1), foreign key(ptest2, base2) references
	                                             pktable(base1, ptest1)) inherits (pktable_base);
2023-08-01 17:01:40.169 +07 client backend[296512] pg_regress/foreign_key ERROR:  table "pktable" does not exist
2023-08-01 17:01:40.169 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  drop table pktable;
2023-08-01 17:01:40.169 +07 client backend[296517] pg_regress/bitmapops LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp296517.1.sharedfileset/0.0", size 942080
2023-08-01 17:01:40.169 +07 client backend[296517] pg_regress/bitmapops STATEMENT:  CREATE INDEX i_bmtest_b ON bmscantest(b);
2023-08-01 17:01:40.170 +07 client backend[296517] pg_regress/bitmapops LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp296517.1.sharedfileset/1.0", size 466944
2023-08-01 17:01:40.170 +07 client backend[296517] pg_regress/bitmapops STATEMENT:  CREATE INDEX i_bmtest_b ON bmscantest(b);
2023-08-01 17:01:40.179 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_fk_fkey"
2023-08-01 17:01:40.179 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (fk)=(10) is not present in table "pktable".
2023-08-01 17:01:40.179 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  INSERT INTO fktable VALUES (5, 10);
2023-08-01 17:01:40.183 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_fk_fkey"
2023-08-01 17:01:40.183 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (fk)=(1000) is not present in table "pktable".
2023-08-01 17:01:40.183 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  INSERT INTO fktable VALUES (500, 1000);
2023-08-01 17:01:40.186 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_fk_fkey"
2023-08-01 17:01:40.186 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (fk)=(2000) is not present in table "pktable".
2023-08-01 17:01:40.186 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  SET CONSTRAINTS ALL IMMEDIATE;
2023-08-01 17:01:40.186 +07 client backend[296512] pg_regress/foreign_key ERROR:  current transaction is aborted, commands ignored until end of transaction block
2023-08-01 17:01:40.186 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  INSERT INTO pktable VALUES (2000, 3);
2023-08-01 17:01:40.189 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_fk_fkey"
2023-08-01 17:01:40.189 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (fk)=(200) is not present in table "pktable".
2023-08-01 17:01:40.189 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  COMMIT;
2023-08-01 17:01:40.194 +07 client backend[296512] pg_regress/foreign_key ERROR:  foreign key constraint "fk_2_3" cannot be implemented
2023-08-01 17:01:40.194 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key columns "x2" and "id3" are of incompatible types: character varying and real.
2023-08-01 17:01:40.194 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  ALTER TABLE fktable ADD CONSTRAINT fk_2_3
	FOREIGN KEY (x2) REFERENCES pktable(id3);
2023-08-01 17:01:40.194 +07 client backend[296512] pg_regress/foreign_key ERROR:  foreign key constraint "fk_2_1" cannot be implemented
2023-08-01 17:01:40.194 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key columns "x2" and "id1" are of incompatible types: character varying and integer.
2023-08-01 17:01:40.194 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  ALTER TABLE fktable ADD CONSTRAINT fk_2_1
	FOREIGN KEY (x2) REFERENCES pktable(id1);
2023-08-01 17:01:40.194 +07 client backend[296512] pg_regress/foreign_key ERROR:  foreign key constraint "fk_3_1" cannot be implemented
2023-08-01 17:01:40.194 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key columns "x3" and "id1" are of incompatible types: real and integer.
2023-08-01 17:01:40.194 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  ALTER TABLE fktable ADD CONSTRAINT fk_3_1
	FOREIGN KEY (x3) REFERENCES pktable(id1);
2023-08-01 17:01:40.194 +07 client backend[296512] pg_regress/foreign_key ERROR:  foreign key constraint "fk_1_2" cannot be implemented
2023-08-01 17:01:40.194 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key columns "x1" and "id2" are of incompatible types: integer and character varying.
2023-08-01 17:01:40.194 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  ALTER TABLE fktable ADD CONSTRAINT fk_1_2
	FOREIGN KEY (x1) REFERENCES pktable(id2);
2023-08-01 17:01:40.199 +07 client backend[296512] pg_regress/foreign_key ERROR:  foreign key constraint "fk_123_231" cannot be implemented
2023-08-01 17:01:40.199 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key columns "x1" and "id2" are of incompatible types: integer and character varying.
2023-08-01 17:01:40.199 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  ALTER TABLE fktable ADD CONSTRAINT fk_123_231
	FOREIGN KEY (x1,x2,x3) REFERENCES pktable(id2,id3,id1);
2023-08-01 17:01:40.199 +07 client backend[296512] pg_regress/foreign_key ERROR:  foreign key constraint "fk_241_132" cannot be implemented
2023-08-01 17:01:40.199 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key columns "x2" and "id1" are of incompatible types: character varying and integer.
2023-08-01 17:01:40.199 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  ALTER TABLE fktable ADD CONSTRAINT fk_241_132
	FOREIGN KEY (x2,x4,x1) REFERENCES pktable(id1,id3,id2);
2023-08-01 17:01:40.204 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_fk_fkey"
2023-08-01 17:01:40.204 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (fk)=(20) is not present in table "pktable".
2023-08-01 17:01:40.204 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  COMMIT;
2023-08-01 17:01:40.205 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_fk_fkey"
2023-08-01 17:01:40.205 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (fk)=(20) is not present in table "pktable".
2023-08-01 17:01:40.205 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  COMMIT;
2023-08-01 17:01:40.205 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_fk_fkey"
2023-08-01 17:01:40.205 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (fk)=(20) is not present in table "pktable".
2023-08-01 17:01:40.205 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  COMMIT;
2023-08-01 17:01:40.206 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_fk_fkey"
2023-08-01 17:01:40.206 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (fk)=(20) is not present in table "pktable".
2023-08-01 17:01:40.206 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  COMMIT;
2023-08-01 17:01:40.207 +07 client backend[296512] pg_regress/foreign_key ERROR:  update or delete on table "pktable" violates foreign key constraint "fktable_fk_fkey" on table "fktable"
2023-08-01 17:01:40.207 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (id)=(5) is still referenced from table "fktable".
2023-08-01 17:01:40.207 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  UPDATE pktable SET id = 10 WHERE id = 5;
2023-08-01 17:01:40.207 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_fk_fkey"
2023-08-01 17:01:40.207 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (fk)=(20) is not present in table "pktable".
2023-08-01 17:01:40.207 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  INSERT INTO fktable VALUES (0, 20);
2023-08-01 17:01:40.207 +07 client backend[296512] pg_regress/foreign_key ERROR:  constraint declared INITIALLY DEFERRED must be DEFERRABLE at character 69
2023-08-01 17:01:40.207 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  ALTER TABLE fktable ALTER CONSTRAINT fktable_fk_fkey NOT DEFERRABLE INITIALLY DEFERRED;
2023-08-01 17:01:40.210 +07 client backend[296523] pg_regress/foreign_data ERROR:  "ft2" is not a table
2023-08-01 17:01:40.210 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  ALTER TABLE fd_pt1 ALTER COLUMN c8 TYPE char(10) USING '0';
2023-08-01 17:01:40.217 +07 client backend[296512] pg_regress/foreign_key ERROR:  update or delete on table "defp" violates foreign key constraint "defc_f1_fkey" on table "defc"
2023-08-01 17:01:40.217 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (f1)=(0) is still referenced from table "defc".
2023-08-01 17:01:40.217 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  delete from defp where f1 = 0;
2023-08-01 17:01:40.218 +07 client backend[296512] pg_regress/foreign_key ERROR:  update or delete on table "defp" violates foreign key constraint "defc_f1_fkey" on table "defc"
2023-08-01 17:01:40.218 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (f1)=(1) is still referenced from table "defc".
2023-08-01 17:01:40.218 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  delete from defp where f1 = 1;
2023-08-01 17:01:40.221 +07 client backend[296512] pg_regress/foreign_key ERROR:  update or delete on table "pp" violates foreign key constraint "cc_f1_fkey" on table "cc"
2023-08-01 17:01:40.221 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (f1)=(13) is still referenced from table "cc".
2023-08-01 17:01:40.221 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  update pp set f1=f1+1;
2023-08-01 17:01:40.221 +07 client backend[296512] pg_regress/foreign_key ERROR:  update or delete on table "pp" violates foreign key constraint "cc_f1_fkey" on table "cc"
2023-08-01 17:01:40.221 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (f1)=(13) is still referenced from table "cc".
2023-08-01 17:01:40.221 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  delete from pp where f1 = 13;
2023-08-01 17:01:40.224 +07 client backend[296512] pg_regress/foreign_key ERROR:  update or delete on table "pp" violates foreign key constraint "cc_f1_fkey" on table "cc"
2023-08-01 17:01:40.224 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (f1)=(13) is still referenced from table "cc".
2023-08-01 17:01:40.224 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  update pp set f1=f1+1;
2023-08-01 17:01:40.224 +07 client backend[296512] pg_regress/foreign_key ERROR:  update or delete on table "pp" violates foreign key constraint "cc_f1_fkey" on table "cc"
2023-08-01 17:01:40.224 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (f1)=(13) is still referenced from table "cc".
2023-08-01 17:01:40.224 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  delete from pp where f1 = 13;
2023-08-01 17:01:40.230 +07 client backend[296512] pg_regress/foreign_key ERROR:  update or delete on table "pktable2" violates foreign key constraint "fktable2_d_e_fkey" on table "fktable2"
2023-08-01 17:01:40.230 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (d, e)=(4, 5) is still referenced from table "fktable2".
2023-08-01 17:01:40.230 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  delete from pktable2;
2023-08-01 17:01:40.230 +07 client backend[296512] pg_regress/foreign_key ERROR:  update or delete on table "pktable2" violates foreign key constraint "fktable2_d_e_fkey" on table "fktable2"
2023-08-01 17:01:40.230 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (d, e)=(4, 5) is still referenced from table "fktable2".
2023-08-01 17:01:40.230 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  update pktable2 set d = 5;
2023-08-01 17:01:40.237 +07 client backend[296523] pg_regress/foreign_data ERROR:  cannot drop foreign table ft2 because other objects depend on it
2023-08-01 17:01:40.237 +07 client backend[296523] pg_regress/foreign_data DETAIL:  table ct3 depends on foreign table ft2
	foreign table ft3 depends on foreign table ft2
2023-08-01 17:01:40.237 +07 client backend[296523] pg_regress/foreign_data HINT:  Use DROP ... CASCADE to drop the dependent objects too.
2023-08-01 17:01:40.237 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  DROP FOREIGN TABLE ft2;
2023-08-01 17:01:40.238 +07 client backend[296523] pg_regress/foreign_data ERROR:  child table is missing constraint "fd_pt1chk2"
2023-08-01 17:01:40.238 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  ALTER FOREIGN TABLE ft2 INHERIT fd_pt1;
2023-08-01 17:01:40.239 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fktable2" violates foreign key constraint "fktable2_f1_fkey"
2023-08-01 17:01:40.239 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (f1)=(2) is not present in table "pktable2".
2023-08-01 17:01:40.239 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  commit;
2023-08-01 17:01:40.240 +07 client backend[296512] pg_regress/foreign_key ERROR:  cannot ALTER TABLE "fktable2" because it has pending trigger events
2023-08-01 17:01:40.240 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  alter table fktable2 drop constraint fktable2_f1_fkey;
2023-08-01 17:01:40.240 +07 client backend[296512] pg_regress/foreign_key ERROR:  cannot ALTER TABLE "pktable2" because it has pending trigger events
2023-08-01 17:01:40.240 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  alter table fktable2 drop constraint fktable2_f1_fkey;
2023-08-01 17:01:40.253 +07 client backend[296512] pg_regress/foreign_key ERROR:  cannot use ONLY for foreign key on partitioned table "fk_partitioned_fk" referencing relation "fk_notpartitioned_pk"
2023-08-01 17:01:40.253 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  ALTER TABLE ONLY fk_partitioned_fk ADD FOREIGN KEY (a, b)
	  REFERENCES fk_notpartitioned_pk;
2023-08-01 17:01:40.253 +07 client backend[296512] pg_regress/foreign_key ERROR:  cannot add NOT VALID foreign key on partitioned table "fk_partitioned_fk" referencing relation "fk_notpartitioned_pk"
2023-08-01 17:01:40.253 +07 client backend[296512] pg_regress/foreign_key DETAIL:  This feature is not yet supported on partitioned tables.
2023-08-01 17:01:40.253 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  ALTER TABLE fk_partitioned_fk ADD FOREIGN KEY (a, b)
	  REFERENCES fk_notpartitioned_pk NOT VALID;
2023-08-01 17:01:40.253 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fk_partitioned_fk_1" violates foreign key constraint "fk_partitioned_fk_a_b_fkey"
2023-08-01 17:01:40.253 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (a, b)=(500, 501) is not present in table "fk_notpartitioned_pk".
2023-08-01 17:01:40.253 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  INSERT INTO fk_partitioned_fk (a,b) VALUES (500, 501);
2023-08-01 17:01:40.253 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fk_partitioned_fk_1" violates foreign key constraint "fk_partitioned_fk_a_b_fkey"
2023-08-01 17:01:40.253 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (a, b)=(500, 501) is not present in table "fk_notpartitioned_pk".
2023-08-01 17:01:40.253 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  INSERT INTO fk_partitioned_fk_1 (a,b) VALUES (500, 501);
2023-08-01 17:01:40.253 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fk_partitioned_fk_2" violates foreign key constraint "fk_partitioned_fk_a_b_fkey"
2023-08-01 17:01:40.253 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (a, b)=(1500, 1501) is not present in table "fk_notpartitioned_pk".
2023-08-01 17:01:40.253 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  INSERT INTO fk_partitioned_fk (a,b) VALUES (1500, 1501);
2023-08-01 17:01:40.254 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fk_partitioned_fk_2" violates foreign key constraint "fk_partitioned_fk_a_b_fkey"
2023-08-01 17:01:40.254 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (a, b)=(1500, 1501) is not present in table "fk_notpartitioned_pk".
2023-08-01 17:01:40.254 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  INSERT INTO fk_partitioned_fk_2 (a,b) VALUES (1500, 1501);
2023-08-01 17:01:40.254 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fk_partitioned_fk_3_1" violates foreign key constraint "fk_partitioned_fk_a_b_fkey"
2023-08-01 17:01:40.254 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (a, b)=(2500, 2502) is not present in table "fk_notpartitioned_pk".
2023-08-01 17:01:40.254 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  INSERT INTO fk_partitioned_fk (a,b) VALUES (2500, 2502);
2023-08-01 17:01:40.254 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fk_partitioned_fk_3_1" violates foreign key constraint "fk_partitioned_fk_a_b_fkey"
2023-08-01 17:01:40.254 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (a, b)=(2500, 2502) is not present in table "fk_notpartitioned_pk".
2023-08-01 17:01:40.254 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  INSERT INTO fk_partitioned_fk_3 (a,b) VALUES (2500, 2502);
2023-08-01 17:01:40.254 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fk_partitioned_fk_3_0" violates foreign key constraint "fk_partitioned_fk_a_b_fkey"
2023-08-01 17:01:40.254 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (a, b)=(2501, 2503) is not present in table "fk_notpartitioned_pk".
2023-08-01 17:01:40.254 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  INSERT INTO fk_partitioned_fk (a,b) VALUES (2501, 2503);
2023-08-01 17:01:40.254 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fk_partitioned_fk_3_0" violates foreign key constraint "fk_partitioned_fk_a_b_fkey"
2023-08-01 17:01:40.254 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (a, b)=(2501, 2503) is not present in table "fk_notpartitioned_pk".
2023-08-01 17:01:40.254 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  INSERT INTO fk_partitioned_fk_3 (a,b) VALUES (2501, 2503);
2023-08-01 17:01:40.256 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fk_partitioned_fk_3_1" violates foreign key constraint "fk_partitioned_fk_a_b_fkey"
2023-08-01 17:01:40.256 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (a, b)=(2502, 2503) is not present in table "fk_notpartitioned_pk".
2023-08-01 17:01:40.256 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  UPDATE fk_partitioned_fk SET a = a + 1 WHERE a = 2501;
2023-08-01 17:01:40.256 +07 client backend[296512] pg_regress/foreign_key ERROR:  update or delete on table "fk_notpartitioned_pk" violates foreign key constraint "fk_partitioned_fk_a_b_fkey" on table "fk_partitioned_fk"
2023-08-01 17:01:40.256 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (a, b)=(500, 501) is still referenced from table "fk_partitioned_fk".
2023-08-01 17:01:40.256 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  UPDATE fk_notpartitioned_pk SET b = 502 WHERE a = 500;
2023-08-01 17:01:40.256 +07 client backend[296512] pg_regress/foreign_key ERROR:  update or delete on table "fk_notpartitioned_pk" violates foreign key constraint "fk_partitioned_fk_a_b_fkey" on table "fk_partitioned_fk"
2023-08-01 17:01:40.256 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (a, b)=(1500, 1501) is still referenced from table "fk_partitioned_fk".
2023-08-01 17:01:40.256 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  UPDATE fk_notpartitioned_pk SET b = 1502 WHERE a = 1500;
2023-08-01 17:01:40.257 +07 client backend[296512] pg_regress/foreign_key ERROR:  update or delete on table "fk_notpartitioned_pk" violates foreign key constraint "fk_partitioned_fk_a_b_fkey" on table "fk_partitioned_fk"
2023-08-01 17:01:40.257 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (a, b)=(2500, 2502) is still referenced from table "fk_partitioned_fk".
2023-08-01 17:01:40.257 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  UPDATE fk_notpartitioned_pk SET b = 2504 WHERE a = 2500;
2023-08-01 17:01:40.259 +07 client backend[296523] pg_regress/foreign_data ERROR:  "ft2" is not a table
2023-08-01 17:01:40.259 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  TRUNCATE ft2;
2023-08-01 17:01:40.259 +07 client backend[296523] pg_regress/foreign_data ERROR:  "ft2" is not a table
2023-08-01 17:01:40.259 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  TRUNCATE fd_pt1;
2023-08-01 17:01:40.260 +07 client backend[296523] pg_regress/foreign_data ERROR:  foreign-data wrapper "foo" has no handler
2023-08-01 17:01:40.260 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  IMPORT FOREIGN SCHEMA s1 FROM SERVER s9 INTO public;
2023-08-01 17:01:40.260 +07 client backend[296523] pg_regress/foreign_data ERROR:  foreign-data wrapper "foo" has no handler
2023-08-01 17:01:40.260 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  IMPORT FOREIGN SCHEMA s1 LIMIT TO (t1) FROM SERVER s9 INTO public;
2023-08-01 17:01:40.260 +07 client backend[296523] pg_regress/foreign_data ERROR:  foreign-data wrapper "foo" has no handler
2023-08-01 17:01:40.260 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  IMPORT FOREIGN SCHEMA s1 EXCEPT (t1) FROM SERVER s9 INTO public;
2023-08-01 17:01:40.260 +07 client backend[296523] pg_regress/foreign_data ERROR:  foreign-data wrapper "foo" has no handler
2023-08-01 17:01:40.260 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  IMPORT FOREIGN SCHEMA s1 EXCEPT (t1, t2) FROM SERVER s9 INTO public
	OPTIONS (option1 'value1', option2 'value2');
2023-08-01 17:01:40.260 +07 client backend[296523] pg_regress/foreign_data ERROR:  foreign table "no_table" does not exist
2023-08-01 17:01:40.260 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  DROP FOREIGN TABLE no_table;
2023-08-01 17:01:40.261 +07 client backend[296523] pg_regress/foreign_data ERROR:  cannot drop desired object(s) because other objects depend on them
2023-08-01 17:01:40.261 +07 client backend[296523] pg_regress/foreign_data DETAIL:  user mapping for regress_test_role on server s5 depends on server s5
2023-08-01 17:01:40.261 +07 client backend[296523] pg_regress/foreign_data HINT:  Use DROP ... CASCADE to drop the dependent objects too.
2023-08-01 17:01:40.261 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  DROP OWNED BY regress_test_role2;
2023-08-01 17:01:40.270 +07 client backend[296523] pg_regress/foreign_data ERROR:  table "fd_pt2_1" contains column "c4" not found in parent "fd_pt2"
2023-08-01 17:01:40.270 +07 client backend[296523] pg_regress/foreign_data DETAIL:  The new partition may contain only the columns present in parent.
2023-08-01 17:01:40.270 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  ALTER TABLE fd_pt2 ATTACH PARTITION fd_pt2_1 FOR VALUES IN (1);
2023-08-01 17:01:40.272 +07 client backend[296512] pg_regress/foreign_key ERROR:  update or delete on table "fk_notpartitioned_pk" violates foreign key constraint "fk_partitioned_fk_a_fkey" on table "fk_partitioned_fk"
2023-08-01 17:01:40.272 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (a)=(1) is still referenced from table "fk_partitioned_fk".
2023-08-01 17:01:40.272 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  DELETE FROM fk_notpartitioned_pk WHERE a = 1;
2023-08-01 17:01:40.279 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fk_partitioned_fk_3" violates foreign key constraint "fk_partitioned_fk_a_b_fkey"
2023-08-01 17:01:40.279 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (a, b)=(2502, 2503) is not present in table "fk_notpartitioned_pk".
2023-08-01 17:01:40.279 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  INSERT INTO fk_partitioned_fk (a, b) VALUES (2502, 2503);
2023-08-01 17:01:40.279 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fk_partitioned_fk_3" violates foreign key constraint "fk_partitioned_fk_a_b_fkey"
2023-08-01 17:01:40.279 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (a, b)=(2502, 2503) is not present in table "fk_notpartitioned_pk".
2023-08-01 17:01:40.279 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  INSERT INTO fk_partitioned_fk_3 (a, b) VALUES (2502, 2503);
2023-08-01 17:01:40.281 +07 client backend[296523] pg_regress/foreign_data ERROR:  cannot add column to a partition
2023-08-01 17:01:40.281 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  ALTER TABLE fd_pt2_1 ADD c4 char;
2023-08-01 17:01:40.281 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fk_partitioned_fk_full_1" violates foreign key constraint "fk_partitioned_fk_full_x_y_fkey"
2023-08-01 17:01:40.281 +07 client backend[296512] pg_regress/foreign_key DETAIL:  MATCH FULL does not allow mixing of null and nonnull key values.
2023-08-01 17:01:40.281 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  ALTER TABLE fk_partitioned_fk_full ADD FOREIGN KEY (x, y) REFERENCES fk_notpartitioned_pk MATCH FULL;
2023-08-01 17:01:40.283 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fk_partitioned_fk_full_1" violates foreign key constraint "fk_partitioned_fk_full_x_y_fkey"
2023-08-01 17:01:40.283 +07 client backend[296512] pg_regress/foreign_key DETAIL:  MATCH FULL does not allow mixing of null and nonnull key values.
2023-08-01 17:01:40.283 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  INSERT INTO fk_partitioned_fk_full VALUES (1, NULL);
2023-08-01 17:01:40.287 +07 client backend[296523] pg_regress/foreign_data ERROR:  column "c1" is marked NOT NULL in parent table
2023-08-01 17:01:40.287 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  ALTER TABLE fd_pt2_1 ALTER c1 DROP NOT NULL;
2023-08-01 17:01:40.288 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fk_partitioned_fk_3" violates foreign key constraint "fk_partitioned_fk_a_b_fkey"
2023-08-01 17:01:40.288 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (a, b)=(2501, 142857) is not present in table "fk_notpartitioned_pk".
2023-08-01 17:01:40.288 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  UPDATE fk_notpartitioned_pk SET a = 1500 WHERE a = 2502;
2023-08-01 17:01:40.292 +07 client backend[296523] pg_regress/foreign_data ERROR:  column "c2" in child table must be marked NOT NULL
2023-08-01 17:01:40.292 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  ALTER TABLE fd_pt2 ATTACH PARTITION fd_pt2_1 FOR VALUES IN (1);
2023-08-01 17:01:40.298 +07 client backend[296523] pg_regress/foreign_data ERROR:  child table is missing constraint "fd_pt2chk1"
2023-08-01 17:01:40.298 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  ALTER TABLE fd_pt2 ATTACH PARTITION fd_pt2_1 FOR VALUES IN (1);
2023-08-01 17:01:40.299 +07 client backend[296523] pg_regress/foreign_data ERROR:  "fd_pt2_1" is not a table
2023-08-01 17:01:40.299 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  TRUNCATE fd_pt2_1;
2023-08-01 17:01:40.299 +07 client backend[296523] pg_regress/foreign_data ERROR:  "fd_pt2_1" is not a table
2023-08-01 17:01:40.299 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  TRUNCATE fd_pt2;
2023-08-01 17:01:40.300 +07 client backend[296523] pg_regress/foreign_data ERROR:  cannot create a permanent relation as partition of temporary relation "temp_parted"
2023-08-01 17:01:40.300 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  CREATE FOREIGN TABLE foreign_part PARTITION OF temp_parted DEFAULT
	  SERVER s0;
2023-08-01 17:01:40.300 +07 client backend[296523] pg_regress/foreign_data ERROR:  cannot attach a permanent relation as partition of temporary relation "temp_parted"
2023-08-01 17:01:40.300 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  ALTER TABLE temp_parted ATTACH PARTITION foreign_part DEFAULT;
2023-08-01 17:01:40.301 +07 client backend[296523] pg_regress/foreign_data ERROR:  role "regress_test_role" cannot be dropped because some objects depend on it
2023-08-01 17:01:40.301 +07 client backend[296523] pg_regress/foreign_data DETAIL:  privileges for foreign-data wrapper foo
	privileges for server s4
	owner of user mapping for regress_test_role on server s6
2023-08-01 17:01:40.301 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  DROP ROLE regress_test_role;
2023-08-01 17:01:40.302 +07 client backend[296523] pg_regress/foreign_data ERROR:  role "regress_unprivileged_role" cannot be dropped because some objects depend on it
2023-08-01 17:01:40.302 +07 client backend[296523] pg_regress/foreign_data DETAIL:  privileges for foreign-data wrapper postgresql
2023-08-01 17:01:40.302 +07 client backend[296523] pg_regress/foreign_data STATEMENT:  DROP ROLE regress_unprivileged_role;
2023-08-01 17:01:40.340 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fk_partitioned_fk_2_1" violates foreign key constraint "fk_partitioned_fk_a_b_fkey"
2023-08-01 17:01:40.340 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (a, b)=(1600, 601) is not present in table "fk_notpartitioned_pk".
2023-08-01 17:01:40.340 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  ALTER TABLE fk_partitioned_fk ATTACH PARTITION fk_partitioned_fk_2
	  FOR VALUES IN (1600);
2023-08-01 17:01:40.344 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "other_partitioned_fk_1" violates foreign key constraint "other_partitioned_fk_a_b_fkey"
2023-08-01 17:01:40.344 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (a, b)=(2048, 1) is not present in table "fk_notpartitioned_pk".
2023-08-01 17:01:40.344 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  alter table other_partitioned_fk add foreign key (a, b)
	  references fk_notpartitioned_pk(a, b);
2023-08-01 17:01:40.354 +07 client backend[296512] pg_regress/foreign_key ERROR:  cannot drop inherited constraint "fk_part_1_a_fkey" of relation "fk_part_1"
2023-08-01 17:01:40.354 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  alter table fkpart0.fk_part_1 drop constraint fk_part_1_a_fkey;
2023-08-01 17:01:40.362 +07 client backend[296512] pg_regress/foreign_key ERROR:  cannot drop inherited constraint "fk_part_23_a_fkey" of relation "fk_part_23"
2023-08-01 17:01:40.362 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  alter table fkpart0.fk_part_23 drop constraint fk_part_23_a_fkey;
2023-08-01 17:01:40.362 +07 client backend[296512] pg_regress/foreign_key ERROR:  cannot drop inherited constraint "fk_part_23_a_fkey" of relation "fk_part_23_2"
2023-08-01 17:01:40.362 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  alter table fkpart0.fk_part_23_2 drop constraint fk_part_23_a_fkey;
2023-08-01 17:01:40.367 +07 client backend[296512] pg_regress/foreign_key ERROR:  cannot drop inherited constraint "fk_part_a_fkey" of relation "fk_part_4"
2023-08-01 17:01:40.367 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  alter table fkpart0.fk_part_4 drop constraint fk_part_a_fkey;
2023-08-01 17:01:40.372 +07 client backend[296512] pg_regress/foreign_key ERROR:  cannot drop inherited constraint "fk_part_a_fkey" of relation "fk_part_56"
2023-08-01 17:01:40.372 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  alter table fkpart0.fk_part_56 drop constraint fk_part_a_fkey;
2023-08-01 17:01:40.372 +07 client backend[296512] pg_regress/foreign_key ERROR:  cannot drop inherited constraint "fk_part_a_fkey" of relation "fk_part_56_5"
2023-08-01 17:01:40.372 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  alter table fkpart0.fk_part_56_5 drop constraint fk_part_a_fkey;
2023-08-01 17:01:40.375 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fk_part_1_1" violates foreign key constraint "fk_part_a_fkey"
2023-08-01 17:01:40.375 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (a)=(1) is not present in table "pkey".
2023-08-01 17:01:40.375 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  insert into fkpart1.fk_part values (1);
2023-08-01 17:01:40.375 +07 client backend[296512] pg_regress/foreign_key ERROR:  update or delete on table "pkey" violates foreign key constraint "fk_part_a_fkey" on table "fk_part"
2023-08-01 17:01:40.375 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (a)=(1) is still referenced from table "fk_part".
2023-08-01 17:01:40.375 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  delete from fkpart1.pkey where a = 1;
2023-08-01 17:01:40.376 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fk_part_1_2" violates foreign key constraint "fk_part_a_fkey"
2023-08-01 17:01:40.376 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (a)=(2) is not present in table "pkey".
2023-08-01 17:01:40.376 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  insert into fkpart1.fk_part_1 values (2);
2023-08-01 17:01:40.377 +07 client backend[296512] pg_regress/foreign_key ERROR:  update or delete on table "pkey" violates foreign key constraint "fk_part_a_fkey" on table "fk_part_1"
2023-08-01 17:01:40.377 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (a)=(1) is still referenced from table "fk_part_1".
2023-08-01 17:01:40.377 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  delete from fkpart1.pkey where a = 1;
2023-08-01 17:01:40.380 +07 client backend[296512] pg_regress/foreign_key ERROR:  cannot drop inherited constraint "fkey" of relation "fk_part_1"
2023-08-01 17:01:40.380 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  alter table fkpart2.fk_part_1 drop constraint fkey;
2023-08-01 17:01:40.380 +07 client backend[296512] pg_regress/foreign_key ERROR:  cannot drop inherited constraint "my_fkey" of relation "fk_part_1_1"
2023-08-01 17:01:40.380 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  alter table fkpart2.fk_part_1_1 drop constraint my_fkey;
2023-08-01 17:01:40.381 +07 client backend[296512] pg_regress/foreign_key ERROR:  constraint "my_fkey" of relation "fk_part_1_1" does not exist
2023-08-01 17:01:40.381 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  alter table fkpart2.fk_part_1_1 drop constraint my_fkey;
2023-08-01 17:01:40.405 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fk1" violates foreign key constraint "fk_a_fkey"
2023-08-01 17:01:40.405 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (a)=(1) is not present in table "pk".
2023-08-01 17:01:40.405 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  INSERT into fk VALUES (1);
2023-08-01 17:01:40.406 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fk2" violates foreign key constraint "fk_a_fkey"
2023-08-01 17:01:40.406 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (a)=(1000) is not present in table "pk".
2023-08-01 17:01:40.406 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  INSERT into fk VALUES (1000);
2023-08-01 17:01:40.406 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fk2" violates foreign key constraint "fk_a_fkey"
2023-08-01 17:01:40.406 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (a)=(2000) is not present in table "pk".
2023-08-01 17:01:40.406 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  INSERT into fk VALUES (2000);
2023-08-01 17:01:40.406 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fk2" violates foreign key constraint "fk_a_fkey"
2023-08-01 17:01:40.406 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (a)=(3000) is not present in table "pk".
2023-08-01 17:01:40.406 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  INSERT into fk VALUES (3000);
2023-08-01 17:01:40.406 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fk3" violates foreign key constraint "fk_a_fkey"
2023-08-01 17:01:40.406 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (a)=(4000) is not present in table "pk".
2023-08-01 17:01:40.406 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  INSERT into fk VALUES (4000);
2023-08-01 17:01:40.407 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fk3" violates foreign key constraint "fk_a_fkey"
2023-08-01 17:01:40.407 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (a)=(4500) is not present in table "pk".
2023-08-01 17:01:40.407 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  INSERT into fk VALUES (4500);
2023-08-01 17:01:40.408 +07 client backend[296512] pg_regress/foreign_key ERROR:  update or delete on table "pk1" violates foreign key constraint "fk_a_fkey1" on table "fk"
2023-08-01 17:01:40.408 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (a)=(1) is still referenced from table "fk".
2023-08-01 17:01:40.408 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  DELETE FROM pk WHERE a = 1;
2023-08-01 17:01:40.408 +07 client backend[296512] pg_regress/foreign_key ERROR:  update or delete on table "pk2" violates foreign key constraint "fk_a_fkey2" on table "fk"
2023-08-01 17:01:40.408 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (a)=(1000) is still referenced from table "fk".
2023-08-01 17:01:40.408 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  DELETE FROM pk WHERE a = 1000;
2023-08-01 17:01:40.409 +07 client backend[296512] pg_regress/foreign_key ERROR:  update or delete on table "pk3" violates foreign key constraint "fk_a_fkey3" on table "fk"
2023-08-01 17:01:40.409 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (a)=(2000) is still referenced from table "fk".
2023-08-01 17:01:40.409 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  DELETE FROM pk WHERE a = 2000;
2023-08-01 17:01:40.409 +07 client backend[296512] pg_regress/foreign_key ERROR:  update or delete on table "pk4" violates foreign key constraint "fk_a_fkey4" on table "fk"
2023-08-01 17:01:40.409 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (a)=(3000) is still referenced from table "fk".
2023-08-01 17:01:40.409 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  DELETE FROM pk WHERE a = 3000;
2023-08-01 17:01:40.409 +07 client backend[296512] pg_regress/foreign_key ERROR:  update or delete on table "pk51" violates foreign key constraint "fk_a_fkey6" on table "fk"
2023-08-01 17:01:40.409 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (a)=(4000) is still referenced from table "fk".
2023-08-01 17:01:40.409 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  DELETE FROM pk WHERE a = 4000;
2023-08-01 17:01:40.409 +07 client backend[296512] pg_regress/foreign_key ERROR:  update or delete on table "pk52" violates foreign key constraint "fk_a_fkey7" on table "fk"
2023-08-01 17:01:40.409 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (a)=(4500) is still referenced from table "fk".
2023-08-01 17:01:40.409 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  DELETE FROM pk WHERE a = 4500;
2023-08-01 17:01:40.410 +07 client backend[296512] pg_regress/foreign_key ERROR:  update or delete on table "pk1" violates foreign key constraint "fk_a_fkey1" on table "fk"
2023-08-01 17:01:40.410 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (a)=(1) is still referenced from table "fk".
2023-08-01 17:01:40.410 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  UPDATE pk SET a = 2 WHERE a = 1;
2023-08-01 17:01:40.410 +07 client backend[296512] pg_regress/foreign_key ERROR:  update or delete on table "pk2" violates foreign key constraint "fk_a_fkey2" on table "fk"
2023-08-01 17:01:40.410 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (a)=(1000) is still referenced from table "fk".
2023-08-01 17:01:40.410 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  UPDATE pk SET a = 1002 WHERE a = 1000;
2023-08-01 17:01:40.410 +07 client backend[296512] pg_regress/foreign_key ERROR:  update or delete on table "pk3" violates foreign key constraint "fk_a_fkey3" on table "fk"
2023-08-01 17:01:40.410 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (a)=(2000) is still referenced from table "fk".
2023-08-01 17:01:40.410 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  UPDATE pk SET a = 2002 WHERE a = 2000;
2023-08-01 17:01:40.410 +07 client backend[296512] pg_regress/foreign_key ERROR:  update or delete on table "pk4" violates foreign key constraint "fk_a_fkey4" on table "fk"
2023-08-01 17:01:40.410 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (a)=(3000) is still referenced from table "fk".
2023-08-01 17:01:40.410 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  UPDATE pk SET a = 3002 WHERE a = 3000;
2023-08-01 17:01:40.410 +07 client backend[296512] pg_regress/foreign_key ERROR:  update or delete on table "pk51" violates foreign key constraint "fk_a_fkey6" on table "fk"
2023-08-01 17:01:40.410 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (a)=(4000) is still referenced from table "fk".
2023-08-01 17:01:40.410 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  UPDATE pk SET a = 4002 WHERE a = 4000;
2023-08-01 17:01:40.411 +07 client backend[296512] pg_regress/foreign_key ERROR:  update or delete on table "pk52" violates foreign key constraint "fk_a_fkey7" on table "fk"
2023-08-01 17:01:40.411 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (a)=(4500) is still referenced from table "fk".
2023-08-01 17:01:40.411 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  UPDATE pk SET a = 4502 WHERE a = 4500;
2023-08-01 17:01:40.423 +07 client backend[296512] pg_regress/foreign_key ERROR:  removing partition "droppk_d" violates foreign key constraint "dropfk_a_fkey5"
2023-08-01 17:01:40.423 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (a)=(2000) is still referenced from table "dropfk".
2023-08-01 17:01:40.423 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  ALTER TABLE droppk DETACH PARTITION droppk_d;
2023-08-01 17:01:40.423 +07 client backend[296512] pg_regress/foreign_key ERROR:  removing partition "droppk2_d" violates foreign key constraint "dropfk_a_fkey4"
2023-08-01 17:01:40.423 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (a)=(1500) is still referenced from table "dropfk".
2023-08-01 17:01:40.423 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  ALTER TABLE droppk2 DETACH PARTITION droppk2_d;
2023-08-01 17:01:40.423 +07 client backend[296512] pg_regress/foreign_key ERROR:  removing partition "droppk1" violates foreign key constraint "dropfk_a_fkey1"
2023-08-01 17:01:40.423 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (a)=(1) is still referenced from table "dropfk".
2023-08-01 17:01:40.423 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  ALTER TABLE droppk DETACH PARTITION droppk1;
2023-08-01 17:01:40.424 +07 client backend[296512] pg_regress/foreign_key ERROR:  removing partition "droppk2" violates foreign key constraint "dropfk_a_fkey2"
2023-08-01 17:01:40.424 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (a)=(1000) is still referenced from table "dropfk".
2023-08-01 17:01:40.424 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  ALTER TABLE droppk DETACH PARTITION droppk2;
2023-08-01 17:01:40.424 +07 client backend[296512] pg_regress/foreign_key ERROR:  removing partition "droppk21" violates foreign key constraint "dropfk_a_fkey3"
2023-08-01 17:01:40.424 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (a)=(1000) is still referenced from table "dropfk".
2023-08-01 17:01:40.424 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  ALTER TABLE droppk2 DETACH PARTITION droppk21;
2023-08-01 17:01:40.424 +07 client backend[296512] pg_regress/foreign_key ERROR:  cannot drop table droppk_d because other objects depend on it
2023-08-01 17:01:40.424 +07 client backend[296512] pg_regress/foreign_key DETAIL:  constraint dropfk_a_fkey on table dropfk depends on table droppk_d
2023-08-01 17:01:40.424 +07 client backend[296512] pg_regress/foreign_key HINT:  Use DROP ... CASCADE to drop the dependent objects too.
2023-08-01 17:01:40.424 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  DROP TABLE droppk_d;
2023-08-01 17:01:40.424 +07 client backend[296512] pg_regress/foreign_key ERROR:  cannot drop table droppk2_d because other objects depend on it
2023-08-01 17:01:40.424 +07 client backend[296512] pg_regress/foreign_key DETAIL:  constraint dropfk_a_fkey on table dropfk depends on table droppk2_d
2023-08-01 17:01:40.424 +07 client backend[296512] pg_regress/foreign_key HINT:  Use DROP ... CASCADE to drop the dependent objects too.
2023-08-01 17:01:40.424 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  DROP TABLE droppk2_d;
2023-08-01 17:01:40.425 +07 client backend[296512] pg_regress/foreign_key ERROR:  cannot drop table droppk1 because other objects depend on it
2023-08-01 17:01:40.425 +07 client backend[296512] pg_regress/foreign_key DETAIL:  constraint dropfk_a_fkey on table dropfk depends on table droppk1
2023-08-01 17:01:40.425 +07 client backend[296512] pg_regress/foreign_key HINT:  Use DROP ... CASCADE to drop the dependent objects too.
2023-08-01 17:01:40.425 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  DROP TABLE droppk1;
2023-08-01 17:01:40.425 +07 client backend[296512] pg_regress/foreign_key ERROR:  cannot drop table droppk2 because other objects depend on it
2023-08-01 17:01:40.425 +07 client backend[296512] pg_regress/foreign_key DETAIL:  constraint dropfk_a_fkey on table dropfk depends on table droppk2
2023-08-01 17:01:40.425 +07 client backend[296512] pg_regress/foreign_key HINT:  Use DROP ... CASCADE to drop the dependent objects too.
2023-08-01 17:01:40.425 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  DROP TABLE droppk2;
2023-08-01 17:01:40.425 +07 client backend[296512] pg_regress/foreign_key ERROR:  cannot drop table droppk21 because other objects depend on it
2023-08-01 17:01:40.425 +07 client backend[296512] pg_regress/foreign_key DETAIL:  constraint dropfk_a_fkey on table dropfk depends on table droppk21
2023-08-01 17:01:40.425 +07 client backend[296512] pg_regress/foreign_key HINT:  Use DROP ... CASCADE to drop the dependent objects too.
2023-08-01 17:01:40.425 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  DROP TABLE droppk21;
2023-08-01 17:01:40.426 +07 client backend[296512] pg_regress/foreign_key ERROR:  cannot drop table droppk_d because other objects depend on it
2023-08-01 17:01:40.426 +07 client backend[296512] pg_regress/foreign_key DETAIL:  constraint dropfk_a_fkey on table dropfk depends on table droppk_d
2023-08-01 17:01:40.426 +07 client backend[296512] pg_regress/foreign_key HINT:  Use DROP ... CASCADE to drop the dependent objects too.
2023-08-01 17:01:40.426 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  DROP TABLE droppk_d;
2023-08-01 17:01:40.426 +07 client backend[296512] pg_regress/foreign_key ERROR:  cannot drop table droppk2_d because other objects depend on it
2023-08-01 17:01:40.426 +07 client backend[296512] pg_regress/foreign_key DETAIL:  constraint dropfk_a_fkey on table dropfk depends on table droppk2_d
2023-08-01 17:01:40.426 +07 client backend[296512] pg_regress/foreign_key HINT:  Use DROP ... CASCADE to drop the dependent objects too.
2023-08-01 17:01:40.426 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  DROP TABLE droppk2_d;
2023-08-01 17:01:40.426 +07 client backend[296512] pg_regress/foreign_key ERROR:  cannot drop table droppk1 because other objects depend on it
2023-08-01 17:01:40.426 +07 client backend[296512] pg_regress/foreign_key DETAIL:  constraint dropfk_a_fkey on table dropfk depends on table droppk1
2023-08-01 17:01:40.426 +07 client backend[296512] pg_regress/foreign_key HINT:  Use DROP ... CASCADE to drop the dependent objects too.
2023-08-01 17:01:40.426 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  DROP TABLE droppk1;
2023-08-01 17:01:40.427 +07 client backend[296512] pg_regress/foreign_key ERROR:  cannot drop table droppk2 because other objects depend on it
2023-08-01 17:01:40.427 +07 client backend[296512] pg_regress/foreign_key DETAIL:  constraint dropfk_a_fkey on table dropfk depends on table droppk2
2023-08-01 17:01:40.427 +07 client backend[296512] pg_regress/foreign_key HINT:  Use DROP ... CASCADE to drop the dependent objects too.
2023-08-01 17:01:40.427 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  DROP TABLE droppk2;
2023-08-01 17:01:40.442 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fk4" violates foreign key constraint "fk_a_fkey"
2023-08-01 17:01:40.442 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (a)=(50) is not present in table "pk".
2023-08-01 17:01:40.442 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  ALTER TABLE fk ATTACH PARTITION fk4 FOR VALUES IN (50);
2023-08-01 17:01:40.446 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fk" violates foreign key constraint "fk_a_fkey"
2023-08-01 17:01:40.446 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (a)=(1) is not present in table "pk".
2023-08-01 17:01:40.446 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  INSERT INTO fk VALUES (1);
2023-08-01 17:01:40.447 +07 client backend[296512] pg_regress/foreign_key ERROR:  insert or update on table "fk" violates foreign key constraint "fk_a_fkey"
2023-08-01 17:01:40.447 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (a)=(1) is not present in table "pk".
2023-08-01 17:01:40.447 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  COMMIT;
2023-08-01 17:01:40.482 +07 client backend[296512] pg_regress/foreign_key ERROR:  update or delete on table "pk11" violates foreign key constraint "fk_a_fkey2" on table "fk"
2023-08-01 17:01:40.482 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (a)=(20) is still referenced from table "fk".
2023-08-01 17:01:40.482 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  DELETE FROM pk WHERE a = 20;
2023-08-01 17:01:40.482 +07 client backend[296512] pg_regress/foreign_key ERROR:  update or delete on table "pk11" violates foreign key constraint "fk_a_fkey2" on table "fk"
2023-08-01 17:01:40.482 +07 client backend[296512] pg_regress/foreign_key DETAIL:  Key (a)=(30) is still referenced from table "fk".
2023-08-01 17:01:40.482 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  UPDATE pk SET a = 90 WHERE a = 30;
2023-08-01 17:01:40.488 +07 client backend[296512] pg_regress/foreign_key ERROR:  cannot ALTER TABLE "tbl2_p1" because it has pending trigger events
2023-08-01 17:01:40.488 +07 client backend[296512] pg_regress/foreign_key STATEMENT:  ALTER TABLE fkpart8.tbl2 DROP CONSTRAINT tbl2_f1_fkey;
2023-08-01 17:01:40.511 +07 client backend[296576] pg_regress/jsonpath ERROR:  invalid input syntax for type jsonpath: "" at character 8
2023-08-01 17:01:40.511 +07 client backend[296576] pg_regress/jsonpath STATEMENT:  select ''::jsonpath;
2023-08-01 17:01:40.511 +07 client backend[296573] pg_regress/json ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.511 +07 client backend[296573] pg_regress/json DETAIL:  Token "'" is invalid.
2023-08-01 17:01:40.511 +07 client backend[296573] pg_regress/json CONTEXT:  JSON data, line 1: '...
2023-08-01 17:01:40.511 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT $$''$$::json;
2023-08-01 17:01:40.512 +07 client backend[296574] pg_regress/jsonb ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.512 +07 client backend[296574] pg_regress/jsonb DETAIL:  Token "'" is invalid.
2023-08-01 17:01:40.512 +07 client backend[296574] pg_regress/jsonb CONTEXT:  JSON data, line 1: '...
2023-08-01 17:01:40.512 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT $$''$$::jsonb;
2023-08-01 17:01:40.512 +07 client backend[296573] pg_regress/json ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.512 +07 client backend[296573] pg_regress/json DETAIL:  Token ""abc" is invalid.
2023-08-01 17:01:40.512 +07 client backend[296573] pg_regress/json CONTEXT:  JSON data, line 1: "abc
2023-08-01 17:01:40.512 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT '"abc'::json;
2023-08-01 17:01:40.512 +07 client backend[296575] pg_regress/jsonpath_encoding ERROR:  invalid unicode sequence at or near "\u" of jsonpath input at character 8
2023-08-01 17:01:40.512 +07 client backend[296575] pg_regress/jsonpath_encoding STATEMENT:  SELECT '"\u"'::jsonpath;
2023-08-01 17:01:40.512 +07 client backend[296573] pg_regress/json ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.512 +07 client backend[296573] pg_regress/json DETAIL:  Character with value 0x0a must be escaped.
2023-08-01 17:01:40.512 +07 client backend[296573] pg_regress/json CONTEXT:  JSON data, line 1: "abc
2023-08-01 17:01:40.512 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT '"abc
	def"'::json;
2023-08-01 17:01:40.512 +07 client backend[296575] pg_regress/jsonpath_encoding ERROR:  invalid unicode sequence at or near "\u00" of jsonpath input at character 8
2023-08-01 17:01:40.512 +07 client backend[296575] pg_regress/jsonpath_encoding STATEMENT:  SELECT '"\u00"'::jsonpath;
2023-08-01 17:01:40.512 +07 client backend[296575] pg_regress/jsonpath_encoding ERROR:  invalid unicode sequence at or near "\u000" of jsonpath input at character 8
2023-08-01 17:01:40.512 +07 client backend[296575] pg_regress/jsonpath_encoding STATEMENT:  SELECT '"\u000g"'::jsonpath;
2023-08-01 17:01:40.512 +07 client backend[296574] pg_regress/jsonb ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.512 +07 client backend[296574] pg_regress/jsonb DETAIL:  Token ""abc" is invalid.
2023-08-01 17:01:40.512 +07 client backend[296574] pg_regress/jsonb CONTEXT:  JSON data, line 1: "abc
2023-08-01 17:01:40.512 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT '"abc'::jsonb;
2023-08-01 17:01:40.512 +07 client backend[296575] pg_regress/jsonpath_encoding ERROR:  unsupported Unicode escape sequence at character 8
2023-08-01 17:01:40.512 +07 client backend[296575] pg_regress/jsonpath_encoding DETAIL:  \u0000 cannot be converted to text.
2023-08-01 17:01:40.512 +07 client backend[296575] pg_regress/jsonpath_encoding STATEMENT:  SELECT '"\u0000"'::jsonpath;
2023-08-01 17:01:40.512 +07 client backend[296573] pg_regress/json ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.512 +07 client backend[296573] pg_regress/json DETAIL:  Escape sequence "\v" is invalid.
2023-08-01 17:01:40.512 +07 client backend[296573] pg_regress/json CONTEXT:  JSON data, line 1: "\v...
2023-08-01 17:01:40.512 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT '"\v"'::json;
2023-08-01 17:01:40.512 +07 client backend[296574] pg_regress/jsonb ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.512 +07 client backend[296574] pg_regress/jsonb DETAIL:  Character with value 0x0a must be escaped.
2023-08-01 17:01:40.512 +07 client backend[296574] pg_regress/jsonb CONTEXT:  JSON data, line 1: "abc
2023-08-01 17:01:40.512 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT '"abc
	def"'::jsonb;
2023-08-01 17:01:40.512 +07 client backend[296574] pg_regress/jsonb ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.512 +07 client backend[296574] pg_regress/jsonb DETAIL:  Escape sequence "\v" is invalid.
2023-08-01 17:01:40.512 +07 client backend[296574] pg_regress/jsonb CONTEXT:  JSON data, line 1: "\v...
2023-08-01 17:01:40.512 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT '"\v"'::jsonb;
2023-08-01 17:01:40.512 +07 client backend[296575] pg_regress/jsonpath_encoding ERROR:  invalid input syntax for type jsonpath at character 8
2023-08-01 17:01:40.512 +07 client backend[296575] pg_regress/jsonpath_encoding DETAIL:  Unicode high surrogate must not follow a high surrogate.
2023-08-01 17:01:40.512 +07 client backend[296575] pg_regress/jsonpath_encoding STATEMENT:  select '"\ud83d\ud83d"'::jsonpath;
2023-08-01 17:01:40.512 +07 client backend[296575] pg_regress/jsonpath_encoding ERROR:  invalid input syntax for type jsonpath at character 8
2023-08-01 17:01:40.512 +07 client backend[296575] pg_regress/jsonpath_encoding DETAIL:  Unicode low surrogate must follow a high surrogate.
2023-08-01 17:01:40.512 +07 client backend[296575] pg_regress/jsonpath_encoding STATEMENT:  select '"\ude04\ud83d"'::jsonpath;
2023-08-01 17:01:40.512 +07 client backend[296577] pg_regress/json_encoding ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.512 +07 client backend[296577] pg_regress/json_encoding DETAIL:  "\u" must be followed by four hexadecimal digits.
2023-08-01 17:01:40.512 +07 client backend[296577] pg_regress/json_encoding CONTEXT:  JSON data, line 1: "\u"
2023-08-01 17:01:40.512 +07 client backend[296577] pg_regress/json_encoding STATEMENT:  SELECT '"\u"'::json;
2023-08-01 17:01:40.512 +07 client backend[296573] pg_regress/json ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.512 +07 client backend[296573] pg_regress/json DETAIL:  Token "01" is invalid.
2023-08-01 17:01:40.512 +07 client backend[296573] pg_regress/json CONTEXT:  JSON data, line 1: 01
2023-08-01 17:01:40.512 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT '01'::json;
2023-08-01 17:01:40.512 +07 client backend[296575] pg_regress/jsonpath_encoding ERROR:  invalid input syntax for type jsonpath at character 8
2023-08-01 17:01:40.512 +07 client backend[296575] pg_regress/jsonpath_encoding DETAIL:  Unicode low surrogate must follow a high surrogate.
2023-08-01 17:01:40.512 +07 client backend[296575] pg_regress/jsonpath_encoding STATEMENT:  select '"\ud83dX"'::jsonpath;
2023-08-01 17:01:40.512 +07 client backend[296577] pg_regress/json_encoding ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.512 +07 client backend[296577] pg_regress/json_encoding DETAIL:  "\u" must be followed by four hexadecimal digits.
2023-08-01 17:01:40.512 +07 client backend[296577] pg_regress/json_encoding CONTEXT:  JSON data, line 1: "\u00"
2023-08-01 17:01:40.512 +07 client backend[296577] pg_regress/json_encoding STATEMENT:  SELECT '"\u00"'::json;
2023-08-01 17:01:40.512 +07 client backend[296575] pg_regress/jsonpath_encoding ERROR:  invalid input syntax for type jsonpath at character 8
2023-08-01 17:01:40.512 +07 client backend[296575] pg_regress/jsonpath_encoding DETAIL:  Unicode low surrogate must follow a high surrogate.
2023-08-01 17:01:40.512 +07 client backend[296575] pg_regress/jsonpath_encoding STATEMENT:  select '"\ude04X"'::jsonpath;
2023-08-01 17:01:40.512 +07 client backend[296574] pg_regress/jsonb ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.512 +07 client backend[296574] pg_regress/jsonb DETAIL:  Token "01" is invalid.
2023-08-01 17:01:40.512 +07 client backend[296574] pg_regress/jsonb CONTEXT:  JSON data, line 1: 01
2023-08-01 17:01:40.512 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT '01'::jsonb;
2023-08-01 17:01:40.512 +07 client backend[296577] pg_regress/json_encoding ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.512 +07 client backend[296577] pg_regress/json_encoding DETAIL:  "\u" must be followed by four hexadecimal digits.
2023-08-01 17:01:40.512 +07 client backend[296577] pg_regress/json_encoding CONTEXT:  JSON data, line 1: "\u000g...
2023-08-01 17:01:40.512 +07 client backend[296577] pg_regress/json_encoding STATEMENT:  SELECT '"\u000g"'::json;
2023-08-01 17:01:40.512 +07 client backend[296575] pg_regress/jsonpath_encoding ERROR:  unsupported Unicode escape sequence at character 8
2023-08-01 17:01:40.512 +07 client backend[296575] pg_regress/jsonpath_encoding DETAIL:  \u0000 cannot be converted to text.
2023-08-01 17:01:40.512 +07 client backend[296575] pg_regress/jsonpath_encoding STATEMENT:  select '"null \u0000 escape"'::jsonpath as not_unescaped;
2023-08-01 17:01:40.512 +07 client backend[296573] pg_regress/json ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.512 +07 client backend[296573] pg_regress/json DETAIL:  Token "1f2" is invalid.
2023-08-01 17:01:40.512 +07 client backend[296573] pg_regress/json CONTEXT:  JSON data, line 1: 1f2
2023-08-01 17:01:40.512 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT '1f2'::json;
2023-08-01 17:01:40.513 +07 client backend[296573] pg_regress/json ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.513 +07 client backend[296573] pg_regress/json DETAIL:  Token "0.x1" is invalid.
2023-08-01 17:01:40.513 +07 client backend[296573] pg_regress/json CONTEXT:  JSON data, line 1: 0.x1
2023-08-01 17:01:40.513 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT '0.x1'::json;
2023-08-01 17:01:40.513 +07 client backend[296573] pg_regress/json ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.513 +07 client backend[296573] pg_regress/json DETAIL:  Token "1.3ex100" is invalid.
2023-08-01 17:01:40.513 +07 client backend[296573] pg_regress/json CONTEXT:  JSON data, line 1: 1.3ex100
2023-08-01 17:01:40.513 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT '1.3ex100'::json;
2023-08-01 17:01:40.513 +07 client backend[296575] pg_regress/jsonpath_encoding ERROR:  invalid unicode sequence at or near "\u" of jsonpath input at character 8
2023-08-01 17:01:40.513 +07 client backend[296575] pg_regress/jsonpath_encoding STATEMENT:  SELECT '$."\u"'::jsonpath;
2023-08-01 17:01:40.513 +07 client backend[296577] pg_regress/json_encoding ERROR:  invalid input syntax for type json
2023-08-01 17:01:40.513 +07 client backend[296577] pg_regress/json_encoding DETAIL:  Unicode high surrogate must not follow a high surrogate.
2023-08-01 17:01:40.513 +07 client backend[296577] pg_regress/json_encoding CONTEXT:  JSON data, line 1: { "a":...
2023-08-01 17:01:40.513 +07 client backend[296577] pg_regress/json_encoding STATEMENT:  select json '{ "a":  "\ud83d\ud83d" }' -> 'a';
2023-08-01 17:01:40.513 +07 client backend[296575] pg_regress/jsonpath_encoding ERROR:  invalid unicode sequence at or near "\u00" of jsonpath input at character 8
2023-08-01 17:01:40.513 +07 client backend[296575] pg_regress/jsonpath_encoding STATEMENT:  SELECT '$."\u00"'::jsonpath;
2023-08-01 17:01:40.513 +07 client backend[296577] pg_regress/json_encoding ERROR:  invalid input syntax for type json
2023-08-01 17:01:40.513 +07 client backend[296577] pg_regress/json_encoding DETAIL:  Unicode low surrogate must follow a high surrogate.
2023-08-01 17:01:40.513 +07 client backend[296577] pg_regress/json_encoding CONTEXT:  JSON data, line 1: { "a":...
2023-08-01 17:01:40.513 +07 client backend[296577] pg_regress/json_encoding STATEMENT:  select json '{ "a":  "\ude04\ud83d" }' -> 'a';
2023-08-01 17:01:40.513 +07 client backend[296574] pg_regress/jsonb ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.513 +07 client backend[296574] pg_regress/jsonb DETAIL:  Token "1f2" is invalid.
2023-08-01 17:01:40.513 +07 client backend[296574] pg_regress/jsonb CONTEXT:  JSON data, line 1: 1f2
2023-08-01 17:01:40.513 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT '1f2'::jsonb;
2023-08-01 17:01:40.513 +07 client backend[296575] pg_regress/jsonpath_encoding ERROR:  invalid unicode sequence at or near "\u000" of jsonpath input at character 8
2023-08-01 17:01:40.513 +07 client backend[296575] pg_regress/jsonpath_encoding STATEMENT:  SELECT '$."\u000g"'::jsonpath;
2023-08-01 17:01:40.513 +07 client backend[296577] pg_regress/json_encoding ERROR:  invalid input syntax for type json
2023-08-01 17:01:40.513 +07 client backend[296577] pg_regress/json_encoding DETAIL:  Unicode low surrogate must follow a high surrogate.
2023-08-01 17:01:40.513 +07 client backend[296577] pg_regress/json_encoding CONTEXT:  JSON data, line 1: { "a":...
2023-08-01 17:01:40.513 +07 client backend[296577] pg_regress/json_encoding STATEMENT:  select json '{ "a":  "\ud83dX" }' -> 'a';
2023-08-01 17:01:40.513 +07 client backend[296575] pg_regress/jsonpath_encoding ERROR:  unsupported Unicode escape sequence at character 8
2023-08-01 17:01:40.513 +07 client backend[296575] pg_regress/jsonpath_encoding DETAIL:  \u0000 cannot be converted to text.
2023-08-01 17:01:40.513 +07 client backend[296575] pg_regress/jsonpath_encoding STATEMENT:  SELECT '$."\u0000"'::jsonpath;
2023-08-01 17:01:40.513 +07 client backend[296574] pg_regress/jsonb ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.513 +07 client backend[296574] pg_regress/jsonb DETAIL:  Token "0.x1" is invalid.
2023-08-01 17:01:40.513 +07 client backend[296574] pg_regress/jsonb CONTEXT:  JSON data, line 1: 0.x1
2023-08-01 17:01:40.513 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT '0.x1'::jsonb;
2023-08-01 17:01:40.513 +07 client backend[296573] pg_regress/json ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.513 +07 client backend[296573] pg_regress/json DETAIL:  Expected JSON value, but found "]".
2023-08-01 17:01:40.513 +07 client backend[296573] pg_regress/json CONTEXT:  JSON data, line 1: [1,2,]
2023-08-01 17:01:40.513 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT '[1,2,]'::json;
2023-08-01 17:01:40.513 +07 client backend[296577] pg_regress/json_encoding ERROR:  invalid input syntax for type json
2023-08-01 17:01:40.513 +07 client backend[296577] pg_regress/json_encoding DETAIL:  Unicode low surrogate must follow a high surrogate.
2023-08-01 17:01:40.513 +07 client backend[296577] pg_regress/json_encoding CONTEXT:  JSON data, line 1: { "a":...
2023-08-01 17:01:40.513 +07 client backend[296577] pg_regress/json_encoding STATEMENT:  select json '{ "a":  "\ude04X" }' -> 'a';
2023-08-01 17:01:40.513 +07 client backend[296573] pg_regress/json ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.513 +07 client backend[296573] pg_regress/json DETAIL:  The input string ended unexpectedly.
2023-08-01 17:01:40.513 +07 client backend[296573] pg_regress/json CONTEXT:  JSON data, line 1: [1,2
2023-08-01 17:01:40.513 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT '[1,2'::json;
2023-08-01 17:01:40.513 +07 client backend[296574] pg_regress/jsonb ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.513 +07 client backend[296574] pg_regress/jsonb DETAIL:  Token "1.3ex100" is invalid.
2023-08-01 17:01:40.513 +07 client backend[296574] pg_regress/jsonb CONTEXT:  JSON data, line 1: 1.3ex100
2023-08-01 17:01:40.513 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT '1.3ex100'::jsonb;
2023-08-01 17:01:40.513 +07 client backend[296573] pg_regress/json ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.513 +07 client backend[296573] pg_regress/json DETAIL:  The input string ended unexpectedly.
2023-08-01 17:01:40.513 +07 client backend[296573] pg_regress/json CONTEXT:  JSON data, line 1: [1,[2]
2023-08-01 17:01:40.513 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT '[1,[2]'::json;
2023-08-01 17:01:40.513 +07 client backend[296575] pg_regress/jsonpath_encoding ERROR:  invalid input syntax for type jsonpath at character 8
2023-08-01 17:01:40.513 +07 client backend[296575] pg_regress/jsonpath_encoding DETAIL:  Unicode high surrogate must not follow a high surrogate.
2023-08-01 17:01:40.513 +07 client backend[296575] pg_regress/jsonpath_encoding STATEMENT:  select '$."\ud83d\ud83d"'::jsonpath;
2023-08-01 17:01:40.513 +07 client backend[296575] pg_regress/jsonpath_encoding ERROR:  invalid input syntax for type jsonpath at character 8
2023-08-01 17:01:40.513 +07 client backend[296575] pg_regress/jsonpath_encoding DETAIL:  Unicode low surrogate must follow a high surrogate.
2023-08-01 17:01:40.513 +07 client backend[296575] pg_regress/jsonpath_encoding STATEMENT:  select '$."\ude04\ud83d"'::jsonpath;
2023-08-01 17:01:40.513 +07 client backend[296573] pg_regress/json ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.513 +07 client backend[296573] pg_regress/json DETAIL:  Expected ":", but found "}".
2023-08-01 17:01:40.513 +07 client backend[296573] pg_regress/json CONTEXT:  JSON data, line 1: {"abc"}
2023-08-01 17:01:40.513 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT '{"abc"}'::json;
2023-08-01 17:01:40.513 +07 client backend[296575] pg_regress/jsonpath_encoding ERROR:  invalid input syntax for type jsonpath at character 8
2023-08-01 17:01:40.513 +07 client backend[296575] pg_regress/jsonpath_encoding DETAIL:  Unicode low surrogate must follow a high surrogate.
2023-08-01 17:01:40.513 +07 client backend[296575] pg_regress/jsonpath_encoding STATEMENT:  select '$."\ud83dX"'::jsonpath;
2023-08-01 17:01:40.513 +07 client backend[296575] pg_regress/jsonpath_encoding ERROR:  invalid input syntax for type jsonpath at character 8
2023-08-01 17:01:40.513 +07 client backend[296575] pg_regress/jsonpath_encoding DETAIL:  Unicode low surrogate must follow a high surrogate.
2023-08-01 17:01:40.513 +07 client backend[296575] pg_regress/jsonpath_encoding STATEMENT:  select '$."\ude04X"'::jsonpath;
2023-08-01 17:01:40.513 +07 client backend[296574] pg_regress/jsonb ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.513 +07 client backend[296574] pg_regress/jsonb DETAIL:  Expected JSON value, but found "]".
2023-08-01 17:01:40.513 +07 client backend[296574] pg_regress/jsonb CONTEXT:  JSON data, line 1: [1,2,]
2023-08-01 17:01:40.513 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT '[1,2,]'::jsonb;
2023-08-01 17:01:40.513 +07 client backend[296573] pg_regress/json ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.513 +07 client backend[296573] pg_regress/json DETAIL:  Expected string or "}", but found "1".
2023-08-01 17:01:40.513 +07 client backend[296573] pg_regress/json CONTEXT:  JSON data, line 1: {1...
2023-08-01 17:01:40.513 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT '{1:"abc"}'::json;
2023-08-01 17:01:40.513 +07 client backend[296574] pg_regress/jsonb ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.513 +07 client backend[296574] pg_regress/jsonb DETAIL:  The input string ended unexpectedly.
2023-08-01 17:01:40.513 +07 client backend[296574] pg_regress/jsonb CONTEXT:  JSON data, line 1: [1,2
2023-08-01 17:01:40.513 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT '[1,2'::jsonb;
2023-08-01 17:01:40.513 +07 client backend[296573] pg_regress/json ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.513 +07 client backend[296573] pg_regress/json DETAIL:  Expected ":", but found ",".
2023-08-01 17:01:40.513 +07 client backend[296573] pg_regress/json CONTEXT:  JSON data, line 1: {"abc",...
2023-08-01 17:01:40.513 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT '{"abc",1}'::json;
2023-08-01 17:01:40.513 +07 client backend[296574] pg_regress/jsonb ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.513 +07 client backend[296574] pg_regress/jsonb DETAIL:  The input string ended unexpectedly.
2023-08-01 17:01:40.513 +07 client backend[296574] pg_regress/jsonb CONTEXT:  JSON data, line 1: [1,[2]
2023-08-01 17:01:40.513 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT '[1,[2]'::jsonb;
2023-08-01 17:01:40.513 +07 client backend[296573] pg_regress/json ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.513 +07 client backend[296573] pg_regress/json DETAIL:  Token "=" is invalid.
2023-08-01 17:01:40.513 +07 client backend[296573] pg_regress/json CONTEXT:  JSON data, line 1: {"abc"=...
2023-08-01 17:01:40.513 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT '{"abc"=1}'::json;
2023-08-01 17:01:40.513 +07 client backend[296573] pg_regress/json ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.513 +07 client backend[296573] pg_regress/json DETAIL:  Expected JSON value, but found ":".
2023-08-01 17:01:40.513 +07 client backend[296573] pg_regress/json CONTEXT:  JSON data, line 1: {"abc"::...
2023-08-01 17:01:40.513 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT '{"abc"::1}'::json;
2023-08-01 17:01:40.513 +07 client backend[296574] pg_regress/jsonb ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.513 +07 client backend[296574] pg_regress/jsonb DETAIL:  Expected ":", but found "}".
2023-08-01 17:01:40.513 +07 client backend[296574] pg_regress/jsonb CONTEXT:  JSON data, line 1: {"abc"}
2023-08-01 17:01:40.513 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT '{"abc"}'::jsonb;
2023-08-01 17:01:40.513 +07 client backend[296575] pg_regress/jsonpath_encoding ERROR:  unsupported Unicode escape sequence at character 8
2023-08-01 17:01:40.513 +07 client backend[296575] pg_regress/jsonpath_encoding DETAIL:  \u0000 cannot be converted to text.
2023-08-01 17:01:40.513 +07 client backend[296575] pg_regress/jsonpath_encoding STATEMENT:  select '$."null \u0000 escape"'::jsonpath as not_unescaped;
2023-08-01 17:01:40.513 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  jsonpath array subscript is out of bounds
2023-08-01 17:01:40.513 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('[1]', 'strict $[1]');
2023-08-01 17:01:40.514 +07 client backend[296573] pg_regress/json ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.514 +07 client backend[296573] pg_regress/json DETAIL:  Expected "," or "}", but found ":".
2023-08-01 17:01:40.514 +07 client backend[296573] pg_regress/json CONTEXT:  JSON data, line 1: {"abc":1:...
2023-08-01 17:01:40.514 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT '{"abc":1:2}'::json;
2023-08-01 17:01:40.514 +07 client backend[296574] pg_regress/jsonb ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.514 +07 client backend[296574] pg_regress/jsonb DETAIL:  Expected string or "}", but found "1".
2023-08-01 17:01:40.514 +07 client backend[296574] pg_regress/jsonb CONTEXT:  JSON data, line 1: {1...
2023-08-01 17:01:40.514 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT '{1:"abc"}'::jsonb;
2023-08-01 17:01:40.514 +07 client backend[296573] pg_regress/json ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.514 +07 client backend[296573] pg_regress/json DETAIL:  Expected string, but found "3".
2023-08-01 17:01:40.514 +07 client backend[296573] pg_regress/json CONTEXT:  JSON data, line 1: {"abc":1,3...
2023-08-01 17:01:40.514 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT '{"abc":1,3}'::json;
2023-08-01 17:01:40.514 +07 client backend[296574] pg_regress/jsonb ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.514 +07 client backend[296574] pg_regress/jsonb DETAIL:  Expected ":", but found ",".
2023-08-01 17:01:40.514 +07 client backend[296574] pg_regress/jsonb CONTEXT:  JSON data, line 1: {"abc",...
2023-08-01 17:01:40.514 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT '{"abc",1}'::jsonb;
2023-08-01 17:01:40.514 +07 client backend[296574] pg_regress/jsonb ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.514 +07 client backend[296574] pg_regress/jsonb DETAIL:  Token "=" is invalid.
2023-08-01 17:01:40.514 +07 client backend[296574] pg_regress/jsonb CONTEXT:  JSON data, line 1: {"abc"=...
2023-08-01 17:01:40.514 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT '{"abc"=1}'::jsonb;
2023-08-01 17:01:40.514 +07 client backend[296574] pg_regress/jsonb ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.514 +07 client backend[296574] pg_regress/jsonb DETAIL:  Expected JSON value, but found ":".
2023-08-01 17:01:40.514 +07 client backend[296574] pg_regress/jsonb CONTEXT:  JSON data, line 1: {"abc"::...
2023-08-01 17:01:40.514 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT '{"abc"::1}'::jsonb;
2023-08-01 17:01:40.514 +07 client backend[296577] pg_regress/json_encoding ERROR:  unsupported Unicode escape sequence
2023-08-01 17:01:40.514 +07 client backend[296577] pg_regress/json_encoding DETAIL:  \u0000 cannot be converted to text.
2023-08-01 17:01:40.514 +07 client backend[296577] pg_regress/json_encoding CONTEXT:  JSON data, line 1: { "a":...
2023-08-01 17:01:40.514 +07 client backend[296577] pg_regress/json_encoding STATEMENT:  select json '{ "a":  "null \u0000 escape" }' ->> 'a' as fails;
2023-08-01 17:01:40.514 +07 client backend[296574] pg_regress/jsonb ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.514 +07 client backend[296574] pg_regress/jsonb DETAIL:  Expected "," or "}", but found ":".
2023-08-01 17:01:40.514 +07 client backend[296574] pg_regress/jsonb CONTEXT:  JSON data, line 1: {"abc":1:...
2023-08-01 17:01:40.514 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT '{"abc":1:2}'::jsonb;
2023-08-01 17:01:40.514 +07 client backend[296574] pg_regress/jsonb ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.514 +07 client backend[296574] pg_regress/jsonb DETAIL:  Expected string, but found "3".
2023-08-01 17:01:40.514 +07 client backend[296574] pg_regress/jsonb CONTEXT:  JSON data, line 1: {"abc":1,3...
2023-08-01 17:01:40.514 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT '{"abc":1,3}'::jsonb;
2023-08-01 17:01:40.514 +07 client backend[296577] pg_regress/json_encoding ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.514 +07 client backend[296577] pg_regress/json_encoding DETAIL:  "\u" must be followed by four hexadecimal digits.
2023-08-01 17:01:40.514 +07 client backend[296577] pg_regress/json_encoding CONTEXT:  JSON data, line 1: "\u"
2023-08-01 17:01:40.514 +07 client backend[296577] pg_regress/json_encoding STATEMENT:  SELECT '"\u"'::jsonb;
2023-08-01 17:01:40.514 +07 client backend[296573] pg_regress/json ERROR:  stack depth limit exceeded
2023-08-01 17:01:40.514 +07 client backend[296573] pg_regress/json HINT:  Increase the configuration parameter "max_stack_depth" (currently 100kB), after ensuring the platform's stack depth limit is adequate.
2023-08-01 17:01:40.514 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT repeat('[', 10000)::json;
2023-08-01 17:01:40.514 +07 client backend[296577] pg_regress/json_encoding ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.514 +07 client backend[296577] pg_regress/json_encoding DETAIL:  "\u" must be followed by four hexadecimal digits.
2023-08-01 17:01:40.514 +07 client backend[296577] pg_regress/json_encoding CONTEXT:  JSON data, line 1: "\u00"
2023-08-01 17:01:40.514 +07 client backend[296577] pg_regress/json_encoding STATEMENT:  SELECT '"\u00"'::jsonb;
2023-08-01 17:01:40.514 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  jsonpath array subscript is out of integer range
2023-08-01 17:01:40.514 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('[1]', 'lax $[10000000000000000]');
2023-08-01 17:01:40.514 +07 client backend[296577] pg_regress/json_encoding ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.514 +07 client backend[296577] pg_regress/json_encoding DETAIL:  "\u" must be followed by four hexadecimal digits.
2023-08-01 17:01:40.514 +07 client backend[296577] pg_regress/json_encoding CONTEXT:  JSON data, line 1: "\u000g...
2023-08-01 17:01:40.514 +07 client backend[296577] pg_regress/json_encoding STATEMENT:  SELECT '"\u000g"'::jsonb;
2023-08-01 17:01:40.514 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  jsonpath array subscript is out of integer range
2023-08-01 17:01:40.514 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('[1]', 'strict $[10000000000000000]');
2023-08-01 17:01:40.514 +07 client backend[296573] pg_regress/json ERROR:  stack depth limit exceeded
2023-08-01 17:01:40.514 +07 client backend[296573] pg_regress/json HINT:  Increase the configuration parameter "max_stack_depth" (currently 100kB), after ensuring the platform's stack depth limit is adequate.
2023-08-01 17:01:40.514 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT repeat('{"a":', 10000)::json;
2023-08-01 17:01:40.514 +07 client backend[296577] pg_regress/json_encoding ERROR:  unsupported Unicode escape sequence at character 8
2023-08-01 17:01:40.514 +07 client backend[296577] pg_regress/json_encoding DETAIL:  \u0000 cannot be converted to text.
2023-08-01 17:01:40.514 +07 client backend[296577] pg_regress/json_encoding CONTEXT:  JSON data, line 1: ...
2023-08-01 17:01:40.514 +07 client backend[296577] pg_regress/json_encoding STATEMENT:  SELECT '"\u0000"'::jsonb;
2023-08-01 17:01:40.514 +07 client backend[296574] pg_regress/jsonb ERROR:  stack depth limit exceeded
2023-08-01 17:01:40.514 +07 client backend[296574] pg_regress/jsonb HINT:  Increase the configuration parameter "max_stack_depth" (currently 100kB), after ensuring the platform's stack depth limit is adequate.
2023-08-01 17:01:40.514 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT repeat('[', 10000)::jsonb;
2023-08-01 17:01:40.514 +07 client backend[296573] pg_regress/json ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.514 +07 client backend[296573] pg_regress/json DETAIL:  Expected end of input, but found "false".
2023-08-01 17:01:40.514 +07 client backend[296573] pg_regress/json CONTEXT:  JSON data, line 1: true false
2023-08-01 17:01:40.514 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT 'true false'::json;
2023-08-01 17:01:40.514 +07 client backend[296573] pg_regress/json ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.514 +07 client backend[296573] pg_regress/json DETAIL:  Expected end of input, but found ",".
2023-08-01 17:01:40.514 +07 client backend[296573] pg_regress/json CONTEXT:  JSON data, line 1: true,...
2023-08-01 17:01:40.514 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT 'true, false'::json;
2023-08-01 17:01:40.514 +07 client backend[296577] pg_regress/json_encoding ERROR:  invalid input syntax for type json at character 14
2023-08-01 17:01:40.514 +07 client backend[296577] pg_regress/json_encoding DETAIL:  Unicode high surrogate must not follow a high surrogate.
2023-08-01 17:01:40.514 +07 client backend[296577] pg_regress/json_encoding CONTEXT:  JSON data, line 1: { "a":...
2023-08-01 17:01:40.514 +07 client backend[296577] pg_regress/json_encoding STATEMENT:  SELECT jsonb '{ "a":  "\ud83d\ud83d" }' -> 'a';
2023-08-01 17:01:40.514 +07 client backend[296573] pg_regress/json ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.514 +07 client backend[296573] pg_regress/json DETAIL:  Token "truf" is invalid.
2023-08-01 17:01:40.514 +07 client backend[296573] pg_regress/json CONTEXT:  JSON data, line 1: truf
2023-08-01 17:01:40.514 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT 'truf'::json;
2023-08-01 17:01:40.514 +07 client backend[296573] pg_regress/json ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.514 +07 client backend[296573] pg_regress/json DETAIL:  Token "trues" is invalid.
2023-08-01 17:01:40.514 +07 client backend[296573] pg_regress/json CONTEXT:  JSON data, line 1: trues
2023-08-01 17:01:40.514 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT 'trues'::json;
2023-08-01 17:01:40.514 +07 client backend[296577] pg_regress/json_encoding ERROR:  invalid input syntax for type json at character 14
2023-08-01 17:01:40.514 +07 client backend[296577] pg_regress/json_encoding DETAIL:  Unicode low surrogate must follow a high surrogate.
2023-08-01 17:01:40.514 +07 client backend[296577] pg_regress/json_encoding CONTEXT:  JSON data, line 1: { "a":...
2023-08-01 17:01:40.514 +07 client backend[296577] pg_regress/json_encoding STATEMENT:  SELECT jsonb '{ "a":  "\ude04\ud83d" }' -> 'a';
2023-08-01 17:01:40.515 +07 client backend[296574] pg_regress/jsonb ERROR:  stack depth limit exceeded
2023-08-01 17:01:40.515 +07 client backend[296574] pg_regress/jsonb HINT:  Increase the configuration parameter "max_stack_depth" (currently 100kB), after ensuring the platform's stack depth limit is adequate.
2023-08-01 17:01:40.515 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT repeat('{"a":', 10000)::jsonb;
2023-08-01 17:01:40.515 +07 client backend[296573] pg_regress/json ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.515 +07 client backend[296573] pg_regress/json DETAIL:  The input string ended unexpectedly.
2023-08-01 17:01:40.515 +07 client backend[296573] pg_regress/json CONTEXT:  JSON data, line 1: 
2023-08-01 17:01:40.515 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT ''::json;
2023-08-01 17:01:40.515 +07 client backend[296577] pg_regress/json_encoding ERROR:  invalid input syntax for type json at character 14
2023-08-01 17:01:40.515 +07 client backend[296577] pg_regress/json_encoding DETAIL:  Unicode low surrogate must follow a high surrogate.
2023-08-01 17:01:40.515 +07 client backend[296577] pg_regress/json_encoding CONTEXT:  JSON data, line 1: { "a":...
2023-08-01 17:01:40.515 +07 client backend[296577] pg_regress/json_encoding STATEMENT:  SELECT jsonb '{ "a":  "\ud83dX" }' -> 'a';
2023-08-01 17:01:40.515 +07 client backend[296573] pg_regress/json ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.515 +07 client backend[296573] pg_regress/json DETAIL:  The input string ended unexpectedly.
2023-08-01 17:01:40.515 +07 client backend[296573] pg_regress/json CONTEXT:  JSON data, line 1:     
2023-08-01 17:01:40.515 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT '    '::json;
2023-08-01 17:01:40.515 +07 client backend[296577] pg_regress/json_encoding ERROR:  invalid input syntax for type json at character 14
2023-08-01 17:01:40.515 +07 client backend[296577] pg_regress/json_encoding DETAIL:  Unicode low surrogate must follow a high surrogate.
2023-08-01 17:01:40.515 +07 client backend[296577] pg_regress/json_encoding CONTEXT:  JSON data, line 1: { "a":...
2023-08-01 17:01:40.515 +07 client backend[296577] pg_regress/json_encoding STATEMENT:  SELECT jsonb '{ "a":  "\ude04X" }' -> 'a';
2023-08-01 17:01:40.515 +07 client backend[296577] pg_regress/json_encoding ERROR:  unsupported Unicode escape sequence at character 14
2023-08-01 17:01:40.515 +07 client backend[296577] pg_regress/json_encoding DETAIL:  \u0000 cannot be converted to text.
2023-08-01 17:01:40.515 +07 client backend[296577] pg_regress/json_encoding CONTEXT:  JSON data, line 1: { "a":...
2023-08-01 17:01:40.515 +07 client backend[296577] pg_regress/json_encoding STATEMENT:  SELECT jsonb '{ "a":  "null \u0000 escape" }' as fails;
2023-08-01 17:01:40.515 +07 client backend[296574] pg_regress/jsonb ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.515 +07 client backend[296574] pg_regress/jsonb DETAIL:  Expected end of input, but found "false".
2023-08-01 17:01:40.515 +07 client backend[296574] pg_regress/jsonb CONTEXT:  JSON data, line 1: true false
2023-08-01 17:01:40.515 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT 'true false'::jsonb;
2023-08-01 17:01:40.515 +07 client backend[296574] pg_regress/jsonb ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.515 +07 client backend[296574] pg_regress/jsonb DETAIL:  Expected end of input, but found ",".
2023-08-01 17:01:40.515 +07 client backend[296574] pg_regress/jsonb CONTEXT:  JSON data, line 1: true,...
2023-08-01 17:01:40.515 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT 'true, false'::jsonb;
2023-08-01 17:01:40.515 +07 client backend[296574] pg_regress/jsonb ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.515 +07 client backend[296574] pg_regress/jsonb DETAIL:  Token "truf" is invalid.
2023-08-01 17:01:40.515 +07 client backend[296574] pg_regress/jsonb CONTEXT:  JSON data, line 1: truf
2023-08-01 17:01:40.515 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT 'truf'::jsonb;
2023-08-01 17:01:40.515 +07 client backend[296574] pg_regress/jsonb ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.515 +07 client backend[296574] pg_regress/jsonb DETAIL:  Token "trues" is invalid.
2023-08-01 17:01:40.515 +07 client backend[296574] pg_regress/jsonb CONTEXT:  JSON data, line 1: trues
2023-08-01 17:01:40.515 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT 'trues'::jsonb;
2023-08-01 17:01:40.515 +07 client backend[296574] pg_regress/jsonb ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.515 +07 client backend[296574] pg_regress/jsonb DETAIL:  The input string ended unexpectedly.
2023-08-01 17:01:40.515 +07 client backend[296574] pg_regress/jsonb CONTEXT:  JSON data, line 1: 
2023-08-01 17:01:40.515 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT ''::jsonb;
2023-08-01 17:01:40.515 +07 client backend[296574] pg_regress/jsonb ERROR:  invalid input syntax for type json at character 8
2023-08-01 17:01:40.515 +07 client backend[296574] pg_regress/jsonb DETAIL:  The input string ended unexpectedly.
2023-08-01 17:01:40.515 +07 client backend[296574] pg_regress/jsonb CONTEXT:  JSON data, line 1:     
2023-08-01 17:01:40.515 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT '    '::jsonb;
2023-08-01 17:01:40.515 +07 client backend[296577] pg_regress/json_encoding ERROR:  unsupported Unicode escape sequence at character 14
2023-08-01 17:01:40.515 +07 client backend[296577] pg_regress/json_encoding DETAIL:  \u0000 cannot be converted to text.
2023-08-01 17:01:40.515 +07 client backend[296577] pg_regress/json_encoding CONTEXT:  JSON data, line 1: { "a":...
2023-08-01 17:01:40.515 +07 client backend[296577] pg_regress/json_encoding STATEMENT:  SELECT jsonb '{ "a":  "null \u0000 escape" }' ->> 'a' as fails;
2023-08-01 17:01:40.515 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  jsonpath member accessor can only be applied to an object
2023-08-01 17:01:40.515 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_exists('[{"a": 1}, {"a": 2}, 3]', 'strict $[*].a', silent => false);
2023-08-01 17:01:40.516 +07 client backend[296576] pg_regress/jsonpath ERROR:  LAST is allowed only in array subscripts at character 8
2023-08-01 17:01:40.516 +07 client backend[296576] pg_regress/jsonpath STATEMENT:  select 'last'::jsonpath;
2023-08-01 17:01:40.516 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  jsonpath member accessor can only be applied to an object
2023-08-01 17:01:40.516 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('1', 'strict $.a');
2023-08-01 17:01:40.516 +07 client backend[296576] pg_regress/jsonpath ERROR:  LAST is allowed only in array subscripts at character 8
2023-08-01 17:01:40.516 +07 client backend[296576] pg_regress/jsonpath STATEMENT:  select '$ ? (last > 0)'::jsonpath;
2023-08-01 17:01:40.516 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  jsonpath wildcard member accessor can only be applied to an object
2023-08-01 17:01:40.516 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('1', 'strict $.*');
2023-08-01 17:01:40.516 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  jsonpath member accessor can only be applied to an object
2023-08-01 17:01:40.516 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('[]', 'strict $.a');
2023-08-01 17:01:40.516 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  JSON object does not contain key "a"
2023-08-01 17:01:40.516 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('{}', 'strict $.a');
2023-08-01 17:01:40.516 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  jsonpath array accessor can only be applied to an array
2023-08-01 17:01:40.516 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('1', 'strict $[1]');
2023-08-01 17:01:40.516 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  jsonpath wildcard array accessor can only be applied to an array
2023-08-01 17:01:40.516 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('1', 'strict $[*]');
2023-08-01 17:01:40.517 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  jsonpath array subscript is out of bounds
2023-08-01 17:01:40.517 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('[]', 'strict $[1]');
2023-08-01 17:01:40.517 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  jsonpath array subscript is not a single numeric value
2023-08-01 17:01:40.517 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('[]', 'strict $["a"]');
2023-08-01 17:01:40.517 +07 client backend[296576] pg_regress/jsonpath ERROR:  invalid regular expression: parentheses () not balanced at character 8
2023-08-01 17:01:40.517 +07 client backend[296576] pg_regress/jsonpath STATEMENT:  select '$ ? (@ like_regex "(invalid pattern")'::jsonpath;
2023-08-01 17:01:40.517 +07 client backend[296576] pg_regress/jsonpath ERROR:  XQuery "x" flag (expanded regular expressions) is not implemented at character 8
2023-08-01 17:01:40.517 +07 client backend[296576] pg_regress/jsonpath STATEMENT:  select '$ ? (@ like_regex "pattern" flag "xsms")'::jsonpath;
2023-08-01 17:01:40.517 +07 client backend[296576] pg_regress/jsonpath ERROR:  invalid input syntax for type jsonpath at character 8
2023-08-01 17:01:40.517 +07 client backend[296576] pg_regress/jsonpath DETAIL:  unrecognized flag character "a" in LIKE_REGEX predicate
2023-08-01 17:01:40.517 +07 client backend[296576] pg_regress/jsonpath STATEMENT:  select '$ ? (@ like_regex "pattern" flag "a")'::jsonpath;
2023-08-01 17:01:40.517 +07 client backend[296576] pg_regress/jsonpath ERROR:  @ is not allowed in root expressions at character 8
2023-08-01 17:01:40.517 +07 client backend[296576] pg_regress/jsonpath STATEMENT:  select '@ + 1'::jsonpath;
2023-08-01 17:01:40.518 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  division by zero
2023-08-01 17:01:40.518 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('[12, {"a": 13}, {"b": 14}]', 'lax $[0 to 10 / 0].a');
2023-08-01 17:01:40.518 +07 client backend[296576] pg_regress/jsonpath ERROR:  syntax error, unexpected '.' at or near "." of jsonpath input at character 8
2023-08-01 17:01:40.518 +07 client backend[296576] pg_regress/jsonpath STATEMENT:  select '$ ? (@.a < .1)'::jsonpath;
2023-08-01 17:01:40.518 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  jsonpath member accessor can only be applied to an object
2023-08-01 17:01:40.518 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('[1,2,3]', 'strict $[*].a');
2023-08-01 17:01:40.518 +07 client backend[296576] pg_regress/jsonpath ERROR:  syntax error, unexpected '.' at or near "." of jsonpath input at character 8
2023-08-01 17:01:40.518 +07 client backend[296576] pg_regress/jsonpath STATEMENT:  select '$ ? (@.a < -.1)'::jsonpath;
2023-08-01 17:01:40.518 +07 client backend[296576] pg_regress/jsonpath ERROR:  syntax error, unexpected '.' at or near "." of jsonpath input at character 8
2023-08-01 17:01:40.518 +07 client backend[296576] pg_regress/jsonpath STATEMENT:  select '$ ? (@.a < +.1)'::jsonpath;
2023-08-01 17:01:40.518 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  jsonpath array subscript is out of bounds
2023-08-01 17:01:40.518 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('[]', 'strict $[last]');
2023-08-01 17:01:40.519 +07 client backend[296576] pg_regress/jsonpath ERROR:  syntax error, unexpected '.' at or near "." of jsonpath input at character 8
2023-08-01 17:01:40.519 +07 client backend[296576] pg_regress/jsonpath STATEMENT:  select '$ ? (@.a < .1e1)'::jsonpath;
2023-08-01 17:01:40.519 +07 client backend[296576] pg_regress/jsonpath ERROR:  syntax error, unexpected '.' at or near "." of jsonpath input at character 8
2023-08-01 17:01:40.519 +07 client backend[296576] pg_regress/jsonpath STATEMENT:  select '$ ? (@.a < -.1e1)'::jsonpath;
2023-08-01 17:01:40.519 +07 client backend[296576] pg_regress/jsonpath ERROR:  syntax error, unexpected '.' at or near "." of jsonpath input at character 8
2023-08-01 17:01:40.519 +07 client backend[296576] pg_regress/jsonpath STATEMENT:  select '$ ? (@.a < +.1e1)'::jsonpath;
2023-08-01 17:01:40.519 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  jsonpath array subscript is not a single numeric value
2023-08-01 17:01:40.519 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('[1,2,3]', '$[last ? (@.type() == "string")]');
2023-08-01 17:01:40.519 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  could not find jsonpath variable "value"
2023-08-01 17:01:40.519 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select * from jsonb_path_query('{"a": 10}', '$ ? (@.a < $value)');
2023-08-01 17:01:40.519 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  "vars" argument is not an object
2023-08-01 17:01:40.519 +07 client backend[296578] pg_regress/jsonb_jsonpath DETAIL:  Jsonpath parameters should be encoded as key-value pairs of "vars" object.
2023-08-01 17:01:40.519 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select * from jsonb_path_query('{"a": 10}', '$ ? (@.a < $value)', '1');
2023-08-01 17:01:40.519 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  "vars" argument is not an object
2023-08-01 17:01:40.519 +07 client backend[296578] pg_regress/jsonb_jsonpath DETAIL:  Jsonpath parameters should be encoded as key-value pairs of "vars" object.
2023-08-01 17:01:40.519 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select * from jsonb_path_query('{"a": 10}', '$ ? (@.a < $value)', '[{"value" : 13}]');
2023-08-01 17:01:40.519 +07 client backend[296576] pg_regress/jsonpath ERROR:  syntax error, unexpected '.' at or near "." of jsonpath input at character 8
2023-08-01 17:01:40.519 +07 client backend[296576] pg_regress/jsonpath STATEMENT:  select '$ ? (@.a < .1e-1)'::jsonpath;
2023-08-01 17:01:40.519 +07 client backend[296576] pg_regress/jsonpath ERROR:  syntax error, unexpected '.' at or near "." of jsonpath input at character 8
2023-08-01 17:01:40.519 +07 client backend[296576] pg_regress/jsonpath STATEMENT:  select '$ ? (@.a < -.1e-1)'::jsonpath;
2023-08-01 17:01:40.519 +07 client backend[296576] pg_regress/jsonpath ERROR:  syntax error, unexpected '.' at or near "." of jsonpath input at character 8
2023-08-01 17:01:40.519 +07 client backend[296576] pg_regress/jsonpath STATEMENT:  select '$ ? (@.a < +.1e-1)'::jsonpath;
2023-08-01 17:01:40.520 +07 client backend[296576] pg_regress/jsonpath ERROR:  syntax error, unexpected '.' at or near "." of jsonpath input at character 8
2023-08-01 17:01:40.520 +07 client backend[296576] pg_regress/jsonpath STATEMENT:  select '$ ? (@.a < .1e+1)'::jsonpath;
2023-08-01 17:01:40.520 +07 client backend[296576] pg_regress/jsonpath ERROR:  syntax error, unexpected '.' at or near "." of jsonpath input at character 8
2023-08-01 17:01:40.520 +07 client backend[296576] pg_regress/jsonpath STATEMENT:  select '$ ? (@.a < -.1e+1)'::jsonpath;
2023-08-01 17:01:40.520 +07 client backend[296576] pg_regress/jsonpath ERROR:  syntax error, unexpected '.' at or near "." of jsonpath input at character 8
2023-08-01 17:01:40.520 +07 client backend[296576] pg_regress/jsonpath STATEMENT:  select '$ ? (@.a < +.1e+1)'::jsonpath;
2023-08-01 17:01:40.521 +07 client backend[296576] pg_regress/jsonpath ERROR:  syntax error, unexpected IDENT_P at end of jsonpath input at character 8
2023-08-01 17:01:40.521 +07 client backend[296576] pg_regress/jsonpath STATEMENT:  select '00'::jsonpath;
2023-08-01 17:01:40.521 +07 client backend[296576] pg_regress/jsonpath ERROR:  invalid floating point number at or near "1e" of jsonpath input at character 8
2023-08-01 17:01:40.521 +07 client backend[296576] pg_regress/jsonpath STATEMENT:  select '1e'::jsonpath;
2023-08-01 17:01:40.521 +07 client backend[296576] pg_regress/jsonpath ERROR:  invalid floating point number at or near "1.2e" of jsonpath input at character 8
2023-08-01 17:01:40.521 +07 client backend[296576] pg_regress/jsonpath STATEMENT:  select '1.2e'::jsonpath;
2023-08-01 17:01:40.522 +07 client backend[296576] pg_regress/jsonpath ERROR:  syntax error, unexpected '.' at or near "." of jsonpath input at character 8
2023-08-01 17:01:40.522 +07 client backend[296576] pg_regress/jsonpath STATEMENT:  select '1..e'::jsonpath;
2023-08-01 17:01:40.522 +07 client backend[296576] pg_regress/jsonpath ERROR:  syntax error, unexpected '.' at or near "." of jsonpath input at character 8
2023-08-01 17:01:40.522 +07 client backend[296576] pg_regress/jsonpath STATEMENT:  select '1..e3'::jsonpath;
2023-08-01 17:01:40.522 +07 client backend[296576] pg_regress/jsonpath ERROR:  syntax error, unexpected ')' at or near ")" of jsonpath input at character 8
2023-08-01 17:01:40.522 +07 client backend[296576] pg_regress/jsonpath STATEMENT:  select '(1.).e'::jsonpath;
2023-08-01 17:01:40.522 +07 client backend[296576] pg_regress/jsonpath ERROR:  syntax error, unexpected ')' at or near ")" of jsonpath input at character 8
2023-08-01 17:01:40.522 +07 client backend[296576] pg_regress/jsonpath STATEMENT:  select '(1.).e3'::jsonpath;
2023-08-01 17:01:40.524 +07 client backend[296574] pg_regress/jsonb ERROR:  cannot call jsonb_object_keys on a scalar
2023-08-01 17:01:40.524 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT jsonb_object_keys(test_json) FROM test_jsonb WHERE json_type = 'scalar';
2023-08-01 17:01:40.524 +07 client backend[296574] pg_regress/jsonb ERROR:  cannot call jsonb_object_keys on an array
2023-08-01 17:01:40.524 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT jsonb_object_keys(test_json) FROM test_jsonb WHERE json_type = 'array';
2023-08-01 17:01:40.525 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  division by zero
2023-08-01 17:01:40.525 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('0', '1 / $');
2023-08-01 17:01:40.525 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  division by zero
2023-08-01 17:01:40.525 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('0', '1 / $ + 2');
2023-08-01 17:01:40.525 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  division by zero
2023-08-01 17:01:40.525 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('0', '-(3 + 1 % $)');
2023-08-01 17:01:40.525 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  right operand of jsonpath operator + is not a single numeric value
2023-08-01 17:01:40.525 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('1', '$ + "2"');
2023-08-01 17:01:40.525 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  right operand of jsonpath operator * is not a single numeric value
2023-08-01 17:01:40.525 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('[1, 2]', '3 * $');
2023-08-01 17:01:40.525 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  operand of unary jsonpath operator - is not a numeric value
2023-08-01 17:01:40.525 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('"a"', '-$');
2023-08-01 17:01:40.526 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  operand of unary jsonpath operator + is not a numeric value
2023-08-01 17:01:40.526 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('[1,"2",3]', '+$');
2023-08-01 17:01:40.526 +07 client backend[296573] pg_regress/json ERROR:  cannot call json_object_keys on a scalar
2023-08-01 17:01:40.526 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT json_object_keys(test_json)
	FROM test_json
	WHERE json_type = 'scalar';
2023-08-01 17:01:40.526 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  left operand of jsonpath operator * is not a single numeric value
2023-08-01 17:01:40.526 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('{"a": [1, 2]}', 'lax $.a * 3');
2023-08-01 17:01:40.526 +07 client backend[296573] pg_regress/json ERROR:  cannot call json_object_keys on an array
2023-08-01 17:01:40.526 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT json_object_keys(test_json)
	FROM test_json
	WHERE json_type = 'array';
2023-08-01 17:01:40.528 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  jsonpath item method .size() can only be applied to an array
2023-08-01 17:01:40.528 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('[1,null,true,"11",[],[1],[1,2,3],{},{"a":1,"b":2}]', 'strict $[*].size()');
2023-08-01 17:01:40.528 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  jsonpath item method .keyvalue() can only be applied to an object
2023-08-01 17:01:40.528 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('[{},1]', '$[*].keyvalue()');
2023-08-01 17:01:40.529 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  jsonpath item method .keyvalue() can only be applied to an object
2023-08-01 17:01:40.529 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('[{"a": 1, "b": [1, 2]}, {"c": {"a": "bbb"}}]', 'strict $.keyvalue()');
2023-08-01 17:01:40.529 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  jsonpath item method .keyvalue() can only be applied to an object
2023-08-01 17:01:40.529 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('[{"a": 1, "b": [1, 2]}, {"c": {"a": "bbb"}}]', 'strict $.keyvalue().a');
2023-08-01 17:01:40.529 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  jsonpath item method .double() can only be applied to a string or numeric value
2023-08-01 17:01:40.529 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('null', '$.double()');
2023-08-01 17:01:40.529 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  jsonpath item method .double() can only be applied to a string or numeric value
2023-08-01 17:01:40.529 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('true', '$.double()');
2023-08-01 17:01:40.529 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  jsonpath item method .double() can only be applied to a string or numeric value
2023-08-01 17:01:40.529 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('[]', 'strict $.double()');
2023-08-01 17:01:40.529 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  jsonpath item method .double() can only be applied to a string or numeric value
2023-08-01 17:01:40.529 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('{}', '$.double()');
2023-08-01 17:01:40.529 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  string argument of jsonpath item method .double() is not a valid representation of a double precision number
2023-08-01 17:01:40.529 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('"1.23aaa"', '$.double()');
2023-08-01 17:01:40.529 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  numeric argument of jsonpath item method .double() is out of range for type double precision
2023-08-01 17:01:40.529 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('1e1000', '$.double()');
2023-08-01 17:01:40.529 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  string argument of jsonpath item method .double() is not a valid representation of a double precision number
2023-08-01 17:01:40.529 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('"nan"', '$.double()');
2023-08-01 17:01:40.529 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  string argument of jsonpath item method .double() is not a valid representation of a double precision number
2023-08-01 17:01:40.529 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('"NaN"', '$.double()');
2023-08-01 17:01:40.529 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  string argument of jsonpath item method .double() is not a valid representation of a double precision number
2023-08-01 17:01:40.529 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('"inf"', '$.double()');
2023-08-01 17:01:40.529 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  string argument of jsonpath item method .double() is not a valid representation of a double precision number
2023-08-01 17:01:40.529 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('"-inf"', '$.double()');
2023-08-01 17:01:40.530 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  jsonpath item method .abs() can only be applied to a numeric value
2023-08-01 17:01:40.530 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('{}', '$.abs()');
2023-08-01 17:01:40.530 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  jsonpath item method .floor() can only be applied to a numeric value
2023-08-01 17:01:40.530 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('true', '$.floor()');
2023-08-01 17:01:40.530 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  jsonpath item method .ceiling() can only be applied to a numeric value
2023-08-01 17:01:40.530 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('"1.2"', '$.ceiling()');
2023-08-01 17:01:40.530 +07 client backend[296573] pg_regress/json ERROR:  cannot get array length of a non-array
2023-08-01 17:01:40.530 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT json_array_length('{"f1":1,"f2":[5,6]}');
2023-08-01 17:01:40.530 +07 client backend[296573] pg_regress/json ERROR:  cannot get array length of a scalar
2023-08-01 17:01:40.530 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT json_array_length('4');
2023-08-01 17:01:40.530 +07 client backend[296574] pg_regress/jsonb ERROR:  cannot get array length of a non-array
2023-08-01 17:01:40.530 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT jsonb_array_length('{"f1":1,"f2":[5,6]}');
2023-08-01 17:01:40.530 +07 client backend[296574] pg_regress/jsonb ERROR:  cannot get array length of a scalar
2023-08-01 17:01:40.530 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT jsonb_array_length('4');
2023-08-01 17:01:40.531 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  jsonpath item method .datetime() can only be applied to a string
2023-08-01 17:01:40.531 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('null', '$.datetime()');
2023-08-01 17:01:40.531 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  jsonpath item method .datetime() can only be applied to a string
2023-08-01 17:01:40.531 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('true', '$.datetime()');
2023-08-01 17:01:40.531 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  jsonpath item method .datetime() can only be applied to a string
2023-08-01 17:01:40.531 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('1', '$.datetime()');
2023-08-01 17:01:40.531 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  jsonpath item method .datetime() can only be applied to a string
2023-08-01 17:01:40.531 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('[]', 'strict $.datetime()');
2023-08-01 17:01:40.531 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  jsonpath item method .datetime() can only be applied to a string
2023-08-01 17:01:40.531 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('{}', '$.datetime()');
2023-08-01 17:01:40.531 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  datetime format is not recognized: "bogus"
2023-08-01 17:01:40.531 +07 client backend[296578] pg_regress/jsonb_jsonpath HINT:  Use a datetime template argument to specify the input data format.
2023-08-01 17:01:40.531 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('"bogus"', '$.datetime()');
2023-08-01 17:01:40.531 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  invalid datetime format separator: "a"
2023-08-01 17:01:40.531 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('"12:34"', '$.datetime("aaa")');
2023-08-01 17:01:40.531 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  invalid value "aa" for "HH24"
2023-08-01 17:01:40.531 +07 client backend[296578] pg_regress/jsonb_jsonpath DETAIL:  Value must be an integer.
2023-08-01 17:01:40.531 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('"aaaa"', '$.datetime("HH24")');
2023-08-01 17:01:40.532 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  trailing characters remain in input string after datetime format
2023-08-01 17:01:40.532 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('"10-03-2017 12:34"', '$.datetime("dd-mm-yyyy")');
2023-08-01 17:01:40.532 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  trailing characters remain in input string after datetime format
2023-08-01 17:01:40.532 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('"10-03-2017 12:34"', '$.datetime("dd-mm-yyyy").type()');
2023-08-01 17:01:40.532 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  unmatched format character "T"
2023-08-01 17:01:40.532 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('"10-03-2017t12:34:56"', '$.datetime("dd-mm-yyyy\"T\"HH24:MI:SS")');
2023-08-01 17:01:40.532 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  unmatched format character "T"
2023-08-01 17:01:40.532 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('"10-03-2017 12:34:56"', '$.datetime("dd-mm-yyyy\"T\"HH24:MI:SS")');
2023-08-01 17:01:40.532 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  input string is too short for datetime format
2023-08-01 17:01:40.532 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('"10-03-2017 12:34"', '$.datetime("dd-mm-yyyy HH24:MI TZH")');
2023-08-01 17:01:40.533 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  input string is too short for datetime format
2023-08-01 17:01:40.533 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('"12:34"', '$.datetime("HH24:MI TZH")');
2023-08-01 17:01:40.533 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  input string is too short for datetime format
2023-08-01 17:01:40.533 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('"10-03-2017 12:34"', '$.datetime("dd-mm-yyyy HH24:MI TZH")');
2023-08-01 17:01:40.533 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  input string is too short for datetime format
2023-08-01 17:01:40.533 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('"12:34"', '$.datetime("HH24:MI TZH")');
2023-08-01 17:01:40.534 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  datetime format is not recognized: "2017-03-10t12:34:56+3:10"
2023-08-01 17:01:40.534 +07 client backend[296578] pg_regress/jsonb_jsonpath HINT:  Use a datetime template argument to specify the input data format.
2023-08-01 17:01:40.534 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query('"2017-03-10t12:34:56+3:10"', '$.datetime()');
2023-08-01 17:01:40.535 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  cannot convert value from date to timestamptz without time zone usage
2023-08-01 17:01:40.535 +07 client backend[296578] pg_regress/jsonb_jsonpath HINT:  Use *_tz() function for time zone support.
2023-08-01 17:01:40.535 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query(
		'["2017-03-10", "2017-03-11", "2017-03-09", "12:34:56", "01:02:03+04", "2017-03-10 00:00:00", "2017-03-10 12:34:56", "2017-03-10 01:02:03+04", "2017-03-10 03:00:00+03"]',
		'$[*].datetime() ? (@ == "10.03.2017".datetime("dd.mm.yyyy"))');
2023-08-01 17:01:40.535 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  cannot convert value from date to timestamptz without time zone usage
2023-08-01 17:01:40.535 +07 client backend[296578] pg_regress/jsonb_jsonpath HINT:  Use *_tz() function for time zone support.
2023-08-01 17:01:40.535 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query(
		'["2017-03-10", "2017-03-11", "2017-03-09", "12:34:56", "01:02:03+04", "2017-03-10 00:00:00", "2017-03-10 12:34:56", "2017-03-10 01:02:03+04", "2017-03-10 03:00:00+03"]',
		'$[*].datetime() ? (@ >= "10.03.2017".datetime("dd.mm.yyyy"))');
2023-08-01 17:01:40.535 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  cannot convert value from date to timestamptz without time zone usage
2023-08-01 17:01:40.535 +07 client backend[296578] pg_regress/jsonb_jsonpath HINT:  Use *_tz() function for time zone support.
2023-08-01 17:01:40.535 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query(
		'["2017-03-10", "2017-03-11", "2017-03-09", "12:34:56", "01:02:03+04", "2017-03-10 00:00:00", "2017-03-10 12:34:56", "2017-03-10 01:02:03+04", "2017-03-10 03:00:00+03"]',
		'$[*].datetime() ? (@ <  "10.03.2017".datetime("dd.mm.yyyy"))');
2023-08-01 17:01:40.535 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  cannot convert value from time to timetz without time zone usage
2023-08-01 17:01:40.535 +07 client backend[296578] pg_regress/jsonb_jsonpath HINT:  Use *_tz() function for time zone support.
2023-08-01 17:01:40.535 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query(
		'["12:34:00", "12:35:00", "12:36:00", "12:35:00+00", "12:35:00+01", "13:35:00+01", "2017-03-10", "2017-03-10 12:35:00", "2017-03-10 12:35:00+01"]',
		'$[*].datetime() ? (@ == "12:35".datetime("HH24:MI"))');
2023-08-01 17:01:40.535 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  cannot convert value from time to timetz without time zone usage
2023-08-01 17:01:40.535 +07 client backend[296578] pg_regress/jsonb_jsonpath HINT:  Use *_tz() function for time zone support.
2023-08-01 17:01:40.535 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query(
		'["12:34:00", "12:35:00", "12:36:00", "12:35:00+00", "12:35:00+01", "13:35:00+01", "2017-03-10", "2017-03-10 12:35:00", "2017-03-10 12:35:00+01"]',
		'$[*].datetime() ? (@ >= "12:35".datetime("HH24:MI"))');
2023-08-01 17:01:40.535 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  cannot convert value from time to timetz without time zone usage
2023-08-01 17:01:40.535 +07 client backend[296578] pg_regress/jsonb_jsonpath HINT:  Use *_tz() function for time zone support.
2023-08-01 17:01:40.535 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query(
		'["12:34:00", "12:35:00", "12:36:00", "12:35:00+00", "12:35:00+01", "13:35:00+01", "2017-03-10", "2017-03-10 12:35:00", "2017-03-10 12:35:00+01"]',
		'$[*].datetime() ? (@ <  "12:35".datetime("HH24:MI"))');
2023-08-01 17:01:40.536 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  cannot convert value from time to timetz without time zone usage
2023-08-01 17:01:40.536 +07 client backend[296578] pg_regress/jsonb_jsonpath HINT:  Use *_tz() function for time zone support.
2023-08-01 17:01:40.536 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query(
		'["12:34:00+01", "12:35:00+01", "12:36:00+01", "12:35:00+02", "12:35:00-02", "10:35:00", "11:35:00", "12:35:00", "2017-03-10", "2017-03-10 12:35:00", "2017-03-10 12:35:00 +1"]',
		'$[*].datetime() ? (@ == "12:35 +1".datetime("HH24:MI TZH"))');
2023-08-01 17:01:40.536 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  cannot convert value from time to timetz without time zone usage
2023-08-01 17:01:40.536 +07 client backend[296578] pg_regress/jsonb_jsonpath HINT:  Use *_tz() function for time zone support.
2023-08-01 17:01:40.536 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query(
		'["12:34:00+01", "12:35:00+01", "12:36:00+01", "12:35:00+02", "12:35:00-02", "10:35:00", "11:35:00", "12:35:00", "2017-03-10", "2017-03-10 12:35:00", "2017-03-10 12:35:00 +1"]',
		'$[*].datetime() ? (@ >= "12:35 +1".datetime("HH24:MI TZH"))');
2023-08-01 17:01:40.536 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  cannot convert value from time to timetz without time zone usage
2023-08-01 17:01:40.536 +07 client backend[296578] pg_regress/jsonb_jsonpath HINT:  Use *_tz() function for time zone support.
2023-08-01 17:01:40.536 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query(
		'["12:34:00+01", "12:35:00+01", "12:36:00+01", "12:35:00+02", "12:35:00-02", "10:35:00", "11:35:00", "12:35:00", "2017-03-10", "2017-03-10 12:35:00", "2017-03-10 12:35:00 +1"]',
		'$[*].datetime() ? (@ <  "12:35 +1".datetime("HH24:MI TZH"))');
2023-08-01 17:01:40.536 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  cannot convert value from timestamp to timestamptz without time zone usage
2023-08-01 17:01:40.536 +07 client backend[296578] pg_regress/jsonb_jsonpath HINT:  Use *_tz() function for time zone support.
2023-08-01 17:01:40.536 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query(
		'["2017-03-10 12:34:00", "2017-03-10 12:35:00", "2017-03-10 12:36:00", "2017-03-10 12:35:00+01", "2017-03-10 13:35:00+01", "2017-03-10 12:35:00-01", "2017-03-10", "2017-03-11", "12:34:56", "12:34:56+01"]',
		'$[*].datetime() ? (@ == "10.03.2017 12:35".datetime("dd.mm.yyyy HH24:MI"))');
2023-08-01 17:01:40.536 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  cannot convert value from timestamp to timestamptz without time zone usage
2023-08-01 17:01:40.536 +07 client backend[296578] pg_regress/jsonb_jsonpath HINT:  Use *_tz() function for time zone support.
2023-08-01 17:01:40.536 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query(
		'["2017-03-10 12:34:00", "2017-03-10 12:35:00", "2017-03-10 12:36:00", "2017-03-10 12:35:00+01", "2017-03-10 13:35:00+01", "2017-03-10 12:35:00-01", "2017-03-10", "2017-03-11", "12:34:56", "12:34:56+01"]',
		'$[*].datetime() ? (@ >= "10.03.2017 12:35".datetime("dd.mm.yyyy HH24:MI"))');
2023-08-01 17:01:40.536 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  cannot convert value from timestamp to timestamptz without time zone usage
2023-08-01 17:01:40.536 +07 client backend[296578] pg_regress/jsonb_jsonpath HINT:  Use *_tz() function for time zone support.
2023-08-01 17:01:40.536 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query(
		'["2017-03-10 12:34:00", "2017-03-10 12:35:00", "2017-03-10 12:36:00", "2017-03-10 12:35:00+01", "2017-03-10 13:35:00+01", "2017-03-10 12:35:00-01", "2017-03-10", "2017-03-11", "12:34:56", "12:34:56+01"]',
		'$[*].datetime() ? (@ < "10.03.2017 12:35".datetime("dd.mm.yyyy HH24:MI"))');
2023-08-01 17:01:40.537 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  cannot convert value from timestamp to timestamptz without time zone usage
2023-08-01 17:01:40.537 +07 client backend[296578] pg_regress/jsonb_jsonpath HINT:  Use *_tz() function for time zone support.
2023-08-01 17:01:40.537 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query(
		'["2017-03-10 12:34:00+01", "2017-03-10 12:35:00+01", "2017-03-10 12:36:00+01", "2017-03-10 12:35:00+02", "2017-03-10 12:35:00-02", "2017-03-10 10:35:00", "2017-03-10 11:35:00", "2017-03-10 12:35:00", "2017-03-10", "2017-03-11", "12:34:56", "12:34:56+01"]',
		'$[*].datetime() ? (@ == "10.03.2017 12:35 +1".datetime("dd.mm.yyyy HH24:MI TZH"))');
2023-08-01 17:01:40.537 +07 client backend[296574] pg_regress/jsonb ERROR:  argument list must have even number of elements
2023-08-01 17:01:40.537 +07 client backend[296574] pg_regress/jsonb HINT:  The arguments of jsonb_build_object() must consist of alternating keys and values.
2023-08-01 17:01:40.537 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT jsonb_build_object('{a,b,c}'::text[]);
2023-08-01 17:01:40.537 +07 client backend[296574] pg_regress/jsonb ERROR:  key value must be scalar, not array, composite, or json
2023-08-01 17:01:40.537 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT jsonb_build_object('{a,b,c}'::text[], '{d,e,f}'::text[]);
2023-08-01 17:01:40.537 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  cannot convert value from timestamp to timestamptz without time zone usage
2023-08-01 17:01:40.537 +07 client backend[296578] pg_regress/jsonb_jsonpath HINT:  Use *_tz() function for time zone support.
2023-08-01 17:01:40.537 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query(
		'["2017-03-10 12:34:00+01", "2017-03-10 12:35:00+01", "2017-03-10 12:36:00+01", "2017-03-10 12:35:00+02", "2017-03-10 12:35:00-02", "2017-03-10 10:35:00", "2017-03-10 11:35:00", "2017-03-10 12:35:00", "2017-03-10", "2017-03-11", "12:34:56", "12:34:56+01"]',
		'$[*].datetime() ? (@ >= "10.03.2017 12:35 +1".datetime("dd.mm.yyyy HH24:MI TZH"))');
2023-08-01 17:01:40.537 +07 client backend[296574] pg_regress/jsonb ERROR:  argument list must have even number of elements
2023-08-01 17:01:40.537 +07 client backend[296574] pg_regress/jsonb HINT:  The arguments of jsonb_build_object() must consist of alternating keys and values.
2023-08-01 17:01:40.537 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT jsonb_build_object('a', 'b', 'c');
2023-08-01 17:01:40.537 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  cannot convert value from timestamp to timestamptz without time zone usage
2023-08-01 17:01:40.537 +07 client backend[296578] pg_regress/jsonb_jsonpath HINT:  Use *_tz() function for time zone support.
2023-08-01 17:01:40.537 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  select jsonb_path_query(
		'["2017-03-10 12:34:00+01", "2017-03-10 12:35:00+01", "2017-03-10 12:36:00+01", "2017-03-10 12:35:00+02", "2017-03-10 12:35:00-02", "2017-03-10 10:35:00", "2017-03-10 11:35:00", "2017-03-10 12:35:00", "2017-03-10", "2017-03-11", "12:34:56", "12:34:56+01"]',
		'$[*].datetime() ? (@ < "10.03.2017 12:35 +1".datetime("dd.mm.yyyy HH24:MI TZH"))');
2023-08-01 17:01:40.537 +07 client backend[296574] pg_regress/jsonb ERROR:  argument 1: key must not be null
2023-08-01 17:01:40.537 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT jsonb_build_object(NULL, 'a');
2023-08-01 17:01:40.537 +07 client backend[296574] pg_regress/jsonb ERROR:  argument list must have even number of elements
2023-08-01 17:01:40.537 +07 client backend[296574] pg_regress/jsonb HINT:  The arguments of jsonb_build_object() must consist of alternating keys and values.
2023-08-01 17:01:40.537 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT jsonb_build_object(VARIADIC '{a,b,c}'::text[]);
2023-08-01 17:01:40.537 +07 client backend[296574] pg_regress/jsonb ERROR:  argument 1: key must not be null
2023-08-01 17:01:40.537 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT jsonb_build_object(VARIADIC ARRAY[NULL, 'a']::text[]);
2023-08-01 17:01:40.537 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  JSON object does not contain key "a"
2023-08-01 17:01:40.537 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  SELECT jsonb_path_query_array('[{"a": 1}, {"a": 2}, {}]', 'strict $[*].a');
2023-08-01 17:01:40.538 +07 client backend[296574] pg_regress/jsonb ERROR:  argument 1: key must not be null
2023-08-01 17:01:40.538 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT jsonb_build_object(null,2);
2023-08-01 17:01:40.538 +07 client backend[296574] pg_regress/jsonb ERROR:  key value must be scalar, not array, composite, or json
2023-08-01 17:01:40.538 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT jsonb_build_object(r,2) FROM (SELECT 1 AS a, 2 AS b) r;
2023-08-01 17:01:40.538 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  JSON object does not contain key "a"
2023-08-01 17:01:40.538 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  SELECT jsonb_path_query_first('[{"a": 1}, {"a": 2}, {}]', 'strict $[*].a');
2023-08-01 17:01:40.538 +07 client backend[296574] pg_regress/jsonb ERROR:  key value must be scalar, not array, composite, or json
2023-08-01 17:01:40.538 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT jsonb_build_object(json '{"a":1,"b":2}', 3);
2023-08-01 17:01:40.538 +07 client backend[296574] pg_regress/jsonb ERROR:  key value must be scalar, not array, composite, or json
2023-08-01 17:01:40.538 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT jsonb_build_object('{1,2,3}'::int[], 3);
2023-08-01 17:01:40.538 +07 client backend[296574] pg_regress/jsonb ERROR:  field name must not be null
2023-08-01 17:01:40.538 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT jsonb_object_agg(NULL, '{"a":1}');
2023-08-01 17:01:40.538 +07 client backend[296573] pg_regress/json ERROR:  invalid input syntax for type timestamp: "[100,200,false]"
2023-08-01 17:01:40.538 +07 client backend[296573] pg_regress/json STATEMENT:  select * from json_populate_record(row('x',3,'2012-12-31 15:30:56')::jpop,'{"c":[100,200,false],"x":43.2}') q;
2023-08-01 17:01:40.538 +07 client backend[296573] pg_regress/json ERROR:  domain js_int_not_null does not allow null values
2023-08-01 17:01:40.538 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT i FROM json_populate_record(NULL::jsrec_i_not_null, '{"x": 43.2}') q;
2023-08-01 17:01:40.538 +07 client backend[296573] pg_regress/json ERROR:  domain js_int_not_null does not allow null values
2023-08-01 17:01:40.538 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT i FROM json_populate_record(NULL::jsrec_i_not_null, '{"i": null}') q;
2023-08-01 17:01:40.539 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  single boolean result is expected
2023-08-01 17:01:40.539 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  SELECT jsonb_path_match('1', '$', silent => false);
2023-08-01 17:01:40.539 +07 client backend[296573] pg_regress/json ERROR:  expected JSON array
2023-08-01 17:01:40.539 +07 client backend[296573] pg_regress/json HINT:  See the value of key "ia".
2023-08-01 17:01:40.539 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT ia FROM json_populate_record(NULL::jsrec, '{"ia": 123}') q;
2023-08-01 17:01:40.539 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  single boolean result is expected
2023-08-01 17:01:40.539 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  SELECT jsonb_path_match('"a"', '$', silent => false);
2023-08-01 17:01:40.539 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  single boolean result is expected
2023-08-01 17:01:40.539 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  SELECT jsonb_path_match('{}', '$', silent => false);
2023-08-01 17:01:40.539 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  single boolean result is expected
2023-08-01 17:01:40.539 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  SELECT jsonb_path_match('[true]', '$', silent => false);
2023-08-01 17:01:40.539 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  single boolean result is expected
2023-08-01 17:01:40.539 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  SELECT jsonb_path_match('{}', 'lax $.a', silent => false);
2023-08-01 17:01:40.539 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  JSON object does not contain key "a"
2023-08-01 17:01:40.539 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  SELECT jsonb_path_match('{}', 'strict $.a', silent => false);
2023-08-01 17:01:40.539 +07 client backend[296578] pg_regress/jsonb_jsonpath ERROR:  single boolean result is expected
2023-08-01 17:01:40.539 +07 client backend[296578] pg_regress/jsonb_jsonpath STATEMENT:  SELECT jsonb_path_match('[true, true]', '$[*]', silent => false);
2023-08-01 17:01:40.539 +07 client backend[296573] pg_regress/json ERROR:  expected JSON array
2023-08-01 17:01:40.539 +07 client backend[296573] pg_regress/json HINT:  See the array element [1] of key "ia".
2023-08-01 17:01:40.539 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT ia FROM json_populate_record(NULL::jsrec, '{"ia": [[1], 2]}') q;
2023-08-01 17:01:40.539 +07 client backend[296573] pg_regress/json ERROR:  malformed JSON array
2023-08-01 17:01:40.539 +07 client backend[296573] pg_regress/json DETAIL:  Multidimensional arrays must have sub-arrays with matching dimensions.
2023-08-01 17:01:40.539 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT ia FROM json_populate_record(NULL::jsrec, '{"ia": [[1], [2, 3]]}') q;
2023-08-01 17:01:40.539 +07 client backend[296573] pg_regress/json ERROR:  expected JSON array
2023-08-01 17:01:40.539 +07 client backend[296573] pg_regress/json HINT:  See the value of key "ia1".
2023-08-01 17:01:40.539 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT ia1 FROM json_populate_record(NULL::jsrec, '{"ia1": 123}') q;
2023-08-01 17:01:40.540 +07 client backend[296574] pg_regress/jsonb ERROR:  field name must not be null
2023-08-01 17:01:40.540 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT jsonb_object_agg(name, type) FROM foo;
2023-08-01 17:01:40.540 +07 client backend[296573] pg_regress/json ERROR:  expected JSON array
2023-08-01 17:01:40.540 +07 client backend[296573] pg_regress/json HINT:  See the value of key "ia1d".
2023-08-01 17:01:40.540 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT ia1d FROM json_populate_record(NULL::jsrec, '{"ia1d": 123}') q;
2023-08-01 17:01:40.540 +07 client backend[296573] pg_regress/json ERROR:  value for domain js_int_array_1d violates check constraint "js_int_array_1d_check"
2023-08-01 17:01:40.540 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT ia1d FROM json_populate_record(NULL::jsrec, '{"ia1d": [1, "2", null, 4]}') q;
2023-08-01 17:01:40.540 +07 client backend[296574] pg_regress/jsonb ERROR:  array must have even number of elements
2023-08-01 17:01:40.540 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT jsonb_object('{a,b,c}');
2023-08-01 17:01:40.540 +07 client backend[296574] pg_regress/jsonb ERROR:  array must have two columns
2023-08-01 17:01:40.540 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT jsonb_object('{{a},{b}}');
2023-08-01 17:01:40.540 +07 client backend[296574] pg_regress/jsonb ERROR:  array must have two columns
2023-08-01 17:01:40.540 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT jsonb_object('{{a,b,c},{b,c,d}}');
2023-08-01 17:01:40.540 +07 client backend[296574] pg_regress/jsonb ERROR:  wrong number of array subscripts
2023-08-01 17:01:40.540 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT jsonb_object('{{{a,b},{c,d}},{{b,c},{d,e}}}');
2023-08-01 17:01:40.540 +07 client backend[296573] pg_regress/json ERROR:  malformed JSON array
2023-08-01 17:01:40.540 +07 client backend[296573] pg_regress/json DETAIL:  Multidimensional arrays must have sub-arrays with matching dimensions.
2023-08-01 17:01:40.540 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT ia2 FROM json_populate_record(NULL::jsrec, '{"ia2": [[1, 2], [3]]}') q;
2023-08-01 17:01:40.540 +07 client backend[296574] pg_regress/jsonb ERROR:  wrong number of array subscripts
2023-08-01 17:01:40.540 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT jsonb_object('{{a,1},{b,2},{3,NULL},{"d e f","a b c"}}', '{{a,1},{b,2},{3,NULL},{"d e f","a b c"}}');
2023-08-01 17:01:40.540 +07 client backend[296573] pg_regress/json ERROR:  expected JSON array
2023-08-01 17:01:40.540 +07 client backend[296573] pg_regress/json HINT:  See the array element [1] of key "ia2".
2023-08-01 17:01:40.540 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT ia2 FROM json_populate_record(NULL::jsrec, '{"ia2": [[1, 2], 3, 4]}') q;
2023-08-01 17:01:40.540 +07 client backend[296574] pg_regress/jsonb ERROR:  mismatched array dimensions
2023-08-01 17:01:40.540 +07 client backend[296574] pg_regress/jsonb STATEMENT:  select jsonb_object('{a,b,c,"d e f",g}','{1,2,3,"a b c"}');
2023-08-01 17:01:40.540 +07 client backend[296573] pg_regress/json ERROR:  value for domain js_int_array_2d violates check constraint "js_int_array_2d_check"
2023-08-01 17:01:40.540 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT ia2d FROM json_populate_record(NULL::jsrec, '{"ia2d": [[1, "2"], [null, 4]]}') q;
2023-08-01 17:01:40.540 +07 client backend[296574] pg_regress/jsonb ERROR:  mismatched array dimensions
2023-08-01 17:01:40.540 +07 client backend[296574] pg_regress/jsonb STATEMENT:  select jsonb_object('{a,b,c,"d e f"}','{1,2,3,"a b c",g}');
2023-08-01 17:01:40.540 +07 client backend[296574] pg_regress/jsonb ERROR:  null value not allowed for object key
2023-08-01 17:01:40.540 +07 client backend[296574] pg_regress/jsonb STATEMENT:  select jsonb_object('{a,b,NULL,"d e f"}','{1,2,3,"a b c"}');
2023-08-01 17:01:40.541 +07 client backend[296573] pg_regress/json ERROR:  malformed JSON array
2023-08-01 17:01:40.541 +07 client backend[296573] pg_regress/json DETAIL:  Multidimensional arrays must have sub-arrays with matching dimensions.
2023-08-01 17:01:40.541 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT ia3 FROM json_populate_record(NULL::jsrec, '{"ia3": [ [[1, 2], [3, 4]], [[5, 6], [7, 8], [9, 10]] ]}') q;
2023-08-01 17:01:40.541 +07 client backend[296573] pg_regress/json ERROR:  expected JSON array
2023-08-01 17:01:40.541 +07 client backend[296573] pg_regress/json HINT:  See the value of key "ta".
2023-08-01 17:01:40.541 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT ta FROM json_populate_record(NULL::jsrec, '{"ta": 123}') q;
2023-08-01 17:01:40.541 +07 client backend[296573] pg_regress/json ERROR:  expected JSON array
2023-08-01 17:01:40.541 +07 client backend[296573] pg_regress/json HINT:  See the array element [1] of key "ta".
2023-08-01 17:01:40.541 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT ta FROM json_populate_record(NULL::jsrec, '{"ta": [[1, 2, 3], {"k": "v"}]}') q;
2023-08-01 17:01:40.542 +07 client backend[296573] pg_regress/json ERROR:  value too long for type character(10)
2023-08-01 17:01:40.542 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT c FROM json_populate_record(NULL::jsrec, '{"c": "aaaaaaaaaaaaa"}') q;
2023-08-01 17:01:40.542 +07 client backend[296573] pg_regress/json ERROR:  expected JSON array
2023-08-01 17:01:40.542 +07 client backend[296573] pg_regress/json HINT:  See the value of key "ca".
2023-08-01 17:01:40.542 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT ca FROM json_populate_record(NULL::jsrec, '{"ca": 123}') q;
2023-08-01 17:01:40.542 +07 client backend[296573] pg_regress/json ERROR:  value too long for type character(10)
2023-08-01 17:01:40.542 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT ca FROM json_populate_record(NULL::jsrec, '{"ca": ["aaaaaaaaaaaaaaaa"]}') q;
2023-08-01 17:01:40.542 +07 client backend[296573] pg_regress/json ERROR:  expected JSON array
2023-08-01 17:01:40.542 +07 client backend[296573] pg_regress/json HINT:  See the array element [1] of key "ca".
2023-08-01 17:01:40.542 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT ca FROM json_populate_record(NULL::jsrec, '{"ca": [[1, 2, 3], {"k": "v"}]}') q;
2023-08-01 17:01:40.543 +07 client backend[296573] pg_regress/json ERROR:  expected JSON array
2023-08-01 17:01:40.543 +07 client backend[296573] pg_regress/json HINT:  See the value of key "jsa".
2023-08-01 17:01:40.543 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT jsa FROM json_populate_record(NULL::jsrec, '{"jsa": 123}') q;
2023-08-01 17:01:40.544 +07 client backend[296573] pg_regress/json ERROR:  cannot call populate_composite on a scalar
2023-08-01 17:01:40.544 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT rec FROM json_populate_record(NULL::jsrec, '{"rec": 123}') q;
2023-08-01 17:01:40.544 +07 client backend[296573] pg_regress/json ERROR:  cannot call populate_composite on an array
2023-08-01 17:01:40.544 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT rec FROM json_populate_record(NULL::jsrec, '{"rec": [1, 2]}') q;
2023-08-01 17:01:40.544 +07 client backend[296573] pg_regress/json ERROR:  expected JSON array
2023-08-01 17:01:40.544 +07 client backend[296573] pg_regress/json HINT:  See the value of key "reca".
2023-08-01 17:01:40.544 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT reca FROM json_populate_record(NULL::jsrec, '{"reca": 123}') q;
2023-08-01 17:01:40.544 +07 client backend[296573] pg_regress/json ERROR:  cannot call populate_composite on a scalar
2023-08-01 17:01:40.544 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT reca FROM json_populate_record(NULL::jsrec, '{"reca": [1, 2]}') q;
2023-08-01 17:01:40.545 +07 client backend[296573] pg_regress/json ERROR:  could not determine row type for result of json_populate_record
2023-08-01 17:01:40.545 +07 client backend[296573] pg_regress/json HINT:  Provide a non-null record argument, or call the function in the FROM clause using a column definition list.
2023-08-01 17:01:40.545 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT json_populate_record(null::record, '{"x": 0, "y": 1}');
2023-08-01 17:01:40.545 +07 client backend[296573] pg_regress/json ERROR:  value for domain j_ordered_pair violates check constraint "j_ordered_pair_check"
2023-08-01 17:01:40.545 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT json_populate_record(row(1,2)::j_ordered_pair, '{"x": 1, "y": 0}');
2023-08-01 17:01:40.546 +07 client backend[296573] pg_regress/json ERROR:  invalid input syntax for type timestamp: "[100,200,300]"
2023-08-01 17:01:40.546 +07 client backend[296573] pg_regress/json STATEMENT:  select * from json_populate_recordset(row('def',99,null)::jpop,'[{"c":[100,200,300],"x":43.2},{"a":{"z":true},"b":3,"c":"2012-01-20 10:42:53"}]') q;
2023-08-01 17:01:40.546 +07 client backend[296573] pg_regress/json ERROR:  could not determine row type for result of json_populate_recordset
2023-08-01 17:01:40.546 +07 client backend[296573] pg_regress/json HINT:  Provide a non-null record argument, or call the function in the FROM clause using a column definition list.
2023-08-01 17:01:40.546 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT json_populate_recordset(null::record, '[{"x": 0, "y": 1}]');
2023-08-01 17:01:40.547 +07 client backend[296573] pg_regress/json ERROR:  could not determine row type for result of json_populate_recordset
2023-08-01 17:01:40.547 +07 client backend[296573] pg_regress/json HINT:  Provide a non-null record argument, or call the function in the FROM clause using a column definition list.
2023-08-01 17:01:40.547 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT json_populate_recordset(null::record, '[]');
2023-08-01 17:01:40.547 +07 client backend[296573] pg_regress/json ERROR:  value for domain j_ordered_pair violates check constraint "j_ordered_pair_check"
2023-08-01 17:01:40.547 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT json_populate_recordset(row(1,2)::j_ordered_pair, '[{"x": 1, "y": 0}]');
2023-08-01 17:01:40.547 +07 client backend[296573] pg_regress/json ERROR:  function return row and query-specified return row do not match
2023-08-01 17:01:40.547 +07 client backend[296573] pg_regress/json DETAIL:  Returned row contains 1 attribute, but query expects 2.
2023-08-01 17:01:40.547 +07 client backend[296573] pg_regress/json STATEMENT:  select * from json_populate_recordset(row(0::int),'[{"a":"1","b":"2"},{"a":"3"}]') q (a text, b text);
2023-08-01 17:01:40.547 +07 client backend[296573] pg_regress/json ERROR:  function return row and query-specified return row do not match
2023-08-01 17:01:40.547 +07 client backend[296573] pg_regress/json DETAIL:  Returned type integer at ordinal position 1, but query expects text.
2023-08-01 17:01:40.547 +07 client backend[296573] pg_regress/json STATEMENT:  select * from json_populate_recordset(row(0::int,0::int),'[{"a":"1","b":"2"},{"a":"3"}]') q (a text, b text);
2023-08-01 17:01:40.548 +07 client backend[296573] pg_regress/json ERROR:  function return row and query-specified return row do not match
2023-08-01 17:01:40.548 +07 client backend[296573] pg_regress/json DETAIL:  Returned row contains 3 attributes, but query expects 2.
2023-08-01 17:01:40.548 +07 client backend[296573] pg_regress/json STATEMENT:  select * from json_populate_recordset(row(0::int,0::int,0::int),'[{"a":"1","b":"2"},{"a":"3"}]') q (a text, b text);
2023-08-01 17:01:40.548 +07 client backend[296573] pg_regress/json ERROR:  function return row and query-specified return row do not match
2023-08-01 17:01:40.548 +07 client backend[296573] pg_regress/json DETAIL:  Returned type integer at ordinal position 1, but query expects text.
2023-08-01 17:01:40.548 +07 client backend[296573] pg_regress/json STATEMENT:  select * from json_populate_recordset(row(1000000000::int,50::int),'[{"b":"2"},{"a":"3"}]') q (a text, b text);
2023-08-01 17:01:40.549 +07 client backend[296574] pg_regress/jsonb ERROR:  invalid input syntax for type timestamp: "[100, 200, false]"
2023-08-01 17:01:40.549 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT * FROM jsonb_populate_record(row('x',3,'2012-12-31 15:30:56')::jbpop,'{"c":[100,200,false],"x":43.2}') q;
2023-08-01 17:01:40.549 +07 client backend[296574] pg_regress/jsonb ERROR:  domain jsb_int_not_null does not allow null values
2023-08-01 17:01:40.549 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT i FROM jsonb_populate_record(NULL::jsbrec_i_not_null, '{"x": 43.2}') q;
2023-08-01 17:01:40.549 +07 client backend[296574] pg_regress/jsonb ERROR:  domain jsb_int_not_null does not allow null values
2023-08-01 17:01:40.549 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT i FROM jsonb_populate_record(NULL::jsbrec_i_not_null, '{"i": null}') q;
2023-08-01 17:01:40.549 +07 client backend[296574] pg_regress/jsonb ERROR:  expected JSON array
2023-08-01 17:01:40.549 +07 client backend[296574] pg_regress/jsonb HINT:  See the value of key "ia".
2023-08-01 17:01:40.549 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT ia FROM jsonb_populate_record(NULL::jsbrec, '{"ia": 123}') q;
2023-08-01 17:01:40.549 +07 client backend[296574] pg_regress/jsonb ERROR:  expected JSON array
2023-08-01 17:01:40.549 +07 client backend[296574] pg_regress/jsonb HINT:  See the array element [1] of key "ia".
2023-08-01 17:01:40.549 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT ia FROM jsonb_populate_record(NULL::jsbrec, '{"ia": [[1], 2]}') q;
2023-08-01 17:01:40.549 +07 client backend[296574] pg_regress/jsonb ERROR:  malformed JSON array
2023-08-01 17:01:40.549 +07 client backend[296574] pg_regress/jsonb DETAIL:  Multidimensional arrays must have sub-arrays with matching dimensions.
2023-08-01 17:01:40.549 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT ia FROM jsonb_populate_record(NULL::jsbrec, '{"ia": [[1], [2, 3]]}') q;
2023-08-01 17:01:40.550 +07 client backend[296574] pg_regress/jsonb ERROR:  expected JSON array
2023-08-01 17:01:40.550 +07 client backend[296574] pg_regress/jsonb HINT:  See the value of key "ia1".
2023-08-01 17:01:40.550 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT ia1 FROM jsonb_populate_record(NULL::jsbrec, '{"ia1": 123}') q;
2023-08-01 17:01:40.550 +07 client backend[296574] pg_regress/jsonb ERROR:  expected JSON array
2023-08-01 17:01:40.550 +07 client backend[296574] pg_regress/jsonb HINT:  See the value of key "ia1d".
2023-08-01 17:01:40.550 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT ia1d FROM jsonb_populate_record(NULL::jsbrec, '{"ia1d": 123}') q;
2023-08-01 17:01:40.550 +07 client backend[296574] pg_regress/jsonb ERROR:  value for domain jsb_int_array_1d violates check constraint "jsb_int_array_1d_check"
2023-08-01 17:01:40.550 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT ia1d FROM jsonb_populate_record(NULL::jsbrec, '{"ia1d": [1, "2", null, 4]}') q;
2023-08-01 17:01:40.551 +07 client backend[296574] pg_regress/jsonb ERROR:  malformed JSON array
2023-08-01 17:01:40.551 +07 client backend[296574] pg_regress/jsonb DETAIL:  Multidimensional arrays must have sub-arrays with matching dimensions.
2023-08-01 17:01:40.551 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT ia2 FROM jsonb_populate_record(NULL::jsbrec, '{"ia2": [[1, 2], [3]]}') q;
2023-08-01 17:01:40.551 +07 client backend[296574] pg_regress/jsonb ERROR:  expected JSON array
2023-08-01 17:01:40.551 +07 client backend[296574] pg_regress/jsonb HINT:  See the array element [1] of key "ia2".
2023-08-01 17:01:40.551 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT ia2 FROM jsonb_populate_record(NULL::jsbrec, '{"ia2": [[1, 2], 3, 4]}') q;
2023-08-01 17:01:40.551 +07 client backend[296574] pg_regress/jsonb ERROR:  value for domain jsb_int_array_2d violates check constraint "jsb_int_array_2d_check"
2023-08-01 17:01:40.551 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT ia2d FROM jsonb_populate_record(NULL::jsbrec, '{"ia2d": [[1, "2"], [null, 4]]}') q;
2023-08-01 17:01:40.551 +07 client backend[296574] pg_regress/jsonb ERROR:  malformed JSON array
2023-08-01 17:01:40.551 +07 client backend[296574] pg_regress/jsonb DETAIL:  Multidimensional arrays must have sub-arrays with matching dimensions.
2023-08-01 17:01:40.551 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT ia3 FROM jsonb_populate_record(NULL::jsbrec, '{"ia3": [ [[1, 2], [3, 4]], [[5, 6], [7, 8], [9, 10]] ]}') q;
2023-08-01 17:01:40.551 +07 client backend[296574] pg_regress/jsonb ERROR:  expected JSON array
2023-08-01 17:01:40.551 +07 client backend[296574] pg_regress/jsonb HINT:  See the value of key "ta".
2023-08-01 17:01:40.551 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT ta FROM jsonb_populate_record(NULL::jsbrec, '{"ta": 123}') q;
2023-08-01 17:01:40.552 +07 client backend[296574] pg_regress/jsonb ERROR:  expected JSON array
2023-08-01 17:01:40.552 +07 client backend[296574] pg_regress/jsonb HINT:  See the array element [1] of key "ta".
2023-08-01 17:01:40.552 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT ta FROM jsonb_populate_record(NULL::jsbrec, '{"ta": [[1, 2, 3], {"k": "v"}]}') q;
2023-08-01 17:01:40.552 +07 client backend[296573] pg_regress/json ERROR:  argument list must have even number of elements
2023-08-01 17:01:40.552 +07 client backend[296573] pg_regress/json HINT:  The arguments of json_build_object() must consist of alternating keys and values.
2023-08-01 17:01:40.552 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT json_build_object('{a,b,c}'::text[]);
2023-08-01 17:01:40.552 +07 client backend[296573] pg_regress/json ERROR:  key value must be scalar, not array, composite, or json
2023-08-01 17:01:40.552 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT json_build_object('{a,b,c}'::text[], '{d,e,f}'::text[]);
2023-08-01 17:01:40.552 +07 client backend[296573] pg_regress/json ERROR:  argument list must have even number of elements
2023-08-01 17:01:40.552 +07 client backend[296573] pg_regress/json HINT:  The arguments of json_build_object() must consist of alternating keys and values.
2023-08-01 17:01:40.552 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT json_build_object('a', 'b', 'c');
2023-08-01 17:01:40.552 +07 client backend[296573] pg_regress/json ERROR:  argument 1 cannot be null
2023-08-01 17:01:40.552 +07 client backend[296573] pg_regress/json HINT:  Object keys should be text.
2023-08-01 17:01:40.552 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT json_build_object(NULL, 'a');
2023-08-01 17:01:40.552 +07 client backend[296574] pg_regress/jsonb ERROR:  value too long for type character(10)
2023-08-01 17:01:40.552 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT c FROM jsonb_populate_record(NULL::jsbrec, '{"c": "aaaaaaaaaaaaa"}') q;
2023-08-01 17:01:40.552 +07 client backend[296574] pg_regress/jsonb ERROR:  expected JSON array
2023-08-01 17:01:40.552 +07 client backend[296574] pg_regress/jsonb HINT:  See the value of key "ca".
2023-08-01 17:01:40.552 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT ca FROM jsonb_populate_record(NULL::jsbrec, '{"ca": 123}') q;
2023-08-01 17:01:40.552 +07 client backend[296573] pg_regress/json ERROR:  argument list must have even number of elements
2023-08-01 17:01:40.552 +07 client backend[296573] pg_regress/json HINT:  The arguments of json_build_object() must consist of alternating keys and values.
2023-08-01 17:01:40.552 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT json_build_object(VARIADIC '{a,b,c}'::text[]);
2023-08-01 17:01:40.552 +07 client backend[296574] pg_regress/jsonb ERROR:  value too long for type character(10)
2023-08-01 17:01:40.552 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT ca FROM jsonb_populate_record(NULL::jsbrec, '{"ca": ["aaaaaaaaaaaaaaaa"]}') q;
2023-08-01 17:01:40.552 +07 client backend[296573] pg_regress/json ERROR:  argument 1 cannot be null
2023-08-01 17:01:40.552 +07 client backend[296573] pg_regress/json HINT:  Object keys should be text.
2023-08-01 17:01:40.552 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT json_build_object(VARIADIC ARRAY[NULL, 'a']::text[]);
2023-08-01 17:01:40.552 +07 client backend[296574] pg_regress/jsonb ERROR:  expected JSON array
2023-08-01 17:01:40.552 +07 client backend[296574] pg_regress/jsonb HINT:  See the array element [1] of key "ca".
2023-08-01 17:01:40.552 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT ca FROM jsonb_populate_record(NULL::jsbrec, '{"ca": [[1, 2, 3], {"k": "v"}]}') q;
2023-08-01 17:01:40.553 +07 client backend[296573] pg_regress/json ERROR:  argument 1 cannot be null
2023-08-01 17:01:40.553 +07 client backend[296573] pg_regress/json HINT:  Object keys should be text.
2023-08-01 17:01:40.553 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT json_build_object(null,2);
2023-08-01 17:01:40.553 +07 client backend[296573] pg_regress/json ERROR:  key value must be scalar, not array, composite, or json
2023-08-01 17:01:40.553 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT json_build_object(r,2) FROM (SELECT 1 AS a, 2 AS b) r;
2023-08-01 17:01:40.553 +07 client backend[296573] pg_regress/json ERROR:  key value must be scalar, not array, composite, or json
2023-08-01 17:01:40.553 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT json_build_object(json '{"a":1,"b":2}', 3);
2023-08-01 17:01:40.553 +07 client backend[296573] pg_regress/json ERROR:  key value must be scalar, not array, composite, or json
2023-08-01 17:01:40.553 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT json_build_object('{1,2,3}'::int[], 3);
2023-08-01 17:01:40.554 +07 client backend[296574] pg_regress/jsonb ERROR:  expected JSON array
2023-08-01 17:01:40.554 +07 client backend[296574] pg_regress/jsonb HINT:  See the value of key "jsa".
2023-08-01 17:01:40.554 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT jsa FROM jsonb_populate_record(NULL::jsbrec, '{"jsa": 123}') q;
2023-08-01 17:01:40.554 +07 client backend[296574] pg_regress/jsonb ERROR:  cannot call populate_composite on a scalar
2023-08-01 17:01:40.554 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT rec FROM jsonb_populate_record(NULL::jsbrec, '{"rec": 123}') q;
2023-08-01 17:01:40.554 +07 client backend[296574] pg_regress/jsonb ERROR:  cannot call populate_composite on an array
2023-08-01 17:01:40.554 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT rec FROM jsonb_populate_record(NULL::jsbrec, '{"rec": [1, 2]}') q;
2023-08-01 17:01:40.554 +07 client backend[296573] pg_regress/json ERROR:  field name must not be null
2023-08-01 17:01:40.554 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT json_object_agg(name, type) FROM foo;
2023-08-01 17:01:40.554 +07 client backend[296574] pg_regress/jsonb ERROR:  expected JSON array
2023-08-01 17:01:40.554 +07 client backend[296574] pg_regress/jsonb HINT:  See the value of key "reca".
2023-08-01 17:01:40.554 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT reca FROM jsonb_populate_record(NULL::jsbrec, '{"reca": 123}') q;
2023-08-01 17:01:40.554 +07 client backend[296574] pg_regress/jsonb ERROR:  cannot call populate_composite on a scalar
2023-08-01 17:01:40.554 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT reca FROM jsonb_populate_record(NULL::jsbrec, '{"reca": [1, 2]}') q;
2023-08-01 17:01:40.555 +07 client backend[296573] pg_regress/json ERROR:  array must have even number of elements
2023-08-01 17:01:40.555 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT json_object('{a,b,c}');
2023-08-01 17:01:40.555 +07 client backend[296573] pg_regress/json ERROR:  array must have two columns
2023-08-01 17:01:40.555 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT json_object('{{a},{b}}');
2023-08-01 17:01:40.555 +07 client backend[296573] pg_regress/json ERROR:  array must have two columns
2023-08-01 17:01:40.555 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT json_object('{{a,b,c},{b,c,d}}');
2023-08-01 17:01:40.555 +07 client backend[296573] pg_regress/json ERROR:  wrong number of array subscripts
2023-08-01 17:01:40.555 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT json_object('{{{a,b},{c,d}},{{b,c},{d,e}}}');
2023-08-01 17:01:40.555 +07 client backend[296573] pg_regress/json ERROR:  wrong number of array subscripts
2023-08-01 17:01:40.555 +07 client backend[296573] pg_regress/json STATEMENT:  SELECT json_object('{{a,1},{b,2},{3,NULL},{"d e f","a b c"}}', '{{a,1},{b,2},{3,NULL},{"d e f","a b c"}}');
2023-08-01 17:01:40.555 +07 client backend[296574] pg_regress/jsonb ERROR:  could not determine row type for result of jsonb_populate_record
2023-08-01 17:01:40.555 +07 client backend[296574] pg_regress/jsonb HINT:  Provide a non-null record argument, or call the function in the FROM clause using a column definition list.
2023-08-01 17:01:40.555 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT jsonb_populate_record(null::record, '{"x": 0, "y": 1}');
2023-08-01 17:01:40.555 +07 client backend[296573] pg_regress/json ERROR:  mismatched array dimensions
2023-08-01 17:01:40.555 +07 client backend[296573] pg_regress/json STATEMENT:  select json_object('{a,b,c,"d e f",g}','{1,2,3,"a b c"}');
2023-08-01 17:01:40.555 +07 client backend[296573] pg_regress/json ERROR:  mismatched array dimensions
2023-08-01 17:01:40.555 +07 client backend[296573] pg_regress/json STATEMENT:  select json_object('{a,b,c,"d e f"}','{1,2,3,"a b c",g}');
2023-08-01 17:01:40.555 +07 client backend[296573] pg_regress/json ERROR:  null value not allowed for object key
2023-08-01 17:01:40.555 +07 client backend[296573] pg_regress/json STATEMENT:  select json_object('{a,b,NULL,"d e f"}','{1,2,3,"a b c"}');
2023-08-01 17:01:40.555 +07 client backend[296574] pg_regress/jsonb ERROR:  value for domain jb_ordered_pair violates check constraint "jb_ordered_pair_check"
2023-08-01 17:01:40.555 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT jsonb_populate_record(row(1,2)::jb_ordered_pair, '{"x": 1, "y": 0}');
2023-08-01 17:01:40.556 +07 client backend[296573] pg_regress/json ERROR:  expected JSON array
2023-08-01 17:01:40.556 +07 client backend[296573] pg_regress/json HINT:  See the value of key "ia".
2023-08-01 17:01:40.556 +07 client backend[296573] pg_regress/json STATEMENT:  select * from json_to_record('{"ia": 123}') as x(ia _int4);
2023-08-01 17:01:40.556 +07 client backend[296574] pg_regress/jsonb ERROR:  invalid input syntax for type timestamp: "[100, 200, 300]"
2023-08-01 17:01:40.556 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT * FROM jsonb_populate_recordset(row('def',99,NULL)::jbpop,'[{"c":[100,200,300],"x":43.2},{"a":{"z":true},"b":3,"c":"2012-01-20 10:42:53"}]') q;
2023-08-01 17:01:40.556 +07 client backend[296573] pg_regress/json ERROR:  expected JSON array
2023-08-01 17:01:40.556 +07 client backend[296573] pg_regress/json HINT:  See the array element [1] of key "ia".
2023-08-01 17:01:40.556 +07 client backend[296573] pg_regress/json STATEMENT:  select * from json_to_record('{"ia": [[1], 2]}') as x(ia _int4);
2023-08-01 17:01:40.556 +07 client backend[296573] pg_regress/json ERROR:  malformed JSON array
2023-08-01 17:01:40.556 +07 client backend[296573] pg_regress/json DETAIL:  Multidimensional arrays must have sub-arrays with matching dimensions.
2023-08-01 17:01:40.556 +07 client backend[296573] pg_regress/json STATEMENT:  select * from json_to_record('{"ia": [[1], [2, 3]]}') as x(ia _int4);
2023-08-01 17:01:40.556 +07 client backend[296574] pg_regress/jsonb ERROR:  could not determine row type for result of jsonb_populate_recordset
2023-08-01 17:01:40.556 +07 client backend[296574] pg_regress/jsonb HINT:  Provide a non-null record argument, or call the function in the FROM clause using a column definition list.
2023-08-01 17:01:40.556 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT jsonb_populate_recordset(null::record, '[{"x": 0, "y": 1}]');
2023-08-01 17:01:40.557 +07 client backend[296574] pg_regress/jsonb ERROR:  could not determine row type for result of jsonb_populate_recordset
2023-08-01 17:01:40.557 +07 client backend[296574] pg_regress/jsonb HINT:  Provide a non-null record argument, or call the function in the FROM clause using a column definition list.
2023-08-01 17:01:40.557 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT jsonb_populate_recordset(null::record, '[]');
2023-08-01 17:01:40.557 +07 client backend[296574] pg_regress/jsonb ERROR:  value for domain jb_ordered_pair violates check constraint "jb_ordered_pair_check"
2023-08-01 17:01:40.557 +07 client backend[296574] pg_regress/jsonb STATEMENT:  SELECT jsonb_populate_recordset(row(1,2)::jb_ordered_pair, '[{"x": 1, "y": 0}]');
2023-08-01 17:01:40.557 +07 client backend[296574] pg_regress/jsonb ERROR:  function return row and query-specified return row do not match
2023-08-01 17:01:40.557 +07 client backend[296574] pg_regress/jsonb DETAIL:  Returned row contains 1 attribute, but query expects 2.
2023-08-01 17:01:40.557 +07 client backend[296574] pg_regress/jsonb STATEMENT:  select * from jsonb_populate_recordset(row(0::int),'[{"a":"1","b":"2"},{"a":"3"}]') q (a text, b text);
2023-08-01 17:01:40.557 +07 client backend[296574] pg_regress/jsonb ERROR:  function return row and query-specified return row do not match
2023-08-01 17:01:40.557 +07 client backend[296574] pg_regress/jsonb DETAIL:  Returned type integer at ordinal position 1, but query expects text.
2023-08-01 17:01:40.557 +07 client backend[296574] pg_regress/jsonb STATEMENT:  select * from jsonb_populate_recordset(row(0::int,0::int),'[{"a":"1","b":"2"},{"a":"3"}]') q (a text, b text);
2023-08-01 17:01:40.557 +07 client backend[296574] pg_regress/jsonb ERROR:  function return row and query-specified return row do not match
2023-08-01 17:01:40.557 +07 client backend[296574] pg_regress/jsonb DETAIL:  Returned row contains 3 attributes, but query expects 2.
2023-08-01 17:01:40.557 +07 client backend[296574] pg_regress/jsonb STATEMENT:  select * from jsonb_populate_recordset(row(0::int,0::int,0::int),'[{"a":"1","b":"2"},{"a":"3"}]') q (a text, b text);
2023-08-01 17:01:40.557 +07 client backend[296574] pg_regress/jsonb ERROR:  function return row and query-specified return row do not match
2023-08-01 17:01:40.557 +07 client backend[296574] pg_regress/jsonb DETAIL:  Returned type integer at ordinal position 1, but query expects text.
2023-08-01 17:01:40.557 +07 client backend[296574] pg_regress/jsonb STATEMENT:  select * from jsonb_populate_recordset(row(1000000000::int,50::int),'[{"b":"2"},{"a":"3"}]') q (a text, b text);
2023-08-01 17:01:40.558 +07 client backend[296574] pg_regress/jsonb ERROR:  expected JSON array
2023-08-01 17:01:40.558 +07 client backend[296574] pg_regress/jsonb HINT:  See the value of key "ia".
2023-08-01 17:01:40.558 +07 client backend[296574] pg_regress/jsonb STATEMENT:  select * from jsonb_to_record('{"ia": 123}') as x(ia _int4);
2023-08-01 17:01:40.558 +07 client backend[296574] pg_regress/jsonb ERROR:  expected JSON array
2023-08-01 17:01:40.558 +07 client backend[296574] pg_regress/jsonb HINT:  See the array element [1] of key "ia".
2023-08-01 17:01:40.558 +07 client backend[296574] pg_regress/jsonb STATEMENT:  select * from jsonb_to_record('{"ia": [[1], 2]}') as x(ia _int4);
2023-08-01 17:01:40.558 +07 client backend[296574] pg_regress/jsonb ERROR:  malformed JSON array
2023-08-01 17:01:40.558 +07 client backend[296574] pg_regress/jsonb DETAIL:  Multidimensional arrays must have sub-arrays with matching dimensions.
2023-08-01 17:01:40.558 +07 client backend[296574] pg_regress/jsonb STATEMENT:  select * from jsonb_to_record('{"ia": [[1], [2, 3]]}') as x(ia _int4);
2023-08-01 17:01:40.560 +07 client backend[296573] pg_regress/json ERROR:  wrong flag in flag array: ""
2023-08-01 17:01:40.560 +07 client backend[296573] pg_regress/json HINT:  Possible values are: "string", "numeric", "boolean", "key", and "all".
2023-08-01 17:01:40.560 +07 client backend[296573] pg_regress/json STATEMENT:  select json_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::json, '""');
2023-08-01 17:01:40.560 +07 client backend[296573] pg_regress/json ERROR:  wrong flag type, only arrays and scalars are allowed
2023-08-01 17:01:40.560 +07 client backend[296573] pg_regress/json STATEMENT:  select json_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::json, '{}');
2023-08-01 17:01:40.560 +07 client backend[296573] pg_regress/json ERROR:  flag array element is not a string
2023-08-01 17:01:40.560 +07 client backend[296573] pg_regress/json HINT:  Possible values are: "string", "numeric", "boolean", "key", and "all".
2023-08-01 17:01:40.560 +07 client backend[296573] pg_regress/json STATEMENT:  select json_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::json, 'null');
2023-08-01 17:01:40.560 +07 client backend[296573] pg_regress/json ERROR:  flag array element is not a string
2023-08-01 17:01:40.560 +07 client backend[296573] pg_regress/json HINT:  Possible values are: "string", "numeric", "boolean", "key", and "all".
2023-08-01 17:01:40.560 +07 client backend[296573] pg_regress/json STATEMENT:  select json_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::json, '["all", null]');
2023-08-01 17:01:40.622 +07 client backend[296574] pg_regress/jsonb ERROR:  path element at position 2 is null
2023-08-01 17:01:40.622 +07 client backend[296574] pg_regress/jsonb STATEMENT:  select jsonb_set('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb, '{d,NULL,0}', '[1,2,3]');
2023-08-01 17:01:40.622 +07 client backend[296574] pg_regress/jsonb ERROR:  path element at position 2 is null
2023-08-01 17:01:40.622 +07 client backend[296574] pg_regress/jsonb STATEMENT:  select jsonb_set('{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb, '{d,NULL,0}', '{"1": 2}');
2023-08-01 17:01:40.623 +07 client backend[296574] pg_regress/jsonb ERROR:  path element at position 2 is not an integer: "-1e"
2023-08-01 17:01:40.623 +07 client backend[296574] pg_regress/jsonb STATEMENT:  select '{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb #- '{b,-1e}';
2023-08-01 17:01:40.623 +07 client backend[296574] pg_regress/jsonb ERROR:  cannot delete from scalar
2023-08-01 17:01:40.623 +07 client backend[296574] pg_regress/jsonb STATEMENT:  select '"a"'::jsonb - 'a';
2023-08-01 17:01:40.623 +07 client backend[296574] pg_regress/jsonb ERROR:  cannot delete from scalar
2023-08-01 17:01:40.623 +07 client backend[296574] pg_regress/jsonb STATEMENT:  select '"a"'::jsonb - 1;
2023-08-01 17:01:40.623 +07 client backend[296574] pg_regress/jsonb ERROR:  cannot delete from object using integer index
2023-08-01 17:01:40.623 +07 client backend[296574] pg_regress/jsonb STATEMENT:  select '{}'::jsonb -  1;
2023-08-01 17:01:40.623 +07 client backend[296574] pg_regress/jsonb ERROR:  cannot delete path in scalar
2023-08-01 17:01:40.623 +07 client backend[296574] pg_regress/jsonb STATEMENT:  select '"a"'::jsonb #- '{a}';
2023-08-01 17:01:40.624 +07 client backend[296574] pg_regress/jsonb ERROR:  cannot set path in scalar
2023-08-01 17:01:40.624 +07 client backend[296574] pg_regress/jsonb STATEMENT:  select jsonb_set('"a"','{a}','"b"');
2023-08-01 17:01:40.625 +07 client backend[296574] pg_regress/jsonb ERROR:  path element at position 2 is not an integer: "non_integer"
2023-08-01 17:01:40.625 +07 client backend[296574] pg_regress/jsonb STATEMENT:  select jsonb_set('{"a": [1, 2, 3]}', '{a, non_integer}', '"new_value"');
2023-08-01 17:01:40.625 +07 client backend[296574] pg_regress/jsonb ERROR:  path element at position 3 is not an integer: "non_integer"
2023-08-01 17:01:40.625 +07 client backend[296574] pg_regress/jsonb STATEMENT:  select jsonb_set('{"a": {"b": [1, 2, 3]}}', '{a, b, non_integer}', '"new_value"');
2023-08-01 17:01:40.625 +07 client backend[296574] pg_regress/jsonb ERROR:  path element at position 3 is null
2023-08-01 17:01:40.625 +07 client backend[296574] pg_regress/jsonb STATEMENT:  select jsonb_set('{"a": {"b": [1, 2, 3]}}', '{a, b, NULL}', '"new_value"');
2023-08-01 17:01:40.625 +07 client backend[296574] pg_regress/jsonb ERROR:  null_value_treatment must be "delete_key", "return_target", "use_json_null", or "raise_exception"
2023-08-01 17:01:40.625 +07 client backend[296574] pg_regress/jsonb STATEMENT:  select jsonb_set_lax('{"a":1,"b":2}', '{b}', null, true, null);
2023-08-01 17:01:40.625 +07 client backend[296574] pg_regress/jsonb ERROR:  null_value_treatment must be "delete_key", "return_target", "use_json_null", or "raise_exception"
2023-08-01 17:01:40.625 +07 client backend[296574] pg_regress/jsonb STATEMENT:  select jsonb_set_lax('{"a":1,"b":2}', '{b}', null, true, 'no_such_treatment');
2023-08-01 17:01:40.625 +07 client backend[296574] pg_regress/jsonb ERROR:  JSON value must not be null
2023-08-01 17:01:40.625 +07 client backend[296574] pg_regress/jsonb DETAIL:  Exception was raised because null_value_treatment is "raise_exception".
2023-08-01 17:01:40.625 +07 client backend[296574] pg_regress/jsonb HINT:  To avoid, either change the null_value_treatment argument or ensure that an SQL NULL is not passed.
2023-08-01 17:01:40.625 +07 client backend[296574] pg_regress/jsonb STATEMENT:  select jsonb_set_lax('{"a":1,"b":2}', '{b}', null, null_value_treatment => 'raise_exception') as raise_exception;
2023-08-01 17:01:40.627 +07 client backend[296574] pg_regress/jsonb ERROR:  cannot replace existing key
2023-08-01 17:01:40.627 +07 client backend[296574] pg_regress/jsonb HINT:  Try using the function jsonb_set to replace key value.
2023-08-01 17:01:40.627 +07 client backend[296574] pg_regress/jsonb STATEMENT:  select jsonb_insert('{"a": {"b": "value"}}', '{a, b}', '"new_value"');
2023-08-01 17:01:40.627 +07 client backend[296574] pg_regress/jsonb ERROR:  cannot replace existing key
2023-08-01 17:01:40.627 +07 client backend[296574] pg_regress/jsonb HINT:  Try using the function jsonb_set to replace key value.
2023-08-01 17:01:40.627 +07 client backend[296574] pg_regress/jsonb STATEMENT:  select jsonb_insert('{"a": {"b": "value"}}', '{a, b}', '"new_value"', true);
2023-08-01 17:01:40.630 +07 client backend[296574] pg_regress/jsonb ERROR:  wrong flag in flag array: ""
2023-08-01 17:01:40.630 +07 client backend[296574] pg_regress/jsonb HINT:  Possible values are: "string", "numeric", "boolean", "key", and "all".
2023-08-01 17:01:40.630 +07 client backend[296574] pg_regress/jsonb STATEMENT:  select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, '""');
2023-08-01 17:01:40.630 +07 client backend[296574] pg_regress/jsonb ERROR:  wrong flag type, only arrays and scalars are allowed
2023-08-01 17:01:40.630 +07 client backend[296574] pg_regress/jsonb STATEMENT:  select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, '{}');
2023-08-01 17:01:40.630 +07 client backend[296574] pg_regress/jsonb ERROR:  flag array element is not a string
2023-08-01 17:01:40.630 +07 client backend[296574] pg_regress/jsonb HINT:  Possible values are: "string", "numeric", "boolean", "key", and "all".
2023-08-01 17:01:40.630 +07 client backend[296574] pg_regress/jsonb STATEMENT:  select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, 'null');
2023-08-01 17:01:40.630 +07 client backend[296574] pg_regress/jsonb ERROR:  flag array element is not a string
2023-08-01 17:01:40.630 +07 client backend[296574] pg_regress/jsonb HINT:  Possible values are: "string", "numeric", "boolean", "key", and "all".
2023-08-01 17:01:40.630 +07 client backend[296574] pg_regress/jsonb STATEMENT:  select jsonb_to_tsvector('english', '{"a": "aaa in bbb", "b": 123, "c": 456, "d": true, "f": false, "g": null}'::jsonb, '["all", null]');
2023-08-01 17:01:40.631 +07 client backend[296574] pg_regress/jsonb ERROR:  cannot cast jsonb array to type boolean
2023-08-01 17:01:40.631 +07 client backend[296574] pg_regress/jsonb STATEMENT:  select '[]'::jsonb::bool;
2023-08-01 17:01:40.631 +07 client backend[296574] pg_regress/jsonb ERROR:  cannot cast jsonb array to type double precision
2023-08-01 17:01:40.631 +07 client backend[296574] pg_regress/jsonb STATEMENT:  select '[1.0]'::jsonb::float;
2023-08-01 17:01:40.631 +07 client backend[296574] pg_regress/jsonb ERROR:  cannot cast jsonb string to type integer
2023-08-01 17:01:40.631 +07 client backend[296574] pg_regress/jsonb STATEMENT:  select '"hello"'::jsonb::int4;
2023-08-01 17:01:40.631 +07 client backend[296574] pg_regress/jsonb ERROR:  cannot cast jsonb object to type numeric
2023-08-01 17:01:40.631 +07 client backend[296574] pg_regress/jsonb STATEMENT:  select '{}'::jsonb::numeric;
2023-08-01 17:01:40.644 +07 client backend[296608] pg_regress/plancache ERROR:  relation "pcachetest" does not exist at character 35
2023-08-01 17:01:40.644 +07 client backend[296608] pg_regress/plancache STATEMENT:  EXECUTE prepstmt;
2023-08-01 17:01:40.644 +07 client backend[296608] pg_regress/plancache ERROR:  relation "pcachetest" does not exist at character 44
2023-08-01 17:01:40.644 +07 client backend[296608] pg_regress/plancache STATEMENT:  EXECUTE prepstmt2(123);
2023-08-01 17:01:40.644 +07 client backend[296624] pg_regress/sequence ERROR:  unlogged sequences are not supported
2023-08-01 17:01:40.644 +07 client backend[296624] pg_regress/sequence STATEMENT:  CREATE UNLOGGED SEQUENCE sequence_testx;
2023-08-01 17:01:40.644 +07 client backend[296624] pg_regress/sequence ERROR:  INCREMENT must not be zero
2023-08-01 17:01:40.644 +07 client backend[296624] pg_regress/sequence STATEMENT:  CREATE SEQUENCE sequence_testx INCREMENT BY 0;
2023-08-01 17:01:40.644 +07 client backend[296624] pg_regress/sequence ERROR:  MINVALUE (20) must be less than MAXVALUE (-1)
2023-08-01 17:01:40.644 +07 client backend[296624] pg_regress/sequence STATEMENT:  CREATE SEQUENCE sequence_testx INCREMENT BY -1 MINVALUE 20;
2023-08-01 17:01:40.645 +07 client backend[296624] pg_regress/sequence ERROR:  MINVALUE (1) must be less than MAXVALUE (-20)
2023-08-01 17:01:40.645 +07 client backend[296624] pg_regress/sequence STATEMENT:  CREATE SEQUENCE sequence_testx INCREMENT BY 1 MAXVALUE -20;
2023-08-01 17:01:40.645 +07 client backend[296624] pg_regress/sequence ERROR:  START value (10) cannot be greater than MAXVALUE (-1)
2023-08-01 17:01:40.645 +07 client backend[296624] pg_regress/sequence STATEMENT:  CREATE SEQUENCE sequence_testx INCREMENT BY -1 START 10;
2023-08-01 17:01:40.645 +07 client backend[296624] pg_regress/sequence ERROR:  START value (-10) cannot be less than MINVALUE (1)
2023-08-01 17:01:40.645 +07 client backend[296624] pg_regress/sequence STATEMENT:  CREATE SEQUENCE sequence_testx INCREMENT BY 1 START -10;
2023-08-01 17:01:40.645 +07 client backend[296624] pg_regress/sequence ERROR:  CACHE (0) must be greater than zero
2023-08-01 17:01:40.645 +07 client backend[296624] pg_regress/sequence STATEMENT:  CREATE SEQUENCE sequence_testx CACHE 0;
2023-08-01 17:01:40.645 +07 client backend[296608] pg_regress/plancache ERROR:  cached plan must not change result type
2023-08-01 17:01:40.645 +07 client backend[296608] pg_regress/plancache STATEMENT:  EXECUTE prepstmt;
2023-08-01 17:01:40.645 +07 client backend[296608] pg_regress/plancache ERROR:  cached plan must not change result type
2023-08-01 17:01:40.645 +07 client backend[296608] pg_regress/plancache STATEMENT:  EXECUTE prepstmt2(123);
2023-08-01 17:01:40.645 +07 client backend[296624] pg_regress/sequence ERROR:  invalid OWNED BY option
2023-08-01 17:01:40.645 +07 client backend[296624] pg_regress/sequence HINT:  Specify OWNED BY table.column or OWNED BY NONE.
2023-08-01 17:01:40.645 +07 client backend[296624] pg_regress/sequence STATEMENT:  CREATE SEQUENCE sequence_testx OWNED BY nobody;
2023-08-01 17:01:40.645 +07 client backend[296615] pg_regress/prepare ERROR:  prepared statement "q1" already exists
2023-08-01 17:01:40.645 +07 client backend[296615] pg_regress/prepare STATEMENT:  PREPARE q1 AS SELECT 2;
2023-08-01 17:01:40.646 +07 client backend[296624] pg_regress/sequence ERROR:  referenced relation "pg_class_oid_index" is not a table or foreign table
2023-08-01 17:01:40.646 +07 client backend[296624] pg_regress/sequence STATEMENT:  CREATE SEQUENCE sequence_testx OWNED BY pg_class_oid_index.oid;
2023-08-01 17:01:40.646 +07 client backend[296624] pg_regress/sequence ERROR:  sequence must be in same schema as table it is linked to
2023-08-01 17:01:40.646 +07 client backend[296624] pg_regress/sequence STATEMENT:  CREATE SEQUENCE sequence_testx OWNED BY pg_class.relname;
2023-08-01 17:01:40.647 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 32
2023-08-01 17:01:40.647 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.647 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.647 +07 client backend[296623] pg_regress/xml STATEMENT:  INSERT INTO xmltest VALUES (1, '<value>one</value>');
2023-08-01 17:01:40.647 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 32
2023-08-01 17:01:40.647 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.647 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.647 +07 client backend[296623] pg_regress/xml STATEMENT:  INSERT INTO xmltest VALUES (2, '<value>two</value>');
2023-08-01 17:01:40.647 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 32
2023-08-01 17:01:40.647 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.647 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.647 +07 client backend[296623] pg_regress/xml STATEMENT:  INSERT INTO xmltest VALUES (3, '<wrong');
2023-08-01 17:01:40.647 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.647 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.647 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.647 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlcomment('test');
2023-08-01 17:01:40.647 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.647 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.647 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.647 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlcomment('-test');
2023-08-01 17:01:40.647 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.647 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.647 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.647 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlcomment('test-');
2023-08-01 17:01:40.647 +07 client backend[296624] pg_regress/sequence ERROR:  column "b" of relation "sequence_test_table" does not exist
2023-08-01 17:01:40.647 +07 client backend[296624] pg_regress/sequence STATEMENT:  CREATE SEQUENCE sequence_testx OWNED BY sequence_test_table.b;
2023-08-01 17:01:40.648 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.648 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.648 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.648 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlcomment('--test');
2023-08-01 17:01:40.649 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.649 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.649 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.649 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlcomment('te st');
2023-08-01 17:01:40.649 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.649 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.649 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.649 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlconcat(xmlcomment('hello'),
	                 xmlelement(NAME qux, 'foo'),
	                 xmlcomment('world'));
2023-08-01 17:01:40.650 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 18
2023-08-01 17:01:40.650 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.650 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.650 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlconcat('hello', 'you');
2023-08-01 17:01:40.650 +07 client backend[296623] pg_regress/xml ERROR:  argument of XMLCONCAT must be type xml, not type integer at character 18
2023-08-01 17:01:40.650 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlconcat(1, 2);
2023-08-01 17:01:40.650 +07 client backend[296616] pg_regress/copy2 ERROR:  column "xyz" of relation "x" does not exist
2023-08-01 17:01:40.650 +07 client backend[296616] pg_regress/copy2 STATEMENT:  COPY x (xyz) from stdin;
2023-08-01 17:01:40.651 +07 client backend[296616] pg_regress/copy2 ERROR:  column "d" specified more than once
2023-08-01 17:01:40.651 +07 client backend[296616] pg_regress/copy2 STATEMENT:  COPY x (a, b, c, d, e, d, c) from stdin;
2023-08-01 17:01:40.651 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 18
2023-08-01 17:01:40.651 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.651 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.651 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlconcat('bad', '<syntax');
2023-08-01 17:01:40.651 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 18
2023-08-01 17:01:40.651 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.651 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.651 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlconcat('<foo/>', NULL, '<?xml version="1.1" standalone="no"?><bar/>');
2023-08-01 17:01:40.651 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 18
2023-08-01 17:01:40.651 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.651 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.651 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlconcat('<?xml version="1.1"?><foo/>', NULL, '<?xml version="1.1" standalone="no"?><bar/>');
2023-08-01 17:01:40.651 +07 client backend[296615] pg_regress/prepare ERROR:  wrong number of parameters for prepared statement "q3"
2023-08-01 17:01:40.651 +07 client backend[296615] pg_regress/prepare DETAIL:  Expected 5 parameters but got 1.
2023-08-01 17:01:40.651 +07 client backend[296615] pg_regress/prepare STATEMENT:  EXECUTE q3('bool');
2023-08-01 17:01:40.651 +07 client backend[296616] pg_regress/copy2 ERROR:  invalid input syntax for type integer: ""
2023-08-01 17:01:40.651 +07 client backend[296616] pg_regress/copy2 CONTEXT:  COPY x, line 1, column a: ""
2023-08-01 17:01:40.651 +07 client backend[296616] pg_regress/copy2 STATEMENT:  COPY x from stdin;
2023-08-01 17:01:40.651 +07 client backend[296615] pg_regress/prepare ERROR:  wrong number of parameters for prepared statement "q3"
2023-08-01 17:01:40.651 +07 client backend[296615] pg_regress/prepare DETAIL:  Expected 5 parameters but got 6.
2023-08-01 17:01:40.651 +07 client backend[296615] pg_regress/prepare STATEMENT:  EXECUTE q3('bytea', 5::smallint, 10.5::float, false, 4::bigint, true);
2023-08-01 17:01:40.651 +07 client backend[296616] pg_regress/copy2 ERROR:  missing data for column "e"
2023-08-01 17:01:40.651 +07 client backend[296616] pg_regress/copy2 CONTEXT:  COPY x, line 1: "2000	230	23	23"
2023-08-01 17:01:40.651 +07 client backend[296616] pg_regress/copy2 STATEMENT:  COPY x from stdin;
2023-08-01 17:01:40.651 +07 client backend[296615] pg_regress/prepare ERROR:  parameter $3 of type boolean cannot be coerced to the expected type double precision at character 38
2023-08-01 17:01:40.651 +07 client backend[296615] pg_regress/prepare HINT:  You will need to rewrite or cast the expression.
2023-08-01 17:01:40.651 +07 client backend[296615] pg_regress/prepare STATEMENT:  EXECUTE q3(5::smallint, 10.5::float, false, 4::bigint, 'bytea');
2023-08-01 17:01:40.652 +07 client backend[296616] pg_regress/copy2 ERROR:  missing data for column "e"
2023-08-01 17:01:40.652 +07 client backend[296616] pg_regress/copy2 CONTEXT:  COPY x, line 1: "2001	231	\N	\N"
2023-08-01 17:01:40.652 +07 client backend[296616] pg_regress/copy2 STATEMENT:  COPY x from stdin;
2023-08-01 17:01:40.652 +07 client backend[296626] pg_regress/rowtypes ERROR:  malformed record literal: "(Joe)" at character 8
2023-08-01 17:01:40.652 +07 client backend[296626] pg_regress/rowtypes DETAIL:  Too few columns.
2023-08-01 17:01:40.652 +07 client backend[296626] pg_regress/rowtypes STATEMENT:  select '(Joe)'::fullname;
2023-08-01 17:01:40.652 +07 client backend[296616] pg_regress/copy2 ERROR:  extra data after last expected column
2023-08-01 17:01:40.652 +07 client backend[296616] pg_regress/copy2 CONTEXT:  COPY x, line 1: "2002	232	40	50	60	70	80"
2023-08-01 17:01:40.652 +07 client backend[296616] pg_regress/copy2 STATEMENT:  COPY x from stdin;
2023-08-01 17:01:40.652 +07 client backend[296626] pg_regress/rowtypes ERROR:  malformed record literal: "(Joe,,)" at character 8
2023-08-01 17:01:40.652 +07 client backend[296626] pg_regress/rowtypes DETAIL:  Too many columns.
2023-08-01 17:01:40.652 +07 client backend[296626] pg_regress/rowtypes STATEMENT:  select '(Joe,,)'::fullname;
2023-08-01 17:01:40.652 +07 client backend[296626] pg_regress/rowtypes ERROR:  malformed record literal: "[]" at character 8
2023-08-01 17:01:40.652 +07 client backend[296626] pg_regress/rowtypes DETAIL:  Missing left parenthesis.
2023-08-01 17:01:40.652 +07 client backend[296626] pg_regress/rowtypes STATEMENT:  select '[]'::fullname;
2023-08-01 17:01:40.652 +07 client backend[296615] pg_regress/prepare ERROR:  type "nonexistenttype" does not exist at character 12
2023-08-01 17:01:40.652 +07 client backend[296615] pg_regress/prepare STATEMENT:  PREPARE q4(nonexistenttype) AS SELECT $1;
2023-08-01 17:01:40.652 +07 client backend[296626] pg_regress/rowtypes ERROR:  malformed record literal: "(Joe,Blow) /" at character 8
2023-08-01 17:01:40.652 +07 client backend[296626] pg_regress/rowtypes DETAIL:  Junk after right parenthesis.
2023-08-01 17:01:40.652 +07 client backend[296626] pg_regress/rowtypes STATEMENT:  select '(Joe,Blow) /'::fullname;
2023-08-01 17:01:40.653 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.653 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.653 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.653 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlelement(name element,
	                  xmlattributes (1 as one, 'deuce' as two),
	                  'content');
2023-08-01 17:01:40.654 +07 client backend[296618] pg_regress/with ERROR:  operator does not exist: text + integer at character 63
2023-08-01 17:01:40.654 +07 client backend[296618] pg_regress/with HINT:  No operator matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:40.654 +07 client backend[296618] pg_regress/with STATEMENT:  WITH RECURSIVE t(n) AS (
	    SELECT '7'
	UNION ALL
	    SELECT n+1 FROM t WHERE n < 10
	)
	SELECT n, n IS OF (int) AS is_int FROM t;
2023-08-01 17:01:40.655 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.655 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.655 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.655 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlelement(name element,
	                  xmlattributes ('unnamed and wrong'));
2023-08-01 17:01:40.655 +07 client backend[296616] pg_regress/copy2 ERROR:  WHERE clause not allowed with COPY TO at character 18
2023-08-01 17:01:40.655 +07 client backend[296616] pg_regress/copy2 STATEMENT:  COPY x TO stdout WHERE a = 1;
2023-08-01 17:01:40.655 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.655 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.655 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.655 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlelement(name element, xmlelement(name nested, 'stuff'));
2023-08-01 17:01:40.656 +07 client backend[296624] pg_regress/sequence ERROR:  sequence type must be smallint, integer, or bigint
2023-08-01 17:01:40.656 +07 client backend[296624] pg_regress/sequence STATEMENT:  CREATE SEQUENCE sequence_testx AS text;
2023-08-01 17:01:40.656 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.656 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.656 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.656 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlelement(name employee, xmlforest(name, age, salary as pay)) FROM emp;
2023-08-01 17:01:40.656 +07 client backend[296624] pg_regress/sequence ERROR:  type "nosuchtype" does not exist at character 35
2023-08-01 17:01:40.656 +07 client backend[296624] pg_regress/sequence STATEMENT:  CREATE SEQUENCE sequence_testx AS nosuchtype;
2023-08-01 17:01:40.656 +07 client backend[296624] pg_regress/sequence ERROR:  MAXVALUE (100000) is out of range for sequence data type smallint
2023-08-01 17:01:40.656 +07 client backend[296624] pg_regress/sequence STATEMENT:  CREATE SEQUENCE sequence_testx AS smallint MAXVALUE 100000;
2023-08-01 17:01:40.656 +07 client backend[296624] pg_regress/sequence ERROR:  MINVALUE (-100000) is out of range for sequence data type smallint
2023-08-01 17:01:40.656 +07 client backend[296624] pg_regress/sequence STATEMENT:  CREATE SEQUENCE sequence_testx AS smallint MINVALUE -100000;
2023-08-01 17:01:40.656 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.656 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.656 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.656 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlelement(name duplicate, xmlattributes(1 as a, 2 as b, 3 as a));
2023-08-01 17:01:40.656 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.656 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.656 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.656 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlelement(name num, 37);
2023-08-01 17:01:40.657 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.657 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.657 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.657 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlelement(name foo, text 'bar');
2023-08-01 17:01:40.657 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.657 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.657 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.657 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlelement(name foo, xml 'bar');
2023-08-01 17:01:40.657 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.657 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.657 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.657 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlelement(name foo, text 'b<a/>r');
2023-08-01 17:01:40.657 +07 client backend[296616] pg_regress/copy2 ERROR:  column "f" does not exist at character 25
2023-08-01 17:01:40.657 +07 client backend[296616] pg_regress/copy2 STATEMENT:  COPY x from stdin WHERE f > 60003;
2023-08-01 17:01:40.657 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.657 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.657 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.657 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlelement(name foo, xml 'b<a/>r');
2023-08-01 17:01:40.657 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.657 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.657 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.657 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlelement(name foo, array[1, 2, 3]);
2023-08-01 17:01:40.657 +07 client backend[296616] pg_regress/copy2 ERROR:  aggregate functions are not allowed in COPY FROM WHERE conditions at character 29
2023-08-01 17:01:40.657 +07 client backend[296616] pg_regress/copy2 STATEMENT:  COPY x from stdin WHERE a = max(x.b);
2023-08-01 17:01:40.657 +07 client backend[296616] pg_regress/copy2 ERROR:  cannot use subquery in COPY FROM WHERE condition at character 27
2023-08-01 17:01:40.657 +07 client backend[296616] pg_regress/copy2 STATEMENT:  COPY x from stdin WHERE a IN (SELECT 1 FROM x);
2023-08-01 17:01:40.657 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.657 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.657 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.657 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlelement(name foo, bytea 'bar');
2023-08-01 17:01:40.657 +07 client backend[296616] pg_regress/copy2 ERROR:  set-returning functions are not allowed in COPY FROM WHERE conditions at character 31
2023-08-01 17:01:40.657 +07 client backend[296616] pg_regress/copy2 STATEMENT:  COPY x from stdin WHERE a IN (generate_series(1,5));
2023-08-01 17:01:40.657 +07 client backend[296621] pg_regress/polymorphism ERROR:  operator does not exist: point + integer at character 13
2023-08-01 17:01:40.657 +07 client backend[296621] pg_regress/polymorphism HINT:  No operator matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:40.657 +07 client backend[296621] pg_regress/polymorphism QUERY:  
	  select x + 1
	
2023-08-01 17:01:40.657 +07 client backend[296621] pg_regress/polymorphism CONTEXT:  SQL function "polyf" during inlining
2023-08-01 17:01:40.657 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  select polyf(point(3,4));
2023-08-01 17:01:40.658 +07 client backend[296616] pg_regress/copy2 ERROR:  window functions are not allowed in COPY FROM WHERE conditions at character 29
2023-08-01 17:01:40.658 +07 client backend[296616] pg_regress/copy2 STATEMENT:  COPY x from stdin WHERE a = row_number() over(b);
2023-08-01 17:01:40.658 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.658 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.658 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.658 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlelement(name foo, bytea 'bar');
2023-08-01 17:01:40.658 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.658 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.658 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.658 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlelement(name foo, xmlattributes(true as bar));
2023-08-01 17:01:40.659 +07 client backend[296624] pg_regress/sequence ERROR:  MAXVALUE (100000) is out of range for sequence data type smallint
2023-08-01 17:01:40.659 +07 client backend[296624] pg_regress/sequence STATEMENT:  ALTER SEQUENCE sequence_test8 AS smallint;
2023-08-01 17:01:40.659 +07 client backend[296617] pg_regress/conversion ERROR:  conversion "myconv" already exists
2023-08-01 17:01:40.659 +07 client backend[296617] pg_regress/conversion STATEMENT:  CREATE CONVERSION myconv FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
2023-08-01 17:01:40.659 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.659 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.659 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.659 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlelement(name foo, xmlattributes('2009-04-09 00:24:37'::timestamp as bar));
2023-08-01 17:01:40.659 +07 client backend[296625] pg_regress/alter_table ERROR:  relation "attmp_wrong" does not exist
2023-08-01 17:01:40.659 +07 client backend[296625] pg_regress/alter_table STATEMENT:  COMMENT ON TABLE attmp_wrong IS 'table comment';
2023-08-01 17:01:40.659 +07 client backend[296613] pg_regress/domain ERROR:  cannot drop type domaindroptest because other objects depend on it
2023-08-01 17:01:40.659 +07 client backend[296613] pg_regress/domain DETAIL:  type dependenttypetest depends on type domaindroptest
2023-08-01 17:01:40.659 +07 client backend[296613] pg_regress/domain HINT:  Use DROP ... CASCADE to drop the dependent objects too.
2023-08-01 17:01:40.659 +07 client backend[296613] pg_regress/domain STATEMENT:  drop domain domaindroptest;
2023-08-01 17:01:40.659 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.659 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.659 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.659 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlelement(name foo, xmlattributes('infinity'::timestamp as bar));
2023-08-01 17:01:40.659 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.659 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.659 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.659 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlelement(name foo, xmlattributes('<>&"''' as funny, xml 'b<a/>r' as funnier));
2023-08-01 17:01:40.659 +07 client backend[296625] pg_regress/alter_table ERROR:  column name "xmin" conflicts with a system column name
2023-08-01 17:01:40.659 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE attmp ADD COLUMN xmin integer;
2023-08-01 17:01:40.659 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.659 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.659 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.659 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlparse(content '');
2023-08-01 17:01:40.660 +07 client backend[296613] pg_regress/domain ERROR:  type "domaindroptest" does not exist
2023-08-01 17:01:40.660 +07 client backend[296613] pg_regress/domain STATEMENT:  drop domain domaindroptest cascade;
2023-08-01 17:01:40.660 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.660 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.660 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.660 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlparse(content '  ');
2023-08-01 17:01:40.660 +07 client backend[296624] pg_regress/sequence ERROR:  MINVALUE (-100000) is out of range for sequence data type smallint
2023-08-01 17:01:40.660 +07 client backend[296624] pg_regress/sequence STATEMENT:  ALTER SEQUENCE sequence_test10 AS smallint;
2023-08-01 17:01:40.660 +07 client backend[296626] pg_regress/rowtypes ERROR:  missing FROM-clause entry for table "q" at character 12
2023-08-01 17:01:40.660 +07 client backend[296626] pg_regress/rowtypes STATEMENT:  select f1, q.c1 from quadtable;
2023-08-01 17:01:40.661 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.661 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.661 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.661 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlparse(content 'abc');
2023-08-01 17:01:40.662 +07 client backend[296617] pg_regress/conversion ERROR:  default conversion for LATIN1 to UTF8 already exists
2023-08-01 17:01:40.662 +07 client backend[296617] pg_regress/conversion STATEMENT:  CREATE DEFAULT CONVERSION public.mydef2 FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
2023-08-01 17:01:40.662 +07 client backend[296617] pg_regress/conversion ERROR:  conversion "myconv_bad" does not exist
2023-08-01 17:01:40.662 +07 client backend[296617] pg_regress/conversion STATEMENT:  COMMENT ON CONVERSION myconv_bad IS 'foo';
2023-08-01 17:01:40.663 +07 client backend[296621] pg_regress/polymorphism ERROR:  cannot determine element type of "anyarray" argument
2023-08-01 17:01:40.663 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  select polyf(stavalues1) from pg_statistic;
2023-08-01 17:01:40.663 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.663 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.663 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.663 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlparse(content '<abc>x</abc>');
2023-08-01 17:01:40.663 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.663 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.663 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.663 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlparse(content '<invalidentity>&</invalidentity>');
2023-08-01 17:01:40.664 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.664 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.664 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.664 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlparse(content '<undefinedentity>&idontexist;</undefinedentity>');
2023-08-01 17:01:40.664 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.664 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.664 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.664 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlparse(content '<invalidns xmlns=''&lt;''/>');
2023-08-01 17:01:40.664 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.664 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.664 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.664 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlparse(content '<relativens xmlns=''relative''/>');
2023-08-01 17:01:40.664 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.664 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.664 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.664 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlparse(content '<twoerrors>&idontexist;</unbalanced>');
2023-08-01 17:01:40.665 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.665 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.665 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.665 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlparse(content '<nosuchprefix:tag/>');
2023-08-01 17:01:40.665 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.665 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.665 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.665 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlparse(document '   ');
2023-08-01 17:01:40.665 +07 client backend[296621] pg_regress/polymorphism ERROR:  return type anyarray is not supported for SQL functions
2023-08-01 17:01:40.665 +07 client backend[296621] pg_regress/polymorphism CONTEXT:  SQL function "polyf" during inlining
2023-08-01 17:01:40.665 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  select polyf(stavalues1) from pg_statistic;
2023-08-01 17:01:40.666 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.666 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.666 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.666 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlparse(document 'abc');
2023-08-01 17:01:40.666 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.666 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.666 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.666 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlparse(document '<abc>x</abc>');
2023-08-01 17:01:40.666 +07 client backend[296608] pg_regress/plancache ERROR:  new row for relation "pc_list_part_def" violates partition constraint
2023-08-01 17:01:40.666 +07 client backend[296608] pg_regress/plancache DETAIL:  Failing row contains (null).
2023-08-01 17:01:40.666 +07 client backend[296608] pg_regress/plancache STATEMENT:  execute pstmt_def_insert(null);
2023-08-01 17:01:40.666 +07 client backend[296608] pg_regress/plancache ERROR:  new row for relation "pc_list_part_def" violates partition constraint
2023-08-01 17:01:40.666 +07 client backend[296608] pg_regress/plancache DETAIL:  Failing row contains (1).
2023-08-01 17:01:40.666 +07 client backend[296608] pg_regress/plancache STATEMENT:  execute pstmt_def_insert(1);
2023-08-01 17:01:40.666 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.666 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.666 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.666 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlparse(document '<invalidentity>&</abc>');
2023-08-01 17:01:40.666 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.666 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.666 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.666 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlparse(document '<undefinedentity>&idontexist;</abc>');
2023-08-01 17:01:40.666 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.666 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.666 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.666 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlparse(document '<invalidns xmlns=''&lt;''/>');
2023-08-01 17:01:40.667 +07 client backend[296621] pg_regress/polymorphism ERROR:  cannot determine result data type
2023-08-01 17:01:40.667 +07 client backend[296621] pg_regress/polymorphism DETAIL:  A result of type anyrange requires at least one input of type anyrange.
2023-08-01 17:01:40.667 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  create function polyf(x anyelement) returns anyrange as $$
	  select array[x + 1, x + 2]
	$$ language sql;
2023-08-01 17:01:40.667 +07 client backend[296613] pg_regress/domain ERROR:  value too long for type character varying(5)
2023-08-01 17:01:40.667 +07 client backend[296613] pg_regress/domain STATEMENT:  INSERT INTO basictest values ('88', 'haha', 'short text', '123.12');
2023-08-01 17:01:40.667 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.667 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.667 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.667 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlparse(document '<relativens xmlns=''relative''/>');
2023-08-01 17:01:40.667 +07 client backend[296608] pg_regress/plancache ERROR:  new row for relation "pc_list_part_def" violates partition constraint
2023-08-01 17:01:40.667 +07 client backend[296608] pg_regress/plancache DETAIL:  Failing row contains (2).
2023-08-01 17:01:40.667 +07 client backend[296608] pg_regress/plancache STATEMENT:  execute pstmt_def_insert(2);
2023-08-01 17:01:40.667 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.667 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.667 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.667 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlparse(document '<twoerrors>&idontexist;</unbalanced>');
2023-08-01 17:01:40.667 +07 client backend[296626] pg_regress/rowtypes ERROR:  cannot alter table "fullname" because column "people.fn" uses its row type
2023-08-01 17:01:40.667 +07 client backend[296626] pg_regress/rowtypes STATEMENT:  alter table fullname add column suffix text default '';
2023-08-01 17:01:40.668 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.668 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.668 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.668 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlparse(document '<nosuchprefix:tag/>');
2023-08-01 17:01:40.668 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.668 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.668 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.668 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlpi(name foo);
2023-08-01 17:01:40.668 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.668 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.668 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.668 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlpi(name xml);
2023-08-01 17:01:40.668 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.668 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.668 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.668 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlpi(name xmlstuff);
2023-08-01 17:01:40.668 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.668 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.668 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.668 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlpi(name foo, 'bar');
2023-08-01 17:01:40.668 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.668 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.668 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.668 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlpi(name foo, 'in?>valid');
2023-08-01 17:01:40.668 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.668 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.668 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.668 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlpi(name foo, null);
2023-08-01 17:01:40.668 +07 client backend[296624] pg_regress/sequence ERROR:  null value in column "f2" of relation "serialtest1" violates not-null constraint
2023-08-01 17:01:40.668 +07 client backend[296624] pg_regress/sequence DETAIL:  Failing row contains (wrong, null).
2023-08-01 17:01:40.668 +07 client backend[296624] pg_regress/sequence STATEMENT:  INSERT INTO serialTest1 VALUES ('wrong', NULL);
2023-08-01 17:01:40.668 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.668 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.668 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.668 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlpi(name xml, null);
2023-08-01 17:01:40.669 +07 client backend[296613] pg_regress/domain ERROR:  value too long for type character varying(5)
2023-08-01 17:01:40.669 +07 client backend[296613] pg_regress/domain CONTEXT:  COPY basictest, line 1, column testvarchar: "notsoshorttext"
2023-08-01 17:01:40.669 +07 client backend[296613] pg_regress/domain STATEMENT:  COPY basictest (testvarchar) FROM stdin;
2023-08-01 17:01:40.669 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.669 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.669 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.669 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlpi(name xmlstuff, null);
2023-08-01 17:01:40.669 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.669 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.669 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.669 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlpi(name "xml-stylesheet", 'href="mystyle.css" type="text/css"');
2023-08-01 17:01:40.670 +07 client backend[296619] pg_regress/returning ERROR:  cannot perform INSERT RETURNING on relation "voo"
2023-08-01 17:01:40.670 +07 client backend[296619] pg_regress/returning HINT:  You need an unconditional ON INSERT DO INSTEAD rule with a RETURNING clause.
2023-08-01 17:01:40.670 +07 client backend[296619] pg_regress/returning STATEMENT:  INSERT INTO voo VALUES(12,'zoo') RETURNING *, f1*2;
2023-08-01 17:01:40.670 +07 client backend[296619] pg_regress/returning ERROR:  RETURNING list has too many entries
2023-08-01 17:01:40.670 +07 client backend[296619] pg_regress/returning STATEMENT:  CREATE OR REPLACE RULE voo_i AS ON INSERT TO voo DO INSTEAD
	  INSERT INTO foo VALUES(new.*, 57) RETURNING *;
2023-08-01 17:01:40.673 +07 client backend[296627] pg_regress/temp ERROR:  relation "temptest" does not exist at character 15
2023-08-01 17:01:40.673 +07 client backend[296627] pg_regress/temp STATEMENT:  SELECT * FROM temptest;
2023-08-01 17:01:40.674 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.674 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.674 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.674 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlpi(name foo, '   bar');
2023-08-01 17:01:40.675 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 20
2023-08-01 17:01:40.675 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.675 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.675 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlroot(xml '<foo/>', version no value, standalone no value);
2023-08-01 17:01:40.675 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 20
2023-08-01 17:01:40.675 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.675 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.675 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlroot(xml '<foo/>', version '2.0');
2023-08-01 17:01:40.675 +07 client backend[296610] pg_regress/limit ERROR:  WITH TIES cannot be specified without ORDER BY clause
2023-08-01 17:01:40.675 +07 client backend[296610] pg_regress/limit STATEMENT:  SELECT ''::text AS two, unique1, unique2, stringu1
			FROM onek WHERE unique1 > 50
			FETCH FIRST 2 ROW WITH TIES;
2023-08-01 17:01:40.675 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 20
2023-08-01 17:01:40.675 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.675 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.675 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlroot(xml '<foo/>', version no value, standalone yes);
2023-08-01 17:01:40.675 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 20
2023-08-01 17:01:40.675 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.675 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.675 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlroot(xml '<?xml version="1.1"?><foo/>', version no value, standalone yes);
2023-08-01 17:01:40.675 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 28
2023-08-01 17:01:40.675 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.675 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.675 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlroot(xmlroot(xml '<foo/>', version '1.0'), version '1.1', standalone no);
2023-08-01 17:01:40.675 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 16
2023-08-01 17:01:40.675 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.675 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.675 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlroot('<?xml version="1.1" standalone="yes"?><foo/>', version no value, standalone no);
2023-08-01 17:01:40.675 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 16
2023-08-01 17:01:40.675 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.675 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.675 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlroot('<?xml version="1.1" standalone="yes"?><foo/>', version no value, standalone no value);
2023-08-01 17:01:40.675 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 16
2023-08-01 17:01:40.675 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.675 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.675 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlroot('<?xml version="1.1" standalone="yes"?><foo/>', version no value);
2023-08-01 17:01:40.676 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.676 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.676 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.676 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlroot (
	  xmlelement (
	    name gazonk,
	    xmlattributes (
	      'val' AS name,
	      1 + 1 AS num
	    ),
	    xmlelement (
	      NAME qux,
	      'foo'
	    )
	  ),
	  version '1.0',
	  standalone yes
	);
2023-08-01 17:01:40.677 +07 client backend[296621] pg_regress/polymorphism ERROR:  function polyf(int4range, integer, numeric) does not exist at character 8
2023-08-01 17:01:40.677 +07 client backend[296621] pg_regress/polymorphism HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:40.677 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  select polyf(int4range(42, 49), 11, 4.5) as fail;
2023-08-01 17:01:40.677 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 29
2023-08-01 17:01:40.677 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.677 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.677 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlserialize(content 'good' as char(10));
2023-08-01 17:01:40.677 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 30
2023-08-01 17:01:40.677 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.677 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.677 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlserialize(document 'bad' as text);
2023-08-01 17:01:40.677 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 12
2023-08-01 17:01:40.677 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.677 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.677 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xml '<foo>bar</foo>' IS DOCUMENT;
2023-08-01 17:01:40.677 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 12
2023-08-01 17:01:40.677 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.677 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.677 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xml '<foo>bar</foo><bar>foo</bar>' IS DOCUMENT;
2023-08-01 17:01:40.677 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 12
2023-08-01 17:01:40.677 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.677 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.677 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xml '<abc/>' IS NOT DOCUMENT;
2023-08-01 17:01:40.677 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 12
2023-08-01 17:01:40.677 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.677 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.677 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xml 'abc' IS NOT DOCUMENT;
2023-08-01 17:01:40.678 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 8
2023-08-01 17:01:40.678 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.678 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.678 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT '<>' IS NOT DOCUMENT;
2023-08-01 17:01:40.678 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.678 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.678 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.678 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlelement(name employees, xmlagg(xmlelement(name name, name))) FROM emp;
2023-08-01 17:01:40.678 +07 client backend[296621] pg_regress/polymorphism ERROR:  cannot determine result data type
2023-08-01 17:01:40.678 +07 client backend[296621] pg_regress/polymorphism DETAIL:  A result of type anycompatiblerange requires at least one input of type anycompatiblerange.
2023-08-01 17:01:40.678 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  create function polyf(x anycompatible) returns anycompatiblerange as $$
	  select array[x + 1, x + 2]
	$$ language sql;
2023-08-01 17:01:40.678 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.678 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.678 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.678 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlpi(name ":::_xml_abc135.%-&_");
2023-08-01 17:01:40.678 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.678 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.678 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.678 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlpi(name "123");
2023-08-01 17:01:40.678 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 39
2023-08-01 17:01:40.678 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.678 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.678 +07 client backend[296623] pg_regress/xml STATEMENT:  PREPARE foo (xml) AS SELECT xmlconcat('<foo/>', $1);
2023-08-01 17:01:40.679 +07 client backend[296623] pg_regress/xml ERROR:  prepared statement "foo" does not exist
2023-08-01 17:01:40.679 +07 client backend[296623] pg_regress/xml STATEMENT:  EXECUTE foo ('<bar/>');
2023-08-01 17:01:40.679 +07 client backend[296623] pg_regress/xml ERROR:  prepared statement "foo" does not exist
2023-08-01 17:01:40.679 +07 client backend[296623] pg_regress/xml STATEMENT:  EXECUTE foo ('bad');
2023-08-01 17:01:40.679 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 12
2023-08-01 17:01:40.679 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.679 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.679 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xml '<!DOCTYPE a><a/><b/>';
2023-08-01 17:01:40.680 +07 client backend[296624] pg_regress/sequence ERROR:  smallint out of range
2023-08-01 17:01:40.680 +07 client backend[296624] pg_regress/sequence STATEMENT:  INSERT INTO serialTest2 (f1, f3)
	  VALUES ('bogus', -32769);
2023-08-01 17:01:40.680 +07 client backend[296623] pg_regress/xml ERROR:  prepared statement "foo" does not exist
2023-08-01 17:01:40.680 +07 client backend[296623] pg_regress/xml STATEMENT:  EXECUTE foo ('<bar/>');
2023-08-01 17:01:40.680 +07 client backend[296623] pg_regress/xml ERROR:  prepared statement "foo" does not exist
2023-08-01 17:01:40.680 +07 client backend[296623] pg_regress/xml STATEMENT:  EXECUTE foo ('good');
2023-08-01 17:01:40.680 +07 client backend[296613] pg_regress/domain ERROR:  value too long for type character varying(4)
2023-08-01 17:01:40.680 +07 client backend[296613] pg_regress/domain STATEMENT:  INSERT INTO domarrtest values (NULL, '{{"toolong","b","c"},{"d","e","f"}}');
2023-08-01 17:01:40.680 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 12
2023-08-01 17:01:40.680 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.680 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.680 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xml '<!-- in SQL:2006+ a doc is content too--> <?y z?> <!DOCTYPE a><a/>';
2023-08-01 17:01:40.680 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 12
2023-08-01 17:01:40.680 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.680 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.680 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xml '<?xml version="1.0"?> <!-- hi--> <!DOCTYPE a><a/>';
2023-08-01 17:01:40.681 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 12
2023-08-01 17:01:40.681 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.681 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.681 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xml '<!DOCTYPE a><a/>';
2023-08-01 17:01:40.681 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 12
2023-08-01 17:01:40.681 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.681 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.681 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xml '<!-- hi--> oops <!DOCTYPE a><a/>';
2023-08-01 17:01:40.681 +07 client backend[296613] pg_regress/domain ERROR:  value too long for type character varying(4)
2023-08-01 17:01:40.681 +07 client backend[296613] pg_regress/domain CONTEXT:  COPY domarrtest, line 1, column testchar4arr: "{qwerty,w,e}"
2023-08-01 17:01:40.681 +07 client backend[296613] pg_regress/domain STATEMENT:  COPY domarrtest FROM stdin;
2023-08-01 17:01:40.681 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 12
2023-08-01 17:01:40.681 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.681 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.681 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xml '<!-- hi--> <oops/> <!DOCTYPE a><a/>';
2023-08-01 17:01:40.681 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 12
2023-08-01 17:01:40.681 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.681 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.681 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xml '<!DOCTYPE a><a/><b/>';
2023-08-01 17:01:40.682 +07 client backend[296620] pg_regress/truncate ERROR:  cannot truncate a table referenced in a foreign key constraint
2023-08-01 17:01:40.682 +07 client backend[296620] pg_regress/truncate DETAIL:  Table "trunc_b" references "truncate_a".
2023-08-01 17:01:40.682 +07 client backend[296620] pg_regress/truncate HINT:  Truncate table "trunc_b" at the same time, or use TRUNCATE ... CASCADE.
2023-08-01 17:01:40.682 +07 client backend[296620] pg_regress/truncate STATEMENT:  TRUNCATE TABLE truncate_a;
2023-08-01 17:01:40.682 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 42
2023-08-01 17:01:40.682 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.682 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.682 +07 client backend[296623] pg_regress/xml STATEMENT:  CREATE VIEW xmlview2 AS SELECT xmlconcat('hello', 'you');
2023-08-01 17:01:40.682 +07 client backend[296624] pg_regress/sequence ERROR:  smallint out of range
2023-08-01 17:01:40.682 +07 client backend[296624] pg_regress/sequence STATEMENT:  INSERT INTO serialTest2 (f1, f4)
	  VALUES ('bogus', -32769);
2023-08-01 17:01:40.683 +07 client backend[296620] pg_regress/truncate ERROR:  cannot truncate a table referenced in a foreign key constraint
2023-08-01 17:01:40.683 +07 client backend[296620] pg_regress/truncate DETAIL:  Table "trunc_e" references "truncate_a".
2023-08-01 17:01:40.683 +07 client backend[296620] pg_regress/truncate HINT:  Truncate table "trunc_e" at the same time, or use TRUNCATE ... CASCADE.
2023-08-01 17:01:40.683 +07 client backend[296620] pg_regress/truncate STATEMENT:  TRUNCATE TABLE truncate_a,trunc_b;
2023-08-01 17:01:40.683 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.683 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.683 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.683 +07 client backend[296623] pg_regress/xml STATEMENT:  CREATE VIEW xmlview3 AS SELECT xmlelement(name element, xmlattributes (1 as ":one:", 'deuce' as two), 'content&');
2023-08-01 17:01:40.683 +07 client backend[296625] pg_regress/alter_table ERROR:  column number must be in range from 1 to 32767 at character 36
2023-08-01 17:01:40.683 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER INDEX attmp_idx ALTER COLUMN 0 SET STATISTICS 1000;
2023-08-01 17:01:40.683 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.683 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.683 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.683 +07 client backend[296623] pg_regress/xml STATEMENT:  CREATE VIEW xmlview4 AS SELECT xmlelement(name employee, xmlforest(name, age, salary as pay)) FROM emp;
2023-08-01 17:01:40.683 +07 client backend[296625] pg_regress/alter_table ERROR:  cannot alter statistics on non-expression column "a" of index "attmp_idx"
2023-08-01 17:01:40.683 +07 client backend[296625] pg_regress/alter_table HINT:  Alter statistics on table column instead.
2023-08-01 17:01:40.683 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER INDEX attmp_idx ALTER COLUMN 1 SET STATISTICS 1000;
2023-08-01 17:01:40.683 +07 client backend[296621] pg_regress/polymorphism ERROR:  function polyf(integer, numeric[], integer, numeric) does not exist at character 48
2023-08-01 17:01:40.683 +07 client backend[296621] pg_regress/polymorphism HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:40.683 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  select x, pg_typeof(x), y, pg_typeof(y)
	  from polyf(11, array[1, 2.2], 42, 34.5);
2023-08-01 17:01:40.683 +07 client backend[296624] pg_regress/sequence ERROR:  smallint out of range
2023-08-01 17:01:40.683 +07 client backend[296624] pg_regress/sequence STATEMENT:  INSERT INTO serialTest2 (f1, f3)
	  VALUES ('bogus', 32768);
2023-08-01 17:01:40.683 +07 client backend[296624] pg_regress/sequence ERROR:  smallint out of range
2023-08-01 17:01:40.683 +07 client backend[296624] pg_regress/sequence STATEMENT:  INSERT INTO serialTest2 (f1, f4)
	  VALUES ('bogus', 32768);
2023-08-01 17:01:40.684 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.684 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.684 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.684 +07 client backend[296623] pg_regress/xml STATEMENT:  CREATE VIEW xmlview6 AS SELECT xmlpi(name foo, 'bar');
2023-08-01 17:01:40.684 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 44
2023-08-01 17:01:40.684 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.684 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.684 +07 client backend[296623] pg_regress/xml STATEMENT:  CREATE VIEW xmlview7 AS SELECT xmlroot(xml '<foo/>', version no value, standalone yes);
2023-08-01 17:01:40.685 +07 client backend[296624] pg_regress/sequence ERROR:  bigint out of range
2023-08-01 17:01:40.685 +07 client backend[296624] pg_regress/sequence STATEMENT:  INSERT INTO serialTest2 (f1, f5)
	  VALUES ('bogus', -9223372036854775809);
2023-08-01 17:01:40.685 +07 client backend[296620] pg_regress/truncate ERROR:  cannot truncate a table referenced in a foreign key constraint
2023-08-01 17:01:40.685 +07 client backend[296620] pg_regress/truncate DETAIL:  Table "trunc_b" references "truncate_a".
2023-08-01 17:01:40.685 +07 client backend[296620] pg_regress/truncate HINT:  Truncate table "trunc_b" at the same time, or use TRUNCATE ... CASCADE.
2023-08-01 17:01:40.685 +07 client backend[296620] pg_regress/truncate STATEMENT:  TRUNCATE TABLE truncate_a,trunc_e;
2023-08-01 17:01:40.685 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 53
2023-08-01 17:01:40.685 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.685 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.685 +07 client backend[296623] pg_regress/xml STATEMENT:  CREATE VIEW xmlview8 AS SELECT xmlserialize(content 'good' as char(10));
2023-08-01 17:01:40.685 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 53
2023-08-01 17:01:40.685 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.685 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.685 +07 client backend[296623] pg_regress/xml STATEMENT:  CREATE VIEW xmlview9 AS SELECT xmlserialize(content 'good' as text);
2023-08-01 17:01:40.686 +07 client backend[296620] pg_regress/truncate ERROR:  cannot truncate a table referenced in a foreign key constraint
2023-08-01 17:01:40.686 +07 client backend[296620] pg_regress/truncate DETAIL:  Table "trunc_d" references "trunc_c".
2023-08-01 17:01:40.686 +07 client backend[296620] pg_regress/truncate HINT:  Truncate table "trunc_d" at the same time, or use TRUNCATE ... CASCADE.
2023-08-01 17:01:40.686 +07 client backend[296620] pg_regress/truncate STATEMENT:  TRUNCATE TABLE trunc_c;
2023-08-01 17:01:40.686 +07 client backend[296624] pg_regress/sequence ERROR:  bigint out of range
2023-08-01 17:01:40.686 +07 client backend[296624] pg_regress/sequence STATEMENT:  INSERT INTO serialTest2 (f1, f6)
	  VALUES ('bogus', -9223372036854775809);
2023-08-01 17:01:40.686 +07 client backend[296620] pg_regress/truncate ERROR:  cannot truncate a table referenced in a foreign key constraint
2023-08-01 17:01:40.686 +07 client backend[296620] pg_regress/truncate DETAIL:  Table "trunc_e" references "trunc_c".
2023-08-01 17:01:40.686 +07 client backend[296620] pg_regress/truncate HINT:  Truncate table "trunc_e" at the same time, or use TRUNCATE ... CASCADE.
2023-08-01 17:01:40.686 +07 client backend[296620] pg_regress/truncate STATEMENT:  TRUNCATE TABLE trunc_c,trunc_d;
2023-08-01 17:01:40.686 +07 client backend[296624] pg_regress/sequence ERROR:  bigint out of range
2023-08-01 17:01:40.686 +07 client backend[296624] pg_regress/sequence STATEMENT:  INSERT INTO serialTest2 (f1, f5)
	  VALUES ('bogus', 9223372036854775808);
2023-08-01 17:01:40.686 +07 client backend[296624] pg_regress/sequence ERROR:  bigint out of range
2023-08-01 17:01:40.686 +07 client backend[296624] pg_regress/sequence STATEMENT:  INSERT INTO serialTest2 (f1, f6)
	  VALUES ('bogus', 9223372036854775808);
2023-08-01 17:01:40.687 +07 client backend[296611] pg_regress/plpgsql ERROR:  function tg_hub_adjustslots_wrong(character, integer, integer) does not exist
2023-08-01 17:01:40.687 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  COMMENT ON FUNCTION tg_hub_adjustslots_wrong(bpchar, integer, integer) IS 'function with args';
2023-08-01 17:01:40.687 +07 client backend[296616] pg_regress/copy2 ERROR:  cannot perform COPY FREEZE because the table was not created or truncated in the current subtransaction
2023-08-01 17:01:40.687 +07 client backend[296616] pg_regress/copy2 STATEMENT:  COPY vistest FROM stdin CSV FREEZE;
2023-08-01 17:01:40.687 +07 client backend[296619] pg_regress/returning ERROR:  invalid reference to FROM-clause entry for table "foo" at character 49
2023-08-01 17:01:40.687 +07 client backend[296619] pg_regress/returning HINT:  Perhaps you meant to reference the table alias "bar".
2023-08-01 17:01:40.687 +07 client backend[296619] pg_regress/returning STATEMENT:  INSERT INTO foo AS bar DEFAULT VALUES RETURNING foo.*;
2023-08-01 17:01:40.687 +07 client backend[296625] pg_regress/alter_table ERROR:  cannot alter statistics on non-expression column "b" of index "attmp_idx"
2023-08-01 17:01:40.687 +07 client backend[296625] pg_regress/alter_table HINT:  Alter statistics on table column instead.
2023-08-01 17:01:40.687 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER INDEX attmp_idx ALTER COLUMN 3 SET STATISTICS 1000;
2023-08-01 17:01:40.688 +07 client backend[296616] pg_regress/copy2 ERROR:  cannot perform COPY FREEZE because the table was not created or truncated in the current subtransaction
2023-08-01 17:01:40.688 +07 client backend[296616] pg_regress/copy2 STATEMENT:  COPY vistest FROM stdin CSV FREEZE;
2023-08-01 17:01:40.688 +07 client backend[296625] pg_regress/alter_table ERROR:  column number 4 of relation "attmp_idx" does not exist
2023-08-01 17:01:40.688 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER INDEX attmp_idx ALTER COLUMN 4 SET STATISTICS 1000;
2023-08-01 17:01:40.688 +07 client backend[296610] pg_regress/limit ERROR:  row count cannot be null in FETCH FIRST ... WITH TIES clause
2023-08-01 17:01:40.688 +07 client backend[296610] pg_regress/limit STATEMENT:  CREATE VIEW limit_thousand_v_3 AS SELECT thousand FROM onek WHERE thousand < 995
			ORDER BY thousand FETCH FIRST NULL ROWS WITH TIES;
2023-08-01 17:01:40.688 +07 client backend[296620] pg_regress/truncate ERROR:  cannot truncate a table referenced in a foreign key constraint
2023-08-01 17:01:40.688 +07 client backend[296620] pg_regress/truncate DETAIL:  Table "trunc_b" references "truncate_a".
2023-08-01 17:01:40.688 +07 client backend[296620] pg_regress/truncate HINT:  Truncate table "trunc_b" at the same time, or use TRUNCATE ... CASCADE.
2023-08-01 17:01:40.688 +07 client backend[296620] pg_regress/truncate STATEMENT:  TRUNCATE TABLE trunc_c,trunc_d,trunc_e,truncate_a;
2023-08-01 17:01:40.689 +07 client backend[296624] pg_regress/sequence ERROR:  currval of sequence "sequence_test" is not yet defined in this session
2023-08-01 17:01:40.689 +07 client backend[296624] pg_regress/sequence STATEMENT:  SELECT currval('sequence_test'::regclass);
2023-08-01 17:01:40.689 +07 client backend[296616] pg_regress/copy2 ERROR:  cannot perform COPY FREEZE because the table was not created or truncated in the current subtransaction
2023-08-01 17:01:40.689 +07 client backend[296616] pg_regress/copy2 STATEMENT:  COPY vistest FROM stdin CSV FREEZE;
2023-08-01 17:01:40.690 +07 client backend[296625] pg_regress/alter_table ERROR:  relation "attmp" does not exist at character 15
2023-08-01 17:01:40.690 +07 client backend[296625] pg_regress/alter_table STATEMENT:  SELECT * FROM attmp;
2023-08-01 17:01:40.691 +07 client backend[296620] pg_regress/truncate ERROR:  cannot truncate a table referenced in a foreign key constraint
2023-08-01 17:01:40.691 +07 client backend[296620] pg_regress/truncate DETAIL:  Table "trunc_b" references "truncate_a".
2023-08-01 17:01:40.691 +07 client backend[296620] pg_regress/truncate HINT:  Truncate table "trunc_b" at the same time, or use TRUNCATE ... CASCADE.
2023-08-01 17:01:40.691 +07 client backend[296620] pg_regress/truncate STATEMENT:  TRUNCATE TABLE truncate_a RESTRICT;
2023-08-01 17:01:40.692 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 18
2023-08-01 17:01:40.692 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.692 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.692 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xpath('', '<!-- error -->');
2023-08-01 17:01:40.692 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 26
2023-08-01 17:01:40.692 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.692 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.692 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xpath('//text()', '<local:data xmlns:local="http://127.0.0.1"><local:piece id="1">number one</local:piece><local:piece id="2" /></local:data>');
2023-08-01 17:01:40.693 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 33
2023-08-01 17:01:40.693 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.693 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.693 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xpath('//loc:piece/@id', '<local:data xmlns:local="http://127.0.0.1"><local:piece id="1">number one</local:piece><local:piece id="2" /></local:data>', ARRAY[ARRAY['loc', 'http://127.0.0.1']]);
2023-08-01 17:01:40.693 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 29
2023-08-01 17:01:40.693 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.693 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.693 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xpath('//loc:piece', '<local:data xmlns:local="http://127.0.0.1"><local:piece id="1">number one</local:piece><local:piece id="2" /></local:data>', ARRAY[ARRAY['loc', 'http://127.0.0.1']]);
2023-08-01 17:01:40.693 +07 client backend[296613] pg_regress/domain ERROR:  duplicate key value violates unique constraint "dcomptable_d1_key"
2023-08-01 17:01:40.693 +07 client backend[296613] pg_regress/domain DETAIL:  Key (d1)=((1,2)) already exists.
2023-08-01 17:01:40.693 +07 client backend[296613] pg_regress/domain STATEMENT:  insert into dcomptable values (row(1,2)::dcomptype);
2023-08-01 17:01:40.693 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 29
2023-08-01 17:01:40.693 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.693 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.693 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xpath('//loc:piece', '<local:data xmlns:local="http://127.0.0.1" xmlns="http://127.0.0.2"><local:piece id="1"><internal>number one</internal><internal2/></local:piece><local:piece id="2" /></local:data>', ARRAY[ARRAY['loc', 'http://127.0.0.1']]);
2023-08-01 17:01:40.693 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 21
2023-08-01 17:01:40.693 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.693 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.693 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xpath('//b', '<a>one <b>two</b> three <b>etc</b></a>');
2023-08-01 17:01:40.694 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 26
2023-08-01 17:01:40.694 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.694 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.694 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xpath('//text()', '<root>&lt;</root>');
2023-08-01 17:01:40.694 +07 client backend[296627] pg_regress/temp ERROR:  relation "temptest" does not exist at character 15
2023-08-01 17:01:40.694 +07 client backend[296627] pg_regress/temp STATEMENT:  SELECT * FROM temptest;
2023-08-01 17:01:40.694 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 26
2023-08-01 17:01:40.694 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.694 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.694 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xpath('//@value', '<root value="&lt;"/>');
2023-08-01 17:01:40.694 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 33
2023-08-01 17:01:40.694 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.694 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.694 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xpath('''<<invalid>>''', '<root/>');
2023-08-01 17:01:40.694 +07 client backend[296625] pg_regress/alter_table ERROR:  must be owner of index part_attmp_index
2023-08-01 17:01:40.694 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER INDEX part_attmp_index RENAME TO fail;
2023-08-01 17:01:40.694 +07 client backend[296625] pg_regress/alter_table ERROR:  must be owner of index part_attmp1_index
2023-08-01 17:01:40.694 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER INDEX part_attmp1_index RENAME TO fail;
2023-08-01 17:01:40.694 +07 client backend[296625] pg_regress/alter_table ERROR:  must be owner of table part_at2tmp
2023-08-01 17:01:40.694 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE part_at2tmp RENAME TO fail;
2023-08-01 17:01:40.694 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 28
2023-08-01 17:01:40.694 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.694 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.694 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xpath('count(//*)', '<root><sub/><sub/></root>');
2023-08-01 17:01:40.694 +07 client backend[296625] pg_regress/alter_table ERROR:  must be owner of table part_at2tmp1
2023-08-01 17:01:40.694 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE part_at2tmp1 RENAME TO fail;
2023-08-01 17:01:40.694 +07 client backend[296621] pg_regress/polymorphism ERROR:  cannot determine transition data type
2023-08-01 17:01:40.694 +07 client backend[296621] pg_regress/polymorphism DETAIL:  A result of type anyarray requires at least one input of type anyelement, anyarray, anynonarray, anyenum, or anyrange.
2023-08-01 17:01:40.694 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  CREATE AGGREGATE myaggp02a(*) (SFUNC = stfnp, STYPE = anyarray,
	  FINALFUNC = ffp, INITCOND = '{}');
2023-08-01 17:01:40.695 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 30
2023-08-01 17:01:40.695 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.695 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.695 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xpath('count(//*)=0', '<root><sub/><sub/></root>');
2023-08-01 17:01:40.695 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 30
2023-08-01 17:01:40.695 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.695 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.695 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xpath('count(//*)=3', '<root><sub/><sub/></root>');
2023-08-01 17:01:40.695 +07 client backend[296621] pg_regress/polymorphism ERROR:  cannot determine transition data type
2023-08-01 17:01:40.695 +07 client backend[296621] pg_regress/polymorphism DETAIL:  A result of type anyarray requires at least one input of type anyelement, anyarray, anynonarray, anyenum, or anyrange.
2023-08-01 17:01:40.695 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  CREATE AGGREGATE myaggp04a(*) (SFUNC = stfp, STYPE = anyarray,
	  FINALFUNC = ffp, INITCOND = '{}');
2023-08-01 17:01:40.695 +07 client backend[296621] pg_regress/polymorphism ERROR:  cannot determine transition data type
2023-08-01 17:01:40.695 +07 client backend[296621] pg_regress/polymorphism DETAIL:  A result of type anyarray requires at least one input of type anyelement, anyarray, anynonarray, anyenum, or anyrange.
2023-08-01 17:01:40.695 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  CREATE AGGREGATE myaggp04b(*) (SFUNC = stfp, STYPE = anyarray,
	  INITCOND = '{}');
2023-08-01 17:01:40.696 +07 client backend[296624] pg_regress/sequence ERROR:  cannot drop sequence t1_f1_seq because other objects depend on it
2023-08-01 17:01:40.696 +07 client backend[296624] pg_regress/sequence DETAIL:  default value for column f1 of table t1 depends on sequence t1_f1_seq
2023-08-01 17:01:40.696 +07 client backend[296624] pg_regress/sequence HINT:  Use DROP ... CASCADE to drop the dependent objects too.
2023-08-01 17:01:40.696 +07 client backend[296624] pg_regress/sequence STATEMENT:  DROP SEQUENCE t1_f1_seq;
2023-08-01 17:01:40.696 +07 client backend[296624] pg_regress/sequence ERROR:  cannot drop sequence myseq2 because other objects depend on it
2023-08-01 17:01:40.696 +07 client backend[296624] pg_regress/sequence DETAIL:  default value for column f2 of table t1 depends on sequence myseq2
2023-08-01 17:01:40.696 +07 client backend[296624] pg_regress/sequence HINT:  Use DROP ... CASCADE to drop the dependent objects too.
2023-08-01 17:01:40.696 +07 client backend[296624] pg_regress/sequence STATEMENT:  DROP SEQUENCE myseq2;
2023-08-01 17:01:40.696 +07 client backend[296621] pg_regress/polymorphism ERROR:  function tfnp(integer[], anyelement) does not exist
2023-08-01 17:01:40.696 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  CREATE AGGREGATE myaggp07a(BASETYPE = anyelement, SFUNC = tfnp, STYPE = int[],
	  FINALFUNC = ffp, INITCOND = '{}');
2023-08-01 17:01:40.697 +07 client backend[296624] pg_regress/sequence ERROR:  sequence "t1_f1_seq" does not exist
2023-08-01 17:01:40.697 +07 client backend[296624] pg_regress/sequence STATEMENT:  DROP SEQUENCE t1_f1_seq;
2023-08-01 17:01:40.697 +07 client backend[296624] pg_regress/sequence ERROR:  "serialtest1" is not a sequence
2023-08-01 17:01:40.697 +07 client backend[296624] pg_regress/sequence STATEMENT:  ALTER SEQUENCE serialTest1 CYCLE;
2023-08-01 17:01:40.697 +07 client backend[296620] pg_regress/truncate ERROR:  cannot truncate a table referenced in a foreign key constraint
2023-08-01 17:01:40.697 +07 client backend[296620] pg_regress/truncate DETAIL:  Table "truncate_a" references "trunc_c".
2023-08-01 17:01:40.697 +07 client backend[296620] pg_regress/truncate HINT:  Truncate table "truncate_a" at the same time, or use TRUNCATE ... CASCADE.
2023-08-01 17:01:40.697 +07 client backend[296620] pg_regress/truncate STATEMENT:  TRUNCATE TABLE trunc_c;
2023-08-01 17:01:40.697 +07 client backend[296616] pg_regress/copy2 ERROR:  null value in column "b" of relation "forcetest" violates not-null constraint
2023-08-01 17:01:40.697 +07 client backend[296616] pg_regress/copy2 DETAIL:  Failing row contains (3, null, , null, null).
2023-08-01 17:01:40.697 +07 client backend[296616] pg_regress/copy2 CONTEXT:  COPY forcetest, line 1: "3,,"""
2023-08-01 17:01:40.697 +07 client backend[296616] pg_regress/copy2 STATEMENT:  COPY forcetest (a, b, c) FROM STDIN WITH (FORMAT csv, FORCE_NULL(b), FORCE_NOT_NULL(c));
2023-08-01 17:01:40.697 +07 client backend[296620] pg_regress/truncate ERROR:  cannot truncate a table referenced in a foreign key constraint
2023-08-01 17:01:40.697 +07 client backend[296620] pg_regress/truncate DETAIL:  Table "trunc_d" references "trunc_c".
2023-08-01 17:01:40.697 +07 client backend[296620] pg_regress/truncate HINT:  Truncate table "trunc_d" at the same time, or use TRUNCATE ... CASCADE.
2023-08-01 17:01:40.697 +07 client backend[296620] pg_regress/truncate STATEMENT:  TRUNCATE TABLE trunc_c,truncate_a;
2023-08-01 17:01:40.697 +07 client backend[296621] pg_regress/polymorphism ERROR:  function tf1p(integer[], anyelement) does not exist
2023-08-01 17:01:40.697 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  CREATE AGGREGATE myaggp11a(BASETYPE = anyelement, SFUNC = tf1p, STYPE = int[],
	  FINALFUNC = ffp, INITCOND = '{}');
2023-08-01 17:01:40.697 +07 client backend[296621] pg_regress/polymorphism ERROR:  function tf1p(integer[], anyelement) does not exist
2023-08-01 17:01:40.697 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  CREATE AGGREGATE myaggp11b(BASETYPE = anyelement, SFUNC = tf1p, STYPE = int[],
	  INITCOND = '{}');
2023-08-01 17:01:40.697 +07 client backend[296613] pg_regress/domain ERROR:  column "d1" of table "dcomptable" contains values that violate the new constraint
2023-08-01 17:01:40.697 +07 client backend[296613] pg_regress/domain STATEMENT:  alter domain dcomptype add constraint c2 check ((value).r > (value).i);
2023-08-01 17:01:40.697 +07 client backend[296616] pg_regress/copy2 ERROR:  FORCE_NOT_NULL column "b" not referenced by COPY
2023-08-01 17:01:40.697 +07 client backend[296616] pg_regress/copy2 STATEMENT:  COPY forcetest (d, e) FROM STDIN WITH (FORMAT csv, FORCE_NOT_NULL(b));
2023-08-01 17:01:40.698 +07 client backend[296613] pg_regress/domain ERROR:  value for domain dcomptype violates check constraint "c1"
2023-08-01 17:01:40.698 +07 client backend[296613] pg_regress/domain STATEMENT:  select row(2,1)::dcomptype;
2023-08-01 17:01:40.698 +07 client backend[296616] pg_regress/copy2 ERROR:  FORCE_NULL column "b" not referenced by COPY
2023-08-01 17:01:40.698 +07 client backend[296616] pg_regress/copy2 STATEMENT:  COPY forcetest (d, e) FROM STDIN WITH (FORMAT csv, FORCE_NULL(b));
2023-08-01 17:01:40.698 +07 client backend[296621] pg_regress/polymorphism ERROR:  function tfp(integer[], anyelement) does not exist
2023-08-01 17:01:40.698 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  CREATE AGGREGATE myaggp12a(BASETYPE = anyelement, SFUNC = tfp, STYPE = int[],
	  FINALFUNC = ffp, INITCOND = '{}');
2023-08-01 17:01:40.698 +07 client backend[296613] pg_regress/domain ERROR:  value for domain dcomptype violates check constraint "c1"
2023-08-01 17:01:40.698 +07 client backend[296613] pg_regress/domain STATEMENT:  insert into dcomptable values (row(2,1)::comptype);
2023-08-01 17:01:40.698 +07 client backend[296621] pg_regress/polymorphism ERROR:  function tfp(integer[], anyelement) does not exist
2023-08-01 17:01:40.698 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  CREATE AGGREGATE myaggp12b(BASETYPE = anyelement, SFUNC = tfp, STYPE = int[],
	  INITCOND = '{}');
2023-08-01 17:01:40.698 +07 client backend[296613] pg_regress/domain ERROR:  value for domain dcomptype violates check constraint "c1"
2023-08-01 17:01:40.698 +07 client backend[296613] pg_regress/domain STATEMENT:  insert into dcomptable (d1.r, d1.i) values(100, 99);
2023-08-01 17:01:40.698 +07 client backend[296613] pg_regress/domain ERROR:  value for domain dcomptype violates check constraint "c1"
2023-08-01 17:01:40.698 +07 client backend[296613] pg_regress/domain STATEMENT:  update dcomptable set d1.r = (d1).r + 1 where (d1).i > 0;
2023-08-01 17:01:40.698 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 26
2023-08-01 17:01:40.698 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.698 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.698 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xpath('name(/*)', '<root><sub/><sub/></root>');
2023-08-01 17:01:40.698 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 28
2023-08-01 17:01:40.698 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.698 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.698 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xpath('/nosuchtag', '<root/>');
2023-08-01 17:01:40.699 +07 client backend[296624] pg_regress/sequence ERROR:  RESTART value (0) cannot be less than MINVALUE (1)
2023-08-01 17:01:40.699 +07 client backend[296624] pg_regress/sequence STATEMENT:  ALTER SEQUENCE sequence_test2 RESTART WITH 0;
2023-08-01 17:01:40.699 +07 client backend[296624] pg_regress/sequence ERROR:  RESTART value (40) cannot be greater than MAXVALUE (-1)
2023-08-01 17:01:40.699 +07 client backend[296624] pg_regress/sequence STATEMENT:  ALTER SEQUENCE sequence_test4 RESTART WITH 40;
2023-08-01 17:01:40.699 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 22
2023-08-01 17:01:40.699 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.699 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.699 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xpath('root', '<root/>');
2023-08-01 17:01:40.699 +07 client backend[296627] pg_regress/temp ERROR:  relation "temptest" does not exist at character 15
2023-08-01 17:01:40.699 +07 client backend[296627] pg_regress/temp STATEMENT:  SELECT * FROM temptest;
2023-08-01 17:01:40.700 +07 client backend[296627] pg_regress/temp ERROR:  ON COMMIT can only be used on temporary tables
2023-08-01 17:01:40.700 +07 client backend[296627] pg_regress/temp STATEMENT:  CREATE TABLE temptest(col int) ON COMMIT DELETE ROWS;
2023-08-01 17:01:40.700 +07 client backend[296627] pg_regress/temp ERROR:  ON COMMIT can only be used on temporary tables
2023-08-01 17:01:40.700 +07 client backend[296627] pg_regress/temp STATEMENT:  CREATE TABLE temptest(col) ON COMMIT DELETE ROWS AS SELECT 1;
2023-08-01 17:01:40.700 +07 client backend[296620] pg_regress/truncate ERROR:  cannot truncate a table referenced in a foreign key constraint
2023-08-01 17:01:40.700 +07 client backend[296620] pg_regress/truncate DETAIL:  Table "trunc_e" references "trunc_c".
2023-08-01 17:01:40.700 +07 client backend[296620] pg_regress/truncate HINT:  Truncate table "trunc_e" at the same time, or use TRUNCATE ... CASCADE.
2023-08-01 17:01:40.700 +07 client backend[296620] pg_regress/truncate STATEMENT:  TRUNCATE TABLE trunc_c,truncate_a,trunc_d;
2023-08-01 17:01:40.700 +07 client backend[296623] pg_regress/xml LOG:  skip: unsupported XML feature
2023-08-01 17:01:40.700 +07 client backend[296623] pg_regress/xml CONTEXT:  PL/pgSQL function inline_code_block line 32 at RAISE
2023-08-01 17:01:40.700 +07 client backend[296623] pg_regress/xml STATEMENT:  DO $$
	DECLARE
	  xml_declaration text := '<?xml version="1.0" encoding="ISO-8859-1"?>';
	  degree_symbol text;
	  res xml[];
	BEGIN
	  -- Per the documentation, except when the server encoding is UTF8, xpath()
	  -- may not work on non-ASCII data.  The untranslatable_character and
	  -- undefined_function traps below, currently dead code, will become relevant
	  -- if we remove this limitation.
	  IF current_setting('server_encoding') <> 'UTF8' THEN
	    RAISE LOG 'skip: encoding % unsupported for xpath',
	      current_setting('server_encoding');
	    RETURN;
	  END IF;
	
	  degree_symbol := convert_from('\xc2b0', 'UTF8');
	  res := xpath('text()', (xml_declaration ||
	    '<x>' || degree_symbol || '</x>')::xml);
	  IF degree_symbol <> res[1]::text THEN
	    RAISE 'expected % (%), got % (%)',
	      degree_symbol, convert_to(degree_symbol, 'UTF8'),
	      res[1], convert_to(res[1]::text, 'UTF8');
	  END IF;
	EXCEPTION
	  -- character with byte sequence 0xc2 0xb0 in encoding "UTF8" has no equivalent in encoding "LATIN8"
	  WHEN untranslatable_character
	  -- default conversion function for encoding "UTF8" to "MULE_INTERNAL" does not exist
	  OR undefined_function
	  -- unsupported XML feature
	  OR feature_not_supported THEN
	    RAISE LOG 'skip: %', SQLERRM;
	END
	$$;
2023-08-01 17:01:40.701 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 64
2023-08-01 17:01:40.701 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.701 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.701 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlexists('//town[text() = ''Toronto'']' PASSING BY REF '<towns><town>Bidford-on-Avon</town><town>Cwmbran</town><town>Bristol</town></towns>');
2023-08-01 17:01:40.701 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 64
2023-08-01 17:01:40.701 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.701 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.701 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlexists('//town[text() = ''Cwmbran'']' PASSING BY REF '<towns><town>Bidford-on-Avon</town><town>Cwmbran</town><town>Bristol</town></towns>');
2023-08-01 17:01:40.701 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 53
2023-08-01 17:01:40.701 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.701 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.701 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xmlexists('count(/nosuchtag)' PASSING BY REF '<root/>');
2023-08-01 17:01:40.701 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 52
2023-08-01 17:01:40.701 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.701 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.701 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xpath_exists('//town[text() = ''Toronto'']','<towns><town>Bidford-on-Avon</town><town>Cwmbran</town><town>Bristol</town></towns>'::xml);
2023-08-01 17:01:40.701 +07 client backend[296625] pg_regress/alter_table ERROR:  must be owner of index onek_unique1
2023-08-01 17:01:40.701 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER INDEX onek_unique1 RENAME TO fail;
2023-08-01 17:01:40.701 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 52
2023-08-01 17:01:40.701 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.701 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.701 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xpath_exists('//town[text() = ''Cwmbran'']','<towns><town>Bidford-on-Avon</town><town>Cwmbran</town><town>Bristol</town></towns>'::xml);
2023-08-01 17:01:40.701 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 42
2023-08-01 17:01:40.701 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.701 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.701 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xpath_exists('count(/nosuchtag)', '<root/>'::xml);
2023-08-01 17:01:40.701 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 32
2023-08-01 17:01:40.701 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.701 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.701 +07 client backend[296623] pg_regress/xml STATEMENT:  INSERT INTO xmltest VALUES (4, '<menu><beers><name>Budvar</name><cost>free</cost><name>Carling</name><cost>lots</cost></beers></menu>'::xml);
2023-08-01 17:01:40.701 +07 client backend[296620] pg_regress/truncate ERROR:  cannot truncate a table referenced in a foreign key constraint
2023-08-01 17:01:40.701 +07 client backend[296620] pg_regress/truncate DETAIL:  Table "trunc_b" references "truncate_a".
2023-08-01 17:01:40.701 +07 client backend[296620] pg_regress/truncate HINT:  Truncate table "trunc_b" at the same time, or use TRUNCATE ... CASCADE.
2023-08-01 17:01:40.701 +07 client backend[296620] pg_regress/truncate STATEMENT:  TRUNCATE TABLE trunc_c,truncate_a,trunc_d,trunc_e;
2023-08-01 17:01:40.702 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 32
2023-08-01 17:01:40.702 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.702 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.702 +07 client backend[296623] pg_regress/xml STATEMENT:  INSERT INTO xmltest VALUES (5, '<menu><beers><name>Molson</name><cost>free</cost><name>Carling</name><cost>lots</cost></beers></menu>'::xml);
2023-08-01 17:01:40.702 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 32
2023-08-01 17:01:40.702 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.702 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.702 +07 client backend[296623] pg_regress/xml STATEMENT:  INSERT INTO xmltest VALUES (6, '<myns:menu xmlns:myns="http://myns.com"><myns:beers><myns:name>Budvar</myns:name><myns:cost>free</myns:cost><myns:name>Carling</myns:name><myns:cost>lots</myns:cost></myns:beers></myns:menu>'::xml);
2023-08-01 17:01:40.702 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 32
2023-08-01 17:01:40.702 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.702 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.702 +07 client backend[296623] pg_regress/xml STATEMENT:  INSERT INTO xmltest VALUES (7, '<myns:menu xmlns:myns="http://myns.com"><myns:beers><myns:name>Molson</myns:name><myns:cost>free</myns:cost><myns:name>Carling</myns:name><myns:cost>lots</myns:cost></myns:beers></myns:menu>'::xml);
2023-08-01 17:01:40.702 +07 client backend[296625] pg_regress/alter_table ERROR:  must be owner of view attmp_view_new
2023-08-01 17:01:40.702 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER VIEW attmp_view_new RENAME TO fail;
2023-08-01 17:01:40.703 +07 client backend[296621] pg_regress/polymorphism ERROR:  cannot determine transition data type
2023-08-01 17:01:40.703 +07 client backend[296621] pg_regress/polymorphism DETAIL:  A result of type anyarray requires at least one input of type anyelement, anyarray, anynonarray, anyenum, or anyrange.
2023-08-01 17:01:40.703 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  CREATE AGGREGATE myaggp13a(BASETYPE = int, SFUNC = tfnp, STYPE = anyarray,
	  FINALFUNC = ffp, INITCOND = '{}');
2023-08-01 17:01:40.703 +07 client backend[296624] pg_regress/sequence ERROR:  nextval: reached maximum value of sequence "sequence_test2" (36)
2023-08-01 17:01:40.703 +07 client backend[296624] pg_regress/sequence STATEMENT:  SELECT nextval('sequence_test2');
2023-08-01 17:01:40.704 +07 client backend[296621] pg_regress/polymorphism ERROR:  cannot determine transition data type
2023-08-01 17:01:40.704 +07 client backend[296621] pg_regress/polymorphism DETAIL:  A result of type anyarray requires at least one input of type anyelement, anyarray, anynonarray, anyenum, or anyrange.
2023-08-01 17:01:40.704 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  CREATE AGGREGATE myaggp14a(BASETYPE = int, SFUNC = tf2p, STYPE = anyarray,
	  FINALFUNC = ffp, INITCOND = '{}');
2023-08-01 17:01:40.705 +07 client backend[296621] pg_regress/polymorphism ERROR:  function tfnp(anyarray, anyelement) does not exist
2023-08-01 17:01:40.705 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  CREATE AGGREGATE myaggp15a(BASETYPE = anyelement, SFUNC = tfnp,
	  STYPE = anyarray, FINALFUNC = ffp, INITCOND = '{}');
2023-08-01 17:01:40.705 +07 client backend[296621] pg_regress/polymorphism ERROR:  function tf2p(anyarray, anyelement) does not exist
2023-08-01 17:01:40.705 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  CREATE AGGREGATE myaggp16a(BASETYPE = anyelement, SFUNC = tf2p,
	  STYPE = anyarray, FINALFUNC = ffp, INITCOND = '{}');
2023-08-01 17:01:40.705 +07 client backend[296621] pg_regress/polymorphism ERROR:  cannot determine transition data type
2023-08-01 17:01:40.705 +07 client backend[296621] pg_regress/polymorphism DETAIL:  A result of type anyarray requires at least one input of type anyelement, anyarray, anynonarray, anyenum, or anyrange.
2023-08-01 17:01:40.705 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  CREATE AGGREGATE myaggp17a(BASETYPE = int, SFUNC = tf1p, STYPE = anyarray,
	  FINALFUNC = ffp, INITCOND = '{}');
2023-08-01 17:01:40.705 +07 client backend[296621] pg_regress/polymorphism ERROR:  cannot determine transition data type
2023-08-01 17:01:40.705 +07 client backend[296621] pg_regress/polymorphism DETAIL:  A result of type anyarray requires at least one input of type anyelement, anyarray, anynonarray, anyenum, or anyrange.
2023-08-01 17:01:40.705 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  CREATE AGGREGATE myaggp17b(BASETYPE = int, SFUNC = tf1p, STYPE = anyarray,
	  INITCOND = '{}');
2023-08-01 17:01:40.705 +07 client backend[296621] pg_regress/polymorphism ERROR:  cannot determine transition data type
2023-08-01 17:01:40.705 +07 client backend[296621] pg_regress/polymorphism DETAIL:  A result of type anyarray requires at least one input of type anyelement, anyarray, anynonarray, anyenum, or anyrange.
2023-08-01 17:01:40.705 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  CREATE AGGREGATE myaggp18a(BASETYPE = int, SFUNC = tfp, STYPE = anyarray,
	  FINALFUNC = ffp, INITCOND = '{}');
2023-08-01 17:01:40.705 +07 client backend[296621] pg_regress/polymorphism ERROR:  cannot determine transition data type
2023-08-01 17:01:40.705 +07 client backend[296621] pg_regress/polymorphism DETAIL:  A result of type anyarray requires at least one input of type anyelement, anyarray, anynonarray, anyenum, or anyrange.
2023-08-01 17:01:40.705 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  CREATE AGGREGATE myaggp18b(BASETYPE = int, SFUNC = tfp, STYPE = anyarray,
	  INITCOND = '{}');
2023-08-01 17:01:40.705 +07 client backend[296624] pg_regress/sequence ERROR:  nextval: reached minimum value of sequence "sequence_test2" (-36)
2023-08-01 17:01:40.705 +07 client backend[296624] pg_regress/sequence STATEMENT:  SELECT nextval('sequence_test2');
2023-08-01 17:01:40.705 +07 client backend[296621] pg_regress/polymorphism ERROR:  function tf1p(anyarray, anyelement) does not exist
2023-08-01 17:01:40.705 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  CREATE AGGREGATE myaggp19a(BASETYPE = anyelement, SFUNC = tf1p,
	  STYPE = anyarray, FINALFUNC = ffp, INITCOND = '{}');
2023-08-01 17:01:40.705 +07 client backend[296621] pg_regress/polymorphism ERROR:  function tf1p(anyarray, anyelement) does not exist
2023-08-01 17:01:40.705 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  CREATE AGGREGATE myaggp19b(BASETYPE = anyelement, SFUNC = tf1p,
	  STYPE = anyarray, INITCOND = '{}');
2023-08-01 17:01:40.706 +07 client backend[296624] pg_regress/sequence ERROR:  setval: value -100 is out of bounds for sequence "sequence_test2" (5..36)
2023-08-01 17:01:40.706 +07 client backend[296624] pg_regress/sequence STATEMENT:  SELECT setval('sequence_test2', -100);
2023-08-01 17:01:40.706 +07 client backend[296624] pg_regress/sequence ERROR:  setval: value 100 is out of bounds for sequence "sequence_test2" (5..36)
2023-08-01 17:01:40.706 +07 client backend[296624] pg_regress/sequence STATEMENT:  SELECT setval('sequence_test2', 100);
2023-08-01 17:01:40.706 +07 client backend[296621] pg_regress/polymorphism ERROR:  cannot determine transition data type
2023-08-01 17:01:40.706 +07 client backend[296621] pg_regress/polymorphism DETAIL:  A result of type anyarray requires at least one input of type anyelement, anyarray, anynonarray, anyenum, or anyrange.
2023-08-01 17:01:40.706 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  CREATE AGGREGATE myaggn02a(*) (SFUNC = stfnp, STYPE = anyarray,
	  FINALFUNC = ffnp, INITCOND = '{}');
2023-08-01 17:01:40.706 +07 client backend[296621] pg_regress/polymorphism ERROR:  cannot determine transition data type
2023-08-01 17:01:40.706 +07 client backend[296621] pg_regress/polymorphism DETAIL:  A result of type anyarray requires at least one input of type anyelement, anyarray, anynonarray, anyenum, or anyrange.
2023-08-01 17:01:40.706 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  CREATE AGGREGATE myaggn02b(*) (SFUNC = stfnp, STYPE = anyarray,
	  INITCOND = '{}');
2023-08-01 17:01:40.707 +07 client backend[296621] pg_regress/polymorphism ERROR:  cannot determine transition data type
2023-08-01 17:01:40.707 +07 client backend[296621] pg_regress/polymorphism DETAIL:  A result of type anyarray requires at least one input of type anyelement, anyarray, anynonarray, anyenum, or anyrange.
2023-08-01 17:01:40.707 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  CREATE AGGREGATE myaggn04a(*) (SFUNC = stfp, STYPE = anyarray,
	  FINALFUNC = ffnp, INITCOND = '{}');
2023-08-01 17:01:40.708 +07 client backend[296625] pg_regress/alter_table ERROR:  cannot drop index onek_unique1_constraint because constraint onek_unique1_constraint on table onek requires it
2023-08-01 17:01:40.708 +07 client backend[296625] pg_regress/alter_table HINT:  You can drop constraint onek_unique1_constraint on table onek instead.
2023-08-01 17:01:40.708 +07 client backend[296625] pg_regress/alter_table STATEMENT:  DROP INDEX onek_unique1_constraint;
2023-08-01 17:01:40.708 +07 client backend[296625] pg_regress/alter_table ERROR:  cannot drop index onek_unique1_constraint_foo because constraint onek_unique1_constraint_foo on table onek requires it
2023-08-01 17:01:40.708 +07 client backend[296625] pg_regress/alter_table HINT:  You can drop constraint onek_unique1_constraint_foo on table onek instead.
2023-08-01 17:01:40.708 +07 client backend[296625] pg_regress/alter_table STATEMENT:  DROP INDEX onek_unique1_constraint_foo;
2023-08-01 17:01:40.709 +07 client backend[296621] pg_regress/polymorphism ERROR:  function tfnp(integer[], anyelement) does not exist
2023-08-01 17:01:40.709 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  CREATE AGGREGATE myaggn07a(BASETYPE = anyelement, SFUNC = tfnp, STYPE = int[],
	  FINALFUNC = ffnp, INITCOND = '{}');
2023-08-01 17:01:40.709 +07 client backend[296621] pg_regress/polymorphism ERROR:  function tfnp(integer[], anyelement) does not exist
2023-08-01 17:01:40.709 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  CREATE AGGREGATE myaggn07b(BASETYPE = anyelement, SFUNC = tfnp, STYPE = int[],
	  INITCOND = '{}');
2023-08-01 17:01:40.709 +07 client backend[296616] pg_regress/copy2 ERROR:  new row for relation "check_con_tbl" violates check constraint "check_con_tbl_check"
2023-08-01 17:01:40.709 +07 client backend[296616] pg_regress/copy2 DETAIL:  Failing row contains (0).
2023-08-01 17:01:40.709 +07 client backend[296616] pg_regress/copy2 CONTEXT:  COPY check_con_tbl, line 1: "0"
2023-08-01 17:01:40.709 +07 client backend[296616] pg_regress/copy2 STATEMENT:  copy check_con_tbl from stdin;
2023-08-01 17:01:40.711 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.711 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.711 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.711 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xml_is_well_formed_document('<foo>bar</foo>');
2023-08-01 17:01:40.711 +07 client backend[296613] pg_regress/domain ERROR:  value for domain dcomptype violates check constraint "c1"
2023-08-01 17:01:40.711 +07 client backend[296613] pg_regress/domain STATEMENT:  select row(0,1)::dcomptype;
2023-08-01 17:01:40.711 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.711 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.711 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.711 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xml_is_well_formed_document('abc');
2023-08-01 17:01:40.712 +07 client backend[296621] pg_regress/polymorphism ERROR:  function tf1p(integer[], anyelement) does not exist
2023-08-01 17:01:40.712 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  CREATE AGGREGATE myaggn11a(BASETYPE = anyelement, SFUNC = tf1p, STYPE = int[],
	  FINALFUNC = ffnp, INITCOND = '{}');
2023-08-01 17:01:40.712 +07 client backend[296621] pg_regress/polymorphism ERROR:  function tfp(integer[], anyelement) does not exist
2023-08-01 17:01:40.712 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  CREATE AGGREGATE myaggn12a(BASETYPE = anyelement, SFUNC = tfp, STYPE = int[],
	  FINALFUNC = ffnp, INITCOND = '{}');
2023-08-01 17:01:40.712 +07 client backend[296621] pg_regress/polymorphism ERROR:  cannot determine transition data type
2023-08-01 17:01:40.712 +07 client backend[296621] pg_regress/polymorphism DETAIL:  A result of type anyarray requires at least one input of type anyelement, anyarray, anynonarray, anyenum, or anyrange.
2023-08-01 17:01:40.712 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  CREATE AGGREGATE myaggn13a(BASETYPE = int, SFUNC = tfnp, STYPE = anyarray,
	  FINALFUNC = ffnp, INITCOND = '{}');
2023-08-01 17:01:40.712 +07 client backend[296621] pg_regress/polymorphism ERROR:  cannot determine transition data type
2023-08-01 17:01:40.712 +07 client backend[296621] pg_regress/polymorphism DETAIL:  A result of type anyarray requires at least one input of type anyelement, anyarray, anynonarray, anyenum, or anyrange.
2023-08-01 17:01:40.712 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  CREATE AGGREGATE myaggn13b(BASETYPE = int, SFUNC = tfnp, STYPE = anyarray,
	  INITCOND = '{}');
2023-08-01 17:01:40.712 +07 client backend[296621] pg_regress/polymorphism ERROR:  cannot determine transition data type
2023-08-01 17:01:40.712 +07 client backend[296621] pg_regress/polymorphism DETAIL:  A result of type anyarray requires at least one input of type anyelement, anyarray, anynonarray, anyenum, or anyrange.
2023-08-01 17:01:40.712 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  CREATE AGGREGATE myaggn14a(BASETYPE = int, SFUNC = tf2p, STYPE = anyarray,
	  FINALFUNC = ffnp, INITCOND = '{}');
2023-08-01 17:01:40.712 +07 client backend[296621] pg_regress/polymorphism ERROR:  cannot determine transition data type
2023-08-01 17:01:40.712 +07 client backend[296621] pg_regress/polymorphism DETAIL:  A result of type anyarray requires at least one input of type anyelement, anyarray, anynonarray, anyenum, or anyrange.
2023-08-01 17:01:40.712 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  CREATE AGGREGATE myaggn14b(BASETYPE = int, SFUNC = tf2p, STYPE = anyarray,
	  INITCOND = '{}');
2023-08-01 17:01:40.712 +07 client backend[296613] pg_regress/domain ERROR:  operator does not exist: character varying > double precision
2023-08-01 17:01:40.712 +07 client backend[296613] pg_regress/domain HINT:  No operator matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:40.712 +07 client backend[296613] pg_regress/domain STATEMENT:  alter type comptype alter attribute r type varchar;
2023-08-01 17:01:40.712 +07 client backend[296621] pg_regress/polymorphism ERROR:  function tfnp(anyarray, anyelement) does not exist
2023-08-01 17:01:40.712 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  CREATE AGGREGATE myaggn15a(BASETYPE = anyelement, SFUNC = tfnp,
	  STYPE = anyarray, FINALFUNC = ffnp, INITCOND = '{}');
2023-08-01 17:01:40.712 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.712 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.712 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.712 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xml_is_well_formed_content('<foo>bar</foo>');
2023-08-01 17:01:40.712 +07 client backend[296621] pg_regress/polymorphism ERROR:  function tfnp(anyarray, anyelement) does not exist
2023-08-01 17:01:40.712 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  CREATE AGGREGATE myaggn15b(BASETYPE = anyelement, SFUNC = tfnp,
	  STYPE = anyarray, INITCOND = '{}');
2023-08-01 17:01:40.712 +07 client backend[296621] pg_regress/polymorphism ERROR:  function tf2p(anyarray, anyelement) does not exist
2023-08-01 17:01:40.712 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  CREATE AGGREGATE myaggn16a(BASETYPE = anyelement, SFUNC = tf2p,
	  STYPE = anyarray, FINALFUNC = ffnp, INITCOND = '{}');
2023-08-01 17:01:40.712 +07 client backend[296621] pg_regress/polymorphism ERROR:  function tf2p(anyarray, anyelement) does not exist
2023-08-01 17:01:40.712 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  CREATE AGGREGATE myaggn16b(BASETYPE = anyelement, SFUNC = tf2p,
	  STYPE = anyarray, INITCOND = '{}');
2023-08-01 17:01:40.712 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.712 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.712 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.712 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xml_is_well_formed_content('abc');
2023-08-01 17:01:40.712 +07 client backend[296621] pg_regress/polymorphism ERROR:  cannot determine transition data type
2023-08-01 17:01:40.712 +07 client backend[296621] pg_regress/polymorphism DETAIL:  A result of type anyarray requires at least one input of type anyelement, anyarray, anynonarray, anyenum, or anyrange.
2023-08-01 17:01:40.712 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  CREATE AGGREGATE myaggn17a(BASETYPE = int, SFUNC = tf1p, STYPE = anyarray,
	  FINALFUNC = ffnp, INITCOND = '{}');
2023-08-01 17:01:40.713 +07 client backend[296627] pg_regress/temp ERROR:  unsupported ON COMMIT and foreign key combination
2023-08-01 17:01:40.713 +07 client backend[296627] pg_regress/temp DETAIL:  Table "temptest4" references "temptest3", but they do not have the same ON COMMIT setting.
2023-08-01 17:01:40.713 +07 client backend[296627] pg_regress/temp STATEMENT:  COMMIT;
2023-08-01 17:01:40.713 +07 client backend[296621] pg_regress/polymorphism ERROR:  cannot determine transition data type
2023-08-01 17:01:40.713 +07 client backend[296621] pg_regress/polymorphism DETAIL:  A result of type anyarray requires at least one input of type anyelement, anyarray, anynonarray, anyenum, or anyrange.
2023-08-01 17:01:40.713 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  CREATE AGGREGATE myaggn18a(BASETYPE = int, SFUNC = tfp, STYPE = anyarray,
	  FINALFUNC = ffnp, INITCOND = '{}');
2023-08-01 17:01:40.713 +07 client backend[296621] pg_regress/polymorphism ERROR:  function tf1p(anyarray, anyelement) does not exist
2023-08-01 17:01:40.713 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  CREATE AGGREGATE myaggn19a(BASETYPE = anyelement, SFUNC = tf1p,
	  STYPE = anyarray, FINALFUNC = ffnp, INITCOND = '{}');
2023-08-01 17:01:40.713 +07 client backend[296621] pg_regress/polymorphism ERROR:  function ffnp(anyarray) does not exist
2023-08-01 17:01:40.713 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  CREATE AGGREGATE myaggn20a(BASETYPE = anyelement, SFUNC = tfp,
	  STYPE = anyarray, FINALFUNC = ffnp, INITCOND = '{}');
2023-08-01 17:01:40.713 +07 client backend[296618] pg_regress/with ERROR:  recursive query "x" does not have the form non-recursive-term UNION [ALL] recursive-term at character 16
2023-08-01 17:01:40.713 +07 client backend[296618] pg_regress/with STATEMENT:  WITH RECURSIVE x(n) AS (SELECT 1 INTERSECT SELECT n+1 FROM x)
		SELECT * FROM x;
2023-08-01 17:01:40.713 +07 client backend[296618] pg_regress/with ERROR:  recursive query "x" does not have the form non-recursive-term UNION [ALL] recursive-term at character 16
2023-08-01 17:01:40.713 +07 client backend[296618] pg_regress/with STATEMENT:  WITH RECURSIVE x(n) AS (SELECT 1 INTERSECT ALL SELECT n+1 FROM x)
		SELECT * FROM x;
2023-08-01 17:01:40.714 +07 client backend[296618] pg_regress/with ERROR:  recursive query "x" does not have the form non-recursive-term UNION [ALL] recursive-term at character 16
2023-08-01 17:01:40.714 +07 client backend[296618] pg_regress/with STATEMENT:  WITH RECURSIVE x(n) AS (SELECT 1 EXCEPT SELECT n+1 FROM x)
		SELECT * FROM x;
2023-08-01 17:01:40.714 +07 client backend[296618] pg_regress/with ERROR:  recursive query "x" does not have the form non-recursive-term UNION [ALL] recursive-term at character 16
2023-08-01 17:01:40.714 +07 client backend[296618] pg_regress/with STATEMENT:  WITH RECURSIVE x(n) AS (SELECT 1 EXCEPT ALL SELECT n+1 FROM x)
		SELECT * FROM x;
2023-08-01 17:01:40.714 +07 client backend[296616] pg_regress/copy2 ERROR:  permission denied for table rls_t1
2023-08-01 17:01:40.714 +07 client backend[296616] pg_regress/copy2 STATEMENT:  COPY rls_t1 TO stdout;
2023-08-01 17:01:40.714 +07 client backend[296618] pg_regress/with ERROR:  recursive query "x" does not have the form non-recursive-term UNION [ALL] recursive-term at character 16
2023-08-01 17:01:40.714 +07 client backend[296618] pg_regress/with STATEMENT:  WITH RECURSIVE x(n) AS (SELECT n FROM x)
		SELECT * FROM x;
2023-08-01 17:01:40.714 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.714 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.714 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.714 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xml_is_well_formed('abc');
2023-08-01 17:01:40.714 +07 client backend[296616] pg_regress/copy2 ERROR:  permission denied for table rls_t1
2023-08-01 17:01:40.714 +07 client backend[296616] pg_regress/copy2 STATEMENT:  COPY rls_t1 (a, b, c) TO stdout;
2023-08-01 17:01:40.714 +07 client backend[296616] pg_regress/copy2 ERROR:  permission denied for table rls_t1
2023-08-01 17:01:40.714 +07 client backend[296616] pg_regress/copy2 STATEMENT:  COPY rls_t1 (c) TO stdout;
2023-08-01 17:01:40.714 +07 client backend[296618] pg_regress/with ERROR:  recursive reference to query "x" must not appear within its non-recursive term at character 39
2023-08-01 17:01:40.714 +07 client backend[296618] pg_regress/with STATEMENT:  WITH RECURSIVE x(n) AS (SELECT n FROM x UNION ALL SELECT 1)
		SELECT * FROM x;
2023-08-01 17:01:40.714 +07 client backend[296613] pg_regress/domain ERROR:  cannot drop column r of composite type comptype because other objects depend on it
2023-08-01 17:01:40.714 +07 client backend[296613] pg_regress/domain DETAIL:  constraint c1 depends on column r of composite type comptype
2023-08-01 17:01:40.714 +07 client backend[296613] pg_regress/domain HINT:  Use DROP ... CASCADE to drop the dependent objects too.
2023-08-01 17:01:40.714 +07 client backend[296613] pg_regress/domain STATEMENT:  alter type comptype drop attribute r;
2023-08-01 17:01:40.714 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.714 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.714 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.714 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xml_is_well_formed('<>');
2023-08-01 17:01:40.715 +07 client backend[296618] pg_regress/with ERROR:  recursive reference to query "x" must not appear within an outer join at character 95
2023-08-01 17:01:40.715 +07 client backend[296618] pg_regress/with STATEMENT:  WITH RECURSIVE x(n) AS (SELECT a FROM y WHERE a = 1
		UNION ALL
		SELECT x.n+1 FROM y LEFT JOIN x ON x.n = y.a WHERE n < 10)
	SELECT * FROM x;
2023-08-01 17:01:40.715 +07 client backend[296618] pg_regress/with ERROR:  recursive reference to query "x" must not appear within an outer join at character 83
2023-08-01 17:01:40.715 +07 client backend[296618] pg_regress/with STATEMENT:  WITH RECURSIVE x(n) AS (SELECT a FROM y WHERE a = 1
		UNION ALL
		SELECT x.n+1 FROM x RIGHT JOIN y ON x.n = y.a WHERE n < 10)
	SELECT * FROM x;
2023-08-01 17:01:40.715 +07 client backend[296618] pg_regress/with ERROR:  recursive reference to query "x" must not appear within an outer join at character 83
2023-08-01 17:01:40.715 +07 client backend[296618] pg_regress/with STATEMENT:  WITH RECURSIVE x(n) AS (SELECT a FROM y WHERE a = 1
		UNION ALL
		SELECT x.n+1 FROM x FULL JOIN y ON x.n = y.a WHERE n < 10)
	SELECT * FROM x;
2023-08-01 17:01:40.715 +07 client backend[296618] pg_regress/with ERROR:  recursive reference to query "x" must not appear within a subquery at character 114
2023-08-01 17:01:40.715 +07 client backend[296618] pg_regress/with STATEMENT:  WITH RECURSIVE x(n) AS (SELECT 1 UNION ALL SELECT n+1 FROM x
	                          WHERE n IN (SELECT * FROM x))
	  SELECT * FROM x;
2023-08-01 17:01:40.715 +07 client backend[296618] pg_regress/with ERROR:  aggregate functions are not allowed in a recursive query's recursive term at character 51
2023-08-01 17:01:40.715 +07 client backend[296618] pg_regress/with STATEMENT:  WITH RECURSIVE x(n) AS (SELECT 1 UNION ALL SELECT count(*) FROM x)
	  SELECT * FROM x;
2023-08-01 17:01:40.715 +07 client backend[296618] pg_regress/with ERROR:  aggregate functions are not allowed in a recursive query's recursive term at character 51
2023-08-01 17:01:40.715 +07 client backend[296618] pg_regress/with STATEMENT:  WITH RECURSIVE x(n) AS (SELECT 1 UNION ALL SELECT sum(n) FROM x)
	  SELECT * FROM x;
2023-08-01 17:01:40.715 +07 client backend[296618] pg_regress/with ERROR:  ORDER BY in a recursive query is not implemented at character 71
2023-08-01 17:01:40.715 +07 client backend[296618] pg_regress/with STATEMENT:  WITH RECURSIVE x(n) AS (SELECT 1 UNION ALL SELECT n+1 FROM x ORDER BY 1)
	  SELECT * FROM x;
2023-08-01 17:01:40.715 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.715 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.715 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.715 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xml_is_well_formed('<abc/>');
2023-08-01 17:01:40.715 +07 client backend[296618] pg_regress/with ERROR:  OFFSET in a recursive query is not implemented at character 78
2023-08-01 17:01:40.715 +07 client backend[296618] pg_regress/with STATEMENT:  WITH RECURSIVE x(n) AS (SELECT 1 UNION ALL SELECT n+1 FROM x LIMIT 10 OFFSET 1)
	  SELECT * FROM x;
2023-08-01 17:01:40.715 +07 client backend[296618] pg_regress/with ERROR:  FOR UPDATE/SHARE in a recursive query is not implemented
2023-08-01 17:01:40.715 +07 client backend[296618] pg_regress/with STATEMENT:  WITH RECURSIVE x(n) AS (SELECT 1 UNION ALL SELECT n+1 FROM x FOR UPDATE)
	  SELECT * FROM x;
2023-08-01 17:01:40.715 +07 client backend[296618] pg_regress/with ERROR:  recursive reference to query "x" must not appear within a subquery at character 77
2023-08-01 17:01:40.715 +07 client backend[296618] pg_regress/with STATEMENT:  WITH RECURSIVE x(id) AS (values (1)
	    UNION ALL
	    SELECT (SELECT * FROM x) FROM x WHERE id < 5
	) SELECT * FROM x;
2023-08-01 17:01:40.715 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.715 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.715 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.715 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xml_is_well_formed('<foo>bar</foo>');
2023-08-01 17:01:40.715 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.715 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.715 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.715 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xml_is_well_formed('<foo>bar</foo');
2023-08-01 17:01:40.716 +07 client backend[296618] pg_regress/with ERROR:  mutual recursion between WITH items is not implemented at character 18
2023-08-01 17:01:40.716 +07 client backend[296618] pg_regress/with STATEMENT:  WITH RECURSIVE
	  x (id) AS (SELECT 1 UNION ALL SELECT id+1 FROM y WHERE id < 5),
	  y (id) AS (SELECT 1 UNION ALL SELECT id+1 FROM x WHERE id < 5)
	SELECT * FROM x;
2023-08-01 17:01:40.716 +07 client backend[296618] pg_regress/with ERROR:  recursive reference to query "foo" must not appear more than once at character 140
2023-08-01 17:01:40.716 +07 client backend[296618] pg_regress/with STATEMENT:  WITH RECURSIVE foo(i) AS
	    (values (1)
	    UNION ALL
	       (SELECT i+1 FROM foo WHERE i < 10
	          UNION ALL
	       SELECT i+1 FROM foo WHERE i < 5)
	) SELECT * FROM foo;
2023-08-01 17:01:40.716 +07 client backend[296618] pg_regress/with ERROR:  recursive reference to query "foo" must not appear more than once at character 158
2023-08-01 17:01:40.716 +07 client backend[296618] pg_regress/with STATEMENT:  WITH RECURSIVE foo(i) AS
	    (values (1)
	    UNION ALL
		   SELECT * FROM
	       (SELECT i+1 FROM foo WHERE i < 10
	          UNION ALL
	       SELECT i+1 FROM foo WHERE i < 5) AS t
	) SELECT * FROM foo;
2023-08-01 17:01:40.716 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.716 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.716 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.716 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xml_is_well_formed('<foo><bar>baz</foo>');
2023-08-01 17:01:40.716 +07 client backend[296618] pg_regress/with ERROR:  recursive reference to query "foo" must not appear within EXCEPT at character 137
2023-08-01 17:01:40.716 +07 client backend[296618] pg_regress/with STATEMENT:  WITH RECURSIVE foo(i) AS
	    (values (1)
	    UNION ALL
	       (SELECT i+1 FROM foo WHERE i < 10
	          EXCEPT
	       SELECT i+1 FROM foo WHERE i < 5)
	) SELECT * FROM foo;
2023-08-01 17:01:40.716 +07 client backend[296618] pg_regress/with ERROR:  recursive reference to query "foo" must not appear more than once at character 140
2023-08-01 17:01:40.716 +07 client backend[296618] pg_regress/with STATEMENT:  WITH RECURSIVE foo(i) AS
	    (values (1)
	    UNION ALL
	       (SELECT i+1 FROM foo WHERE i < 10
	          INTERSECT
	       SELECT i+1 FROM foo WHERE i < 5)
	) SELECT * FROM foo;
2023-08-01 17:01:40.716 +07 client backend[296618] pg_regress/with ERROR:  recursive query "foo" column 1 has type integer in non-recursive term but type numeric overall at character 37
2023-08-01 17:01:40.716 +07 client backend[296618] pg_regress/with HINT:  Cast the output of the non-recursive term to the correct type.
2023-08-01 17:01:40.716 +07 client backend[296618] pg_regress/with STATEMENT:  WITH RECURSIVE foo(i) AS
	   (SELECT i FROM (VALUES(1),(2)) t(i)
	   UNION ALL
	   SELECT (i+1)::numeric(10,0) FROM foo WHERE i < 10)
	SELECT * FROM foo;
2023-08-01 17:01:40.716 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.716 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.716 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.716 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xml_is_well_formed('<local:data xmlns:local="http://127.0.0.1"><local:piece id="1">number one</local:piece><local:piece id="2" /></local:data>');
2023-08-01 17:01:40.716 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.716 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.716 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.716 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xml_is_well_formed('<pg:foo xmlns:pg="http://postgresql.org/stuff">bar</my:foo>');
2023-08-01 17:01:40.716 +07 client backend[296618] pg_regress/with ERROR:  recursive query "foo" column 1 has type numeric(3,0) in non-recursive term but type numeric overall at character 37
2023-08-01 17:01:40.716 +07 client backend[296618] pg_regress/with HINT:  Cast the output of the non-recursive term to the correct type.
2023-08-01 17:01:40.716 +07 client backend[296618] pg_regress/with STATEMENT:  WITH RECURSIVE foo(i) AS
	   (SELECT i::numeric(3,0) FROM (VALUES(1),(2)) t(i)
	   UNION ALL
	   SELECT (i+1)::numeric(10,0) FROM foo WHERE i < 10)
	SELECT * FROM foo;
2023-08-01 17:01:40.716 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.716 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.716 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.716 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xml_is_well_formed('<pg:foo xmlns:pg="http://postgresql.org/stuff">bar</pg:foo>');
2023-08-01 17:01:40.716 +07 client backend[296624] pg_regress/sequence ERROR:  relation "asdf" does not exist
2023-08-01 17:01:40.716 +07 client backend[296624] pg_regress/sequence STATEMENT:  COMMENT ON SEQUENCE asdf IS 'won''t work';
2023-08-01 17:01:40.716 +07 client backend[296616] pg_regress/copy2 ERROR:  cannot copy to view "instead_of_insert_tbl_view"
2023-08-01 17:01:40.716 +07 client backend[296616] pg_regress/copy2 HINT:  To enable copying to a view, provide an INSTEAD OF INSERT trigger.
2023-08-01 17:01:40.716 +07 client backend[296616] pg_regress/copy2 STATEMENT:  COPY instead_of_insert_tbl_view FROM stdin;
2023-08-01 17:01:40.717 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.717 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.717 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.717 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xml_is_well_formed('<invalidentity>&</abc>');
2023-08-01 17:01:40.717 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.717 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.717 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.717 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xml_is_well_formed('<undefinedentity>&idontexist;</abc>');
2023-08-01 17:01:40.717 +07 client backend[296618] pg_regress/with ERROR:  cannot refer to OLD within WITH query
2023-08-01 17:01:40.717 +07 client backend[296618] pg_regress/with STATEMENT:  CREATE RULE r2 AS ON UPDATE TO x DO INSTEAD
	    WITH t AS (SELECT OLD.*) UPDATE y SET a = t.n FROM t;
2023-08-01 17:01:40.717 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.717 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.717 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.717 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xml_is_well_formed('<invalidns xmlns=''&lt;''/>');
2023-08-01 17:01:40.717 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.717 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.717 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.717 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xml_is_well_formed('<relativens xmlns=''relative''/>');
2023-08-01 17:01:40.717 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.717 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.717 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.717 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xml_is_well_formed('<twoerrors>&idontexist;</unbalanced>');
2023-08-01 17:01:40.718 +07 client backend[296624] pg_regress/sequence ERROR:  lastval is not yet defined in this session
2023-08-01 17:01:40.718 +07 client backend[296624] pg_regress/sequence STATEMENT:  SELECT lastval();
2023-08-01 17:01:40.718 +07 client backend[296625] pg_regress/alter_table ERROR:  cannot rename inherited constraint "con1"
2023-08-01 17:01:40.718 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE constraint_rename_test2 RENAME CONSTRAINT con1 TO con1foo;
2023-08-01 17:01:40.718 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.718 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.718 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.718 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xml_is_well_formed('abc');
2023-08-01 17:01:40.718 +07 client backend[296625] pg_regress/alter_table ERROR:  inherited constraint "con1" must be renamed in child tables too
2023-08-01 17:01:40.718 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE ONLY constraint_rename_test RENAME CONSTRAINT con1 TO con1foo;
2023-08-01 17:01:40.719 +07 client backend[296618] pg_regress/with ERROR:  relation "outermost" does not exist at character 96
2023-08-01 17:01:40.719 +07 client backend[296618] pg_regress/with DETAIL:  There is a WITH item named "outermost", but it cannot be referenced from this part of the query.
2023-08-01 17:01:40.719 +07 client backend[296618] pg_regress/with HINT:  Use WITH RECURSIVE, or re-order the WITH items to remove forward references.
2023-08-01 17:01:40.719 +07 client backend[296618] pg_regress/with STATEMENT:  WITH outermost(x) AS (
	  SELECT 1
	  UNION (WITH innermost as (SELECT 2)
	         SELECT * FROM outermost  
	         UNION SELECT * FROM innermost)
	)
	SELECT * FROM outermost ORDER BY 1;
2023-08-01 17:01:40.719 +07 client backend[296624] pg_regress/sequence ERROR:  lastval is not yet defined in this session
2023-08-01 17:01:40.719 +07 client backend[296624] pg_regress/sequence STATEMENT:  SELECT lastval();
2023-08-01 17:01:40.719 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 20
2023-08-01 17:01:40.719 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.719 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.719 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xpath('/*', '<invalidns xmlns=''&lt;''/>');
2023-08-01 17:01:40.719 +07 client backend[296618] pg_regress/with ERROR:  recursive reference to query "outermost" must not appear within a subquery at character 69
2023-08-01 17:01:40.719 +07 client backend[296618] pg_regress/with STATEMENT:  WITH RECURSIVE outermost(x) AS (
	  WITH innermost as (SELECT 2 FROM outermost) 
	    SELECT * FROM innermost
	    UNION SELECT * from outermost
	)
	SELECT * FROM outermost ORDER BY 1;
2023-08-01 17:01:40.720 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 20
2023-08-01 17:01:40.720 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.720 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.720 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xpath('/*', '<nosuchprefix:tag/>');
2023-08-01 17:01:40.720 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 20
2023-08-01 17:01:40.720 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.720 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.720 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT xpath('/*', '<relativens xmlns=''relative''/>');
2023-08-01 17:01:40.720 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.720 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.720 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.720 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT XMLPARSE(DOCUMENT '<!DOCTYPE foo [<!ENTITY c SYSTEM "/etc/passwd">]><foo>&c;</foo>');
2023-08-01 17:01:40.720 +07 client backend[296624] pg_regress/sequence ERROR:  cannot execute nextval() in a read-only transaction
2023-08-01 17:01:40.720 +07 client backend[296624] pg_regress/sequence STATEMENT:  SELECT nextval('sequence_test2');
2023-08-01 17:01:40.720 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.720 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.720 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.720 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT XMLPARSE(DOCUMENT '<!DOCTYPE foo [<!ENTITY c SYSTEM "/etc/no.such.file">]><foo>&c;</foo>');
2023-08-01 17:01:40.720 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.720 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.720 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.720 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT XMLPARSE(DOCUMENT '<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd"><chapter>&nbsp;</chapter>');
2023-08-01 17:01:40.721 +07 client backend[296613] pg_regress/domain ERROR:  duplicate key value violates unique constraint "dcomptable_d1_key"
2023-08-01 17:01:40.721 +07 client backend[296613] pg_regress/domain DETAIL:  Key (d1)=({"(1,2)"}) already exists.
2023-08-01 17:01:40.721 +07 client backend[296613] pg_regress/domain STATEMENT:  insert into dcomptable values (array[row(1,2)]::dcomptypea);
2023-08-01 17:01:40.721 +07 client backend[296624] pg_regress/sequence ERROR:  cannot execute setval() in a read-only transaction
2023-08-01 17:01:40.721 +07 client backend[296624] pg_regress/sequence STATEMENT:  SELECT setval('sequence_test2', 1);
2023-08-01 17:01:40.721 +07 client backend[296626] pg_regress/rowtypes ERROR:  could not determine interpretation of row comparison operator ~~ at character 25
2023-08-01 17:01:40.721 +07 client backend[296626] pg_regress/rowtypes HINT:  Row comparison operators must be associated with btree operator families.
2023-08-01 17:01:40.721 +07 client backend[296626] pg_regress/rowtypes STATEMENT:  select ROW('ABC','DEF') ~~ ROW('DEF','ABC') as fail;
2023-08-01 17:01:40.721 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 28
2023-08-01 17:01:40.721 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.721 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.721 +07 client backend[296623] pg_regress/xml STATEMENT:  INSERT INTO xmldata VALUES('<ROWS>
	<ROW id="1">
	  <COUNTRY_ID>AU</COUNTRY_ID>
	  <COUNTRY_NAME>Australia</COUNTRY_NAME>
	  <REGION_ID>3</REGION_ID>
	</ROW>
	<ROW id="2">
	  <COUNTRY_ID>CN</COUNTRY_ID>
	  <COUNTRY_NAME>China</COUNTRY_NAME>
	  <REGION_ID>3</REGION_ID>
	</ROW>
	<ROW id="3">
	  <COUNTRY_ID>HK</COUNTRY_ID>
	  <COUNTRY_NAME>HongKong</COUNTRY_NAME>
	  <REGION_ID>3</REGION_ID>
	</ROW>
	<ROW id="4">
	  <COUNTRY_ID>IN</COUNTRY_ID>
	  <COUNTRY_NAME>India</COUNTRY_NAME>
	  <REGION_ID>3</REGION_ID>
	</ROW>
	<ROW id="5">
	  <COUNTRY_ID>JP</COUNTRY_ID>
	  <COUNTRY_NAME>Japan</COUNTRY_NAME>
	  <REGION_ID>3</REGION_ID><PREMIER_NAME>Sinzo Abe</PREMIER_NAME>
	</ROW>
	<ROW id="6">
	  <COUNTRY_ID>SG</COUNTRY_ID>
	  <COUNTRY_NAME>Singapore</COUNTRY_NAME>
	  <REGION_ID>3</REGION_ID><SIZE unit="km">791</SIZE>
	</ROW>
	</ROWS>');
2023-08-01 17:01:40.723 +07 client backend[296624] pg_regress/sequence ERROR:  permission denied for sequence seq3
2023-08-01 17:01:40.723 +07 client backend[296624] pg_regress/sequence STATEMENT:  SELECT nextval('seq3');
2023-08-01 17:01:40.723 +07 client backend[296613] pg_regress/domain ERROR:  column "d1" of table "dcomptable" contains values that violate the new constraint
2023-08-01 17:01:40.723 +07 client backend[296613] pg_regress/domain STATEMENT:  alter domain dcomptypea add constraint c2 check (value[1].r > value[1].i);
2023-08-01 17:01:40.724 +07 client backend[296613] pg_regress/domain ERROR:  value for domain dcomptypea violates check constraint "c1"
2023-08-01 17:01:40.724 +07 client backend[296613] pg_regress/domain STATEMENT:  select array[row(2,1)]::dcomptypea;
2023-08-01 17:01:40.724 +07 client backend[296613] pg_regress/domain ERROR:  value for domain dcomptypea violates check constraint "c1"
2023-08-01 17:01:40.724 +07 client backend[296613] pg_regress/domain STATEMENT:  insert into dcomptable values (array[row(2,1)]::comptype[]);
2023-08-01 17:01:40.724 +07 client backend[296613] pg_regress/domain ERROR:  value for domain dcomptypea violates check constraint "c1"
2023-08-01 17:01:40.724 +07 client backend[296613] pg_regress/domain STATEMENT:  insert into dcomptable (d1[1].r, d1[1].i) values(100, 99);
2023-08-01 17:01:40.724 +07 client backend[296613] pg_regress/domain ERROR:  value for domain dcomptypea violates check constraint "c1"
2023-08-01 17:01:40.724 +07 client backend[296613] pg_regress/domain STATEMENT:  update dcomptable set d1[1].r = d1[1].r + 1 where d1[1].i > 0;
2023-08-01 17:01:40.725 +07 client backend[296627] pg_regress/temp ERROR:  function nonempty(unknown) does not exist at character 8
2023-08-01 17:01:40.725 +07 client backend[296627] pg_regress/temp HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:40.725 +07 client backend[296627] pg_regress/temp STATEMENT:  select nonempty('');
2023-08-01 17:01:40.725 +07 client backend[296627] pg_regress/temp ERROR:  value for domain nonempty violates check constraint "nonempty_check"
2023-08-01 17:01:40.725 +07 client backend[296627] pg_regress/temp STATEMENT:  select pg_temp.nonempty('');
2023-08-01 17:01:40.725 +07 client backend[296627] pg_regress/temp ERROR:  value for domain nonempty violates check constraint "nonempty_check"
2023-08-01 17:01:40.725 +07 client backend[296627] pg_regress/temp STATEMENT:  select ''::nonempty;
2023-08-01 17:01:40.727 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 129
2023-08-01 17:01:40.727 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.727 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.727 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT * FROM XMLTABLE(XMLNAMESPACES('http://x.y' AS zz),
	                      '/zz:rows/zz:row'
	                      PASSING '<rows xmlns="http://x.y"><row><a>10</a></row></rows>'
	                      COLUMNS a int PATH 'zz:a');
2023-08-01 17:01:40.729 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 158
2023-08-01 17:01:40.729 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.729 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.729 +07 client backend[296623] pg_regress/xml STATEMENT:  CREATE VIEW xmltableview2 AS SELECT * FROM XMLTABLE(XMLNAMESPACES('http://x.y' AS zz),
	                      '/zz:rows/zz:row'
	                      PASSING '<rows xmlns="http://x.y"><row><a>10</a></row></rows>'
	                      COLUMNS a int PATH 'zz:a');
2023-08-01 17:01:40.729 +07 client backend[296623] pg_regress/xml ERROR:  relation "xmltableview2" does not exist at character 15
2023-08-01 17:01:40.729 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT * FROM xmltableview2;
2023-08-01 17:01:40.730 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 125
2023-08-01 17:01:40.730 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.730 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.730 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT * FROM XMLTABLE(XMLNAMESPACES(DEFAULT 'http://x.y'),
	                      '/rows/row'
	                      PASSING '<rows xmlns="http://x.y"><row><a>10</a></row></rows>'
	                      COLUMNS a int PATH 'a');
2023-08-01 17:01:40.730 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 59
2023-08-01 17:01:40.730 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.730 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.730 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT * FROM XMLTABLE('.'
	                       PASSING '<foo/>'
	                       COLUMNS a text PATH 'foo/namespace::node()');
2023-08-01 17:01:40.731 +07 client backend[296621] pg_regress/polymorphism ERROR:  function add_group(smallint[], bigint, integer) does not exist
2023-08-01 17:01:40.731 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  create aggregate build_group(int8, integer) (
	  SFUNC = add_group,
	  STYPE = int2[]
	);
2023-08-01 17:01:40.733 +07 client backend[296613] pg_regress/domain ERROR:  value for domain posint violates check constraint "posint_check"
2023-08-01 17:01:40.733 +07 client backend[296613] pg_regress/domain STATEMENT:  insert into pitable values(array[-1]);
2023-08-01 17:01:40.733 +07 client backend[296613] pg_regress/domain ERROR:  value for domain posint violates check constraint "posint_check" at character 28
2023-08-01 17:01:40.733 +07 client backend[296613] pg_regress/domain STATEMENT:  insert into pitable values('{0}');
2023-08-01 17:01:40.734 +07 client backend[296613] pg_regress/domain ERROR:  value for domain posint violates check constraint "posint_check"
2023-08-01 17:01:40.734 +07 client backend[296613] pg_regress/domain STATEMENT:  update pitable set f1[1] = 0;
2023-08-01 17:01:40.736 +07 client backend[296613] pg_regress/domain ERROR:  value too long for type character varying(4)
2023-08-01 17:01:40.736 +07 client backend[296613] pg_regress/domain STATEMENT:  insert into vc4table values(array['too long']);
2023-08-01 17:01:40.736 +07 client backend[296626] pg_regress/rowtypes ERROR:  cannot compare dissimilar column types bigint and integer at record column 1
2023-08-01 17:01:40.736 +07 client backend[296626] pg_regress/rowtypes STATEMENT:  select * from int8_tbl i8 where i8 in (row(123,456));
2023-08-01 17:01:40.736 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 40
2023-08-01 17:01:40.736 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.736 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.736 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT * FROM xmltable('/root' passing '<root><element>a1a<!-- aaaa -->a2a<?aaaaa?> <!--z-->  bbbb<x>xxx</x>cccc</element></root>' COLUMNS element text);
2023-08-01 17:01:40.737 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 40
2023-08-01 17:01:40.737 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.737 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.737 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT * FROM xmltable('/root' passing '<root><element>a1a<!-- aaaa -->a2a<?aaaaa?> <!--z-->  bbbb<x>xxx</x>cccc</element></root>' COLUMNS element text PATH 'element/text()');
2023-08-01 17:01:40.737 +07 client backend[296624] pg_regress/sequence ERROR:  permission denied for sequence seq3
2023-08-01 17:01:40.737 +07 client backend[296624] pg_regress/sequence STATEMENT:  SELECT currval('seq3');
2023-08-01 17:01:40.738 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 38
2023-08-01 17:01:40.738 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.738 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.738 +07 client backend[296623] pg_regress/xml STATEMENT:  select * from xmltable('d/r' passing '<d><r><c><![CDATA[<hello> &"<>!<a>foo</a>]]></c></r><r><c>2</c></r></d>' columns c text);
2023-08-01 17:01:40.738 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 39
2023-08-01 17:01:40.738 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.738 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.738 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT * FROM xmltable('/x/a' PASSING '<x><a><ent>&apos;</ent></a><a><ent>&quot;</ent></a><a><ent>&amp;</ent></a><a><ent>&lt;</ent></a><a><ent>&gt;</ent></a></x>' COLUMNS ent text);
2023-08-01 17:01:40.738 +07 client backend[296626] pg_regress/rowtypes ERROR:  could not identify column "nosuch" in record data type at character 9
2023-08-01 17:01:40.738 +07 client backend[296626] pg_regress/rowtypes STATEMENT:  select (row(1, 2.0)).nosuch;
2023-08-01 17:01:40.738 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 39
2023-08-01 17:01:40.738 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.738 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.738 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT * FROM xmltable('/x/a' PASSING '<x><a><ent>&apos;</ent></a><a><ent>&quot;</ent></a><a><ent>&amp;</ent></a><a><ent>&lt;</ent></a><a><ent>&gt;</ent></a></x>' COLUMNS ent xml);
2023-08-01 17:01:40.739 +07 client backend[296626] pg_regress/rowtypes ERROR:  could not identify column "f3" in record data type at character 9
2023-08-01 17:01:40.739 +07 client backend[296626] pg_regress/rowtypes STATEMENT:  select (r).f3 from (select row(1, 2.0) as r) ss;
2023-08-01 17:01:40.739 +07 client backend[296613] pg_regress/domain ERROR:  column "f1" is of type dposinta[] but expression is of type integer[] at character 34
2023-08-01 17:01:40.739 +07 client backend[296613] pg_regress/domain HINT:  You will need to rewrite or cast the expression.
2023-08-01 17:01:40.739 +07 client backend[296613] pg_regress/domain STATEMENT:  insert into dposintatable values(array[array[42]]);
2023-08-01 17:01:40.739 +07 client backend[296626] pg_regress/rowtypes ERROR:  cannot compare rows of zero length at character 14
2023-08-01 17:01:40.739 +07 client backend[296626] pg_regress/rowtypes STATEMENT:  select ROW() = ROW();
2023-08-01 17:01:40.739 +07 client backend[296613] pg_regress/domain ERROR:  column "f1" is of type dposinta[] but expression is of type posint[] at character 34
2023-08-01 17:01:40.739 +07 client backend[296613] pg_regress/domain HINT:  You will need to rewrite or cast the expression.
2023-08-01 17:01:40.739 +07 client backend[296613] pg_regress/domain STATEMENT:  insert into dposintatable values(array[array[42]::posint[]]);
2023-08-01 17:01:40.741 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 28
2023-08-01 17:01:40.741 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.741 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.741 +07 client backend[296623] pg_regress/xml STATEMENT:  INSERT INTO xmldata VALUES('<ROWS>
	<ROW id="10">
	  <COUNTRY_ID>CZ</COUNTRY_ID>
	  <COUNTRY_NAME>Czech Republic</COUNTRY_NAME>
	  <REGION_ID>2</REGION_ID><PREMIER_NAME>Milos Zeman</PREMIER_NAME>
	</ROW>
	<ROW id="11">
	  <COUNTRY_ID>DE</COUNTRY_ID>
	  <COUNTRY_NAME>Germany</COUNTRY_NAME>
	  <REGION_ID>2</REGION_ID>
	</ROW>
	<ROW id="12">
	  <COUNTRY_ID>FR</COUNTRY_ID>
	  <COUNTRY_NAME>France</COUNTRY_NAME>
	  <REGION_ID>2</REGION_ID>
	</ROW>
	</ROWS>');
2023-08-01 17:01:40.741 +07 client backend[296626] pg_regress/rowtypes ERROR:  could not identify an ordering operator for type cantcompare at character 27
2023-08-01 17:01:40.741 +07 client backend[296626] pg_regress/rowtypes HINT:  Use an explicit ordering operator or modify the query.
2023-08-01 17:01:40.741 +07 client backend[296626] pg_regress/rowtypes STATEMENT:  select * from cc order by f1;
2023-08-01 17:01:40.741 +07 client backend[296624] pg_regress/sequence ERROR:  permission denied for sequence seq3
2023-08-01 17:01:40.741 +07 client backend[296624] pg_regress/sequence STATEMENT:  SELECT lastval();
2023-08-01 17:01:40.742 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 28
2023-08-01 17:01:40.742 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.742 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.742 +07 client backend[296623] pg_regress/xml STATEMENT:  INSERT INTO xmldata VALUES('<ROWS>
	<ROW id="20">
	  <COUNTRY_ID>EG</COUNTRY_ID>
	  <COUNTRY_NAME>Egypt</COUNTRY_NAME>
	  <REGION_ID>1</REGION_ID>
	</ROW>
	<ROW id="21">
	  <COUNTRY_ID>SD</COUNTRY_ID>
	  <COUNTRY_NAME>Sudan</COUNTRY_NAME>
	  <REGION_ID>1</REGION_ID>
	</ROW>
	</ROWS>');
2023-08-01 17:01:40.744 +07 client backend[296624] pg_regress/sequence ERROR:  permission denied for sequence seq3
2023-08-01 17:01:40.744 +07 client backend[296624] pg_regress/sequence STATEMENT:  SELECT setval('seq3', 5);
2023-08-01 17:01:40.744 +07 client backend[296626] pg_regress/rowtypes ERROR:  cannot compare dissimilar column types integer and text at record column 2
2023-08-01 17:01:40.744 +07 client backend[296626] pg_regress/rowtypes STATEMENT:  select row(1, 2)::testtype1 < row(1, 'abc')::testtype3;
2023-08-01 17:01:40.744 +07 client backend[296626] pg_regress/rowtypes ERROR:  cannot compare dissimilar column types integer and text at record column 2
2023-08-01 17:01:40.744 +07 client backend[296626] pg_regress/rowtypes STATEMENT:  select row(1, 2)::testtype1 <> row(1, 'abc')::testtype3;
2023-08-01 17:01:40.744 +07 client backend[296626] pg_regress/rowtypes ERROR:  cannot compare record types with different numbers of columns
2023-08-01 17:01:40.744 +07 client backend[296626] pg_regress/rowtypes STATEMENT:  select row(1, 2)::testtype1 < row(1)::testtype5;
2023-08-01 17:01:40.744 +07 client backend[296626] pg_regress/rowtypes ERROR:  cannot compare record types with different numbers of columns
2023-08-01 17:01:40.744 +07 client backend[296626] pg_regress/rowtypes STATEMENT:  select row(1, 2)::testtype1 <> row(1)::testtype5;
2023-08-01 17:01:40.744 +07 client backend[296613] pg_regress/domain ERROR:  wrong number of array subscripts
2023-08-01 17:01:40.744 +07 client backend[296613] pg_regress/domain STATEMENT:  update dposintatable set f1[2][1] = array[97];
2023-08-01 17:01:40.744 +07 client backend[296624] pg_regress/sequence ERROR:  must be owner of sequence sequence_test2
2023-08-01 17:01:40.744 +07 client backend[296624] pg_regress/sequence STATEMENT:  ALTER SEQUENCE sequence_test2 START WITH 1;
2023-08-01 17:01:40.744 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.744 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.744 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.744 +07 client backend[296623] pg_regress/xml STATEMENT:  WITH
	   x AS (SELECT proname, proowner, procost::numeric, pronargs,
	                array_to_string(proargnames,',') as proargnames,
	                case when proargtypes <> '' then array_to_string(proargtypes::oid[],',') end as proargtypes
	           FROM pg_proc WHERE proname = 'f_leak'),
	   y AS (SELECT xmlelement(name proc,
	                           xmlforest(proname, proowner,
	                                     procost, pronargs,
	                                     proargnames, proargtypes)) as proc
	           FROM x),
	   z AS (SELECT xmltable.*
	           FROM y,
	                LATERAL xmltable('/proc' PASSING proc
	                                 COLUMNS proname name,
	                                         proowner oid,
	                                         procost float,
	                                         pronargs int,
	                                         proargnames text,
	                                         proargtypes text))
	   SELECT * FROM z
	   EXCEPT SELECT * FROM x;
2023-08-01 17:01:40.745 +07 client backend[296621] pg_regress/polymorphism ERROR:  cannot compare arrays of different element types
2023-08-01 17:01:40.745 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  select max(histogram_bounds) from pg_stats where tablename = 'pg_am';
2023-08-01 17:01:40.745 +07 client backend[296626] pg_regress/rowtypes ERROR:  could not identify a comparison function for type point
2023-08-01 17:01:40.745 +07 client backend[296626] pg_regress/rowtypes STATEMENT:  select row(1, '(1,2)')::testtype6 < row(1, '(1,3)')::testtype6;
2023-08-01 17:01:40.745 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.745 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.745 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.745 +07 client backend[296623] pg_regress/xml STATEMENT:  WITH
	   x AS (SELECT proname, proowner, procost::numeric, pronargs,
	                array_to_string(proargnames,',') as proargnames,
	                case when proargtypes <> '' then array_to_string(proargtypes::oid[],',') end as proargtypes
	           FROM pg_proc),
	   y AS (SELECT xmlelement(name data,
	                           xmlagg(xmlelement(name proc,
	                                             xmlforest(proname, proowner, procost,
	                                                       pronargs, proargnames, proargtypes)))) as doc
	           FROM x),
	   z AS (SELECT xmltable.*
	           FROM y,
	                LATERAL xmltable('/data/proc' PASSING doc
	                                 COLUMNS proname name,
	                                         proowner oid,
	                                         procost float,
	                                         pronargs int,
	                                         proargnames text,
	                                         proargtypes text))
	   SELECT * FROM z
	   EXCEPT SELECT * FROM x;
2023-08-01 17:01:40.745 +07 client backend[296626] pg_regress/rowtypes ERROR:  could not identify an equality operator for type point
2023-08-01 17:01:40.745 +07 client backend[296626] pg_regress/rowtypes STATEMENT:  select row(1, '(1,2)')::testtype6 <> row(1, '(1,3)')::testtype6;
2023-08-01 17:01:40.745 +07 client backend[296613] pg_regress/domain ERROR:  syntax error at or near "[" at character 33
2023-08-01 17:01:40.745 +07 client backend[296613] pg_regress/domain STATEMENT:  update dposintatable set (f1[2])[1] = array[98];
2023-08-01 17:01:40.746 +07 client backend[296621] pg_regress/polymorphism ERROR:  function "array_in" in FROM has unsupported return type anyarray at character 15
2023-08-01 17:01:40.746 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  select * from array_in('{1,2,3}','int4'::regtype,-1);
2023-08-01 17:01:40.746 +07 client backend[296621] pg_regress/polymorphism ERROR:  cannot accept a value of type anyrange
2023-08-01 17:01:40.746 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  select anyrange_in('[10,20)','int4range'::regtype,-1);
2023-08-01 17:01:40.747 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 29
2023-08-01 17:01:40.747 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.747 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.747 +07 client backend[296623] pg_regress/xml STATEMENT:  INSERT INTO xmltest2 VALUES('<d><r><ac>1</ac></r></d>', 'A');
2023-08-01 17:01:40.747 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 29
2023-08-01 17:01:40.747 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.747 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.747 +07 client backend[296623] pg_regress/xml STATEMENT:  INSERT INTO xmltest2 VALUES('<d><r><bc>2</bc></r></d>', 'B');
2023-08-01 17:01:40.748 +07 client backend[296621] pg_regress/polymorphism ERROR:  function myleast() does not exist at character 8
2023-08-01 17:01:40.748 +07 client backend[296621] pg_regress/polymorphism HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:40.748 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  select myleast();
2023-08-01 17:01:40.748 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 29
2023-08-01 17:01:40.748 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.748 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.748 +07 client backend[296623] pg_regress/xml STATEMENT:  INSERT INTO xmltest2 VALUES('<d><r><cc>3</cc></r></d>', 'C');
2023-08-01 17:01:40.749 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 29
2023-08-01 17:01:40.749 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.749 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.749 +07 client backend[296623] pg_regress/xml STATEMENT:  INSERT INTO xmltest2 VALUES('<d><r><dc>2</dc></r></d>', 'D');
2023-08-01 17:01:40.750 +07 client backend[296613] pg_regress/domain ERROR:  domain dnotnull does not allow null values
2023-08-01 17:01:40.750 +07 client backend[296613] pg_regress/domain STATEMENT:  INSERT INTO nulltest DEFAULT VALUES;
2023-08-01 17:01:40.751 +07 client backend[296626] pg_regress/rowtypes ERROR:  cannot compare dissimilar column types integer and text at record column 2
2023-08-01 17:01:40.751 +07 client backend[296626] pg_regress/rowtypes STATEMENT:  select row(1, 2)::testtype1 *< row(1, 'abc')::testtype3;
2023-08-01 17:01:40.751 +07 client backend[296626] pg_regress/rowtypes ERROR:  cannot compare dissimilar column types integer and text at record column 2
2023-08-01 17:01:40.751 +07 client backend[296626] pg_regress/rowtypes STATEMENT:  select row(1, 2)::testtype1 *<> row(1, 'abc')::testtype3;
2023-08-01 17:01:40.751 +07 client backend[296613] pg_regress/domain ERROR:  domain dcheck does not allow null values
2023-08-01 17:01:40.751 +07 client backend[296613] pg_regress/domain STATEMENT:  insert into nulltest values ('a', 'b', 'c', 'd', NULL);
2023-08-01 17:01:40.751 +07 client backend[296613] pg_regress/domain ERROR:  new row for relation "nulltest" violates check constraint "nulltest_col5_check"
2023-08-01 17:01:40.751 +07 client backend[296613] pg_regress/domain DETAIL:  Failing row contains (a, b, c, d, a).
2023-08-01 17:01:40.751 +07 client backend[296613] pg_regress/domain STATEMENT:  insert into nulltest values ('a', 'b', 'c', 'd', 'a');
2023-08-01 17:01:40.751 +07 client backend[296613] pg_regress/domain ERROR:  domain dnotnull does not allow null values
2023-08-01 17:01:40.751 +07 client backend[296613] pg_regress/domain STATEMENT:  INSERT INTO nulltest values (NULL, 'b', 'c', 'd', 'd');
2023-08-01 17:01:40.751 +07 client backend[296626] pg_regress/rowtypes ERROR:  cannot compare record types with different numbers of columns
2023-08-01 17:01:40.751 +07 client backend[296626] pg_regress/rowtypes STATEMENT:  select row(1, 2)::testtype1 *< row(1)::testtype5;
2023-08-01 17:01:40.751 +07 client backend[296613] pg_regress/domain ERROR:  domain dnotnull does not allow null values
2023-08-01 17:01:40.751 +07 client backend[296613] pg_regress/domain STATEMENT:  INSERT INTO nulltest values ('a', NULL, 'c', 'd', 'c');
2023-08-01 17:01:40.751 +07 client backend[296626] pg_regress/rowtypes ERROR:  cannot compare record types with different numbers of columns
2023-08-01 17:01:40.751 +07 client backend[296626] pg_regress/rowtypes STATEMENT:  select row(1, 2)::testtype1 *<> row(1)::testtype5;
2023-08-01 17:01:40.751 +07 client backend[296613] pg_regress/domain ERROR:  null value in column "col3" of relation "nulltest" violates not-null constraint
2023-08-01 17:01:40.751 +07 client backend[296613] pg_regress/domain DETAIL:  Failing row contains (a, b, null, d, c).
2023-08-01 17:01:40.751 +07 client backend[296613] pg_regress/domain STATEMENT:  INSERT INTO nulltest values ('a', 'b', NULL, 'd', 'c');
2023-08-01 17:01:40.751 +07 client backend[296621] pg_regress/polymorphism ERROR:  function formarray(numeric, numeric[]) does not exist at character 8
2023-08-01 17:01:40.751 +07 client backend[296621] pg_regress/polymorphism HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:40.751 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  select formarray(1.1, array[1.2,55.5]);
2023-08-01 17:01:40.752 +07 client backend[296613] pg_regress/domain ERROR:  null value in column "col3" of relation "nulltest" violates not-null constraint
2023-08-01 17:01:40.752 +07 client backend[296613] pg_regress/domain DETAIL:  Failing row contains (a, b, null, d, d).
2023-08-01 17:01:40.752 +07 client backend[296613] pg_regress/domain CONTEXT:  COPY nulltest, line 1: "a	b	\N	d	d"
2023-08-01 17:01:40.752 +07 client backend[296613] pg_regress/domain STATEMENT:  COPY nulltest FROM stdin;
2023-08-01 17:01:40.752 +07 client backend[296613] pg_regress/domain ERROR:  domain dcheck does not allow null values
2023-08-01 17:01:40.752 +07 client backend[296613] pg_regress/domain CONTEXT:  COPY nulltest, line 1, column col5: null input
2023-08-01 17:01:40.752 +07 client backend[296613] pg_regress/domain STATEMENT:  COPY nulltest FROM stdin;
2023-08-01 17:01:40.752 +07 client backend[296627] pg_regress/temp ERROR:  cannot PREPARE a transaction that has operated on temporary objects
2023-08-01 17:01:40.752 +07 client backend[296627] pg_regress/temp STATEMENT:  prepare transaction 'twophase_func';
2023-08-01 17:01:40.752 +07 client backend[296613] pg_regress/domain ERROR:  new row for relation "nulltest" violates check constraint "nulltest_col5_check"
2023-08-01 17:01:40.752 +07 client backend[296613] pg_regress/domain DETAIL:  Failing row contains (a, b, c, null, a).
2023-08-01 17:01:40.752 +07 client backend[296613] pg_regress/domain CONTEXT:  COPY nulltest, line 3: "a	b	c	\N	a"
2023-08-01 17:01:40.752 +07 client backend[296613] pg_regress/domain STATEMENT:  COPY nulltest FROM stdin;
2023-08-01 17:01:40.752 +07 client backend[296621] pg_regress/polymorphism ERROR:  function formarray(integer, text) does not exist at character 8
2023-08-01 17:01:40.752 +07 client backend[296621] pg_regress/polymorphism HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:40.752 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  select formarray(1, 'x'::text);
2023-08-01 17:01:40.753 +07 client backend[296621] pg_regress/polymorphism ERROR:  function formarray(integer, text[]) does not exist at character 8
2023-08-01 17:01:40.753 +07 client backend[296621] pg_regress/polymorphism HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:40.753 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  select formarray(1, variadic array['x'::text]);
2023-08-01 17:01:40.753 +07 client backend[296613] pg_regress/domain ERROR:  domain dnotnull does not allow null values
2023-08-01 17:01:40.753 +07 client backend[296613] pg_regress/domain STATEMENT:  SELECT cast(NULL as dnotnull);
2023-08-01 17:01:40.753 +07 client backend[296613] pg_regress/domain ERROR:  domain dnotnull does not allow null values
2023-08-01 17:01:40.753 +07 client backend[296613] pg_regress/domain STATEMENT:  SELECT cast(cast(NULL as dnull) as dnotnull);
2023-08-01 17:01:40.753 +07 client backend[296627] pg_regress/temp ERROR:  cannot PREPARE a transaction that has operated on temporary objects
2023-08-01 17:01:40.753 +07 client backend[296627] pg_regress/temp STATEMENT:  prepare transaction 'twophase_func';
2023-08-01 17:01:40.753 +07 client backend[296613] pg_regress/domain ERROR:  domain dnotnull does not allow null values
2023-08-01 17:01:40.753 +07 client backend[296613] pg_regress/domain STATEMENT:  SELECT cast(col4 as dnotnull) from nulltest;
2023-08-01 17:01:40.753 +07 client backend[296625] pg_regress/alter_table ERROR:  column "c" referenced in foreign key constraint does not exist
2023-08-01 17:01:40.753 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE attmp3 add constraint attmpconstr foreign key(c) references attmp2 match full;
2023-08-01 17:01:40.753 +07 client backend[296625] pg_regress/alter_table ERROR:  column "b" referenced in foreign key constraint does not exist
2023-08-01 17:01:40.753 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE attmp3 add constraint attmpconstr foreign key(a) references attmp2(b) match full;
2023-08-01 17:01:40.754 +07 client backend[296627] pg_regress/temp ERROR:  cannot PREPARE a transaction that has operated on temporary objects
2023-08-01 17:01:40.754 +07 client backend[296627] pg_regress/temp STATEMENT:  prepare transaction 'twophase_operator';
2023-08-01 17:01:40.754 +07 client backend[296625] pg_regress/alter_table ERROR:  insert or update on table "attmp3" violates foreign key constraint "attmpconstr"
2023-08-01 17:01:40.754 +07 client backend[296625] pg_regress/alter_table DETAIL:  Key (a)=(5) is not present in table "attmp2".
2023-08-01 17:01:40.754 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE attmp3 add constraint attmpconstr foreign key (a) references attmp2 match full;
2023-08-01 17:01:40.755 +07 client backend[296627] pg_regress/temp ERROR:  cannot PREPARE a transaction that has operated on temporary objects
2023-08-01 17:01:40.755 +07 client backend[296627] pg_regress/temp STATEMENT:  prepare transaction 'twophase_type';
2023-08-01 17:01:40.755 +07 client backend[296627] pg_regress/temp ERROR:  cannot PREPARE a transaction that has operated on temporary objects
2023-08-01 17:01:40.755 +07 client backend[296627] pg_regress/temp STATEMENT:  prepare transaction 'twophase_view';
2023-08-01 17:01:40.756 +07 client backend[296620] pg_regress/truncate ERROR:  relation "truncate_a_id1" does not exist at character 16
2023-08-01 17:01:40.756 +07 client backend[296620] pg_regress/truncate STATEMENT:  SELECT nextval('truncate_a_id1');
2023-08-01 17:01:40.756 +07 client backend[296621] pg_regress/polymorphism ERROR:  function dfunc(integer, integer, integer) does not exist at character 8
2023-08-01 17:01:40.756 +07 client backend[296621] pg_regress/polymorphism HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:40.756 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  select dfunc(10, 20, 30);
2023-08-01 17:01:40.756 +07 client backend[296621] pg_regress/polymorphism ERROR:  function dfunc() does not exist
2023-08-01 17:01:40.756 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  drop function dfunc();
2023-08-01 17:01:40.756 +07 client backend[296621] pg_regress/polymorphism ERROR:  function dfunc(integer) does not exist
2023-08-01 17:01:40.756 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  drop function dfunc(int);
2023-08-01 17:01:40.756 +07 client backend[296627] pg_regress/temp ERROR:  cannot PREPARE a transaction that has operated on temporary objects
2023-08-01 17:01:40.756 +07 client backend[296627] pg_regress/temp STATEMENT:  prepare transaction 'twophase_sequence';
2023-08-01 17:01:40.756 +07 client backend[296621] pg_regress/polymorphism ERROR:  input parameters after one with a default value must also have defaults
2023-08-01 17:01:40.756 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  create function dfunc(a int = 1, b int) returns int as $$
	  select $1 + $2;
	$$ language sql;
2023-08-01 17:01:40.756 +07 client backend[296620] pg_regress/truncate ERROR:  cannot truncate only a partitioned table
2023-08-01 17:01:40.756 +07 client backend[296620] pg_regress/truncate HINT:  Do not specify the ONLY keyword, or use TRUNCATE ONLY on the partitions directly.
2023-08-01 17:01:40.756 +07 client backend[296620] pg_regress/truncate STATEMENT:  TRUNCATE ONLY truncparted;
2023-08-01 17:01:40.757 +07 client backend[296627] pg_regress/temp ERROR:  cannot PREPARE a transaction that has operated on temporary objects
2023-08-01 17:01:40.757 +07 client backend[296627] pg_regress/temp STATEMENT:  prepare transaction 'twophase_tab';
2023-08-01 17:01:40.757 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 36
2023-08-01 17:01:40.757 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.757 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.757 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT * FROM XMLTABLE('*' PASSING '<a>a</a>' COLUMNS a xml PATH '.', b text PATH '.', c text PATH '"hi"', d boolean PATH '. = "a"', e integer PATH 'string-length(.)');
2023-08-01 17:01:40.757 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature at character 36
2023-08-01 17:01:40.757 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.757 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.757 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT * FROM XMLTABLE('*' PASSING '<e>pre<!--c1--><?pi arg?><![CDATA[&ent1]]><n2>&amp;deep</n2>post</e>' COLUMNS x xml PATH 'node()', y xml PATH '/');
2023-08-01 17:01:40.757 +07 client backend[296627] pg_regress/temp ERROR:  cannot PREPARE a transaction that has operated on temporary objects
2023-08-01 17:01:40.757 +07 client backend[296627] pg_regress/temp STATEMENT:  prepare transaction 'twophase_tab';
2023-08-01 17:01:40.757 +07 client backend[296623] pg_regress/xml ERROR:  unsupported XML feature
2023-08-01 17:01:40.757 +07 client backend[296623] pg_regress/xml DETAIL:  This functionality requires the server to be built with libxml support.
2023-08-01 17:01:40.757 +07 client backend[296623] pg_regress/xml HINT:  You need to rebuild PostgreSQL using --with-libxml.
2023-08-01 17:01:40.757 +07 client backend[296623] pg_regress/xml STATEMENT:  SELECT * FROM XMLTABLE('.' PASSING XMLELEMENT(NAME a) columns a varchar(20) PATH '"<foo/>"', b xml PATH '"<foo/>"');
2023-08-01 17:01:40.757 +07 client backend[296627] pg_regress/temp ERROR:  cannot PREPARE a transaction that has operated on temporary objects
2023-08-01 17:01:40.757 +07 client backend[296627] pg_regress/temp STATEMENT:  prepare transaction 'twophase_tab';
2023-08-01 17:01:40.757 +07 client backend[296620] pg_regress/truncate ERROR:  cannot truncate only a partitioned table
2023-08-01 17:01:40.757 +07 client backend[296620] pg_regress/truncate HINT:  Do not specify the ONLY keyword, or use TRUNCATE ONLY on the partitions directly.
2023-08-01 17:01:40.757 +07 client backend[296620] pg_regress/truncate STATEMENT:  TRUNCATE ONLY truncparted;
2023-08-01 17:01:40.758 +07 client backend[296627] pg_regress/temp ERROR:  cannot PREPARE a transaction that has operated on temporary objects
2023-08-01 17:01:40.758 +07 client backend[296627] pg_regress/temp STATEMENT:  prepare transaction 'twophase_tab';
2023-08-01 17:01:40.760 +07 client backend[296621] pg_regress/polymorphism ERROR:  function dfunc() is not unique at character 8
2023-08-01 17:01:40.760 +07 client backend[296621] pg_regress/polymorphism HINT:  Could not choose a best candidate function. You might need to add explicit type casts.
2023-08-01 17:01:40.760 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  select dfunc();
2023-08-01 17:01:40.760 +07 client backend[296613] pg_regress/domain ERROR:  null value in column "col5" of relation "defaulttest" violates not-null constraint
2023-08-01 17:01:40.760 +07 client backend[296613] pg_regress/domain DETAIL:  Failing row contains (3, 12, 5, 0, null, 88, 8000, 12.12).
2023-08-01 17:01:40.760 +07 client backend[296613] pg_regress/domain STATEMENT:  insert into defaulttest(col4) values(0);
2023-08-01 17:01:40.761 +07 client backend[296613] pg_regress/domain ERROR:  null value in column "col5" of relation "defaulttest" violates not-null constraint
2023-08-01 17:01:40.761 +07 client backend[296613] pg_regress/domain DETAIL:  Failing row contains (3, 12, 5, 0, null, 88, 8000, 12.12).
2023-08-01 17:01:40.761 +07 client backend[296613] pg_regress/domain STATEMENT:  insert into defaulttest(col4) values(0);
2023-08-01 17:01:40.761 +07 client backend[296626] pg_regress/rowtypes ERROR:  column "f1" is of type integer but expression is of type compos at character 82
2023-08-01 17:01:40.761 +07 client backend[296626] pg_regress/rowtypes HINT:  You will need to rewrite or cast the expression.
2023-08-01 17:01:40.761 +07 client backend[296626] pg_regress/rowtypes STATEMENT:  create function fcompos1(v compos) returns void as $$
	insert into compos values (v);  -- fail
	$$ language sql;
2023-08-01 17:01:40.762 +07 client backend[296628] pg_regress/temp ERROR:  cannot PREPARE a transaction that has operated on temporary objects
2023-08-01 17:01:40.762 +07 client backend[296628] pg_regress/temp STATEMENT:  PREPARE TRANSACTION 'twophase_search';
2023-08-01 17:01:40.762 +07 client backend[296621] pg_regress/polymorphism ERROR:  function dfunc() is not unique at character 8
2023-08-01 17:01:40.762 +07 client backend[296621] pg_regress/polymorphism HINT:  Could not choose a best candidate function. You might need to add explicit type casts.
2023-08-01 17:01:40.762 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  select dfunc();
2023-08-01 17:01:40.762 +07 client backend[296621] pg_regress/polymorphism ERROR:  function dfunc(integer) is not unique at character 8
2023-08-01 17:01:40.762 +07 client backend[296621] pg_regress/polymorphism HINT:  Could not choose a best candidate function. You might need to add explicit type casts.
2023-08-01 17:01:40.762 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  select dfunc(1);
2023-08-01 17:01:40.762 +07 client backend[296621] pg_regress/polymorphism ERROR:  function dfunc(integer, integer) is not unique at character 8
2023-08-01 17:01:40.762 +07 client backend[296621] pg_regress/polymorphism HINT:  Could not choose a best candidate function. You might need to add explicit type casts.
2023-08-01 17:01:40.762 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  select dfunc(1, 2);
2023-08-01 17:01:40.763 +07 client backend[296626] pg_regress/rowtypes ERROR:  function text(fullname) does not exist at character 8
2023-08-01 17:01:40.763 +07 client backend[296626] pg_regress/rowtypes HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:40.763 +07 client backend[296626] pg_regress/rowtypes STATEMENT:  select text(fullname) from fullname;
2023-08-01 17:01:40.763 +07 client backend[296626] pg_regress/rowtypes ERROR:  column fullname.text does not exist at character 8
2023-08-01 17:01:40.763 +07 client backend[296626] pg_regress/rowtypes STATEMENT:  select fullname.text from fullname;
2023-08-01 17:01:40.764 +07 client backend[296613] pg_regress/domain ERROR:  column "col1" of table "domnotnull" contains null values
2023-08-01 17:01:40.764 +07 client backend[296613] pg_regress/domain STATEMENT:  alter domain dnotnulltest set not null;
2023-08-01 17:01:40.764 +07 client backend[296621] pg_regress/polymorphism ERROR:  only input parameters can have default values
2023-08-01 17:01:40.764 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  create function dfunc(out int = 20) returns int as $$
	  select 1;
	$$ language sql;
2023-08-01 17:01:40.764 +07 client backend[296613] pg_regress/domain ERROR:  column "col2" of table "domnotnull" contains null values
2023-08-01 17:01:40.764 +07 client backend[296613] pg_regress/domain STATEMENT:  alter domain dnotnulltest set not null;
2023-08-01 17:01:40.764 +07 client backend[296625] pg_regress/alter_table ERROR:  insert or update on table "attmp3" violates foreign key constraint "attmpconstr"
2023-08-01 17:01:40.764 +07 client backend[296625] pg_regress/alter_table DETAIL:  Key (a)=(5) is not present in table "attmp2".
2023-08-01 17:01:40.764 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE attmp3 validate constraint attmpconstr;
2023-08-01 17:01:40.764 +07 client backend[296626] pg_regress/rowtypes ERROR:  function text(record) does not exist at character 8
2023-08-01 17:01:40.764 +07 client backend[296626] pg_regress/rowtypes HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:40.764 +07 client backend[296626] pg_regress/rowtypes STATEMENT:  select text(row('Jim', 'Beam'));
2023-08-01 17:01:40.764 +07 client backend[296626] pg_regress/rowtypes ERROR:  could not identify column "text" in record data type at character 9
2023-08-01 17:01:40.764 +07 client backend[296626] pg_regress/rowtypes STATEMENT:  select (row('Jim', 'Beam')).text;
2023-08-01 17:01:40.765 +07 client backend[296613] pg_regress/domain ERROR:  domain dnotnulltest does not allow null values
2023-08-01 17:01:40.765 +07 client backend[296613] pg_regress/domain STATEMENT:  update domnotnull set col1 = null;
2023-08-01 17:01:40.765 +07 client backend[296620] pg_regress/truncate ERROR:  cannot truncate a table referenced in a foreign key constraint
2023-08-01 17:01:40.765 +07 client backend[296620] pg_regress/truncate DETAIL:  Table "truncpart" references "truncprim".
2023-08-01 17:01:40.765 +07 client backend[296620] pg_regress/truncate HINT:  Truncate table "truncpart" at the same time, or use TRUNCATE ... CASCADE.
2023-08-01 17:01:40.765 +07 client backend[296620] pg_regress/truncate STATEMENT:  TRUNCATE TABLE truncprim;
2023-08-01 17:01:40.765 +07 client backend[296621] pg_regress/polymorphism ERROR:  function dfunc() does not exist at character 8
2023-08-01 17:01:40.765 +07 client backend[296621] pg_regress/polymorphism HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:40.765 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  select dfunc();
2023-08-01 17:01:40.766 +07 client backend[296621] pg_regress/polymorphism ERROR:  cannot remove parameter defaults from existing function
2023-08-01 17:01:40.766 +07 client backend[296621] pg_regress/polymorphism HINT:  Use DROP FUNCTION dfunc(integer[]) first.
2023-08-01 17:01:40.766 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  create or replace function dfunc(a variadic int[]) returns int as
	$$ select array_upper($1, 1) $$ language sql;
2023-08-01 17:01:40.768 +07 client backend[296621] pg_regress/polymorphism ERROR:  function dfunc(integer) is not unique at character 8
2023-08-01 17:01:40.768 +07 client backend[296621] pg_regress/polymorphism HINT:  Could not choose a best candidate function. You might need to add explicit type casts.
2023-08-01 17:01:40.768 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  select dfunc(1);
2023-08-01 17:01:40.768 +07 client backend[296618] pg_regress/with ERROR:  recursive query "t" must not contain data-modifying statements at character 16
2023-08-01 17:01:40.768 +07 client backend[296618] pg_regress/with STATEMENT:  WITH RECURSIVE t AS (
		INSERT INTO y
			SELECT * FROM t
	)
	VALUES(FALSE);
2023-08-01 17:01:40.768 +07 client backend[296618] pg_regress/with ERROR:  WITH query "t" does not have a RETURNING clause at character 54
2023-08-01 17:01:40.768 +07 client backend[296618] pg_regress/with STATEMENT:  WITH t AS (
		INSERT INTO y VALUES(0)
	)
	SELECT * FROM t;
2023-08-01 17:01:40.768 +07 client backend[296613] pg_regress/domain ERROR:  column "col1" of table "domcontest" contains values that violate the new constraint
2023-08-01 17:01:40.768 +07 client backend[296613] pg_regress/domain STATEMENT:  alter domain con add constraint t check (VALUE < 1);
2023-08-01 17:01:40.768 +07 client backend[296618] pg_regress/with ERROR:  WITH clause containing a data-modifying statement must be at the top level at character 23
2023-08-01 17:01:40.768 +07 client backend[296618] pg_regress/with STATEMENT:  SELECT * FROM (
		WITH t AS (UPDATE y SET a=a+1 RETURNING *)
		SELECT * FROM t
	) ss;
2023-08-01 17:01:40.769 +07 client backend[296618] pg_regress/with ERROR:  conditional DO INSTEAD rules are not supported for data-modifying statements in WITH
2023-08-01 17:01:40.769 +07 client backend[296618] pg_regress/with STATEMENT:  WITH t AS (
		INSERT INTO y VALUES(0)
	)
	VALUES(FALSE);
2023-08-01 17:01:40.769 +07 client backend[296613] pg_regress/domain ERROR:  value for domain con violates check constraint "con_check"
2023-08-01 17:01:40.769 +07 client backend[296613] pg_regress/domain STATEMENT:  insert into domcontest values (-5);
2023-08-01 17:01:40.769 +07 client backend[296613] pg_regress/domain ERROR:  value for domain con violates check constraint "t"
2023-08-01 17:01:40.769 +07 client backend[296613] pg_regress/domain STATEMENT:  insert into domcontest values (42);
2023-08-01 17:01:40.769 +07 client backend[296618] pg_regress/with ERROR:  syntax error at or near "with" at character 19
2023-08-01 17:01:40.769 +07 client backend[296618] pg_regress/with STATEMENT:  create table foo (with baz);
2023-08-01 17:01:40.769 +07 client backend[296618] pg_regress/with ERROR:  syntax error at or near "with" at character 19
2023-08-01 17:01:40.769 +07 client backend[296618] pg_regress/with STATEMENT:  create table foo (with ordinality);
2023-08-01 17:01:40.769 +07 client backend[296618] pg_regress/with ERROR:  relation "test" does not exist at character 38
2023-08-01 17:01:40.769 +07 client backend[296618] pg_regress/with STATEMENT:  WITH test AS (SELECT 42) INSERT INTO test VALUES (1);
2023-08-01 17:01:40.769 +07 client backend[296613] pg_regress/domain ERROR:  value for domain con violates check constraint "con_check"
2023-08-01 17:01:40.769 +07 client backend[296613] pg_regress/domain STATEMENT:  insert into domcontest values (-5);
2023-08-01 17:01:40.769 +07 client backend[296621] pg_regress/polymorphism ERROR:  function dfunc(integer) does not exist at character 15
2023-08-01 17:01:40.769 +07 client backend[296621] pg_regress/polymorphism HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:40.769 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  select * from dfunc(0);
2023-08-01 17:01:40.769 +07 client backend[296613] pg_regress/domain ERROR:  constraint "nonexistent" of domain "con" does not exist
2023-08-01 17:01:40.769 +07 client backend[296613] pg_regress/domain STATEMENT:  alter domain con drop constraint nonexistent;
2023-08-01 17:01:40.770 +07 client backend[296621] pg_regress/polymorphism ERROR:  argument name "x" used more than once at character 39
2023-08-01 17:01:40.770 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  select * from dfunc(x := 20, b := 10, x := 30);
2023-08-01 17:01:40.770 +07 client backend[296621] pg_regress/polymorphism ERROR:  positional argument cannot follow named argument at character 34
2023-08-01 17:01:40.770 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  select * from dfunc(10, b := 20, 30);
2023-08-01 17:01:40.770 +07 client backend[296621] pg_regress/polymorphism ERROR:  function dfunc(x => integer, b => integer, c => integer) does not exist at character 15
2023-08-01 17:01:40.770 +07 client backend[296621] pg_regress/polymorphism HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:40.770 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  select * from dfunc(x := 10, b := 20, c := 30);
2023-08-01 17:01:40.770 +07 client backend[296621] pg_regress/polymorphism ERROR:  function dfunc(integer, integer, a => integer) does not exist at character 15
2023-08-01 17:01:40.770 +07 client backend[296621] pg_regress/polymorphism HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:40.770 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  select * from dfunc(10, 10, a := 20);
2023-08-01 17:01:40.770 +07 client backend[296621] pg_regress/polymorphism ERROR:  function dfunc(integer, c => integer, d => integer) does not exist at character 15
2023-08-01 17:01:40.770 +07 client backend[296621] pg_regress/polymorphism HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:40.770 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  select * from dfunc(1,c := 2,d := 3);
2023-08-01 17:01:40.771 +07 client backend[296613] pg_regress/domain ERROR:  column "stuff" of table "thethings" contains values that violate the new constraint
2023-08-01 17:01:40.771 +07 client backend[296613] pg_regress/domain STATEMENT:  ALTER DOMAIN things ADD CONSTRAINT meow CHECK (VALUE < 11);
2023-08-01 17:01:40.771 +07 client backend[296613] pg_regress/domain ERROR:  column "stuff" of table "thethings" contains values that violate the new constraint
2023-08-01 17:01:40.771 +07 client backend[296613] pg_regress/domain STATEMENT:  ALTER DOMAIN things VALIDATE CONSTRAINT meow;
2023-08-01 17:01:40.771 +07 client backend[296621] pg_regress/polymorphism ERROR:  function dfunc(unknown, c => integer, b => date) does not exist at character 15
2023-08-01 17:01:40.771 +07 client backend[296621] pg_regress/polymorphism HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:40.771 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  select * from dfunc('Hello World', c := 20, b := '2009-07-25'::date);
2023-08-01 17:01:40.773 +07 client backend[296614] pg_regress/rangefuncs ERROR:  function result type must be integer because of OUT parameters
2023-08-01 17:01:40.773 +07 client backend[296614] pg_regress/rangefuncs STATEMENT:  CREATE OR REPLACE FUNCTION rngfunc(in f1 int, out f2 int) RETURNS float
	AS 'select $1+1' LANGUAGE sql;
2023-08-01 17:01:40.773 +07 client backend[296621] pg_regress/polymorphism ERROR:  cannot change name of input parameter "c"
2023-08-01 17:01:40.773 +07 client backend[296621] pg_regress/polymorphism HINT:  Use DROP FUNCTION dfunc(character varying,numeric) first.
2023-08-01 17:01:40.773 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  create or replace function dfunc(a varchar = 'def a', out _a varchar, x numeric = NULL, out _c numeric)
	returns record as $$
	  select $1, $2;
	$$ language sql;
2023-08-01 17:01:40.773 +07 client backend[296614] pg_regress/rangefuncs ERROR:  function result type must be record because of OUT parameters
2023-08-01 17:01:40.773 +07 client backend[296614] pg_regress/rangefuncs STATEMENT:  CREATE OR REPLACE FUNCTION rngfunc(in f1 int, out f2 int, out f3 text) RETURNS int
	AS 'select $1+1' LANGUAGE sql;
2023-08-01 17:01:40.773 +07 client backend[296621] pg_regress/polymorphism ERROR:  cannot change name of input parameter "c"
2023-08-01 17:01:40.773 +07 client backend[296621] pg_regress/polymorphism HINT:  Use DROP FUNCTION dfunc(character varying,numeric) first.
2023-08-01 17:01:40.773 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  create or replace function dfunc(a varchar = 'def a', out _a varchar, numeric = NULL, out _c numeric)
	returns record as $$
	  select $1, $2;
	$$ language sql;
2023-08-01 17:01:40.773 +07 client backend[296614] pg_regress/rangefuncs ERROR:  cannot change return type of existing function
2023-08-01 17:01:40.773 +07 client backend[296614] pg_regress/rangefuncs HINT:  Use DROP FUNCTION rngfunc(integer) first.
2023-08-01 17:01:40.773 +07 client backend[296614] pg_regress/rangefuncs STATEMENT:  CREATE OR REPLACE FUNCTION rngfunc(in f1 int, out f2 int, out f3 text)
	RETURNS record
	AS 'select $1+1' LANGUAGE sql;
2023-08-01 17:01:40.773 +07 client backend[296613] pg_regress/domain ERROR:  domain dom does not allow null values
2023-08-01 17:01:40.773 +07 client backend[296613] pg_regress/domain STATEMENT:  select * from domview;
2023-08-01 17:01:40.773 +07 client backend[296621] pg_regress/polymorphism ERROR:  parameter name "a" used more than once
2023-08-01 17:01:40.773 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  create function testpolym(a int, a int) returns int as $$ select 1;$$ language sql;
2023-08-01 17:01:40.774 +07 client backend[296621] pg_regress/polymorphism ERROR:  parameter name "a" used more than once
2023-08-01 17:01:40.774 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  create function testpolym(int, out a int, out a int) returns int as $$ select 1;$$ language sql;
2023-08-01 17:01:40.774 +07 client backend[296626] pg_regress/rowtypes ERROR:  missing FROM-clause entry for table "d" at character 8
2023-08-01 17:01:40.774 +07 client backend[296626] pg_regress/rowtypes STATEMENT:  SELECT d.a FROM (SELECT compositetable AS d FROM compositetable) s;
2023-08-01 17:01:40.774 +07 client backend[296621] pg_regress/polymorphism ERROR:  parameter name "a" used more than once
2023-08-01 17:01:40.774 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  create function testpolym(out a int, inout a int) returns int as $$ select 1;$$ language sql;
2023-08-01 17:01:40.774 +07 client backend[296621] pg_regress/polymorphism ERROR:  parameter name "a" used more than once
2023-08-01 17:01:40.774 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  create function testpolym(a int, inout a int) returns int as $$ select 1;$$ language sql;
2023-08-01 17:01:40.774 +07 client backend[296613] pg_regress/domain ERROR:  value for domain dom violates check constraint "domchkgt6"
2023-08-01 17:01:40.774 +07 client backend[296613] pg_regress/domain STATEMENT:  select * from domview;
2023-08-01 17:01:40.774 +07 client backend[296625] pg_regress/alter_table ERROR:  check constraint "b_greater_than_ten" of relation "attmp3" is violated by some row
2023-08-01 17:01:40.774 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE attmp3 ADD CONSTRAINT b_greater_than_ten CHECK (b > 10);
2023-08-01 17:01:40.775 +07 client backend[296626] pg_regress/rowtypes ERROR:  column "ctid" not found in data type compositetable at character 9
2023-08-01 17:01:40.775 +07 client backend[296626] pg_regress/rowtypes STATEMENT:  SELECT (d).ctid FROM (SELECT compositetable AS d FROM compositetable) s;
2023-08-01 17:01:40.775 +07 client backend[296626] pg_regress/rowtypes ERROR:  column "nonexistent" not found in data type compositetable at character 9
2023-08-01 17:01:40.775 +07 client backend[296626] pg_regress/rowtypes STATEMENT:  SELECT (NULL::compositetable).nonexistent;
2023-08-01 17:01:40.775 +07 client backend[296626] pg_regress/rowtypes ERROR:  column "oid" not found in data type compositetable at character 9
2023-08-01 17:01:40.775 +07 client backend[296626] pg_regress/rowtypes STATEMENT:  SELECT (NULL::compositetable).oid;
2023-08-01 17:01:40.776 +07 client backend[296614] pg_regress/rangefuncs ERROR:  could not determine polymorphic type because input has type unknown
2023-08-01 17:01:40.776 +07 client backend[296614] pg_regress/rangefuncs STATEMENT:  SELECT dup('xyz');
2023-08-01 17:01:40.776 +07 client backend[296625] pg_regress/alter_table ERROR:  check constraint "b_greater_than_ten" of relation "attmp3" is violated by some row
2023-08-01 17:01:40.776 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE attmp3 VALIDATE CONSTRAINT b_greater_than_ten;
2023-08-01 17:01:40.776 +07 client backend[296614] pg_regress/rangefuncs ERROR:  cannot change name of input parameter "f1"
2023-08-01 17:01:40.776 +07 client backend[296614] pg_regress/rangefuncs HINT:  Use DROP FUNCTION dup(anyelement) first.
2023-08-01 17:01:40.776 +07 client backend[296614] pg_regress/rangefuncs STATEMENT:  CREATE OR REPLACE FUNCTION dup (inout f2 anyelement, out f3 anyarray)
	AS 'select $1, array[$1,$1]' LANGUAGE sql;
2023-08-01 17:01:40.777 +07 client backend[296614] pg_regress/rangefuncs ERROR:  cannot determine result data type
2023-08-01 17:01:40.777 +07 client backend[296614] pg_regress/rangefuncs DETAIL:  A result of type anyelement requires at least one input of type anyelement, anyarray, anynonarray, anyenum, or anyrange.
2023-08-01 17:01:40.777 +07 client backend[296614] pg_regress/rangefuncs STATEMENT:  CREATE FUNCTION bad (f1 int, out f2 anyelement, out f3 anyarray)
	AS 'select $1, array[$1,$1]' LANGUAGE sql;
2023-08-01 17:01:40.777 +07 client backend[296613] pg_regress/domain ERROR:  value for domain dtop violates check constraint "dinter_check"
2023-08-01 17:01:40.777 +07 client backend[296613] pg_regress/domain STATEMENT:  select 'y1234'::dtop;
2023-08-01 17:01:40.777 +07 client backend[296613] pg_regress/domain ERROR:  value for domain dtop violates check constraint "dinter_check"
2023-08-01 17:01:40.777 +07 client backend[296613] pg_regress/domain STATEMENT:  select 'y123'::dtop;
2023-08-01 17:01:40.777 +07 client backend[296613] pg_regress/domain ERROR:  value for domain dtop violates check constraint "dinter_check"
2023-08-01 17:01:40.777 +07 client backend[296613] pg_regress/domain STATEMENT:  select 'yz23'::dtop;
2023-08-01 17:01:40.777 +07 client backend[296613] pg_regress/domain ERROR:  value for domain dtop violates check constraint "dtop_check"
2023-08-01 17:01:40.777 +07 client backend[296613] pg_regress/domain STATEMENT:  select 'xz23'::dtop;
2023-08-01 17:01:40.778 +07 client backend[296625] pg_regress/alter_table ERROR:  check constraint "b_le_20" of relation "attmp6" is violated by some row
2023-08-01 17:01:40.778 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE attmp3 VALIDATE CONSTRAINT b_le_20;
2023-08-01 17:01:40.779 +07 client backend[296613] pg_regress/domain ERROR:  value too long for type character varying(4)
2023-08-01 17:01:40.779 +07 client backend[296613] pg_regress/domain STATEMENT:  insert into dtest values('x1234');
2023-08-01 17:01:40.779 +07 client backend[296613] pg_regress/domain ERROR:  value too long for type character varying(4)
2023-08-01 17:01:40.779 +07 client backend[296613] pg_regress/domain STATEMENT:  insert into dtest values('y1234');
2023-08-01 17:01:40.779 +07 client backend[296613] pg_regress/domain ERROR:  value for domain dtop violates check constraint "dinter_check"
2023-08-01 17:01:40.779 +07 client backend[296613] pg_regress/domain STATEMENT:  insert into dtest values('y123');
2023-08-01 17:01:40.779 +07 client backend[296613] pg_regress/domain ERROR:  value for domain dtop violates check constraint "dinter_check"
2023-08-01 17:01:40.779 +07 client backend[296613] pg_regress/domain STATEMENT:  insert into dtest values('yz23');
2023-08-01 17:01:40.779 +07 client backend[296613] pg_regress/domain ERROR:  value for domain dtop violates check constraint "dtop_check"
2023-08-01 17:01:40.779 +07 client backend[296613] pg_regress/domain STATEMENT:  insert into dtest values('xz23');
2023-08-01 17:01:40.779 +07 client backend[296614] pg_regress/rangefuncs ERROR:  cannot determine result data type
2023-08-01 17:01:40.779 +07 client backend[296614] pg_regress/rangefuncs DETAIL:  A result of type anycompatible requires at least one input of type anycompatible, anycompatiblearray, anycompatiblenonarray, or anycompatiblerange.
2023-08-01 17:01:40.779 +07 client backend[296614] pg_regress/rangefuncs STATEMENT:  CREATE FUNCTION bad (f1 anyarray, out f2 anycompatible, out f3 anycompatiblearray)
	AS 'select $1, array[$1,$1]' LANGUAGE sql;
2023-08-01 17:01:40.783 +07 client backend[296613] pg_regress/domain ERROR:  domain str_domain does not allow null values
2023-08-01 17:01:40.783 +07 client backend[296613] pg_regress/domain STATEMENT:  alter table domain_test add column c str_domain;
2023-08-01 17:01:40.783 +07 client backend[296625] pg_regress/alter_table ERROR:  check constraint "check_a_is_2" of relation "parent_noinh_convalid" is violated by some row
2023-08-01 17:01:40.783 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table parent_noinh_convalid validate constraint check_a_is_2;
2023-08-01 17:01:40.785 +07 client backend[296621] pg_regress/polymorphism ERROR:  function anyctest(integer, point) does not exist at character 29
2023-08-01 17:01:40.785 +07 client backend[296621] pg_regress/polymorphism HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:40.785 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  select x, pg_typeof(x) from anyctest(11, point(1,2)) x;
2023-08-01 17:01:40.785 +07 client backend[296625] pg_regress/alter_table ERROR:  there is no unique constraint matching given keys for referenced table "attmp4"
2023-08-01 17:01:40.785 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE attmp5 add constraint attmpconstr foreign key(a) references attmp4(a) match full;
2023-08-01 17:01:40.786 +07 client backend[296621] pg_regress/polymorphism ERROR:  function anyctest(integer, integer[]) does not exist at character 29
2023-08-01 17:01:40.786 +07 client backend[296621] pg_regress/polymorphism HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:40.786 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  select x, pg_typeof(x) from anyctest(11, array[1,2]) x;
2023-08-01 17:01:40.786 +07 client backend[296613] pg_regress/domain ERROR:  value for domain str_domain2 violates check constraint "str_domain2_check"
2023-08-01 17:01:40.786 +07 client backend[296613] pg_regress/domain STATEMENT:  alter table domain_test add column d str_domain2;
2023-08-01 17:01:40.787 +07 client backend[296621] pg_regress/polymorphism ERROR:  function anyctest(integer, point[]) does not exist at character 29
2023-08-01 17:01:40.787 +07 client backend[296621] pg_regress/polymorphism HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:40.787 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  select x, pg_typeof(x) from anyctest(11, array[point(1,2)]) x;
2023-08-01 17:01:40.787 +07 client backend[296621] pg_regress/polymorphism ERROR:  function anyctest(integer, integer) does not exist at character 29
2023-08-01 17:01:40.787 +07 client backend[296621] pg_regress/polymorphism HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:40.787 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  select x, pg_typeof(x) from anyctest(11, 12) x;
2023-08-01 17:01:40.787 +07 client backend[296613] pg_regress/domain ERROR:  value for domain pos_int violates check constraint "pos_int_check"
2023-08-01 17:01:40.787 +07 client backend[296613] pg_regress/domain STATEMENT:  execute s1(0);
2023-08-01 17:01:40.787 +07 client backend[296613] pg_regress/domain ERROR:  domain pos_int does not allow null values
2023-08-01 17:01:40.787 +07 client backend[296613] pg_regress/domain STATEMENT:  execute s1(NULL);
2023-08-01 17:01:40.788 +07 client backend[296621] pg_regress/polymorphism ERROR:  function anyctest(integer, integer) does not exist at character 29
2023-08-01 17:01:40.788 +07 client backend[296621] pg_regress/polymorphism HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:40.788 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  select x, pg_typeof(x) from anyctest(11, 12) x;
2023-08-01 17:01:40.788 +07 client backend[296621] pg_regress/polymorphism ERROR:  function anyctest(numeric, int4range) does not exist at character 29
2023-08-01 17:01:40.788 +07 client backend[296621] pg_regress/polymorphism HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:40.788 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  select x, pg_typeof(x) from anyctest(11.2, int4range(4,7)) x;
2023-08-01 17:01:40.788 +07 client backend[296621] pg_regress/polymorphism ERROR:  could not determine polymorphic type anycompatiblerange because input has type unknown
2023-08-01 17:01:40.788 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  select x, pg_typeof(x) from anyctest(11.2, '[4,7)') x;
2023-08-01 17:01:40.788 +07 client backend[296613] pg_regress/domain ERROR:  domain pos_int does not allow null values
2023-08-01 17:01:40.788 +07 client backend[296613] pg_regress/domain CONTEXT:  PL/pgSQL function doubledecrement(pos_int) line 3 during statement block local variable initialization
2023-08-01 17:01:40.788 +07 client backend[296613] pg_regress/domain STATEMENT:  select doubledecrement(3);
2023-08-01 17:01:40.788 +07 client backend[296621] pg_regress/polymorphism ERROR:  function anyctest(int4range, numrange) does not exist at character 29
2023-08-01 17:01:40.788 +07 client backend[296621] pg_regress/polymorphism HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:40.788 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  select x, pg_typeof(x) from anyctest(int4range(11,12), numrange(4,7)) x;
2023-08-01 17:01:40.788 +07 client backend[296613] pg_regress/domain ERROR:  value for domain pos_int violates check constraint "pos_int_check"
2023-08-01 17:01:40.788 +07 client backend[296613] pg_regress/domain CONTEXT:  PL/pgSQL function doubledecrement(pos_int) line 3 during statement block local variable initialization
2023-08-01 17:01:40.788 +07 client backend[296613] pg_regress/domain STATEMENT:  select doubledecrement(3);
2023-08-01 17:01:40.789 +07 client backend[296621] pg_regress/polymorphism ERROR:  cannot determine result data type
2023-08-01 17:01:40.789 +07 client backend[296621] pg_regress/polymorphism DETAIL:  A result of type anycompatiblerange requires at least one input of type anycompatiblerange.
2023-08-01 17:01:40.789 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  create function anyctest(anycompatible)
	returns anycompatiblerange as $$
	  select $1
	$$ language sql;
2023-08-01 17:01:40.789 +07 client backend[296613] pg_regress/domain ERROR:  domain pos_int does not allow null values
2023-08-01 17:01:40.789 +07 client backend[296613] pg_regress/domain STATEMENT:  select doubledecrement(null);
2023-08-01 17:01:40.789 +07 client backend[296613] pg_regress/domain ERROR:  value for domain pos_int violates check constraint "pos_int_check"
2023-08-01 17:01:40.789 +07 client backend[296613] pg_regress/domain STATEMENT:  select doubledecrement(0);
2023-08-01 17:01:40.789 +07 client backend[296613] pg_regress/domain ERROR:  value for domain pos_int violates check constraint "pos_int_check"
2023-08-01 17:01:40.789 +07 client backend[296613] pg_regress/domain CONTEXT:  PL/pgSQL function doubledecrement(pos_int) line 4 at assignment
2023-08-01 17:01:40.789 +07 client backend[296613] pg_regress/domain STATEMENT:  select doubledecrement(1);
2023-08-01 17:01:40.789 +07 client backend[296621] pg_regress/polymorphism ERROR:  function anyctest(integer[], integer[]) does not exist at character 29
2023-08-01 17:01:40.789 +07 client backend[296621] pg_regress/polymorphism HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:40.789 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  select x, pg_typeof(x) from anyctest(array[11], array[1,2]) x;
2023-08-01 17:01:40.789 +07 client backend[296613] pg_regress/domain ERROR:  value for domain pos_int violates check constraint "pos_int_check"
2023-08-01 17:01:40.789 +07 client backend[296613] pg_regress/domain CONTEXT:  PL/pgSQL function doubledecrement(pos_int) while casting return value to function's return type
2023-08-01 17:01:40.789 +07 client backend[296613] pg_regress/domain STATEMENT:  select doubledecrement(2);
2023-08-01 17:01:40.790 +07 client backend[296611] pg_regress/plpgsql ERROR:  duplicate key value violates unique constraint "pfield_name"
2023-08-01 17:01:40.790 +07 client backend[296611] pg_regress/plpgsql DETAIL:  Key (name)=(PF1_1) already exists.
2023-08-01 17:01:40.790 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  insert into PField values ('PF1_1', 'should fail due to unique index');
2023-08-01 17:01:40.790 +07 client backend[296621] pg_regress/polymorphism ERROR:  function anyctest(integer, numeric[], integer, numeric) does not exist at character 29
2023-08-01 17:01:40.790 +07 client backend[296621] pg_regress/polymorphism HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:40.790 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  select x, pg_typeof(x) from anyctest(11, array[1, 2.2], 42, 34.5) x;
2023-08-01 17:01:40.790 +07 client backend[296611] pg_regress/plpgsql ERROR:  WS.not.there         does not exist
2023-08-01 17:01:40.790 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function tg_backlink_set(character,character) line 30 at RAISE
	PL/pgSQL function tg_backlink_a() line 17 at assignment
2023-08-01 17:01:40.790 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  update PSlot set backlink = 'WS.not.there' where slotname = 'PS.base.a1';
2023-08-01 17:01:40.791 +07 client backend[296611] pg_regress/plpgsql ERROR:  illegal backlink beginning with XX
2023-08-01 17:01:40.791 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function tg_backlink_set(character,character) line 47 at RAISE
	PL/pgSQL function tg_backlink_a() line 17 at assignment
2023-08-01 17:01:40.791 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  update PSlot set backlink = 'XX.illegal' where slotname = 'PS.base.a1';
2023-08-01 17:01:40.791 +07 client backend[296621] pg_regress/polymorphism ERROR:  invalid input syntax for type integer: "12.2" at character 42
2023-08-01 17:01:40.791 +07 client backend[296621] pg_regress/polymorphism STATEMENT:  select x, pg_typeof(x) from anyctest(11, '12.2') x;
2023-08-01 17:01:40.791 +07 client backend[296613] pg_regress/domain ERROR:  cannot alter type "posint" because column "ddtest2.f1" uses it
2023-08-01 17:01:40.791 +07 client backend[296613] pg_regress/domain STATEMENT:  alter domain posint add constraint c1 check(value >= 0);
2023-08-01 17:01:40.791 +07 client backend[296611] pg_regress/plpgsql ERROR:  PS.not.there         does not exist
2023-08-01 17:01:40.791 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function tg_slotlink_set(character,character) line 30 at RAISE
	PL/pgSQL function tg_slotlink_a() line 17 at assignment
2023-08-01 17:01:40.791 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  update PSlot set slotlink = 'PS.not.there' where slotname = 'PS.base.a1';
2023-08-01 17:01:40.792 +07 client backend[296611] pg_regress/plpgsql ERROR:  illegal slotlink beginning with XX
2023-08-01 17:01:40.792 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function tg_slotlink_set(character,character) line 77 at RAISE
	PL/pgSQL function tg_slotlink_a() line 17 at assignment
2023-08-01 17:01:40.792 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  update PSlot set slotlink = 'XX.illegal' where slotname = 'PS.base.a1';
2023-08-01 17:01:40.792 +07 client backend[296611] pg_regress/plpgsql ERROR:  duplicate key value violates unique constraint "hslot_name"
2023-08-01 17:01:40.792 +07 client backend[296611] pg_regress/plpgsql DETAIL:  Key (slotname)=(HS.base.hub1.1      ) already exists.
2023-08-01 17:01:40.792 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  insert into HSlot values ('HS', 'base.hub1', 1, '');
2023-08-01 17:01:40.792 +07 client backend[296611] pg_regress/plpgsql ERROR:  no manual manipulation of HSlot
2023-08-01 17:01:40.792 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function tg_hslot_biu() line 12 at RAISE
2023-08-01 17:01:40.792 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  insert into HSlot values ('HS', 'base.hub1', 20, '');
2023-08-01 17:01:40.793 +07 client backend[296611] pg_regress/plpgsql ERROR:  no manual manipulation of HSlot
2023-08-01 17:01:40.793 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function tg_hslot_bd() line 12 at RAISE
2023-08-01 17:01:40.793 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  delete from HSlot;
2023-08-01 17:01:40.793 +07 client backend[296611] pg_regress/plpgsql ERROR:  system "notthere" does not exist
2023-08-01 17:01:40.793 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function tg_iface_biu() line 8 at RAISE
2023-08-01 17:01:40.793 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  insert into IFace values ('IF', 'notthere', 'eth0', '');
2023-08-01 17:01:40.793 +07 client backend[296611] pg_regress/plpgsql ERROR:  IFace slotname "IF.orion.ethernet_interface_name_too_long" too long (20 char max)
2023-08-01 17:01:40.793 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function tg_iface_biu() line 14 at RAISE
2023-08-01 17:01:40.793 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  insert into IFace values ('IF', 'orion', 'ethernet_interface_name_too_long', '');
2023-08-01 17:01:40.793 +07 client backend[296613] pg_regress/domain ERROR:  cannot alter type "posint" because column "ddtest2.f1" uses it
2023-08-01 17:01:40.793 +07 client backend[296613] pg_regress/domain STATEMENT:  alter domain posint add constraint c1 check(value >= 0);
2023-08-01 17:01:40.795 +07 client backend[296614] pg_regress/rangefuncs LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp296614.0", size 140000
2023-08-01 17:01:40.795 +07 client backend[296614] pg_regress/rangefuncs CONTEXT:  SQL function "rngfunc1" statement 1
2023-08-01 17:01:40.795 +07 client backend[296614] pg_regress/rangefuncs STATEMENT:  select t.a, t, t.a from rngfunc1(10000) t limit 1;
2023-08-01 17:01:40.795 +07 client backend[296614] pg_regress/rangefuncs LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp296614.1", size 277788
2023-08-01 17:01:40.795 +07 client backend[296614] pg_regress/rangefuncs STATEMENT:  select t.a, t, t.a from rngfunc1(10000) t limit 1;
2023-08-01 17:01:40.796 +07 client backend[296613] pg_regress/domain ERROR:  cannot alter type "posint" because column "ddtest2.f1" uses it
2023-08-01 17:01:40.796 +07 client backend[296613] pg_regress/domain STATEMENT:  alter domain posint add constraint c1 check(value >= 0);
2023-08-01 17:01:40.798 +07 client backend[296613] pg_regress/domain ERROR:  cannot alter type "posint" because column "ddtest2.f1" uses it
2023-08-01 17:01:40.798 +07 client backend[296613] pg_regress/domain STATEMENT:  alter domain posint add constraint c1 check(value >= 0);
2023-08-01 17:01:40.801 +07 client backend[296625] pg_regress/alter_table ERROR:  foreign key constraint "fktable_ftest1_fkey" cannot be implemented
2023-08-01 17:01:40.801 +07 client backend[296625] pg_regress/alter_table DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: inet and integer.
2023-08-01 17:01:40.801 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1) references pktable;
2023-08-01 17:01:40.801 +07 client backend[296625] pg_regress/alter_table ERROR:  foreign key constraint "fktable_ftest1_fkey" cannot be implemented
2023-08-01 17:01:40.801 +07 client backend[296625] pg_regress/alter_table DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: inet and integer.
2023-08-01 17:01:40.801 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1) references pktable(ptest1);
2023-08-01 17:01:40.801 +07 client backend[296613] pg_regress/domain ERROR:  cannot alter type "posint" because column "ddtest2.f1" uses it
2023-08-01 17:01:40.801 +07 client backend[296613] pg_regress/domain STATEMENT:  alter domain posint add constraint c1 check(value >= 0);
2023-08-01 17:01:40.802 +07 client backend[296614] pg_regress/rangefuncs ERROR:  a column definition list is required for functions returning "record" at character 15
2023-08-01 17:01:40.802 +07 client backend[296614] pg_regress/rangefuncs STATEMENT:  select * from array_to_set(array['one', 'two']);
2023-08-01 17:01:40.802 +07 client backend[296614] pg_regress/rangefuncs ERROR:  return type mismatch in function declared to return record
2023-08-01 17:01:40.802 +07 client backend[296614] pg_regress/rangefuncs DETAIL:  Final statement returns integer instead of point at column 1.
2023-08-01 17:01:40.802 +07 client backend[296614] pg_regress/rangefuncs CONTEXT:  SQL function "array_to_set" during startup
2023-08-01 17:01:40.802 +07 client backend[296614] pg_regress/rangefuncs STATEMENT:  select * from array_to_set(array['one', 'two']) as t(f1 point,f2 text);
2023-08-01 17:01:40.803 +07 client backend[296613] pg_regress/domain ERROR:  value for domain posint2 violates check constraint "posint2_check"
2023-08-01 17:01:40.803 +07 client backend[296613] pg_regress/domain STATEMENT:  insert into ddtest2 values(11);
2023-08-01 17:01:40.803 +07 client backend[296614] pg_regress/rangefuncs ERROR:  return type mismatch in function declared to return record
2023-08-01 17:01:40.803 +07 client backend[296614] pg_regress/rangefuncs DETAIL:  Final statement returns integer instead of point at column 1.
2023-08-01 17:01:40.803 +07 client backend[296614] pg_regress/rangefuncs CONTEXT:  SQL function "array_to_set" during inlining
2023-08-01 17:01:40.803 +07 client backend[296614] pg_regress/rangefuncs STATEMENT:  select * from array_to_set(array['one', 'two']) as t(f1 point,f2 text);
2023-08-01 17:01:40.803 +07 client backend[296625] pg_regress/alter_table ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_ftest1_fkey"
2023-08-01 17:01:40.803 +07 client backend[296625] pg_regress/alter_table DETAIL:  Key (ftest1)=(43) is not present in table "pktable".
2023-08-01 17:01:40.803 +07 client backend[296625] pg_regress/alter_table STATEMENT:  INSERT INTO FKTABLE VALUES(43);
2023-08-01 17:01:40.803 +07 client backend[296613] pg_regress/domain ERROR:  value for domain posint2 violates check constraint "c1"
2023-08-01 17:01:40.803 +07 client backend[296613] pg_regress/domain STATEMENT:  insert into ddtest2 values(-2);
2023-08-01 17:01:40.804 +07 client backend[296613] pg_regress/domain ERROR:  column "f1" of table "ddtest2" contains values that violate the new constraint
2023-08-01 17:01:40.804 +07 client backend[296613] pg_regress/domain STATEMENT:  alter domain posint add constraint c2 check(value >= 10);
2023-08-01 17:01:40.805 +07 client backend[296614] pg_regress/rangefuncs ERROR:  a column definition list is required for functions returning "record" at character 15
2023-08-01 17:01:40.805 +07 client backend[296614] pg_regress/rangefuncs STATEMENT:  select * from testrngfunc();
2023-08-01 17:01:40.805 +07 client backend[296625] pg_regress/alter_table ERROR:  foreign key constraint "fktable_ftest1_fkey" cannot be implemented
2023-08-01 17:01:40.805 +07 client backend[296625] pg_regress/alter_table DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: numeric and integer.
2023-08-01 17:01:40.805 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1) references pktable;
2023-08-01 17:01:40.805 +07 client backend[296613] pg_regress/domain ERROR:  numeric field overflow
2023-08-01 17:01:40.805 +07 client backend[296613] pg_regress/domain DETAIL:  A field with precision 4, scale 2 must round to an absolute value less than 10^2.
2023-08-01 17:01:40.805 +07 client backend[296613] pg_regress/domain CONTEXT:  PL/pgSQL function array_elem_check(numeric) line 5 at assignment
2023-08-01 17:01:40.805 +07 client backend[296613] pg_regress/domain STATEMENT:  select array_elem_check(121.00);
2023-08-01 17:01:40.805 +07 client backend[296614] pg_regress/rangefuncs ERROR:  a column definition list is required for functions returning "record" at character 15
2023-08-01 17:01:40.805 +07 client backend[296614] pg_regress/rangefuncs STATEMENT:  select * from testrngfunc();
2023-08-01 17:01:40.806 +07 client backend[296613] pg_regress/domain ERROR:  numeric field overflow
2023-08-01 17:01:40.806 +07 client backend[296613] pg_regress/domain DETAIL:  A field with precision 4, scale 2 must round to an absolute value less than 10^2.
2023-08-01 17:01:40.806 +07 client backend[296613] pg_regress/domain CONTEXT:  PL/pgSQL function array_elem_check(numeric) line 5 at assignment
2023-08-01 17:01:40.806 +07 client backend[296613] pg_regress/domain STATEMENT:  select array_elem_check(121.00);
2023-08-01 17:01:40.807 +07 client backend[296613] pg_regress/domain ERROR:  numeric field overflow
2023-08-01 17:01:40.807 +07 client backend[296613] pg_regress/domain DETAIL:  A field with precision 4, scale 2 must round to an absolute value less than 10^2.
2023-08-01 17:01:40.807 +07 client backend[296613] pg_regress/domain CONTEXT:  PL/pgSQL function array_elem_check(numeric) line 5 at assignment
2023-08-01 17:01:40.807 +07 client backend[296613] pg_regress/domain STATEMENT:  select array_elem_check(121.00);
2023-08-01 17:01:40.807 +07 client backend[296611] pg_regress/plpgsql ERROR:  operator does not exist: point + integer at character 10
2023-08-01 17:01:40.807 +07 client backend[296611] pg_regress/plpgsql HINT:  No operator matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:40.807 +07 client backend[296611] pg_regress/plpgsql QUERY:  SELECT x + 1
2023-08-01 17:01:40.807 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function f1(anyelement) line 3 at RETURN
2023-08-01 17:01:40.807 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select f1(point(3,4));
2023-08-01 17:01:40.808 +07 client backend[296613] pg_regress/domain ERROR:  value for domain orderedpair violates check constraint "orderedpair_check"
2023-08-01 17:01:40.808 +07 client backend[296613] pg_regress/domain STATEMENT:  select array[2,1]::orderedpair;
2023-08-01 17:01:40.809 +07 client backend[296613] pg_regress/domain ERROR:  value for domain orderedpair violates check constraint "orderedpair_check"
2023-08-01 17:01:40.809 +07 client backend[296613] pg_regress/domain STATEMENT:  insert into op values (array[2,1]);
2023-08-01 17:01:40.809 +07 client backend[296613] pg_regress/domain ERROR:  value for domain orderedpair violates check constraint "orderedpair_check"
2023-08-01 17:01:40.809 +07 client backend[296613] pg_regress/domain STATEMENT:  update op set f1[2] = 0;
2023-08-01 17:01:40.809 +07 client backend[296613] pg_regress/domain ERROR:  value for domain orderedpair violates check constraint "orderedpair_check"
2023-08-01 17:01:40.809 +07 client backend[296613] pg_regress/domain CONTEXT:  PL/pgSQL function array_elem_check(integer) line 5 at assignment
2023-08-01 17:01:40.809 +07 client backend[296613] pg_regress/domain STATEMENT:  select array_elem_check(-1);
2023-08-01 17:01:40.809 +07 client backend[296625] pg_regress/alter_table ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_ftest1_fkey"
2023-08-01 17:01:40.809 +07 client backend[296625] pg_regress/alter_table DETAIL:  Key (ftest1)=(43) is not present in table "pktable".
2023-08-01 17:01:40.809 +07 client backend[296625] pg_regress/alter_table STATEMENT:  INSERT INTO FKTABLE VALUES(43);
2023-08-01 17:01:40.810 +07 client backend[296613] pg_regress/domain ERROR:  value for domain di violates check constraint "pos"
2023-08-01 17:01:40.810 +07 client backend[296613] pg_regress/domain CONTEXT:  PL/pgSQL function dom_check(integer) line 4 at assignment
2023-08-01 17:01:40.810 +07 client backend[296613] pg_regress/domain STATEMENT:  select dom_check(0);
2023-08-01 17:01:40.811 +07 client backend[296611] pg_regress/plpgsql ERROR:  cannot determine element type of "anyarray" argument
2023-08-01 17:01:40.811 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select f1(stavalues1) from pg_statistic;
2023-08-01 17:01:40.811 +07 client backend[296613] pg_regress/domain ERROR:  value for domain di violates check constraint "pos"
2023-08-01 17:01:40.811 +07 client backend[296613] pg_regress/domain CONTEXT:  PL/pgSQL function dom_check(integer) line 4 at assignment
2023-08-01 17:01:40.811 +07 client backend[296613] pg_regress/domain STATEMENT:  select dom_check(0);
2023-08-01 17:01:40.813 +07 client backend[296613] pg_regress/domain ERROR:  value for domain inotnull violates check constraint "inotnull_check"
2023-08-01 17:01:40.813 +07 client backend[296613] pg_regress/domain STATEMENT:  select null::inotnull;
2023-08-01 17:01:40.813 +07 client backend[296625] pg_regress/alter_table ERROR:  foreign key constraint "fktable_ftest1_ftest2_fkey" cannot be implemented
2023-08-01 17:01:40.813 +07 client backend[296625] pg_regress/alter_table DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: cidr and integer.
2023-08-01 17:01:40.813 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1, ftest2) references pktable;
2023-08-01 17:01:40.813 +07 client backend[296611] pg_regress/plpgsql ERROR:  PL/pgSQL functions cannot accept type anyarray
2023-08-01 17:01:40.813 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  compilation of PL/pgSQL function "f1" near line 1
2023-08-01 17:01:40.813 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select f1(stavalues1) from pg_statistic;
2023-08-01 17:01:40.813 +07 client backend[296614] pg_regress/rangefuncs ERROR:  attribute 5 of type record has been dropped
2023-08-01 17:01:40.813 +07 client backend[296614] pg_regress/rangefuncs STATEMENT:  select * from usersview;
2023-08-01 17:01:40.813 +07 client backend[296611] pg_regress/plpgsql ERROR:  cannot determine result data type
2023-08-01 17:01:40.813 +07 client backend[296611] pg_regress/plpgsql DETAIL:  A result of type anyrange requires at least one input of type anyrange.
2023-08-01 17:01:40.813 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  create function f1(x anyelement) returns anyrange as $$
	begin
	  return array[x + 1, x + 2];
	end$$ language plpgsql;
2023-08-01 17:01:40.813 +07 client backend[296613] pg_regress/domain ERROR:  value for domain inotnull violates check constraint "inotnull_check"
2023-08-01 17:01:40.813 +07 client backend[296613] pg_regress/domain STATEMENT:  insert into dom_table values (null);
2023-08-01 17:01:40.814 +07 client backend[296625] pg_regress/alter_table ERROR:  foreign key constraint "fktable_ftest1_ftest2_fkey" cannot be implemented
2023-08-01 17:01:40.814 +07 client backend[296625] pg_regress/alter_table DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: cidr and integer.
2023-08-01 17:01:40.814 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1, ftest2)
	     references pktable(ptest1, ptest2);
2023-08-01 17:01:40.815 +07 client backend[296614] pg_regress/rangefuncs ERROR:  attribute 2 of type record has wrong type
2023-08-01 17:01:40.815 +07 client backend[296614] pg_regress/rangefuncs DETAIL:  Table has type numeric, but query expects integer.
2023-08-01 17:01:40.815 +07 client backend[296614] pg_regress/rangefuncs STATEMENT:  select * from usersview;
2023-08-01 17:01:40.815 +07 client backend[296625] pg_regress/alter_table ERROR:  foreign key constraint "fktable_ftest1_ftest2_fkey" cannot be implemented
2023-08-01 17:01:40.815 +07 client backend[296625] pg_regress/alter_table DETAIL:  Key columns "ftest1" and "ptest2" are of incompatible types: integer and inet.
2023-08-01 17:01:40.815 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1, ftest2)
	     references pktable(ptest2, ptest1);
2023-08-01 17:01:40.816 +07 client backend[296625] pg_regress/alter_table ERROR:  foreign key constraint "fktable_ftest2_ftest1_fkey" cannot be implemented
2023-08-01 17:01:40.816 +07 client backend[296625] pg_regress/alter_table DETAIL:  Key columns "ftest2" and "ptest1" are of incompatible types: inet and integer.
2023-08-01 17:01:40.816 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest2, ftest1)
	     references pktable(ptest1, ptest2);
2023-08-01 17:01:40.817 +07 client backend[296614] pg_regress/rangefuncs ERROR:  function return row and query-specified return row do not match
2023-08-01 17:01:40.817 +07 client backend[296614] pg_regress/rangefuncs DETAIL:  Returned type integer at ordinal position 2, but query expects numeric.
2023-08-01 17:01:40.817 +07 client backend[296614] pg_regress/rangefuncs STATEMENT:  select * from rngfuncbar();
2023-08-01 17:01:40.818 +07 client backend[296614] pg_regress/rangefuncs ERROR:  function return row and query-specified return row do not match
2023-08-01 17:01:40.818 +07 client backend[296614] pg_regress/rangefuncs DETAIL:  Returned row contains 3 attributes, but query expects 2.
2023-08-01 17:01:40.818 +07 client backend[296614] pg_regress/rangefuncs STATEMENT:  select * from rngfuncbar();
2023-08-01 17:01:40.820 +07 client backend[296611] pg_regress/plpgsql ERROR:  function f1(int4range, integer, numeric) does not exist at character 8
2023-08-01 17:01:40.820 +07 client backend[296611] pg_regress/plpgsql HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:40.820 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select f1(int4range(42, 49), 11, 4.5) as fail;
2023-08-01 17:01:40.821 +07 client backend[296611] pg_regress/plpgsql ERROR:  cannot determine result data type
2023-08-01 17:01:40.821 +07 client backend[296611] pg_regress/plpgsql DETAIL:  A result of type anycompatiblerange requires at least one input of type anycompatiblerange.
2023-08-01 17:01:40.821 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  create function f1(x anycompatible) returns anycompatiblerange as $$
	begin
	  return array[x + 1, x + 2];
	end$$ language plpgsql;
2023-08-01 17:01:40.824 +07 client backend[296625] pg_regress/alter_table ERROR:  new row for relation "atacc1" violates check constraint "atacc_test1"
2023-08-01 17:01:40.824 +07 client backend[296625] pg_regress/alter_table DETAIL:  Failing row contains (2).
2023-08-01 17:01:40.824 +07 client backend[296625] pg_regress/alter_table STATEMENT:  insert into atacc1 (test) values (2);
2023-08-01 17:01:40.824 +07 client backend[296611] pg_regress/plpgsql ERROR:  function f1(integer, numeric[], integer, numeric) does not exist at character 48
2023-08-01 17:01:40.824 +07 client backend[296611] pg_regress/plpgsql HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:40.824 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select x, pg_typeof(x), y, pg_typeof(y)
	  from f1(11, array[1, 2.2], 42, 34.5);
2023-08-01 17:01:40.825 +07 client backend[296611] pg_regress/plpgsql ERROR:  RETURN cannot have a parameter in function with OUT parameters at character 74
2023-08-01 17:01:40.825 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  create function f1(in i int, out j int) returns int as $$
	begin
	  return i+1;
	end$$ language plpgsql;
2023-08-01 17:01:40.825 +07 client backend[296625] pg_regress/alter_table ERROR:  check constraint "atacc_test1" of relation "atacc1" is violated by some row
2023-08-01 17:01:40.825 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc1 add constraint atacc_test1 check (test>3);
2023-08-01 17:01:40.826 +07 client backend[296625] pg_regress/alter_table ERROR:  column "test1" does not exist
2023-08-01 17:01:40.826 +07 client backend[296625] pg_regress/alter_table HINT:  Perhaps you meant to reference the column "atacc1.test".
2023-08-01 17:01:40.826 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc1 add constraint atacc_test1 check (test1>3);
2023-08-01 17:01:40.827 +07 client backend[296625] pg_regress/alter_table ERROR:  new row for relation "atacc1" violates check constraint "atacc_test1"
2023-08-01 17:01:40.827 +07 client backend[296625] pg_regress/alter_table DETAIL:  Failing row contains (4, 4, 2).
2023-08-01 17:01:40.827 +07 client backend[296625] pg_regress/alter_table STATEMENT:  insert into atacc1 (test,test2,test3) values (4,4,2);
2023-08-01 17:01:40.828 +07 client backend[296622] pg_regress/largeobject ERROR:  large object read request is too large
2023-08-01 17:01:40.828 +07 client backend[296622] pg_regress/largeobject STATEMENT:  SELECT lo_get(32320);
2023-08-01 17:01:40.829 +07 client backend[296625] pg_regress/alter_table ERROR:  new row for relation "atacc1" violates check constraint "atacc1_check"
2023-08-01 17:01:40.829 +07 client backend[296625] pg_regress/alter_table DETAIL:  Failing row contains (4, 3).
2023-08-01 17:01:40.829 +07 client backend[296625] pg_regress/alter_table STATEMENT:  insert into atacc1 (test2, test) values (3, 4);
2023-08-01 17:01:40.831 +07 client backend[296625] pg_regress/alter_table ERROR:  new row for relation "atacc2" violates check constraint "foo"
2023-08-01 17:01:40.831 +07 client backend[296625] pg_regress/alter_table DETAIL:  Failing row contains (-3).
2023-08-01 17:01:40.831 +07 client backend[296625] pg_regress/alter_table STATEMENT:  insert into atacc2 (test2) values (-3);
2023-08-01 17:01:40.831 +07 client backend[296625] pg_regress/alter_table ERROR:  new row for relation "atacc3" violates check constraint "foo"
2023-08-01 17:01:40.831 +07 client backend[296625] pg_regress/alter_table DETAIL:  Failing row contains (null, -3, null).
2023-08-01 17:01:40.831 +07 client backend[296625] pg_regress/alter_table STATEMENT:  insert into atacc3 (test2) values (-3);
2023-08-01 17:01:40.833 +07 client backend[296625] pg_regress/alter_table ERROR:  relation "atacc2" is not a parent of relation "atacc3"
2023-08-01 17:01:40.833 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc3 no inherit atacc2;
2023-08-01 17:01:40.834 +07 client backend[296625] pg_regress/alter_table ERROR:  child table is missing constraint "foo"
2023-08-01 17:01:40.834 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc3 inherit atacc2;
2023-08-01 17:01:40.834 +07 client backend[296625] pg_regress/alter_table ERROR:  child table is missing column "test2"
2023-08-01 17:01:40.834 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc3 inherit atacc2;
2023-08-01 17:01:40.834 +07 client backend[296625] pg_regress/alter_table ERROR:  child table "atacc3" has different type for column "test2"
2023-08-01 17:01:40.834 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc3 inherit atacc2;
2023-08-01 17:01:40.835 +07 client backend[296625] pg_regress/alter_table ERROR:  relation "atacc2" would be inherited from more than once
2023-08-01 17:01:40.835 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc3 inherit atacc2;
2023-08-01 17:01:40.835 +07 client backend[296625] pg_regress/alter_table ERROR:  circular inheritance not allowed
2023-08-01 17:01:40.835 +07 client backend[296625] pg_regress/alter_table DETAIL:  "atacc3" is already a child of "atacc2".
2023-08-01 17:01:40.835 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc2 inherit atacc3;
2023-08-01 17:01:40.836 +07 client backend[296625] pg_regress/alter_table ERROR:  circular inheritance not allowed
2023-08-01 17:01:40.836 +07 client backend[296625] pg_regress/alter_table DETAIL:  "atacc2" is already a child of "atacc2".
2023-08-01 17:01:40.836 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc2 inherit atacc2;
2023-08-01 17:01:40.838 +07 client backend[296625] pg_regress/alter_table ERROR:  new row for relation "atacc1" violates check constraint "foo"
2023-08-01 17:01:40.838 +07 client backend[296625] pg_regress/alter_table DETAIL:  Failing row contains (-3).
2023-08-01 17:01:40.838 +07 client backend[296625] pg_regress/alter_table STATEMENT:  insert into atacc1 (test) values (-3);
2023-08-01 17:01:40.838 +07 client backend[296625] pg_regress/alter_table ERROR:  check constraint "foo" of relation "atacc2" is violated by some row
2023-08-01 17:01:40.838 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc2 add constraint foo check (test>0) no inherit;
2023-08-01 17:01:40.840 +07 client backend[296625] pg_regress/alter_table ERROR:  duplicate key value violates unique constraint "atacc_test1"
2023-08-01 17:01:40.840 +07 client backend[296625] pg_regress/alter_table DETAIL:  Key (test)=(2) already exists.
2023-08-01 17:01:40.840 +07 client backend[296625] pg_regress/alter_table STATEMENT:  insert into atacc1 (test) values (2);
2023-08-01 17:01:40.841 +07 client backend[296625] pg_regress/alter_table ERROR:  could not create unique index "atacc_test1"
2023-08-01 17:01:40.841 +07 client backend[296625] pg_regress/alter_table DETAIL:  Key (test)=(0) is duplicated.
2023-08-01 17:01:40.841 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc1 alter column test type integer using 0;
2023-08-01 17:01:40.843 +07 client backend[296625] pg_regress/alter_table ERROR:  could not create unique index "atacc_test1"
2023-08-01 17:01:40.843 +07 client backend[296625] pg_regress/alter_table DETAIL:  Key (test)=(2) is duplicated.
2023-08-01 17:01:40.843 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc1 add constraint atacc_test1 unique (test);
2023-08-01 17:01:40.844 +07 client backend[296625] pg_regress/alter_table ERROR:  column "test1" named in key does not exist
2023-08-01 17:01:40.844 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc1 add constraint atacc_test1 unique (test1);
2023-08-01 17:01:40.845 +07 client backend[296625] pg_regress/alter_table ERROR:  duplicate key value violates unique constraint "atacc_test1"
2023-08-01 17:01:40.845 +07 client backend[296625] pg_regress/alter_table DETAIL:  Key (test, test2)=(4, 4) already exists.
2023-08-01 17:01:40.845 +07 client backend[296625] pg_regress/alter_table STATEMENT:  insert into atacc1 (test,test2) values (4,4);
2023-08-01 17:01:40.847 +07 client backend[296625] pg_regress/alter_table ERROR:  duplicate key value violates unique constraint "atacc1_test_key"
2023-08-01 17:01:40.847 +07 client backend[296625] pg_regress/alter_table DETAIL:  Key (test)=(3) already exists.
2023-08-01 17:01:40.847 +07 client backend[296625] pg_regress/alter_table STATEMENT:  insert into atacc1 (test2, test) values (2, 3);
2023-08-01 17:01:40.850 +07 client backend[296625] pg_regress/alter_table ERROR:  duplicate key value violates unique constraint "atacc_test1"
2023-08-01 17:01:40.850 +07 client backend[296625] pg_regress/alter_table DETAIL:  Key (test)=(2) already exists.
2023-08-01 17:01:40.850 +07 client backend[296625] pg_regress/alter_table STATEMENT:  insert into atacc1 (test) values (2);
2023-08-01 17:01:40.850 +07 client backend[296625] pg_regress/alter_table ERROR:  null value in column "test" of relation "atacc1" violates not-null constraint
2023-08-01 17:01:40.850 +07 client backend[296625] pg_regress/alter_table DETAIL:  Failing row contains (4, null).
2023-08-01 17:01:40.850 +07 client backend[296625] pg_regress/alter_table STATEMENT:  insert into atacc1 (test) values(NULL);
2023-08-01 17:01:40.850 +07 client backend[296625] pg_regress/alter_table ERROR:  multiple primary keys for table "atacc1" are not allowed
2023-08-01 17:01:40.850 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc1 add constraint atacc_oid1 primary key(id);
2023-08-01 17:01:40.852 +07 client backend[296625] pg_regress/alter_table ERROR:  could not create unique index "atacc_test1"
2023-08-01 17:01:40.852 +07 client backend[296625] pg_regress/alter_table DETAIL:  Key (test)=(2) is duplicated.
2023-08-01 17:01:40.852 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc1 add constraint atacc_test1 primary key (test);
2023-08-01 17:01:40.854 +07 client backend[296625] pg_regress/alter_table ERROR:  column "test" of relation "atacc1" contains null values
2023-08-01 17:01:40.854 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc1 add constraint atacc_test1 primary key (test);
2023-08-01 17:01:40.854 +07 client backend[296611] pg_regress/plpgsql ERROR:  cursor "test1" does not exist
2023-08-01 17:01:40.854 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  fetch next from test1;
2023-08-01 17:01:40.855 +07 client backend[296625] pg_regress/alter_table ERROR:  column "test1" of relation "atacc1" does not exist
2023-08-01 17:01:40.855 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc1 add constraint atacc_test1 primary key (test1);
2023-08-01 17:01:40.856 +07 client backend[296625] pg_regress/alter_table ERROR:  column "test2" of relation "atacc1" contains null values
2023-08-01 17:01:40.856 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc1 add column test2 int primary key;
2023-08-01 17:01:40.859 +07 client backend[296611] pg_regress/plpgsql ERROR:  value for parameter "param2" of cursor "c1" specified more than once at character 198
2023-08-01 17:01:40.859 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  create function namedparmcursor_test3() returns void as $$
	declare
	    c1 cursor (param1 int, param2 int) for select * from rc_test where a > param1 and b > param2;
	begin
	    open c1(param2 := 20, 21);
	end
	$$ language plpgsql;
2023-08-01 17:01:40.859 +07 client backend[296611] pg_regress/plpgsql ERROR:  value for parameter "param1" of cursor "c1" specified more than once at character 188
2023-08-01 17:01:40.859 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  create function namedparmcursor_test4() returns void as $$
	declare
	    c1 cursor (param1 int, param2 int) for select * from rc_test where a > param1 and b > param2;
	begin
	    open c1(20, param1 := 21);
	end
	$$ language plpgsql;
2023-08-01 17:01:40.859 +07 client backend[296611] pg_regress/plpgsql ERROR:  value for parameter "p2" of cursor "c1" specified more than once at character 191
2023-08-01 17:01:40.859 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  create function namedparmcursor_test5() returns void as $$
	declare
	  c1 cursor (p1 int, p2 int) for
	    select * from tenk1 where thousand = p1 and tenthous = p2;
	begin
	  open c1 (p2 := 77, p2 := 42);
	end
	$$ language plpgsql;
2023-08-01 17:01:40.859 +07 client backend[296611] pg_regress/plpgsql ERROR:  not enough arguments for cursor "c1" at character 189
2023-08-01 17:01:40.859 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  create function namedparmcursor_test6() returns void as $$
	declare
	  c1 cursor (p1 int, p2 int) for
	    select * from tenk1 where thousand = p1 and tenthous = p2;
	begin
	  open c1 (p2 := 77);
	end
	$$ language plpgsql;
2023-08-01 17:01:40.860 +07 client backend[296611] pg_regress/plpgsql ERROR:  division by zero
2023-08-01 17:01:40.860 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  SQL statement "SELECT 42/0 AS p1, 77 AS p2;"
	PL/pgSQL function namedparmcursor_test7() line 6 at OPEN
2023-08-01 17:01:40.860 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select namedparmcursor_test7();
2023-08-01 17:01:40.865 +07 client backend[296611] pg_regress/plpgsql ERROR:  too many parameters specified for RAISE
2023-08-01 17:01:40.865 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  compilation of PL/pgSQL function "raise_test1" near line 3
2023-08-01 17:01:40.865 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  create function raise_test1(int) returns int as $$
	begin
	    raise notice 'This message has too many parameters!', $1;
	    return $1;
	end;
	$$ language plpgsql;
2023-08-01 17:01:40.865 +07 client backend[296611] pg_regress/plpgsql ERROR:  too few parameters specified for RAISE
2023-08-01 17:01:40.865 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  compilation of PL/pgSQL function "raise_test2" near line 3
2023-08-01 17:01:40.865 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  create function raise_test2(int) returns int as $$
	begin
	    raise notice 'This message has too few parameters: %, %, %', $1, $1;
	    return $1;
	end;
	$$ language plpgsql;
2023-08-01 17:01:40.867 +07 client backend[296625] pg_regress/alter_table ERROR:  check constraint "atacc1_chk" of relation "atacc1" is violated by some row
2023-08-01 17:01:40.867 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc1 validate constraint atacc1_chk, alter a type int;
2023-08-01 17:01:40.868 +07 client backend[296611] pg_regress/plpgsql ERROR:  syntax error at or near "Johnny" at character 83
2023-08-01 17:01:40.868 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  create function bad_sql1() returns int as $$
	declare a int;
	begin
	    a := 5;
	    Johnny Yuma;
	    a := 10;
	    return a;
	end$$ language plpgsql;
2023-08-01 17:01:40.868 +07 client backend[296611] pg_regress/plpgsql ERROR:  syntax error at or near "the" at character 99
2023-08-01 17:01:40.868 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  create function bad_sql2() returns int as $$
	declare r record;
	begin
	    for r in select I fought the law, the law won LOOP
	        raise notice 'in loop';
	    end loop;
	    return 5;
	end;$$ language plpgsql;
2023-08-01 17:01:40.868 +07 client backend[296625] pg_regress/alter_table ERROR:  multiple primary keys for table "atacc1" are not allowed
2023-08-01 17:01:40.868 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc1 add constraint atacc_test2 primary key (test);
2023-08-01 17:01:40.869 +07 client backend[296611] pg_regress/plpgsql ERROR:  missing expression at or near ";" at character 74
2023-08-01 17:01:40.869 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  create function missing_return_expr() returns int as $$
	begin
	    return ;
	end;$$ language plpgsql;
2023-08-01 17:01:40.869 +07 client backend[296625] pg_regress/alter_table ERROR:  duplicate key value violates unique constraint "atacc_test1"
2023-08-01 17:01:40.869 +07 client backend[296625] pg_regress/alter_table DETAIL:  Key (test, test2)=(4, 4) already exists.
2023-08-01 17:01:40.869 +07 client backend[296625] pg_regress/alter_table STATEMENT:  insert into atacc1 (test,test2) values (4,4);
2023-08-01 17:01:40.869 +07 client backend[296611] pg_regress/plpgsql ERROR:  RETURN cannot have a parameter in function returning void at character 72
2023-08-01 17:01:40.869 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  create function void_return_expr() returns void as $$
	begin
	    return 5;
	end;$$ language plpgsql;
2023-08-01 17:01:40.869 +07 client backend[296625] pg_regress/alter_table ERROR:  null value in column "test" of relation "atacc1" violates not-null constraint
2023-08-01 17:01:40.869 +07 client backend[296625] pg_regress/alter_table DETAIL:  Failing row contains (null, 3).
2023-08-01 17:01:40.869 +07 client backend[296625] pg_regress/alter_table STATEMENT:  insert into atacc1 (test,test2) values (NULL,3);
2023-08-01 17:01:40.869 +07 client backend[296625] pg_regress/alter_table ERROR:  null value in column "test2" of relation "atacc1" violates not-null constraint
2023-08-01 17:01:40.869 +07 client backend[296625] pg_regress/alter_table DETAIL:  Failing row contains (3, null).
2023-08-01 17:01:40.869 +07 client backend[296625] pg_regress/alter_table STATEMENT:  insert into atacc1 (test,test2) values (3, NULL);
2023-08-01 17:01:40.869 +07 client backend[296625] pg_regress/alter_table ERROR:  null value in column "test" of relation "atacc1" violates not-null constraint
2023-08-01 17:01:40.869 +07 client backend[296625] pg_regress/alter_table DETAIL:  Failing row contains (null, null).
2023-08-01 17:01:40.869 +07 client backend[296625] pg_regress/alter_table STATEMENT:  insert into atacc1 (test,test2) values (NULL,NULL);
2023-08-01 17:01:40.871 +07 client backend[296611] pg_regress/plpgsql ERROR:  control reached end of function without RETURN
2023-08-01 17:01:40.871 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function missing_return_expr()
2023-08-01 17:01:40.871 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select missing_return_expr();
2023-08-01 17:01:40.871 +07 client backend[296625] pg_regress/alter_table ERROR:  duplicate key value violates unique constraint "atacc1_pkey"
2023-08-01 17:01:40.871 +07 client backend[296625] pg_regress/alter_table DETAIL:  Key (test)=(3) already exists.
2023-08-01 17:01:40.871 +07 client backend[296625] pg_regress/alter_table STATEMENT:  insert into atacc1 (test2, test) values (2, 3);
2023-08-01 17:01:40.871 +07 client backend[296625] pg_regress/alter_table ERROR:  null value in column "test" of relation "atacc1" violates not-null constraint
2023-08-01 17:01:40.871 +07 client backend[296625] pg_regress/alter_table DETAIL:  Failing row contains (null, 1).
2023-08-01 17:01:40.871 +07 client backend[296625] pg_regress/alter_table STATEMENT:  insert into atacc1 (test2, test) values (1, NULL);
2023-08-01 17:01:40.871 +07 client backend[296625] pg_regress/alter_table ERROR:  permission denied: "pg_class" is a system catalog
2023-08-01 17:01:40.871 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table pg_class alter column relname drop not null;
2023-08-01 17:01:40.871 +07 client backend[296625] pg_regress/alter_table ERROR:  permission denied: "pg_class" is a system catalog
2023-08-01 17:01:40.871 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table pg_class alter relname set not null;
2023-08-01 17:01:40.871 +07 client backend[296625] pg_regress/alter_table ERROR:  relation "non_existent" does not exist
2023-08-01 17:01:40.871 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table non_existent alter column bar set not null;
2023-08-01 17:01:40.871 +07 client backend[296625] pg_regress/alter_table ERROR:  relation "non_existent" does not exist
2023-08-01 17:01:40.871 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table non_existent alter column bar drop not null;
2023-08-01 17:01:40.872 +07 client backend[296625] pg_regress/alter_table ERROR:  column "test" is in a primary key
2023-08-01 17:01:40.872 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc1 alter column test drop not null;
2023-08-01 17:01:40.873 +07 client backend[296625] pg_regress/alter_table ERROR:  column "test" of relation "atacc1" contains null values
2023-08-01 17:01:40.873 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc1 alter test set not null;
2023-08-01 17:01:40.873 +07 client backend[296625] pg_regress/alter_table ERROR:  column "bar" of relation "atacc1" does not exist
2023-08-01 17:01:40.873 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc1 alter bar set not null;
2023-08-01 17:01:40.873 +07 client backend[296625] pg_regress/alter_table ERROR:  column "bar" of relation "atacc1" does not exist
2023-08-01 17:01:40.873 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc1 alter bar drop not null;
2023-08-01 17:01:40.874 +07 client backend[296625] pg_regress/alter_table ERROR:  "myview" is not a table or foreign table
2023-08-01 17:01:40.874 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table myview alter column test drop not null;
2023-08-01 17:01:40.874 +07 client backend[296625] pg_regress/alter_table ERROR:  "myview" is not a table or foreign table
2023-08-01 17:01:40.874 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table myview alter column test set not null;
2023-08-01 17:01:40.875 +07 client backend[296625] pg_regress/alter_table ERROR:  column "test_a" of relation "atacc1" contains null values
2023-08-01 17:01:40.875 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc1 alter test_a set not null;
2023-08-01 17:01:40.876 +07 client backend[296625] pg_regress/alter_table ERROR:  column "test_a" of relation "atacc1" contains null values
2023-08-01 17:01:40.876 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc1 alter test_a set not null;
2023-08-01 17:01:40.877 +07 client backend[296625] pg_regress/alter_table ERROR:  column "test_b" of relation "atacc1" contains null values
2023-08-01 17:01:40.877 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc1 alter test_a set not null, alter test_b set not null;
2023-08-01 17:01:40.877 +07 client backend[296611] pg_regress/plpgsql ERROR:  column "sqlstate" does not exist at character 8
2023-08-01 17:01:40.877 +07 client backend[296611] pg_regress/plpgsql QUERY:  SELECT sqlstate
2023-08-01 17:01:40.877 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function excpt_test1() line 3 at RAISE
2023-08-01 17:01:40.877 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select excpt_test1();
2023-08-01 17:01:40.877 +07 client backend[296625] pg_regress/alter_table ERROR:  column "test_b" of relation "atacc1" contains null values
2023-08-01 17:01:40.877 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc1 alter test_b set not null, alter test_a set not null;
2023-08-01 17:01:40.878 +07 client backend[296611] pg_regress/plpgsql ERROR:  column "sqlstate" does not exist at character 8
2023-08-01 17:01:40.878 +07 client backend[296611] pg_regress/plpgsql QUERY:  SELECT sqlstate
2023-08-01 17:01:40.878 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function excpt_test2() line 5 at RAISE
2023-08-01 17:01:40.878 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select excpt_test2();
2023-08-01 17:01:40.880 +07 client backend[296625] pg_regress/alter_table ERROR:  null value in column "a" of relation "parent" violates not-null constraint
2023-08-01 17:01:40.880 +07 client backend[296625] pg_regress/alter_table DETAIL:  Failing row contains (null).
2023-08-01 17:01:40.880 +07 client backend[296625] pg_regress/alter_table STATEMENT:  insert into parent values (NULL);
2023-08-01 17:01:40.880 +07 client backend[296625] pg_regress/alter_table ERROR:  null value in column "a" of relation "child" violates not-null constraint
2023-08-01 17:01:40.880 +07 client backend[296625] pg_regress/alter_table DETAIL:  Failing row contains (null, foo).
2023-08-01 17:01:40.880 +07 client backend[296625] pg_regress/alter_table STATEMENT:  insert into child (a, b) values (NULL, 'foo');
2023-08-01 17:01:40.880 +07 client backend[296625] pg_regress/alter_table ERROR:  column "a" of relation "parent" contains null values
2023-08-01 17:01:40.880 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table only parent alter a set not null;
2023-08-01 17:01:40.881 +07 client backend[296625] pg_regress/alter_table ERROR:  column "a" of relation "child" contains null values
2023-08-01 17:01:40.881 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table child alter a set not null;
2023-08-01 17:01:40.881 +07 client backend[296625] pg_regress/alter_table ERROR:  null value in column "a" of relation "parent" violates not-null constraint
2023-08-01 17:01:40.881 +07 client backend[296625] pg_regress/alter_table DETAIL:  Failing row contains (null).
2023-08-01 17:01:40.881 +07 client backend[296625] pg_regress/alter_table STATEMENT:  insert into parent values (NULL);
2023-08-01 17:01:40.881 +07 client backend[296625] pg_regress/alter_table ERROR:  null value in column "a" of relation "child" violates not-null constraint
2023-08-01 17:01:40.881 +07 client backend[296625] pg_regress/alter_table DETAIL:  Failing row contains (null, foo).
2023-08-01 17:01:40.881 +07 client backend[296625] pg_regress/alter_table STATEMENT:  insert into child (a, b) values (NULL, 'foo');
2023-08-01 17:01:40.881 +07 client backend[296625] pg_regress/alter_table ERROR:  null value in column "a" of relation "child" violates not-null constraint
2023-08-01 17:01:40.881 +07 client backend[296625] pg_regress/alter_table DETAIL:  Failing row contains (null, foo).
2023-08-01 17:01:40.881 +07 client backend[296625] pg_regress/alter_table STATEMENT:  insert into child (a, b) values (NULL, 'foo');
2023-08-01 17:01:40.884 +07 client backend[296625] pg_regress/alter_table ERROR:  invalid input syntax for type integer: "wrong_datatype"
2023-08-01 17:01:40.884 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table def_test alter column c1 set default 'wrong_datatype';
2023-08-01 17:01:40.885 +07 client backend[296625] pg_regress/alter_table ERROR:  column "c3" of relation "def_test" does not exist
2023-08-01 17:01:40.885 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table def_test alter column c3 set default 30;
2023-08-01 17:01:40.888 +07 client backend[296625] pg_regress/alter_table ERROR:  permission denied: "pg_class" is a system catalog
2023-08-01 17:01:40.888 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table pg_class drop column relname;
2023-08-01 17:01:40.888 +07 client backend[296625] pg_regress/alter_table ERROR:  relation "nosuchtable" does not exist
2023-08-01 17:01:40.888 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table nosuchtable drop column bar;
2023-08-01 17:01:40.888 +07 client backend[296625] pg_regress/alter_table ERROR:  column "a" of relation "atacc1" does not exist
2023-08-01 17:01:40.888 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc1 drop a;
2023-08-01 17:01:40.888 +07 client backend[296625] pg_regress/alter_table ERROR:  column "a" does not exist at character 31
2023-08-01 17:01:40.888 +07 client backend[296625] pg_regress/alter_table STATEMENT:  select * from atacc1 order by a;
2023-08-01 17:01:40.888 +07 client backend[296625] pg_regress/alter_table ERROR:  column "........pg.dropped.1........" does not exist at character 31
2023-08-01 17:01:40.888 +07 client backend[296625] pg_regress/alter_table STATEMENT:  select * from atacc1 order by "........pg.dropped.1........";
2023-08-01 17:01:40.888 +07 client backend[296625] pg_regress/alter_table ERROR:  column "a" does not exist at character 31
2023-08-01 17:01:40.888 +07 client backend[296625] pg_regress/alter_table STATEMENT:  select * from atacc1 group by a;
2023-08-01 17:01:40.889 +07 client backend[296625] pg_regress/alter_table ERROR:  column "........pg.dropped.1........" does not exist at character 31
2023-08-01 17:01:40.889 +07 client backend[296625] pg_regress/alter_table STATEMENT:  select * from atacc1 group by "........pg.dropped.1........";
2023-08-01 17:01:40.889 +07 client backend[296625] pg_regress/alter_table ERROR:  column "a" does not exist at character 8
2023-08-01 17:01:40.889 +07 client backend[296625] pg_regress/alter_table STATEMENT:  select a from atacc1;
2023-08-01 17:01:40.889 +07 client backend[296625] pg_regress/alter_table ERROR:  column atacc1.a does not exist at character 8
2023-08-01 17:01:40.889 +07 client backend[296625] pg_regress/alter_table STATEMENT:  select atacc1.a from atacc1;
2023-08-01 17:01:40.889 +07 client backend[296625] pg_regress/alter_table ERROR:  column "a" does not exist at character 8
2023-08-01 17:01:40.889 +07 client backend[296625] pg_regress/alter_table STATEMENT:  select a,b,c,d from atacc1;
2023-08-01 17:01:40.889 +07 client backend[296625] pg_regress/alter_table ERROR:  column "a" does not exist at character 28
2023-08-01 17:01:40.889 +07 client backend[296625] pg_regress/alter_table STATEMENT:  select * from atacc1 where a = 1;
2023-08-01 17:01:40.889 +07 client backend[296625] pg_regress/alter_table ERROR:  column "........pg.dropped.1........" does not exist at character 8
2023-08-01 17:01:40.889 +07 client backend[296625] pg_regress/alter_table STATEMENT:  select "........pg.dropped.1........" from atacc1;
2023-08-01 17:01:40.889 +07 client backend[296625] pg_regress/alter_table ERROR:  column atacc1.........pg.dropped.1........ does not exist at character 8
2023-08-01 17:01:40.889 +07 client backend[296625] pg_regress/alter_table STATEMENT:  select atacc1."........pg.dropped.1........" from atacc1;
2023-08-01 17:01:40.889 +07 client backend[296625] pg_regress/alter_table ERROR:  column "........pg.dropped.1........" does not exist at character 8
2023-08-01 17:01:40.889 +07 client backend[296625] pg_regress/alter_table STATEMENT:  select "........pg.dropped.1........",b,c,d from atacc1;
2023-08-01 17:01:40.889 +07 client backend[296625] pg_regress/alter_table ERROR:  column "........pg.dropped.1........" does not exist at character 28
2023-08-01 17:01:40.889 +07 client backend[296625] pg_regress/alter_table STATEMENT:  select * from atacc1 where "........pg.dropped.1........" = 1;
2023-08-01 17:01:40.889 +07 client backend[296625] pg_regress/alter_table ERROR:  column "a" of relation "atacc1" does not exist at character 19
2023-08-01 17:01:40.889 +07 client backend[296625] pg_regress/alter_table STATEMENT:  update atacc1 set a = 3;
2023-08-01 17:01:40.889 +07 client backend[296625] pg_regress/alter_table ERROR:  column "a" does not exist at character 31
2023-08-01 17:01:40.889 +07 client backend[296625] pg_regress/alter_table STATEMENT:  update atacc1 set b = 2 where a = 3;
2023-08-01 17:01:40.889 +07 client backend[296625] pg_regress/alter_table ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist at character 19
2023-08-01 17:01:40.889 +07 client backend[296625] pg_regress/alter_table STATEMENT:  update atacc1 set "........pg.dropped.1........" = 3;
2023-08-01 17:01:40.889 +07 client backend[296625] pg_regress/alter_table ERROR:  column "........pg.dropped.1........" does not exist at character 31
2023-08-01 17:01:40.889 +07 client backend[296625] pg_regress/alter_table STATEMENT:  update atacc1 set b = 2 where "........pg.dropped.1........" = 3;
2023-08-01 17:01:40.889 +07 client backend[296625] pg_regress/alter_table ERROR:  INSERT has more expressions than target columns at character 40
2023-08-01 17:01:40.889 +07 client backend[296625] pg_regress/alter_table STATEMENT:  insert into atacc1 values (10, 11, 12, 13);
2023-08-01 17:01:40.889 +07 client backend[296625] pg_regress/alter_table ERROR:  INSERT has more expressions than target columns at character 45
2023-08-01 17:01:40.889 +07 client backend[296625] pg_regress/alter_table STATEMENT:  insert into atacc1 values (default, 11, 12, 13);
2023-08-01 17:01:40.889 +07 client backend[296625] pg_regress/alter_table ERROR:  column "a" of relation "atacc1" does not exist at character 21
2023-08-01 17:01:40.889 +07 client backend[296625] pg_regress/alter_table STATEMENT:  insert into atacc1 (a) values (10);
2023-08-01 17:01:40.889 +07 client backend[296625] pg_regress/alter_table ERROR:  column "a" of relation "atacc1" does not exist at character 21
2023-08-01 17:01:40.889 +07 client backend[296625] pg_regress/alter_table STATEMENT:  insert into atacc1 (a) values (default);
2023-08-01 17:01:40.889 +07 client backend[296625] pg_regress/alter_table ERROR:  column "a" of relation "atacc1" does not exist at character 21
2023-08-01 17:01:40.889 +07 client backend[296625] pg_regress/alter_table STATEMENT:  insert into atacc1 (a,b,c,d) values (10,11,12,13);
2023-08-01 17:01:40.890 +07 client backend[296625] pg_regress/alter_table ERROR:  column "a" of relation "atacc1" does not exist at character 21
2023-08-01 17:01:40.890 +07 client backend[296625] pg_regress/alter_table STATEMENT:  insert into atacc1 (a,b,c,d) values (default,11,12,13);
2023-08-01 17:01:40.890 +07 client backend[296625] pg_regress/alter_table ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist at character 21
2023-08-01 17:01:40.890 +07 client backend[296625] pg_regress/alter_table STATEMENT:  insert into atacc1 ("........pg.dropped.1........") values (10);
2023-08-01 17:01:40.890 +07 client backend[296625] pg_regress/alter_table ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist at character 21
2023-08-01 17:01:40.890 +07 client backend[296625] pg_regress/alter_table STATEMENT:  insert into atacc1 ("........pg.dropped.1........") values (default);
2023-08-01 17:01:40.890 +07 client backend[296625] pg_regress/alter_table ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist at character 21
2023-08-01 17:01:40.890 +07 client backend[296625] pg_regress/alter_table STATEMENT:  insert into atacc1 ("........pg.dropped.1........",b,c,d) values (10,11,12,13);
2023-08-01 17:01:40.890 +07 client backend[296625] pg_regress/alter_table ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist at character 21
2023-08-01 17:01:40.890 +07 client backend[296625] pg_regress/alter_table STATEMENT:  insert into atacc1 ("........pg.dropped.1........",b,c,d) values (default,11,12,13);
2023-08-01 17:01:40.890 +07 client backend[296625] pg_regress/alter_table ERROR:  column "a" does not exist at character 26
2023-08-01 17:01:40.890 +07 client backend[296625] pg_regress/alter_table STATEMENT:  delete from atacc1 where a = 3;
2023-08-01 17:01:40.890 +07 client backend[296625] pg_regress/alter_table ERROR:  column "........pg.dropped.1........" does not exist at character 26
2023-08-01 17:01:40.890 +07 client backend[296625] pg_regress/alter_table STATEMENT:  delete from atacc1 where "........pg.dropped.1........" = 3;
2023-08-01 17:01:40.890 +07 client backend[296625] pg_regress/alter_table ERROR:  column "bar" of relation "atacc1" does not exist
2023-08-01 17:01:40.890 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc1 drop bar;
2023-08-01 17:01:40.890 +07 client backend[296625] pg_regress/alter_table ERROR:  syntax error at or near "WITH" at character 24
2023-08-01 17:01:40.890 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc1 SET WITH OIDS;
2023-08-01 17:01:40.890 +07 client backend[296625] pg_regress/alter_table ERROR:  cannot drop system column "xmin"
2023-08-01 17:01:40.890 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc1 drop xmin;
2023-08-01 17:01:40.891 +07 client backend[296625] pg_regress/alter_table ERROR:  "myview" is not a table, composite type, or foreign table
2023-08-01 17:01:40.891 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table myview drop d;
2023-08-01 17:01:40.891 +07 client backend[296625] pg_regress/alter_table ERROR:  column "a" of relation "atacc1" does not exist
2023-08-01 17:01:40.891 +07 client backend[296625] pg_regress/alter_table STATEMENT:  analyze atacc1(a);
2023-08-01 17:01:40.891 +07 client backend[296625] pg_regress/alter_table ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
2023-08-01 17:01:40.891 +07 client backend[296625] pg_regress/alter_table STATEMENT:  analyze atacc1("........pg.dropped.1........");
2023-08-01 17:01:40.892 +07 client backend[296611] pg_regress/plpgsql ERROR:  query returned more than one row
2023-08-01 17:01:40.892 +07 client backend[296611] pg_regress/plpgsql HINT:  Make sure the query returns a single row, or use LIMIT 1.
2023-08-01 17:01:40.892 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function stricttest() line 5 at SQL statement
2023-08-01 17:01:40.892 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select stricttest();
2023-08-01 17:01:40.895 +07 client backend[296611] pg_regress/plpgsql ERROR:  query returned no rows
2023-08-01 17:01:40.895 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function stricttest() line 5 at SQL statement
2023-08-01 17:01:40.895 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select stricttest();
2023-08-01 17:01:40.896 +07 client backend[296611] pg_regress/plpgsql ERROR:  query returned more than one row
2023-08-01 17:01:40.896 +07 client backend[296611] pg_regress/plpgsql HINT:  Make sure the query returns a single row, or use LIMIT 1.
2023-08-01 17:01:40.896 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function stricttest() line 5 at SQL statement
2023-08-01 17:01:40.896 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select stricttest();
2023-08-01 17:01:40.897 +07 client backend[296611] pg_regress/plpgsql ERROR:  query returned no rows
2023-08-01 17:01:40.897 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function stricttest() line 5 at EXECUTE
2023-08-01 17:01:40.897 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select stricttest();
2023-08-01 17:01:40.897 +07 client backend[296611] pg_regress/plpgsql ERROR:  query returned more than one row
2023-08-01 17:01:40.897 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function stricttest() line 5 at EXECUTE
2023-08-01 17:01:40.897 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select stricttest();
2023-08-01 17:01:40.898 +07 client backend[296611] pg_regress/plpgsql ERROR:  query returned no rows
2023-08-01 17:01:40.898 +07 client backend[296611] pg_regress/plpgsql DETAIL:  parameters: p1 = '2', p3 = 'foo'
2023-08-01 17:01:40.898 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function stricttest() line 8 at SQL statement
2023-08-01 17:01:40.898 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select stricttest();
2023-08-01 17:01:40.899 +07 client backend[296611] pg_regress/plpgsql ERROR:  query returned no rows
2023-08-01 17:01:40.899 +07 client backend[296611] pg_regress/plpgsql DETAIL:  parameters: p1 = '2', p3 = '''Valame Dios!'' dijo Sancho; ''no le dije yo a vuestra merced que mirase bien lo que hacia?'''
2023-08-01 17:01:40.899 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function stricttest() line 8 at SQL statement
2023-08-01 17:01:40.899 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select stricttest();
2023-08-01 17:01:40.900 +07 client backend[296611] pg_regress/plpgsql ERROR:  query returned more than one row
2023-08-01 17:01:40.900 +07 client backend[296611] pg_regress/plpgsql DETAIL:  parameters: p1 = '2', p3 = 'foo'
2023-08-01 17:01:40.900 +07 client backend[296611] pg_regress/plpgsql HINT:  Make sure the query returns a single row, or use LIMIT 1.
2023-08-01 17:01:40.900 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function stricttest() line 8 at SQL statement
2023-08-01 17:01:40.900 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select stricttest();
2023-08-01 17:01:40.900 +07 client backend[296611] pg_regress/plpgsql ERROR:  query returned more than one row
2023-08-01 17:01:40.900 +07 client backend[296611] pg_regress/plpgsql HINT:  Make sure the query returns a single row, or use LIMIT 1.
2023-08-01 17:01:40.900 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function stricttest() line 5 at SQL statement
2023-08-01 17:01:40.900 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select stricttest();
2023-08-01 17:01:40.901 +07 client backend[296611] pg_regress/plpgsql ERROR:  query returned no rows
2023-08-01 17:01:40.901 +07 client backend[296611] pg_regress/plpgsql DETAIL:  parameters: $1 = '0', $2 = 'foo'
2023-08-01 17:01:40.901 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function stricttest() line 5 at EXECUTE
2023-08-01 17:01:40.901 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select stricttest();
2023-08-01 17:01:40.901 +07 client backend[296611] pg_regress/plpgsql ERROR:  query returned more than one row
2023-08-01 17:01:40.901 +07 client backend[296611] pg_regress/plpgsql DETAIL:  parameters: $1 = '1'
2023-08-01 17:01:40.901 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function stricttest() line 5 at EXECUTE
2023-08-01 17:01:40.901 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select stricttest();
2023-08-01 17:01:40.902 +07 client backend[296611] pg_regress/plpgsql ERROR:  query returned more than one row
2023-08-01 17:01:40.902 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function stricttest() line 5 at EXECUTE
2023-08-01 17:01:40.902 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select stricttest();
2023-08-01 17:01:40.902 +07 client backend[296611] pg_regress/plpgsql ERROR:  query returned more than one row
2023-08-01 17:01:40.902 +07 client backend[296611] pg_regress/plpgsql HINT:  Make sure the query returns a single row, or use LIMIT 1.
2023-08-01 17:01:40.902 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function stricttest() line 10 at SQL statement
2023-08-01 17:01:40.902 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select stricttest();
2023-08-01 17:01:40.902 +07 client backend[296625] pg_regress/alter_table ERROR:  column "a" of relation "atacc1" does not exist
2023-08-01 17:01:40.902 +07 client backend[296625] pg_regress/alter_table STATEMENT:  vacuum analyze atacc1(a);
2023-08-01 17:01:40.903 +07 client backend[296625] pg_regress/alter_table ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
2023-08-01 17:01:40.903 +07 client backend[296625] pg_regress/alter_table STATEMENT:  vacuum analyze atacc1("........pg.dropped.1........");
2023-08-01 17:01:40.903 +07 client backend[296625] pg_regress/alter_table ERROR:  column "a" of relation "atacc1" does not exist
2023-08-01 17:01:40.903 +07 client backend[296625] pg_regress/alter_table STATEMENT:  comment on column atacc1.a is 'testing';
2023-08-01 17:01:40.903 +07 client backend[296625] pg_regress/alter_table ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
2023-08-01 17:01:40.903 +07 client backend[296625] pg_regress/alter_table STATEMENT:  comment on column atacc1."........pg.dropped.1........" is 'testing';
2023-08-01 17:01:40.903 +07 client backend[296625] pg_regress/alter_table ERROR:  column "a" of relation "atacc1" does not exist
2023-08-01 17:01:40.903 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc1 alter a set storage plain;
2023-08-01 17:01:40.903 +07 client backend[296611] pg_regress/plpgsql ERROR:  query returned more than one row
2023-08-01 17:01:40.903 +07 client backend[296611] pg_regress/plpgsql DETAIL:  parameters: p1 = '2', p3 = 'foo'
2023-08-01 17:01:40.903 +07 client backend[296611] pg_regress/plpgsql HINT:  Make sure the query returns a single row, or use LIMIT 1.
2023-08-01 17:01:40.903 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function stricttest() line 10 at SQL statement
2023-08-01 17:01:40.903 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select stricttest();
2023-08-01 17:01:40.903 +07 client backend[296625] pg_regress/alter_table ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
2023-08-01 17:01:40.903 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc1 alter "........pg.dropped.1........" set storage plain;
2023-08-01 17:01:40.903 +07 client backend[296625] pg_regress/alter_table ERROR:  column "a" of relation "atacc1" does not exist
2023-08-01 17:01:40.903 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc1 alter a set statistics 0;
2023-08-01 17:01:40.903 +07 client backend[296625] pg_regress/alter_table ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
2023-08-01 17:01:40.903 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc1 alter "........pg.dropped.1........" set statistics 0;
2023-08-01 17:01:40.903 +07 client backend[296625] pg_regress/alter_table ERROR:  column "a" of relation "atacc1" does not exist
2023-08-01 17:01:40.903 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc1 alter a set default 3;
2023-08-01 17:01:40.903 +07 client backend[296625] pg_regress/alter_table ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
2023-08-01 17:01:40.903 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc1 alter "........pg.dropped.1........" set default 3;
2023-08-01 17:01:40.903 +07 client backend[296625] pg_regress/alter_table ERROR:  column "a" of relation "atacc1" does not exist
2023-08-01 17:01:40.903 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc1 alter a drop default;
2023-08-01 17:01:40.903 +07 client backend[296625] pg_regress/alter_table ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
2023-08-01 17:01:40.903 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc1 alter "........pg.dropped.1........" drop default;
2023-08-01 17:01:40.903 +07 client backend[296625] pg_regress/alter_table ERROR:  column "a" of relation "atacc1" does not exist
2023-08-01 17:01:40.903 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc1 alter a set not null;
2023-08-01 17:01:40.903 +07 client backend[296625] pg_regress/alter_table ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
2023-08-01 17:01:40.903 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc1 alter "........pg.dropped.1........" set not null;
2023-08-01 17:01:40.903 +07 client backend[296625] pg_regress/alter_table ERROR:  column "a" of relation "atacc1" does not exist
2023-08-01 17:01:40.903 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc1 alter a drop not null;
2023-08-01 17:01:40.903 +07 client backend[296625] pg_regress/alter_table ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
2023-08-01 17:01:40.903 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc1 alter "........pg.dropped.1........" drop not null;
2023-08-01 17:01:40.904 +07 client backend[296625] pg_regress/alter_table ERROR:  column "a" does not exist
2023-08-01 17:01:40.904 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc1 rename a to x;
2023-08-01 17:01:40.904 +07 client backend[296625] pg_regress/alter_table ERROR:  column "........pg.dropped.1........" does not exist
2023-08-01 17:01:40.904 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc1 rename "........pg.dropped.1........" to x;
2023-08-01 17:01:40.904 +07 client backend[296625] pg_regress/alter_table ERROR:  column "a" of relation "atacc1" does not exist
2023-08-01 17:01:40.904 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc1 add primary key(a);
2023-08-01 17:01:40.904 +07 client backend[296625] pg_regress/alter_table ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
2023-08-01 17:01:40.904 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc1 add primary key("........pg.dropped.1........");
2023-08-01 17:01:40.904 +07 client backend[296625] pg_regress/alter_table ERROR:  column "a" named in key does not exist
2023-08-01 17:01:40.904 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc1 add unique(a);
2023-08-01 17:01:40.904 +07 client backend[296625] pg_regress/alter_table ERROR:  column "........pg.dropped.1........" named in key does not exist
2023-08-01 17:01:40.904 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc1 add unique("........pg.dropped.1........");
2023-08-01 17:01:40.904 +07 client backend[296625] pg_regress/alter_table ERROR:  column "a" does not exist
2023-08-01 17:01:40.904 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc1 add check (a > 3);
2023-08-01 17:01:40.904 +07 client backend[296625] pg_regress/alter_table ERROR:  column "........pg.dropped.1........" does not exist
2023-08-01 17:01:40.904 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc1 add check ("........pg.dropped.1........" > 3);
2023-08-01 17:01:40.905 +07 client backend[296625] pg_regress/alter_table ERROR:  column "a" referenced in foreign key constraint does not exist
2023-08-01 17:01:40.905 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc1 add foreign key (a) references atacc2(id);
2023-08-01 17:01:40.905 +07 client backend[296625] pg_regress/alter_table ERROR:  column "........pg.dropped.1........" referenced in foreign key constraint does not exist
2023-08-01 17:01:40.905 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc1 add foreign key ("........pg.dropped.1........") references atacc2(id);
2023-08-01 17:01:40.905 +07 client backend[296625] pg_regress/alter_table ERROR:  column "a" referenced in foreign key constraint does not exist
2023-08-01 17:01:40.905 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc2 add foreign key (id) references atacc1(a);
2023-08-01 17:01:40.905 +07 client backend[296611] pg_regress/plpgsql WARNING:  variable "in1" shadows a previously defined variable at character 88
2023-08-01 17:01:40.905 +07 client backend[296611] pg_regress/plpgsql WARNING:  variable "out1" shadows a previously defined variable at character 97
2023-08-01 17:01:40.905 +07 client backend[296625] pg_regress/alter_table ERROR:  column "........pg.dropped.1........" referenced in foreign key constraint does not exist
2023-08-01 17:01:40.905 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table atacc2 add foreign key (id) references atacc1("........pg.dropped.1........");
2023-08-01 17:01:40.905 +07 client backend[296625] pg_regress/alter_table ERROR:  column "a" does not exist
2023-08-01 17:01:40.905 +07 client backend[296625] pg_regress/alter_table STATEMENT:  create index "testing_idx" on atacc1(a);
2023-08-01 17:01:40.905 +07 client backend[296625] pg_regress/alter_table ERROR:  column "........pg.dropped.1........" does not exist
2023-08-01 17:01:40.905 +07 client backend[296625] pg_regress/alter_table STATEMENT:  create index "testing_idx" on atacc1("........pg.dropped.1........");
2023-08-01 17:01:40.906 +07 client backend[296611] pg_regress/plpgsql WARNING:  variable "in1" shadows a previously defined variable at character 88
2023-08-01 17:01:40.906 +07 client backend[296611] pg_regress/plpgsql WARNING:  variable "out1" shadows a previously defined variable at character 97
2023-08-01 17:01:40.907 +07 client backend[296611] pg_regress/plpgsql WARNING:  variable "f1" shadows a previously defined variable at character 93
2023-08-01 17:01:40.908 +07 client backend[296611] pg_regress/plpgsql WARNING:  variable "in1" shadows a previously defined variable at character 76
2023-08-01 17:01:40.908 +07 client backend[296611] pg_regress/plpgsql WARNING:  variable "in1" shadows a previously defined variable at character 101
2023-08-01 17:01:40.909 +07 client backend[296625] pg_regress/alter_table ERROR:  new row for relation "atacc1" violates check constraint "atacc1_value_check"
2023-08-01 17:01:40.909 +07 client backend[296625] pg_regress/alter_table DETAIL:  Failing row contains (1, 100).
2023-08-01 17:01:40.909 +07 client backend[296625] pg_regress/alter_table STATEMENT:  insert into atacc1(value) values (100);
2023-08-01 17:01:40.909 +07 client backend[296611] pg_regress/plpgsql WARNING:  variable "f1" shadows a previously defined variable at character 88
2023-08-01 17:01:40.909 +07 client backend[296625] pg_regress/alter_table ERROR:  new row for relation "atacc1" violates check constraint "atacc1_value_check"
2023-08-01 17:01:40.909 +07 client backend[296625] pg_regress/alter_table DETAIL:  Failing row contains (2, 100).
2023-08-01 17:01:40.909 +07 client backend[296625] pg_regress/alter_table STATEMENT:  insert into atacc1(value) values (100);
2023-08-01 17:01:40.909 +07 client backend[296625] pg_regress/alter_table ERROR:  null value in column "id" of relation "atacc1" violates not-null constraint
2023-08-01 17:01:40.909 +07 client backend[296625] pg_regress/alter_table DETAIL:  Failing row contains (null, 0).
2023-08-01 17:01:40.909 +07 client backend[296625] pg_regress/alter_table STATEMENT:  insert into atacc1(id, value) values (null, 0);
2023-08-01 17:01:40.910 +07 client backend[296611] pg_regress/plpgsql ERROR:  variable "f1" shadows a previously defined variable at character 78
2023-08-01 17:01:40.910 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  create or replace function shadowtest(f1 int)
		returns boolean as $$
	declare f1 int; begin return 1; end $$ language plpgsql;
2023-08-01 17:01:40.910 +07 client backend[296611] pg_regress/plpgsql ERROR:  function shadowtest(integer) does not exist at character 8
2023-08-01 17:01:40.910 +07 client backend[296611] pg_regress/plpgsql HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:40.910 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select shadowtest(1);
2023-08-01 17:01:40.912 +07 client backend[296611] pg_regress/plpgsql WARNING:  query returned more than one row
2023-08-01 17:01:40.912 +07 client backend[296611] pg_regress/plpgsql HINT:  Make sure the query returns a single row, or use LIMIT 1.
2023-08-01 17:01:40.912 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function inline_code_block line 4 at SQL statement
2023-08-01 17:01:40.912 +07 client backend[296611] pg_regress/plpgsql ERROR:  query returned more than one row
2023-08-01 17:01:40.912 +07 client backend[296611] pg_regress/plpgsql HINT:  Make sure the query returns a single row, or use LIMIT 1.
2023-08-01 17:01:40.912 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function inline_code_block line 4 at SQL statement
2023-08-01 17:01:40.912 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  do $$
	declare x int;
	begin
	  select v from generate_series(1,2) g(v) into x;
	end;
	$$;
2023-08-01 17:01:40.913 +07 client backend[296625] pg_regress/alter_table ERROR:  column "a" has a type conflict
2023-08-01 17:01:40.913 +07 client backend[296625] pg_regress/alter_table DETAIL:  double precision versus real
2023-08-01 17:01:40.913 +07 client backend[296625] pg_regress/alter_table STATEMENT:  create table child (a float4) inherits (parent);
2023-08-01 17:01:40.913 +07 client backend[296625] pg_regress/alter_table ERROR:  column "b" has a type conflict
2023-08-01 17:01:40.913 +07 client backend[296625] pg_regress/alter_table DETAIL:  numeric(10,4) versus numeric(10,7)
2023-08-01 17:01:40.913 +07 client backend[296625] pg_regress/alter_table STATEMENT:  create table child (b decimal(10,7)) inherits (parent);
2023-08-01 17:01:40.913 +07 client backend[296625] pg_regress/alter_table ERROR:  column "c" has a collation conflict
2023-08-01 17:01:40.913 +07 client backend[296625] pg_regress/alter_table DETAIL:  "C" versus "POSIX"
2023-08-01 17:01:40.913 +07 client backend[296625] pg_regress/alter_table STATEMENT:  create table child (c text collate "POSIX") inherits (parent);
2023-08-01 17:01:40.913 +07 client backend[296611] pg_regress/plpgsql WARNING:  number of source and target fields in assignment does not match
2023-08-01 17:01:40.913 +07 client backend[296611] pg_regress/plpgsql DETAIL:  strict_multi_assignment check of extra_warnings is active.
2023-08-01 17:01:40.913 +07 client backend[296611] pg_regress/plpgsql HINT:  Make sure the query returns the exact list of columns.
2023-08-01 17:01:40.913 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function inline_code_block line 6 at SQL statement
2023-08-01 17:01:40.913 +07 client backend[296611] pg_regress/plpgsql WARNING:  number of source and target fields in assignment does not match
2023-08-01 17:01:40.913 +07 client backend[296611] pg_regress/plpgsql DETAIL:  strict_multi_assignment check of extra_warnings is active.
2023-08-01 17:01:40.913 +07 client backend[296611] pg_regress/plpgsql HINT:  Make sure the query returns the exact list of columns.
2023-08-01 17:01:40.913 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function inline_code_block line 8 at SQL statement
2023-08-01 17:01:40.914 +07 client backend[296611] pg_regress/plpgsql ERROR:  number of source and target fields in assignment does not match
2023-08-01 17:01:40.914 +07 client backend[296611] pg_regress/plpgsql DETAIL:  strict_multi_assignment check of extra_errors is active.
2023-08-01 17:01:40.914 +07 client backend[296611] pg_regress/plpgsql HINT:  Make sure the query returns the exact list of columns.
2023-08-01 17:01:40.914 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function inline_code_block line 6 at SQL statement
2023-08-01 17:01:40.914 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  do $$
	declare
	  x int;
	  y int;
	begin
	  select 1 into x, y;
	  select 1,2 into x, y;
	  select 1,2,3 into x, y;
	end
	$$;
2023-08-01 17:01:40.915 +07 client backend[296625] pg_regress/alter_table ERROR:  column "a" of relation "attest" does not exist
2023-08-01 17:01:40.915 +07 client backend[296625] pg_regress/alter_table STATEMENT:  copy attest(a) to stdout;
2023-08-01 17:01:40.915 +07 client backend[296625] pg_regress/alter_table ERROR:  column "........pg.dropped.1........" of relation "attest" does not exist
2023-08-01 17:01:40.915 +07 client backend[296625] pg_regress/alter_table STATEMENT:  copy attest("........pg.dropped.1........") to stdout;
2023-08-01 17:01:40.915 +07 client backend[296625] pg_regress/alter_table ERROR:  extra data after last expected column
2023-08-01 17:01:40.915 +07 client backend[296625] pg_regress/alter_table CONTEXT:  COPY attest, line 1: "10	11	12"
2023-08-01 17:01:40.915 +07 client backend[296625] pg_regress/alter_table STATEMENT:  copy attest from stdin;
2023-08-01 17:01:40.916 +07 client backend[296625] pg_regress/alter_table ERROR:  column "a" of relation "attest" does not exist
2023-08-01 17:01:40.916 +07 client backend[296625] pg_regress/alter_table STATEMENT:  copy attest(a) from stdin;
2023-08-01 17:01:40.916 +07 client backend[296625] pg_regress/alter_table ERROR:  column "........pg.dropped.1........" of relation "attest" does not exist
2023-08-01 17:01:40.916 +07 client backend[296625] pg_regress/alter_table STATEMENT:  copy attest("........pg.dropped.1........") from stdin;
2023-08-01 17:01:40.916 +07 client backend[296611] pg_regress/plpgsql ERROR:  number of source and target fields in assignment does not match
2023-08-01 17:01:40.916 +07 client backend[296611] pg_regress/plpgsql DETAIL:  strict_multi_assignment check of extra_errors is active.
2023-08-01 17:01:40.916 +07 client backend[296611] pg_regress/plpgsql HINT:  Make sure the query returns the exact list of columns.
2023-08-01 17:01:40.916 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function inline_code_block line 8 at SQL statement
2023-08-01 17:01:40.916 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  do $$
	declare
	  x int;
	  y int;
	begin
	  select * from test_01 into x, y; -- should be ok
	  raise notice 'ok';
	  select * from test_01 into x;    -- should to fail
	end;
	$$;
2023-08-01 17:01:40.916 +07 client backend[296611] pg_regress/plpgsql ERROR:  number of source and target fields in assignment does not match
2023-08-01 17:01:40.916 +07 client backend[296611] pg_regress/plpgsql DETAIL:  strict_multi_assignment check of extra_errors is active.
2023-08-01 17:01:40.916 +07 client backend[296611] pg_regress/plpgsql HINT:  Make sure the query returns the exact list of columns.
2023-08-01 17:01:40.916 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function inline_code_block line 7 at SQL statement
2023-08-01 17:01:40.916 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  do $$
	declare
	  t test_01;
	begin
	  select 1, 2 into t;  -- should be ok
	  raise notice 'ok';
	  select 1, 2, 3 into t; -- should fail;
	end;
	$$;
2023-08-01 17:01:40.916 +07 client backend[296611] pg_regress/plpgsql ERROR:  number of source and target fields in assignment does not match
2023-08-01 17:01:40.916 +07 client backend[296611] pg_regress/plpgsql DETAIL:  strict_multi_assignment check of extra_errors is active.
2023-08-01 17:01:40.916 +07 client backend[296611] pg_regress/plpgsql HINT:  Make sure the query returns the exact list of columns.
2023-08-01 17:01:40.916 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function inline_code_block line 5 at SQL statement
2023-08-01 17:01:40.916 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  do $$
	declare
	  t test_01;
	begin
	  select 1 into t; -- should fail;
	end;
	$$;
2023-08-01 17:01:40.917 +07 client backend[296625] pg_regress/alter_table ERROR:  cannot drop inherited column "a"
2023-08-01 17:01:40.917 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table dropColumnchild drop column a;
2023-08-01 17:01:40.917 +07 client backend[296625] pg_regress/alter_table ERROR:  cannot drop inherited column "b"
2023-08-01 17:01:40.917 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table only dropColumnChild drop column b;
2023-08-01 17:01:40.919 +07 client backend[296611] pg_regress/plpgsql ERROR:  cursor can only scan forward
2023-08-01 17:01:40.919 +07 client backend[296611] pg_regress/plpgsql HINT:  Declare it with SCROLL option to enable backward scan.
2023-08-01 17:01:40.919 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function sc_test() line 7 at FETCH
2023-08-01 17:01:40.919 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select * from sc_test();
2023-08-01 17:01:40.919 +07 client backend[296625] pg_regress/alter_table ERROR:  cannot rename inherited column "a"
2023-08-01 17:01:40.919 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table renameColumnChild rename column a to d;
2023-08-01 17:01:40.919 +07 client backend[296625] pg_regress/alter_table ERROR:  inherited column "a" must be renamed in child tables too
2023-08-01 17:01:40.919 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table only renameColumnChild rename column a to d;
2023-08-01 17:01:40.919 +07 client backend[296625] pg_regress/alter_table ERROR:  inherited column "a" must be renamed in child tables too
2023-08-01 17:01:40.919 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table only renameColumn rename column a to d;
2023-08-01 17:01:40.920 +07 client backend[296625] pg_regress/alter_table ERROR:  column must be added to child tables too
2023-08-01 17:01:40.920 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table only renameColumn add column x int;
2023-08-01 17:01:40.920 +07 client backend[296625] pg_regress/alter_table ERROR:  cannot drop inherited column "f1"
2023-08-01 17:01:40.920 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table c1 drop column f1;
2023-08-01 17:01:40.921 +07 client backend[296625] pg_regress/alter_table ERROR:  column "f1" does not exist at character 8
2023-08-01 17:01:40.921 +07 client backend[296625] pg_regress/alter_table HINT:  Perhaps you meant to reference the column "c1.f2".
2023-08-01 17:01:40.921 +07 client backend[296625] pg_regress/alter_table STATEMENT:  select f1 from c1;
2023-08-01 17:01:40.922 +07 client backend[296625] pg_regress/alter_table ERROR:  cannot drop inherited column "f1"
2023-08-01 17:01:40.922 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table c1 drop column f1;
2023-08-01 17:01:40.922 +07 client backend[296625] pg_regress/alter_table ERROR:  column "f1" does not exist at character 8
2023-08-01 17:01:40.922 +07 client backend[296625] pg_regress/alter_table HINT:  Perhaps you meant to reference the column "c1.f2".
2023-08-01 17:01:40.922 +07 client backend[296625] pg_regress/alter_table STATEMENT:  select f1 from c1;
2023-08-01 17:01:40.923 +07 client backend[296625] pg_regress/alter_table ERROR:  cannot drop inherited column "f1"
2023-08-01 17:01:40.923 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table c1 drop column f1;
2023-08-01 17:01:40.924 +07 client backend[296625] pg_regress/alter_table ERROR:  cannot drop inherited column "f1"
2023-08-01 17:01:40.924 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table c1 drop column f1;
2023-08-01 17:01:40.928 +07 client backend[296625] pg_regress/alter_table ERROR:  cannot drop inherited column "name"
2023-08-01 17:01:40.928 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table gc1 drop column name;
2023-08-01 17:01:40.929 +07 client backend[296625] pg_regress/alter_table ERROR:  column "name" of relation "gc1" does not exist
2023-08-01 17:01:40.929 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table gc1 drop column name;
2023-08-01 17:01:40.929 +07 client backend[296625] pg_regress/alter_table ERROR:  column "non_existing" of relation "dropcolumnexists" does not exist
2023-08-01 17:01:40.929 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table dropColumnExists drop column non_existing;
2023-08-01 17:01:40.935 +07 client backend[296625] pg_regress/alter_table ERROR:  new row for relation "c1" violates check constraint "p1_a1_check"
2023-08-01 17:01:40.935 +07 client backend[296625] pg_regress/alter_table DETAIL:  Failing row contains (11, xyz, 33, 0).
2023-08-01 17:01:40.935 +07 client backend[296625] pg_regress/alter_table STATEMENT:  insert into c1 values(11,'xyz',33,0);
2023-08-01 17:01:40.936 +07 client backend[296611] pg_regress/plpgsql ERROR:  cursor FOR loop must use a bound cursor variable at character 98
2023-08-01 17:01:40.936 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  create or replace function forc_bad() returns void as $$
	declare
	  c refcursor;
	begin
	  for r in c loop
	    raise notice '%', r.i;
	  end loop;
	end;
	$$ language plpgsql;
2023-08-01 17:01:40.939 +07 client backend[296625] pg_regress/alter_table ERROR:  column "f1" cannot be cast automatically to type integer
2023-08-01 17:01:40.939 +07 client backend[296625] pg_regress/alter_table HINT:  You might need to specify "USING f1::integer".
2023-08-01 17:01:40.939 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table foo alter f1 TYPE integer;
2023-08-01 17:01:40.941 +07 client backend[296625] pg_regress/alter_table ERROR:  column "atcol1" cannot be cast automatically to type boolean
2023-08-01 17:01:40.941 +07 client backend[296625] pg_regress/alter_table HINT:  You might need to specify "USING atcol1::boolean".
2023-08-01 17:01:40.941 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table anothertab alter column atcol1 type boolean;
2023-08-01 17:01:40.941 +07 client backend[296625] pg_regress/alter_table ERROR:  result of USING clause for column "atcol1" cannot be cast automatically to type boolean
2023-08-01 17:01:40.941 +07 client backend[296625] pg_regress/alter_table HINT:  You might need to add an explicit cast.
2023-08-01 17:01:40.941 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table anothertab alter column atcol1 type boolean using atcol1::int;
2023-08-01 17:01:40.942 +07 client backend[296625] pg_regress/alter_table ERROR:  new row for relation "anothertab" violates check constraint "anothertab_chk"
2023-08-01 17:01:40.942 +07 client backend[296625] pg_regress/alter_table DETAIL:  Failing row contains (45, null).
2023-08-01 17:01:40.942 +07 client backend[296625] pg_regress/alter_table STATEMENT:  insert into anothertab (atcol1, atcol2) values (45, null);
2023-08-01 17:01:40.944 +07 client backend[296625] pg_regress/alter_table ERROR:  default for column "atcol1" cannot be cast automatically to type boolean
2023-08-01 17:01:40.944 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table anothertab alter column atcol1 type boolean
	        using case when atcol1 % 2 = 0 then true else false end;
2023-08-01 17:01:40.945 +07 client backend[296625] pg_regress/alter_table ERROR:  operator does not exist: boolean <= integer
2023-08-01 17:01:40.945 +07 client backend[296625] pg_regress/alter_table HINT:  No operator matches the given name and argument types. You might need to add explicit type casts.
2023-08-01 17:01:40.945 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table anothertab alter column atcol1 type boolean
	        using case when atcol1 % 2 = 0 then true else false end;
2023-08-01 17:01:40.945 +07 client backend[296625] pg_regress/alter_table ERROR:  constraint "anothertab_chk" of relation "anothertab" does not exist
2023-08-01 17:01:40.945 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table anothertab drop constraint anothertab_chk;
2023-08-01 17:01:40.946 +07 client backend[296611] pg_regress/plpgsql ERROR:  returned record type does not match expected record type
2023-08-01 17:01:40.946 +07 client backend[296611] pg_regress/plpgsql DETAIL:  Returned type unknown does not match expected type character varying in column 2.
2023-08-01 17:01:40.946 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function compos() while casting return value to function's return type
2023-08-01 17:01:40.946 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select compos();
2023-08-01 17:01:40.951 +07 client backend[296611] pg_regress/plpgsql ERROR:  cannot return non-composite value from function returning composite type
2023-08-01 17:01:40.951 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function compos() line 3 at RETURN
2023-08-01 17:01:40.951 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select compos();
2023-08-01 17:01:40.952 +07 client backend[296611] pg_regress/plpgsql ERROR:  cannot return non-composite value from function returning composite type
2023-08-01 17:01:40.952 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function compos() line 4 at RETURN
2023-08-01 17:01:40.952 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select * from compos();
2023-08-01 17:01:40.953 +07 client backend[296611] pg_regress/plpgsql ERROR:  invalid input syntax for type integer: "(1,hello)"
2023-08-01 17:01:40.953 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function compos() while casting return value to function's return type
2023-08-01 17:01:40.953 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select compos();
2023-08-01 17:01:40.953 +07 client backend[296611] pg_regress/plpgsql ERROR:  invalid input syntax for type integer: "(1,hello)"
2023-08-01 17:01:40.953 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function compos() while casting return value to function's return type
2023-08-01 17:01:40.953 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select compos();
2023-08-01 17:01:40.955 +07 client backend[296611] pg_regress/plpgsql ERROR:  1 2 3
2023-08-01 17:01:40.955 +07 client backend[296611] pg_regress/plpgsql DETAIL:  some detail info
2023-08-01 17:01:40.955 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function raise_test() line 5 at RAISE
2023-08-01 17:01:40.955 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select raise_test();
2023-08-01 17:01:40.955 +07 client backend[296611] pg_regress/plpgsql ERROR:  check me
2023-08-01 17:01:40.955 +07 client backend[296611] pg_regress/plpgsql DETAIL:  some detail info
2023-08-01 17:01:40.955 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function raise_test() line 3 at RAISE
2023-08-01 17:01:40.955 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select raise_test();
2023-08-01 17:01:40.956 +07 client backend[296611] pg_regress/plpgsql ERROR:  check me
2023-08-01 17:01:40.956 +07 client backend[296611] pg_regress/plpgsql DETAIL:  some detail info
2023-08-01 17:01:40.956 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function raise_test() line 3 at RAISE
2023-08-01 17:01:40.956 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select raise_test();
2023-08-01 17:01:40.957 +07 client backend[296611] pg_regress/plpgsql ERROR:  check me
2023-08-01 17:01:40.957 +07 client backend[296611] pg_regress/plpgsql DETAIL:  some detail info
2023-08-01 17:01:40.957 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function raise_test() line 3 at RAISE
2023-08-01 17:01:40.957 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select raise_test();
2023-08-01 17:01:40.957 +07 client backend[296611] pg_regress/plpgsql ERROR:  division_by_zero
2023-08-01 17:01:40.957 +07 client backend[296611] pg_regress/plpgsql DETAIL:  some detail info
2023-08-01 17:01:40.957 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function raise_test() line 3 at RAISE
2023-08-01 17:01:40.957 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select raise_test();
2023-08-01 17:01:40.958 +07 client backend[296611] pg_regress/plpgsql ERROR:  division_by_zero
2023-08-01 17:01:40.958 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function raise_test() line 3 at RAISE
2023-08-01 17:01:40.958 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select raise_test();
2023-08-01 17:01:40.958 +07 client backend[296611] pg_regress/plpgsql ERROR:  1234F
2023-08-01 17:01:40.958 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function raise_test() line 3 at RAISE
2023-08-01 17:01:40.958 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select raise_test();
2023-08-01 17:01:40.959 +07 client backend[296611] pg_regress/plpgsql ERROR:  custom message
2023-08-01 17:01:40.959 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function raise_test() line 3 at RAISE
2023-08-01 17:01:40.959 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select raise_test();
2023-08-01 17:01:40.959 +07 client backend[296611] pg_regress/plpgsql ERROR:  custom message
2023-08-01 17:01:40.959 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function raise_test() line 3 at RAISE
2023-08-01 17:01:40.959 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select raise_test();
2023-08-01 17:01:40.960 +07 client backend[296611] pg_regress/plpgsql ERROR:  RAISE option already specified: MESSAGE
2023-08-01 17:01:40.960 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function raise_test() line 3 at RAISE
2023-08-01 17:01:40.960 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select raise_test();
2023-08-01 17:01:40.961 +07 client backend[296611] pg_regress/plpgsql ERROR:  RAISE option already specified: ERRCODE
2023-08-01 17:01:40.961 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function raise_test() line 3 at RAISE
2023-08-01 17:01:40.961 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select raise_test();
2023-08-01 17:01:40.961 +07 client backend[296611] pg_regress/plpgsql ERROR:  RAISE without parameters cannot be used outside an exception handler
2023-08-01 17:01:40.961 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function raise_test() line 3 at RAISE
2023-08-01 17:01:40.961 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select raise_test();
2023-08-01 17:01:40.965 +07 client backend[296611] pg_regress/plpgsql ERROR:  GET STACKED DIAGNOSTICS cannot be used outside an exception handler
2023-08-01 17:01:40.965 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function stacked_diagnostics_test() line 6 at GET STACKED DIAGNOSTICS
2023-08-01 17:01:40.965 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select stacked_diagnostics_test();
2023-08-01 17:01:40.966 +07 client backend[296611] pg_regress/plpgsql ERROR:  substitute message
2023-08-01 17:01:40.966 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function raise_test() line 7 at RAISE
2023-08-01 17:01:40.966 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select raise_test();
2023-08-01 17:01:40.970 +07 client backend[296625] pg_regress/alter_table ERROR:  cannot alter table "tab1" because column "tab2.y" uses its row type
2023-08-01 17:01:40.970 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table tab1 alter column b type varchar;
2023-08-01 17:01:40.989 +07 client backend[296611] pg_regress/plpgsql ERROR:  schema "nonexistent" does not exist
2023-08-01 17:01:40.989 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  SQL function "error1" statement 1
	PL/pgSQL function error2(text) line 3 at RETURN
2023-08-01 17:01:40.989 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select error2('nonexistent.stuffs');
2023-08-01 17:01:40.996 +07 client backend[296611] pg_regress/plpgsql ERROR:  invalid input syntax for type date: "-1"
2023-08-01 17:01:40.996 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  SQL function "sql_to_date" statement 1
	PL/pgSQL function cast_invoker(integer) while casting return value to function's return type
2023-08-01 17:01:40.996 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select cast_invoker(-1);
2023-08-01 17:01:40.998 +07 client backend[296625] pg_regress/alter_table ERROR:  composite type recur1 cannot be made a member of itself
2023-08-01 17:01:40.998 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table recur1 add column f2 recur1;
2023-08-01 17:01:40.998 +07 client backend[296625] pg_regress/alter_table ERROR:  composite type recur1 cannot be made a member of itself
2023-08-01 17:01:40.998 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table recur1 add column f2 recur1[];
2023-08-01 17:01:40.999 +07 client backend[296625] pg_regress/alter_table ERROR:  composite type recur1 cannot be made a member of itself
2023-08-01 17:01:40.999 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table recur1 add column f2 array_of_recur1;
2023-08-01 17:01:40.999 +07 client backend[296625] pg_regress/alter_table ERROR:  composite type recur1 cannot be made a member of itself
2023-08-01 17:01:40.999 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table recur1 add column f2 recur2;
2023-08-01 17:01:41.000 +07 client backend[296625] pg_regress/alter_table ERROR:  composite type recur1 cannot be made a member of itself
2023-08-01 17:01:41.000 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table recur1 alter column f2 type recur2;
2023-08-01 17:01:41.001 +07 client backend[296611] pg_regress/plpgsql ERROR:  division by zero
2023-08-01 17:01:41.001 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  SQL statement "SELECT 1/0"
	PL/pgSQL function fail() line 3 at RETURN
2023-08-01 17:01:41.001 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select fail();
2023-08-01 17:01:41.001 +07 client backend[296611] pg_regress/plpgsql ERROR:  division by zero
2023-08-01 17:01:41.001 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  SQL statement "SELECT 1/0"
	PL/pgSQL function fail() line 3 at RETURN
2023-08-01 17:01:41.001 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select fail();
2023-08-01 17:01:41.002 +07 client backend[296611] pg_regress/plpgsql WARNING:  nonstandard use of \\ in a string literal at character 78
2023-08-01 17:01:41.002 +07 client backend[296611] pg_regress/plpgsql HINT:  Use the escape string syntax for backslashes, e.g., E'\\'.
2023-08-01 17:01:41.002 +07 client backend[296611] pg_regress/plpgsql WARNING:  nonstandard use of \\ in a string literal at character 106
2023-08-01 17:01:41.002 +07 client backend[296611] pg_regress/plpgsql HINT:  Use the escape string syntax for backslashes, e.g., E'\\'.
2023-08-01 17:01:41.002 +07 client backend[296611] pg_regress/plpgsql WARNING:  nonstandard use of \\ in a string literal at character 106
2023-08-01 17:01:41.002 +07 client backend[296611] pg_regress/plpgsql HINT:  Use the escape string syntax for backslashes, e.g., E'\\'.
2023-08-01 17:01:41.002 +07 client backend[296611] pg_regress/plpgsql WARNING:  nonstandard use of \\ in a string literal at character 8
2023-08-01 17:01:41.002 +07 client backend[296611] pg_regress/plpgsql HINT:  Use the escape string syntax for backslashes, e.g., E'\\'.
2023-08-01 17:01:41.002 +07 client backend[296611] pg_regress/plpgsql QUERY:  SELECT 'foo\\bar\041baz'
2023-08-01 17:01:41.002 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function strtest() line 4 at RETURN
2023-08-01 17:01:41.007 +07 client backend[296611] pg_regress/plpgsql ERROR:  RETURN cannot have a parameter in function returning void at character 36
2023-08-01 17:01:41.007 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  DO LANGUAGE plpgsql $$begin return 1; end$$;
2023-08-01 17:01:41.007 +07 client backend[296611] pg_regress/plpgsql ERROR:  column "foo" does not exist at character 33
2023-08-01 17:01:41.007 +07 client backend[296611] pg_regress/plpgsql QUERY:  SELECT rtrim(roomno) AS roomno, foo FROM Room ORDER BY roomno
2023-08-01 17:01:41.007 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function inline_code_block line 4 at FOR over SELECT rows
2023-08-01 17:01:41.007 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  DO $$
	DECLARE r record;
	BEGIN
	    FOR r IN SELECT rtrim(roomno) AS roomno, foo FROM Room ORDER BY roomno
	    LOOP
	        RAISE NOTICE '%, %', r.roomno, r.comment;
	    END LOOP;
	END$$;
2023-08-01 17:01:41.010 +07 client backend[296611] pg_regress/plpgsql ERROR:  column reference "q1" is ambiguous at character 8
2023-08-01 17:01:41.010 +07 client backend[296611] pg_regress/plpgsql DETAIL:  It could refer to either a PL/pgSQL variable or a table column.
2023-08-01 17:01:41.010 +07 client backend[296611] pg_regress/plpgsql QUERY:  select q1,q2 from int8_tbl
2023-08-01 17:01:41.010 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function conflict_test() line 5 at FOR over SELECT rows
2023-08-01 17:01:41.010 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select * from conflict_test();
2023-08-01 17:01:41.021 +07 client backend[296611] pg_regress/plpgsql ERROR:  FOREACH ... SLICE loop variable must be of an array type
2023-08-01 17:01:41.021 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function foreach_test(anyarray) line 4 at FOREACH over array
2023-08-01 17:01:41.021 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select foreach_test(ARRAY[1,2,3,4]);
2023-08-01 17:01:41.021 +07 client backend[296611] pg_regress/plpgsql ERROR:  FOREACH ... SLICE loop variable must be of an array type
2023-08-01 17:01:41.021 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function foreach_test(anyarray) line 4 at FOREACH over array
2023-08-01 17:01:41.021 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select foreach_test(ARRAY[[1,2],[3,4]]);
2023-08-01 17:01:41.024 +07 client backend[296611] pg_regress/plpgsql ERROR:  slice dimension (2) is out of the valid range 0..1
2023-08-01 17:01:41.024 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function foreach_test(anyarray) line 4 at FOREACH over array
2023-08-01 17:01:41.024 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select foreach_test(ARRAY[1,2,3,4]);
2023-08-01 17:01:41.037 +07 client backend[296625] pg_regress/alter_table ERROR:  cannot convert whole-row table reference
2023-08-01 17:01:41.037 +07 client backend[296625] pg_regress/alter_table DETAIL:  USING expression contains a whole-row table reference.
2023-08-01 17:01:41.037 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE test_type_diff2 ALTER COLUMN int_four TYPE int4 USING (pg_column_size(test_type_diff2));
2023-08-01 17:01:41.041 +07 client backend[296611] pg_regress/plpgsql ERROR:  value for domain orderedarray violates check constraint "sorted"
2023-08-01 17:01:41.041 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select '{2,1}'::orderedarray;
2023-08-01 17:01:41.042 +07 client backend[296611] pg_regress/plpgsql ERROR:  value for domain orderedarray violates check constraint "sorted"
2023-08-01 17:01:41.042 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function testoa(integer,integer,integer) line 4 at assignment
2023-08-01 17:01:41.042 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select testoa(2,1,3);
2023-08-01 17:01:41.043 +07 client backend[296611] pg_regress/plpgsql ERROR:  value for domain orderedarray violates check constraint "sorted"
2023-08-01 17:01:41.043 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function testoa(integer,integer,integer) line 5 at assignment
2023-08-01 17:01:41.043 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  select testoa(1,2,1);
2023-08-01 17:01:41.062 +07 client backend[296611] pg_regress/plpgsql ERROR:  assertion failed
2023-08-01 17:01:41.062 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function inline_code_block line 3 at ASSERT
2023-08-01 17:01:41.062 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  do $$
	begin
	  assert 1=0;  -- should fail
	end;
	$$;
2023-08-01 17:01:41.062 +07 client backend[296611] pg_regress/plpgsql ERROR:  assertion failed
2023-08-01 17:01:41.062 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function inline_code_block line 3 at ASSERT
2023-08-01 17:01:41.062 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  do $$
	begin
	  assert NULL;  -- should fail
	end;
	$$;
2023-08-01 17:01:41.062 +07 client backend[296625] pg_regress/alter_table ERROR:  type "lockmodes" does not exist
2023-08-01 17:01:41.062 +07 client backend[296625] pg_regress/alter_table STATEMENT:  drop type lockmodes;
2023-08-01 17:01:41.063 +07 client backend[296625] pg_regress/alter_table ERROR:  view "my_locks" does not exist
2023-08-01 17:01:41.063 +07 client backend[296625] pg_regress/alter_table STATEMENT:  drop view my_locks;
2023-08-01 17:01:41.064 +07 client backend[296611] pg_regress/plpgsql ERROR:  assertion failed, var = "some value"
2023-08-01 17:01:41.064 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function inline_code_block line 4 at ASSERT
2023-08-01 17:01:41.064 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  do $$
	declare var text := 'some value';
	begin
	  assert 1=0, format('assertion failed, var = "%s"', var);
	end;
	$$;
2023-08-01 17:01:41.064 +07 client backend[296611] pg_regress/plpgsql ERROR:  unhandled assertion
2023-08-01 17:01:41.064 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function inline_code_block line 3 at ASSERT
2023-08-01 17:01:41.064 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  do $$
	begin
	  assert 1=0, 'unhandled assertion';
	exception when others then
	  null; -- do nothing
	end;
	$$;
2023-08-01 17:01:41.066 +07 client backend[296611] pg_regress/plpgsql ERROR:  value for domain plpgsql_domain violates check constraint "plpgsql_domain_check"
2023-08-01 17:01:41.066 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function inline_code_block line 4 at assignment
2023-08-01 17:01:41.066 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  do $$
	declare v_test plpgsql_domain := 1;
	begin
	  v_test := 0;  -- fail
	end;
	$$;
2023-08-01 17:01:41.068 +07 client backend[296611] pg_regress/plpgsql ERROR:  value for domain plpgsql_arr_domain violates check constraint "plpgsql_arr_domain_check"
2023-08-01 17:01:41.068 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function inline_code_block line 4 at assignment
2023-08-01 17:01:41.068 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  do $$
	declare v_test plpgsql_arr_domain := array[1];
	begin
	  v_test := 0 || v_test;  -- fail
	end;
	$$;
2023-08-01 17:01:41.071 +07 client backend[296611] pg_regress/plpgsql ERROR:  OLD TABLE can only be specified for a DELETE or UPDATE trigger
2023-08-01 17:01:41.071 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  CREATE TRIGGER transition_table_base_ins_trig
	  AFTER INSERT ON transition_table_base
	  REFERENCING OLD TABLE AS oldtable NEW TABLE AS newtable
	  FOR EACH STATEMENT
	  EXECUTE PROCEDURE transition_table_base_ins_func();
2023-08-01 17:01:41.079 +07 client backend[296625] pg_regress/alter_table ERROR:  unrecognized parameter "autovacuum_enabled"
2023-08-01 17:01:41.079 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table my_locks set (autovacuum_enabled = false);
2023-08-01 17:01:41.079 +07 client backend[296625] pg_regress/alter_table ERROR:  unrecognized parameter "autovacuum_enabled"
2023-08-01 17:01:41.079 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter view my_locks set (autovacuum_enabled = false);
2023-08-01 17:01:41.094 +07 client backend[296625] pg_regress/alter_table ERROR:  relation "nosuchtype" does not exist
2023-08-01 17:01:41.094 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TYPE nosuchtype ADD ATTRIBUTE b text;
2023-08-01 17:01:41.095 +07 client backend[296625] pg_regress/alter_table ERROR:  column "b" of relation "test_type" already exists
2023-08-01 17:01:41.095 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TYPE test_type ADD ATTRIBUTE b text;
2023-08-01 17:01:41.098 +07 client backend[296625] pg_regress/alter_table ERROR:  column "c" of relation "test_type" does not exist
2023-08-01 17:01:41.098 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TYPE test_type DROP ATTRIBUTE c;
2023-08-01 17:01:41.099 +07 client backend[296625] pg_regress/alter_table ERROR:  column "a" does not exist
2023-08-01 17:01:41.099 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TYPE test_type RENAME ATTRIBUTE a TO aa;
2023-08-01 17:01:41.101 +07 client backend[296625] pg_regress/alter_table ERROR:  cannot alter type "test_type1" because column "test_tbl1.y" uses it
2023-08-01 17:01:41.101 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TYPE test_type1 ALTER ATTRIBUTE b TYPE varchar;
2023-08-01 17:01:41.106 +07 client backend[296625] pg_regress/alter_table ERROR:  cannot alter type "test_type2" because it is the type of a typed table
2023-08-01 17:01:41.106 +07 client backend[296625] pg_regress/alter_table HINT:  Use ALTER ... CASCADE to alter the typed tables too.
2023-08-01 17:01:41.106 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TYPE test_type2 ADD ATTRIBUTE c text;
2023-08-01 17:01:41.108 +07 client backend[296625] pg_regress/alter_table ERROR:  cannot alter type "test_type2" because it is the type of a typed table
2023-08-01 17:01:41.108 +07 client backend[296625] pg_regress/alter_table HINT:  Use ALTER ... CASCADE to alter the typed tables too.
2023-08-01 17:01:41.108 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TYPE test_type2 ALTER ATTRIBUTE b TYPE varchar;
2023-08-01 17:01:41.111 +07 client backend[296625] pg_regress/alter_table ERROR:  cannot alter type "test_type2" because it is the type of a typed table
2023-08-01 17:01:41.111 +07 client backend[296625] pg_regress/alter_table HINT:  Use ALTER ... CASCADE to alter the typed tables too.
2023-08-01 17:01:41.111 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TYPE test_type2 DROP ATTRIBUTE b;
2023-08-01 17:01:41.114 +07 client backend[296625] pg_regress/alter_table ERROR:  cannot alter type "test_type2" because it is the type of a typed table
2023-08-01 17:01:41.114 +07 client backend[296625] pg_regress/alter_table HINT:  Use ALTER ... CASCADE to alter the typed tables too.
2023-08-01 17:01:41.114 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TYPE test_type2 RENAME ATTRIBUTE a TO aa;
2023-08-01 17:01:41.121 +07 client backend[296625] pg_regress/alter_table ERROR:  cannot drop column a of composite type test_typex because other objects depend on it
2023-08-01 17:01:41.121 +07 client backend[296625] pg_regress/alter_table DETAIL:  constraint test_tblx_y_check on table test_tblx depends on column a of composite type test_typex
2023-08-01 17:01:41.121 +07 client backend[296625] pg_regress/alter_table HINT:  Use DROP ... CASCADE to drop the dependent objects too.
2023-08-01 17:01:41.121 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TYPE test_typex DROP ATTRIBUTE a;
2023-08-01 17:01:41.128 +07 client backend[296625] pg_regress/alter_table ERROR:  table "tt1" has different type for column "y"
2023-08-01 17:01:41.128 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE tt1 OF tt_t0;
2023-08-01 17:01:41.128 +07 client backend[296625] pg_regress/alter_table ERROR:  table "tt2" has different type for column "y"
2023-08-01 17:01:41.128 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE tt2 OF tt_t0;
2023-08-01 17:01:41.128 +07 client backend[296625] pg_regress/alter_table ERROR:  table has column "y" where type requires "x"
2023-08-01 17:01:41.128 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE tt3 OF tt_t0;
2023-08-01 17:01:41.129 +07 client backend[296625] pg_regress/alter_table ERROR:  table is missing column "y"
2023-08-01 17:01:41.129 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE tt4 OF tt_t0;
2023-08-01 17:01:41.129 +07 client backend[296625] pg_regress/alter_table ERROR:  table has extra column "z"
2023-08-01 17:01:41.129 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE tt5 OF tt_t0;
2023-08-01 17:01:41.129 +07 client backend[296625] pg_regress/alter_table ERROR:  typed tables cannot inherit
2023-08-01 17:01:41.129 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE tt6 OF tt_t0;
2023-08-01 17:01:41.133 +07 client backend[296625] pg_regress/alter_table ERROR:  new row for relation "test_drop_constr_child" violates check constraint "test_drop_constr_parent_c_check"
2023-08-01 17:01:41.133 +07 client backend[296625] pg_regress/alter_table DETAIL:  Failing row contains (null).
2023-08-01 17:01:41.133 +07 client backend[296625] pg_regress/alter_table STATEMENT:  INSERT INTO test_drop_constr_child (c) VALUES (NULL);
2023-08-01 17:01:41.140 +07 client backend[296625] pg_regress/alter_table ERROR:  constraint "foo" for relation "tt9" already exists
2023-08-01 17:01:41.140 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE tt9 ADD CONSTRAINT foo CHECK(c > 4);
2023-08-01 17:01:41.140 +07 client backend[296625] pg_regress/alter_table ERROR:  relation "tt9_c_key" already exists
2023-08-01 17:01:41.140 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE tt9 ADD CONSTRAINT tt9_c_key UNIQUE(c);
2023-08-01 17:01:41.141 +07 client backend[296625] pg_regress/alter_table ERROR:  constraint "foo" for relation "tt9" already exists
2023-08-01 17:01:41.141 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE tt9 ADD CONSTRAINT foo UNIQUE(c);
2023-08-01 17:01:41.141 +07 client backend[296625] pg_regress/alter_table ERROR:  constraint "tt9_c_key" for relation "tt9" already exists
2023-08-01 17:01:41.141 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE tt9 ADD CONSTRAINT tt9_c_key CHECK(c > 5);
2023-08-01 17:01:41.141 +07 client backend[296611] pg_regress/plpgsql ERROR:  relation "dx" cannot be the target of a modifying statement
2023-08-01 17:01:41.141 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  SQL statement "INSERT INTO dx VALUES (1000000, 1000000, 'x')"
	PL/pgSQL function transition_table_level2_bad_usage_func() line 3 at SQL statement
2023-08-01 17:01:41.141 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  DELETE FROM transition_table_level2
	  WHERE level2_no BETWEEN 301 AND 305;
2023-08-01 17:01:41.142 +07 client backend[296611] pg_regress/plpgsql ERROR:  RI error
2023-08-01 17:01:41.142 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function transition_table_level1_ri_parent_del_func() line 6 at RAISE
2023-08-01 17:01:41.142 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  DELETE FROM transition_table_level1
	  WHERE level1_no = 25;
2023-08-01 17:01:41.143 +07 client backend[296611] pg_regress/plpgsql ERROR:  RI error
2023-08-01 17:01:41.143 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function transition_table_level1_ri_parent_upd_func() line 15 at RAISE
2023-08-01 17:01:41.143 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  UPDATE transition_table_level1 SET level1_no = -1
	  WHERE level1_no = 30;
2023-08-01 17:01:41.143 +07 client backend[296611] pg_regress/plpgsql ERROR:  RI error
2023-08-01 17:01:41.143 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function transition_table_level2_ri_child_insupd_func() line 8 at RAISE
2023-08-01 17:01:41.143 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  INSERT INTO transition_table_level2 (level2_no, parent_no)
	  VALUES (10000, 10000);
2023-08-01 17:01:41.143 +07 client backend[296611] pg_regress/plpgsql ERROR:  RI error
2023-08-01 17:01:41.143 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function transition_table_level2_ri_child_insupd_func() line 8 at RAISE
2023-08-01 17:01:41.143 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  UPDATE transition_table_level2 SET parent_no = 2000
	  WHERE level2_no = 40;
2023-08-01 17:01:41.152 +07 client backend[296611] pg_regress/plpgsql ERROR:  TRUNCATE triggers with transition tables are not supported
2023-08-01 17:01:41.152 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  CREATE TRIGGER alter_table_under_transition_tables_upd_trigger
	  AFTER TRUNCATE OR UPDATE ON alter_table_under_transition_tables
	  REFERENCING OLD TABLE AS d NEW TABLE AS i
	  FOR EACH STATEMENT EXECUTE PROCEDURE
	    alter_table_under_transition_tables_upd_func();
2023-08-01 17:01:41.154 +07 client backend[296611] pg_regress/plpgsql WARNING:  old table = 1=1,2=2,3=3, new table = 1=11,2=22,3=33
2023-08-01 17:01:41.154 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function alter_table_under_transition_tables_upd_func() line 3 at RAISE
2023-08-01 17:01:41.157 +07 client backend[296611] pg_regress/plpgsql WARNING:  old table = 1=11,2=22,3=33, new table = 1=1111,2=2222,3=3333
2023-08-01 17:01:41.157 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function alter_table_under_transition_tables_upd_func() line 3 at RAISE
2023-08-01 17:01:41.158 +07 client backend[296625] pg_regress/alter_table ERROR:  foreign key constraint "comment_test_child_fk" cannot be implemented
2023-08-01 17:01:41.158 +07 client backend[296625] pg_regress/alter_table DETAIL:  Key columns "id" and "id" are of incompatible types: text and integer.
2023-08-01 17:01:41.158 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE comment_test ALTER COLUMN id SET DATA TYPE int USING id::integer;
2023-08-01 17:01:41.159 +07 client backend[296611] pg_regress/plpgsql ERROR:  column "name" does not exist at character 40
2023-08-01 17:01:41.159 +07 client backend[296611] pg_regress/plpgsql QUERY:  SELECT (SELECT string_agg(id || '=' || name, ',') FROM d)
2023-08-01 17:01:41.159 +07 client backend[296611] pg_regress/plpgsql CONTEXT:  PL/pgSQL function alter_table_under_transition_tables_upd_func() line 3 at RAISE
2023-08-01 17:01:41.159 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  UPDATE alter_table_under_transition_tables
	  SET id = id;
2023-08-01 17:01:41.167 +07 client backend[296625] pg_regress/alter_table ERROR:  permission denied to create "pg_catalog.new_system_table"
2023-08-01 17:01:41.167 +07 client backend[296625] pg_regress/alter_table DETAIL:  System catalog modifications are currently disallowed.
2023-08-01 17:01:41.167 +07 client backend[296625] pg_regress/alter_table STATEMENT:  CREATE TABLE pg_catalog.new_system_table();
2023-08-01 17:01:41.171 +07 client backend[296611] pg_regress/plpgsql ERROR:  "x" is not a scalar variable at character 72
2023-08-01 17:01:41.171 +07 client backend[296611] pg_regress/plpgsql STATEMENT:  CREATE FUNCTION fx(x WSlot) RETURNS void AS $$
	BEGIN
	  GET DIAGNOSTICS x = ROW_COUNT;
	  RETURN;
	END; $$ LANGUAGE plpgsql;
2023-08-01 17:01:41.179 +07 client backend[296625] pg_regress/alter_table ERROR:  could not change table "unlogged2" to logged because it references unlogged table "unlogged1"
2023-08-01 17:01:41.179 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE unlogged2 SET LOGGED;
2023-08-01 17:01:41.189 +07 client backend[296625] pg_regress/alter_table ERROR:  could not change table "logged1" to unlogged because it references logged table "logged2"
2023-08-01 17:01:41.189 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE logged1 SET UNLOGGED;
2023-08-01 17:01:41.200 +07 client backend[296625] pg_regress/alter_table ERROR:  column "c2" of relation "test_add_column" already exists
2023-08-01 17:01:41.200 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE test_add_column
		ADD COLUMN c2 integer;
2023-08-01 17:01:41.200 +07 client backend[296625] pg_regress/alter_table ERROR:  column "c2" of relation "test_add_column" already exists
2023-08-01 17:01:41.200 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE ONLY test_add_column
		ADD COLUMN c2 integer;
2023-08-01 17:01:41.203 +07 client backend[296625] pg_regress/alter_table ERROR:  column "c2" of relation "test_add_column" already exists
2023-08-01 17:01:41.203 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE test_add_column
		ADD COLUMN c2 integer, 
		ADD COLUMN c3 integer primary key;
2023-08-01 17:01:41.245 +07 client backend[296625] pg_regress/alter_table ERROR:  exclusion constraints are not supported on partitioned tables at character 29
2023-08-01 17:01:41.245 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE partitioned ADD EXCLUDE USING gist (a WITH &&);
2023-08-01 17:01:41.245 +07 client backend[296625] pg_regress/alter_table ERROR:  cannot drop column "a" because it is part of the partition key of relation "partitioned"
2023-08-01 17:01:41.245 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE partitioned DROP COLUMN a;
2023-08-01 17:01:41.245 +07 client backend[296625] pg_regress/alter_table ERROR:  cannot alter column "a" because it is part of the partition key of relation "partitioned"
2023-08-01 17:01:41.245 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE partitioned ALTER COLUMN a TYPE char(5);
2023-08-01 17:01:41.245 +07 client backend[296625] pg_regress/alter_table ERROR:  cannot drop column "b" because it is part of the partition key of relation "partitioned"
2023-08-01 17:01:41.245 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE partitioned DROP COLUMN b;
2023-08-01 17:01:41.245 +07 client backend[296625] pg_regress/alter_table ERROR:  cannot alter column "b" because it is part of the partition key of relation "partitioned"
2023-08-01 17:01:41.245 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE partitioned ALTER COLUMN b TYPE char(5);
2023-08-01 17:01:41.245 +07 client backend[296625] pg_regress/alter_table ERROR:  cannot change inheritance of partitioned table
2023-08-01 17:01:41.245 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE partitioned INHERIT nonpartitioned;
2023-08-01 17:01:41.246 +07 client backend[296625] pg_regress/alter_table ERROR:  cannot inherit from partitioned table "partitioned"
2023-08-01 17:01:41.246 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE nonpartitioned INHERIT partitioned;
2023-08-01 17:01:41.246 +07 client backend[296625] pg_regress/alter_table ERROR:  cannot add NO INHERIT constraint to partitioned table "partitioned"
2023-08-01 17:01:41.246 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE partitioned ADD CONSTRAINT chk_a CHECK (a > 0) NO INHERIT;
2023-08-01 17:01:41.247 +07 client backend[296625] pg_regress/alter_table ERROR:  table "unparted" is not partitioned
2023-08-01 17:01:41.247 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE unparted ATTACH PARTITION fail_part FOR VALUES IN ('a');
2023-08-01 17:01:41.248 +07 client backend[296625] pg_regress/alter_table ERROR:  invalid bound specification for a list partition at character 63
2023-08-01 17:01:41.248 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES FROM (1) TO (10);
2023-08-01 17:01:41.248 +07 client backend[296625] pg_regress/alter_table ERROR:  relation "nonexistent" does not exist
2023-08-01 17:01:41.248 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE list_parted ATTACH PARTITION nonexistent FOR VALUES IN (1);
2023-08-01 17:01:41.249 +07 client backend[296625] pg_regress/alter_table ERROR:  must be owner of table not_owned_by_me
2023-08-01 17:01:41.249 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE owned_by_me ATTACH PARTITION not_owned_by_me FOR VALUES IN (1);
2023-08-01 17:01:41.251 +07 client backend[296625] pg_regress/alter_table ERROR:  cannot attach inheritance child as partition
2023-08-01 17:01:41.251 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE list_parted ATTACH PARTITION child FOR VALUES IN (1);
2023-08-01 17:01:41.251 +07 client backend[296625] pg_regress/alter_table ERROR:  cannot attach inheritance parent as partition
2023-08-01 17:01:41.251 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE list_parted ATTACH PARTITION parent FOR VALUES IN (1);
2023-08-01 17:01:41.252 +07 client backend[296625] pg_regress/alter_table ERROR:  cannot attach a permanent relation as partition of temporary relation "temp_parted"
2023-08-01 17:01:41.252 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE temp_parted ATTACH PARTITION perm_part FOR VALUES IN (1);
2023-08-01 17:01:41.253 +07 client backend[296625] pg_regress/alter_table ERROR:  cannot attach a typed table as partition
2023-08-01 17:01:41.253 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
2023-08-01 17:01:41.254 +07 client backend[296625] pg_regress/alter_table ERROR:  table "fail_part" contains column "c" not found in parent "list_parted"
2023-08-01 17:01:41.254 +07 client backend[296625] pg_regress/alter_table DETAIL:  The new partition may contain only the columns present in parent.
2023-08-01 17:01:41.254 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
2023-08-01 17:01:41.254 +07 client backend[296625] pg_regress/alter_table ERROR:  child table is missing column "b"
2023-08-01 17:01:41.254 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
2023-08-01 17:01:41.255 +07 client backend[296625] pg_regress/alter_table ERROR:  child table "fail_part" has different type for column "b"
2023-08-01 17:01:41.255 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
2023-08-01 17:01:41.256 +07 client backend[296625] pg_regress/alter_table ERROR:  child table "fail_part" has different collation for column "b"
2023-08-01 17:01:41.256 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
2023-08-01 17:01:41.256 +07 client backend[296625] pg_regress/alter_table ERROR:  child table is missing constraint "check_a"
2023-08-01 17:01:41.256 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
2023-08-01 17:01:41.257 +07 client backend[296625] pg_regress/alter_table ERROR:  child table "fail_part" has different definition for check constraint "check_a"
2023-08-01 17:01:41.257 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
2023-08-01 17:01:41.258 +07 client backend[296625] pg_regress/alter_table ERROR:  partition "fail_part" would overlap partition "part_1"
2023-08-01 17:01:41.258 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
2023-08-01 17:01:41.260 +07 client backend[296625] pg_regress/alter_table ERROR:  partition "fail_def_part" conflicts with existing default partition "def_part"
2023-08-01 17:01:41.260 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE list_parted ATTACH PARTITION fail_def_part DEFAULT;
2023-08-01 17:01:41.261 +07 client backend[296625] pg_regress/alter_table ERROR:  partition constraint of relation "part_2" is violated by some row
2023-08-01 17:01:41.261 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE list_parted2 ATTACH PARTITION part_2 FOR VALUES IN (2);
2023-08-01 17:01:41.263 +07 client backend[296625] pg_regress/alter_table ERROR:  updated partition constraint for default partition "list_parted2_def" would be violated by some row
2023-08-01 17:01:41.263 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE list_parted2 ATTACH PARTITION part_3 FOR VALUES IN (11);
2023-08-01 17:01:41.266 +07 client backend[296625] pg_regress/alter_table ERROR:  partition constraint of relation "part1" is violated by some row
2023-08-01 17:01:41.266 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE range_parted ATTACH PARTITION part1 FOR VALUES FROM (1, 1) TO (1, 10);
2023-08-01 17:01:41.269 +07 client backend[296625] pg_regress/alter_table ERROR:  partition "partr_def2" conflicts with existing default partition "partr_def1"
2023-08-01 17:01:41.269 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE range_parted ATTACH PARTITION partr_def2 DEFAULT;
2023-08-01 17:01:41.269 +07 client backend[296625] pg_regress/alter_table ERROR:  updated partition constraint for default partition "partr_def1" would be violated by some row
2023-08-01 17:01:41.269 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE range_parted ATTACH partition part3 FOR VALUES FROM (2, 10) TO (2, 20);
2023-08-01 17:01:41.271 +07 client backend[296625] pg_regress/alter_table ERROR:  partition constraint of relation "part_5_a" is violated by some row
2023-08-01 17:01:41.271 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE list_parted2 ATTACH PARTITION part_5 FOR VALUES IN (5);
2023-08-01 17:01:41.277 +07 client backend[296625] pg_regress/alter_table ERROR:  partition constraint of relation "part_7_a_null" is violated by some row
2023-08-01 17:01:41.277 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE list_parted2 ATTACH PARTITION part_7 FOR VALUES IN (7);
2023-08-01 17:01:41.279 +07 client backend[296625] pg_regress/alter_table ERROR:  updated partition constraint for default partition "part5_def_p1" would be violated by some row
2023-08-01 17:01:41.279 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE part_5 ATTACH PARTITION part5_p1 FOR VALUES IN ('y');
2023-08-01 17:01:41.280 +07 client backend[296625] pg_regress/alter_table ERROR:  "part_2" is already a partition
2023-08-01 17:01:41.280 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE list_parted2 ATTACH PARTITION part_2 FOR VALUES IN (2);
2023-08-01 17:01:41.280 +07 client backend[296625] pg_regress/alter_table ERROR:  circular inheritance not allowed
2023-08-01 17:01:41.280 +07 client backend[296625] pg_regress/alter_table DETAIL:  "part_5" is already a child of "list_parted2".
2023-08-01 17:01:41.280 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE part_5 ATTACH PARTITION list_parted2 FOR VALUES IN ('b');
2023-08-01 17:01:41.280 +07 client backend[296625] pg_regress/alter_table ERROR:  circular inheritance not allowed
2023-08-01 17:01:41.280 +07 client backend[296625] pg_regress/alter_table DETAIL:  "list_parted2" is already a child of "list_parted2".
2023-08-01 17:01:41.280 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE list_parted2 ATTACH PARTITION list_parted2 FOR VALUES IN (0);
2023-08-01 17:01:41.291 +07 client backend[296625] pg_regress/alter_table ERROR:  partition "fail_part" would overlap partition "hpart_1"
2023-08-01 17:01:41.291 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE hash_parted ATTACH PARTITION fail_part FOR VALUES WITH (MODULUS 8, REMAINDER 4);
2023-08-01 17:01:41.291 +07 client backend[296625] pg_regress/alter_table ERROR:  partition "fail_part" would overlap partition "hpart_1"
2023-08-01 17:01:41.291 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE hash_parted ATTACH PARTITION fail_part FOR VALUES WITH (MODULUS 8, REMAINDER 0);
2023-08-01 17:01:41.292 +07 client backend[296625] pg_regress/alter_table ERROR:  partition constraint of relation "hpart_2" is violated by some row
2023-08-01 17:01:41.292 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE hash_parted ATTACH PARTITION hpart_2 FOR VALUES WITH (MODULUS 4, REMAINDER 1);
2023-08-01 17:01:41.294 +07 client backend[296625] pg_regress/alter_table ERROR:  partition constraint of relation "hpart_5_a" is violated by some row
2023-08-01 17:01:41.294 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE hash_parted ATTACH PARTITION hpart_5 FOR VALUES WITH (MODULUS 4, REMAINDER 2);
2023-08-01 17:01:41.295 +07 client backend[296625] pg_regress/alter_table ERROR:  modulus for hash partition must be a positive integer
2023-08-01 17:01:41.295 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE hash_parted ATTACH PARTITION fail_part FOR VALUES WITH (MODULUS 0, REMAINDER 1);
2023-08-01 17:01:41.295 +07 client backend[296625] pg_regress/alter_table ERROR:  remainder for hash partition must be less than modulus
2023-08-01 17:01:41.295 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE hash_parted ATTACH PARTITION fail_part FOR VALUES WITH (MODULUS 8, REMAINDER 8);
2023-08-01 17:01:41.295 +07 client backend[296625] pg_regress/alter_table ERROR:  every hash partition modulus must be a factor of the next larger modulus
2023-08-01 17:01:41.295 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE hash_parted ATTACH PARTITION fail_part FOR VALUES WITH (MODULUS 3, REMAINDER 2);
2023-08-01 17:01:41.296 +07 client backend[296625] pg_regress/alter_table ERROR:  table "regular_table" is not partitioned
2023-08-01 17:01:41.296 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE regular_table DETACH PARTITION any_name;
2023-08-01 17:01:41.296 +07 client backend[296625] pg_regress/alter_table ERROR:  relation "part_4" does not exist
2023-08-01 17:01:41.296 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE list_parted2 DETACH PARTITION part_4;
2023-08-01 17:01:41.296 +07 client backend[296625] pg_regress/alter_table ERROR:  relation "hpart_4" does not exist
2023-08-01 17:01:41.296 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE hash_parted DETACH PARTITION hpart_4;
2023-08-01 17:01:41.297 +07 client backend[296625] pg_regress/alter_table ERROR:  relation "not_a_part" is not a partition of relation "list_parted2"
2023-08-01 17:01:41.297 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE list_parted2 DETACH PARTITION not_a_part;
2023-08-01 17:01:41.297 +07 client backend[296625] pg_regress/alter_table ERROR:  relation "part_1" is not a partition of relation "list_parted2"
2023-08-01 17:01:41.297 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE list_parted2 DETACH PARTITION part_1;
2023-08-01 17:01:41.297 +07 client backend[296625] pg_regress/alter_table ERROR:  relation "not_a_part" is not a partition of relation "hash_parted"
2023-08-01 17:01:41.297 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE hash_parted DETACH PARTITION not_a_part;
2023-08-01 17:01:41.300 +07 client backend[296625] pg_regress/alter_table ERROR:  column must be added to child tables too
2023-08-01 17:01:41.300 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE ONLY list_parted2 ADD COLUMN c int;
2023-08-01 17:01:41.300 +07 client backend[296625] pg_regress/alter_table ERROR:  cannot drop column from only the partitioned table when partitions exist
2023-08-01 17:01:41.300 +07 client backend[296625] pg_regress/alter_table HINT:  Do not specify the ONLY keyword.
2023-08-01 17:01:41.300 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE ONLY list_parted2 DROP COLUMN b;
2023-08-01 17:01:41.300 +07 client backend[296625] pg_regress/alter_table ERROR:  cannot add column to a partition
2023-08-01 17:01:41.300 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE part_2 ADD COLUMN c text;
2023-08-01 17:01:41.300 +07 client backend[296625] pg_regress/alter_table ERROR:  cannot drop inherited column "b"
2023-08-01 17:01:41.300 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE part_2 DROP COLUMN b;
2023-08-01 17:01:41.301 +07 client backend[296625] pg_regress/alter_table ERROR:  cannot rename inherited column "b"
2023-08-01 17:01:41.301 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE part_2 RENAME COLUMN b to c;
2023-08-01 17:01:41.301 +07 client backend[296625] pg_regress/alter_table ERROR:  cannot alter inherited column "b"
2023-08-01 17:01:41.301 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE part_2 ALTER COLUMN b TYPE text;
2023-08-01 17:01:41.301 +07 client backend[296625] pg_regress/alter_table ERROR:  constraint must be added to child tables too
2023-08-01 17:01:41.301 +07 client backend[296625] pg_regress/alter_table DETAIL:  Column "b" of relation "part_2" is not already NOT NULL.
2023-08-01 17:01:41.301 +07 client backend[296625] pg_regress/alter_table HINT:  Do not specify the ONLY keyword.
2023-08-01 17:01:41.301 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE ONLY list_parted2 ALTER b SET NOT NULL;
2023-08-01 17:01:41.301 +07 client backend[296625] pg_regress/alter_table ERROR:  constraint must be added to child tables too
2023-08-01 17:01:41.301 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE ONLY list_parted2 ADD CONSTRAINT check_b CHECK (b <> 'zz');
2023-08-01 17:01:41.302 +07 client backend[296625] pg_regress/alter_table ERROR:  cannot remove constraint from only the partitioned table when partitions exist
2023-08-01 17:01:41.302 +07 client backend[296625] pg_regress/alter_table HINT:  Do not specify the ONLY keyword.
2023-08-01 17:01:41.302 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE ONLY list_parted2 ALTER b DROP NOT NULL;
2023-08-01 17:01:41.303 +07 client backend[296625] pg_regress/alter_table ERROR:  cannot remove constraint from only the partitioned table when partitions exist
2023-08-01 17:01:41.303 +07 client backend[296625] pg_regress/alter_table HINT:  Do not specify the ONLY keyword.
2023-08-01 17:01:41.303 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE ONLY list_parted2 DROP CONSTRAINT check_b;
2023-08-01 17:01:41.306 +07 client backend[296625] pg_regress/alter_table ERROR:  column "b" is marked NOT NULL in parent table
2023-08-01 17:01:41.306 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE part_2 ALTER b DROP NOT NULL;
2023-08-01 17:01:41.306 +07 client backend[296625] pg_regress/alter_table ERROR:  cannot drop inherited constraint "check_a2" of relation "part_2"
2023-08-01 17:01:41.306 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE part_2 DROP CONSTRAINT check_a2;
2023-08-01 17:01:41.306 +07 client backend[296625] pg_regress/alter_table ERROR:  cannot add NO INHERIT constraint to partitioned table "list_parted2"
2023-08-01 17:01:41.306 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE list_parted2 add constraint check_b2 check (b <> 'zz') NO INHERIT;
2023-08-01 17:01:41.306 +07 client backend[296625] pg_regress/alter_table ERROR:  cannot inherit from partition "part_2"
2023-08-01 17:01:41.306 +07 client backend[296625] pg_regress/alter_table STATEMENT:  CREATE TABLE inh_test () INHERITS (part_2);
2023-08-01 17:01:41.307 +07 client backend[296625] pg_regress/alter_table ERROR:  cannot inherit from a partition
2023-08-01 17:01:41.307 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE inh_test INHERIT part_2;
2023-08-01 17:01:41.307 +07 client backend[296625] pg_regress/alter_table ERROR:  cannot change inheritance of a partition
2023-08-01 17:01:41.307 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE part_2 INHERIT inh_test;
2023-08-01 17:01:41.307 +07 client backend[296625] pg_regress/alter_table ERROR:  cannot drop column "b" because it is part of the partition key of relation "part_5"
2023-08-01 17:01:41.307 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE list_parted2 DROP COLUMN b;
2023-08-01 17:01:41.307 +07 client backend[296625] pg_regress/alter_table ERROR:  cannot alter column "b" because it is part of the partition key of relation "part_5"
2023-08-01 17:01:41.307 +07 client backend[296625] pg_regress/alter_table STATEMENT:  ALTER TABLE list_parted2 ALTER COLUMN b TYPE text;
2023-08-01 17:01:41.317 +07 client backend[296625] pg_regress/alter_table ERROR:  partition constraint of relation "p11" is violated by some row
2023-08-01 17:01:41.317 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table p attach partition p1 for values from (1, 2) to (1, 10);
2023-08-01 17:01:41.324 +07 client backend[296625] pg_regress/alter_table ERROR:  partition constraint of relation "defpart_attach_test_d" is violated by some row
2023-08-01 17:01:41.324 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table defpart_attach_test attach partition defpart_attach_test_d default;
2023-08-01 17:01:41.326 +07 client backend[296625] pg_regress/alter_table ERROR:  updated partition constraint for default partition "defpart_attach_test_d" would be violated by some row
2023-08-01 17:01:41.326 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table defpart_attach_test attach partition defpart_attach_test_2 for values in (2);
2023-08-01 17:01:41.329 +07 client backend[296625] pg_regress/alter_table ERROR:  cannot attach a permanent relation as partition of temporary relation "temp_part_parent"
2023-08-01 17:01:41.329 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table temp_part_parent attach partition perm_part_child default;
2023-08-01 17:01:41.329 +07 client backend[296625] pg_regress/alter_table ERROR:  cannot attach a temporary relation as partition of permanent relation "perm_part_parent"
2023-08-01 17:01:41.329 +07 client backend[296625] pg_regress/alter_table STATEMENT:  alter table perm_part_parent attach partition temp_part_child default;
2023-08-01 17:01:41.331 +07 client backend[296625] pg_regress/alter_table ERROR:  cannot ALTER TABLE "tab_part_attach" because it is being used by active queries in this session
2023-08-01 17:01:41.331 +07 client backend[296625] pg_regress/alter_table CONTEXT:  SQL statement "alter table tab_part_attach attach partition tab_part_attach_1 for values in (1)"
	PL/pgSQL function func_part_attach() line 4 at EXECUTE
2023-08-01 17:01:41.331 +07 client backend[296625] pg_regress/alter_table STATEMENT:  insert into tab_part_attach values (1);
2023-08-01 17:01:41.368 +07 client backend[296679] pg_regress/reloptions ERROR:  value 2 out of bounds for option "fillfactor"
2023-08-01 17:01:41.368 +07 client backend[296679] pg_regress/reloptions DETAIL:  Valid values are between "10" and "100".
2023-08-01 17:01:41.368 +07 client backend[296679] pg_regress/reloptions STATEMENT:  CREATE TABLE reloptions_test2(i INT) WITH (fillfactor=2);
2023-08-01 17:01:41.368 +07 client backend[296679] pg_regress/reloptions ERROR:  value 110 out of bounds for option "fillfactor"
2023-08-01 17:01:41.368 +07 client backend[296679] pg_regress/reloptions DETAIL:  Valid values are between "10" and "100".
2023-08-01 17:01:41.368 +07 client backend[296679] pg_regress/reloptions STATEMENT:  CREATE TABLE reloptions_test2(i INT) WITH (fillfactor=110);
2023-08-01 17:01:41.368 +07 client backend[296679] pg_regress/reloptions ERROR:  value -10.0 out of bounds for option "autovacuum_analyze_scale_factor"
2023-08-01 17:01:41.368 +07 client backend[296679] pg_regress/reloptions DETAIL:  Valid values are between "0.000000" and "100.000000".
2023-08-01 17:01:41.368 +07 client backend[296679] pg_regress/reloptions STATEMENT:  CREATE TABLE reloptions_test2(i INT) WITH (autovacuum_analyze_scale_factor = -10.0);
2023-08-01 17:01:41.368 +07 client backend[296679] pg_regress/reloptions ERROR:  value 110.0 out of bounds for option "autovacuum_analyze_scale_factor"
2023-08-01 17:01:41.368 +07 client backend[296679] pg_regress/reloptions DETAIL:  Valid values are between "0.000000" and "100.000000".
2023-08-01 17:01:41.368 +07 client backend[296679] pg_regress/reloptions STATEMENT:  CREATE TABLE reloptions_test2(i INT) WITH (autovacuum_analyze_scale_factor = 110.0);
2023-08-01 17:01:41.368 +07 client backend[296679] pg_regress/reloptions ERROR:  unrecognized parameter "not_existing_option"
2023-08-01 17:01:41.368 +07 client backend[296679] pg_regress/reloptions STATEMENT:  CREATE TABLE reloptions_test2(i INT) WITH (not_existing_option=2);
2023-08-01 17:01:41.368 +07 client backend[296679] pg_regress/reloptions ERROR:  unrecognized parameter namespace "not_existing_namespace"
2023-08-01 17:01:41.368 +07 client backend[296679] pg_regress/reloptions STATEMENT:  CREATE TABLE reloptions_test2(i INT) WITH (not_existing_namespace.fillfactor=2);
2023-08-01 17:01:41.368 +07 client backend[296679] pg_regress/reloptions ERROR:  value -30.1 out of bounds for option "fillfactor"
2023-08-01 17:01:41.368 +07 client backend[296679] pg_regress/reloptions DETAIL:  Valid values are between "10" and "100".
2023-08-01 17:01:41.368 +07 client backend[296679] pg_regress/reloptions STATEMENT:  CREATE TABLE reloptions_test2(i INT) WITH (fillfactor=-30.1);
2023-08-01 17:01:41.369 +07 client backend[296679] pg_regress/reloptions ERROR:  invalid value for integer option "fillfactor": string
2023-08-01 17:01:41.369 +07 client backend[296679] pg_regress/reloptions STATEMENT:  CREATE TABLE reloptions_test2(i INT) WITH (fillfactor='string');
2023-08-01 17:01:41.369 +07 client backend[296679] pg_regress/reloptions ERROR:  invalid value for integer option "fillfactor": true
2023-08-01 17:01:41.369 +07 client backend[296679] pg_regress/reloptions STATEMENT:  CREATE TABLE reloptions_test2(i INT) WITH (fillfactor=true);
2023-08-01 17:01:41.369 +07 client backend[296679] pg_regress/reloptions ERROR:  invalid value for boolean option "autovacuum_enabled": 12
2023-08-01 17:01:41.369 +07 client backend[296679] pg_regress/reloptions STATEMENT:  CREATE TABLE reloptions_test2(i INT) WITH (autovacuum_enabled=12);
2023-08-01 17:01:41.369 +07 client backend[296679] pg_regress/reloptions ERROR:  invalid value for boolean option "autovacuum_enabled": 30.5
2023-08-01 17:01:41.369 +07 client backend[296679] pg_regress/reloptions STATEMENT:  CREATE TABLE reloptions_test2(i INT) WITH (autovacuum_enabled=30.5);
2023-08-01 17:01:41.369 +07 client backend[296679] pg_regress/reloptions ERROR:  invalid value for boolean option "autovacuum_enabled": string
2023-08-01 17:01:41.369 +07 client backend[296679] pg_regress/reloptions STATEMENT:  CREATE TABLE reloptions_test2(i INT) WITH (autovacuum_enabled='string');
2023-08-01 17:01:41.369 +07 client backend[296679] pg_regress/reloptions ERROR:  invalid value for floating point option "autovacuum_analyze_scale_factor": string
2023-08-01 17:01:41.369 +07 client backend[296679] pg_regress/reloptions STATEMENT:  CREATE TABLE reloptions_test2(i INT) WITH (autovacuum_analyze_scale_factor='string');
2023-08-01 17:01:41.369 +07 client backend[296679] pg_regress/reloptions ERROR:  invalid value for floating point option "autovacuum_analyze_scale_factor": true
2023-08-01 17:01:41.369 +07 client backend[296679] pg_regress/reloptions STATEMENT:  CREATE TABLE reloptions_test2(i INT) WITH (autovacuum_analyze_scale_factor=true);
2023-08-01 17:01:41.369 +07 client backend[296679] pg_regress/reloptions ERROR:  parameter "fillfactor" specified more than once
2023-08-01 17:01:41.369 +07 client backend[296679] pg_regress/reloptions STATEMENT:  CREATE TABLE reloptions_test2(i INT) WITH (fillfactor=30, fillfactor=40);
2023-08-01 17:01:41.369 +07 client backend[296679] pg_regress/reloptions ERROR:  invalid value for integer option "fillfactor": true
2023-08-01 17:01:41.369 +07 client backend[296679] pg_regress/reloptions STATEMENT:  CREATE TABLE reloptions_test2(i INT) WITH (fillfactor);
2023-08-01 17:01:41.371 +07 client backend[296678] pg_regress/hash_part ERROR:  could not open relation with OID 0
2023-08-01 17:01:41.371 +07 client backend[296678] pg_regress/hash_part STATEMENT:  SELECT satisfies_hash_partition(0, 4, 0, NULL);
2023-08-01 17:01:41.371 +07 client backend[296679] pg_regress/reloptions ERROR:  RESET must not include values for parameters
2023-08-01 17:01:41.371 +07 client backend[296679] pg_regress/reloptions STATEMENT:  ALTER TABLE reloptions_test RESET (fillfactor=12);
2023-08-01 17:01:41.371 +07 client backend[296678] pg_regress/hash_part ERROR:  "tenk1" is not a hash partitioned table
2023-08-01 17:01:41.371 +07 client backend[296678] pg_regress/hash_part STATEMENT:  SELECT satisfies_hash_partition('tenk1'::regclass, 4, 0, NULL);
2023-08-01 17:01:41.371 +07 client backend[296678] pg_regress/hash_part ERROR:  "mchash1" is not a hash partitioned table
2023-08-01 17:01:41.371 +07 client backend[296678] pg_regress/hash_part STATEMENT:  SELECT satisfies_hash_partition('mchash1'::regclass, 4, 0, NULL);
2023-08-01 17:01:41.371 +07 client backend[296678] pg_regress/hash_part ERROR:  modulus for hash partition must be a positive integer
2023-08-01 17:01:41.371 +07 client backend[296678] pg_regress/hash_part STATEMENT:  SELECT satisfies_hash_partition('mchash'::regclass, 0, 0, NULL);
2023-08-01 17:01:41.371 +07 client backend[296678] pg_regress/hash_part ERROR:  remainder for hash partition must be a non-negative integer
2023-08-01 17:01:41.371 +07 client backend[296678] pg_regress/hash_part STATEMENT:  SELECT satisfies_hash_partition('mchash'::regclass, 1, -1, NULL);
2023-08-01 17:01:41.371 +07 client backend[296678] pg_regress/hash_part ERROR:  remainder for hash partition must be less than modulus
2023-08-01 17:01:41.371 +07 client backend[296678] pg_regress/hash_part STATEMENT:  SELECT satisfies_hash_partition('mchash'::regclass, 1, 1, NULL);
2023-08-01 17:01:41.371 +07 client backend[296678] pg_regress/hash_part ERROR:  number of partitioning columns (2) does not match number of partition keys provided (3)
2023-08-01 17:01:41.371 +07 client backend[296678] pg_regress/hash_part STATEMENT:  SELECT satisfies_hash_partition('mchash'::regclass, 4, 0, NULL::int, NULL::text, NULL::json);
2023-08-01 17:01:41.372 +07 client backend[296678] pg_regress/hash_part ERROR:  number of partitioning columns (2) does not match number of partition keys provided (1)
2023-08-01 17:01:41.372 +07 client backend[296678] pg_regress/hash_part STATEMENT:  SELECT satisfies_hash_partition('mchash'::regclass, 3, 1, NULL::int);
2023-08-01 17:01:41.372 +07 client backend[296678] pg_regress/hash_part ERROR:  column 2 of the partition key has type "text", but supplied value is of type "integer"
2023-08-01 17:01:41.372 +07 client backend[296678] pg_regress/hash_part STATEMENT:  SELECT satisfies_hash_partition('mchash'::regclass, 2, 1, NULL::int, NULL::int);
2023-08-01 17:01:41.372 +07 client backend[296678] pg_regress/hash_part ERROR:  column 2 of the partition key has type "text", but supplied value is of type "integer"
2023-08-01 17:01:41.372 +07 client backend[296678] pg_regress/hash_part STATEMENT:  SELECT satisfies_hash_partition('mchash'::regclass, 2, 1,
									variadic array[1,2]::int[]);
2023-08-01 17:01:41.373 +07 client backend[296678] pg_regress/hash_part ERROR:  number of partitioning columns (2) does not match number of partition keys provided (0)
2023-08-01 17:01:41.373 +07 client backend[296678] pg_regress/hash_part STATEMENT:  SELECT satisfies_hash_partition('mcinthash'::regclass, 4, 0,
									variadic array[]::int[]);
2023-08-01 17:01:41.373 +07 client backend[296678] pg_regress/hash_part ERROR:  column 1 of the partition key has type "integer", but supplied value is of type "timestamp with time zone"
2023-08-01 17:01:41.373 +07 client backend[296678] pg_regress/hash_part STATEMENT:  SELECT satisfies_hash_partition('mcinthash'::regclass, 4, 0,
									variadic array[now(), now()]);
2023-08-01 17:01:41.376 +07 client backend[296679] pg_regress/reloptions ERROR:  null value in column "i" of relation "reloptions_test" violates not-null constraint
2023-08-01 17:01:41.376 +07 client backend[296679] pg_regress/reloptions DETAIL:  Failing row contains (null, null).
2023-08-01 17:01:41.376 +07 client backend[296679] pg_regress/reloptions STATEMENT:  INSERT INTO reloptions_test VALUES (1, NULL), (NULL, NULL);
2023-08-01 17:01:41.384 +07 client backend[296679] pg_regress/reloptions ERROR:  null value in column "i" of relation "reloptions_test" violates not-null constraint
2023-08-01 17:01:41.384 +07 client backend[296679] pg_regress/reloptions DETAIL:  Failing row contains (null, null).
2023-08-01 17:01:41.384 +07 client backend[296679] pg_regress/reloptions STATEMENT:  INSERT INTO reloptions_test VALUES (1, NULL), (NULL, NULL);
2023-08-01 17:01:41.385 +07 client backend[296684] pg_regress/indexing ERROR:  cannot create index on partitioned table "idxpart" concurrently
2023-08-01 17:01:41.385 +07 client backend[296684] pg_regress/indexing STATEMENT:  create index concurrently on idxpart (a);
2023-08-01 17:01:41.391 +07 client backend[296682] pg_regress/explain LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp296682.0", size 1916928
2023-08-01 17:01:41.391 +07 client backend[296682] pg_regress/explain CONTEXT:  PL/pgSQL function explain_filter_to_json(text) line 6 at FOR over EXECUTE statement
2023-08-01 17:01:41.391 +07 client backend[296682] pg_regress/explain STATEMENT:  select jsonb_pretty(
	  explain_filter_to_json('explain (analyze, verbose, buffers, format json)
	                         select * from tenk1 order by tenthous')
	  
	  #- '{0,Plan,Plans,0,Plans,0,Workers}'
	  
	  #- '{0,Plan,Plans,0,Workers}'
	  
	  #- '{0,Plan,Plans,0,Sort Method}'
	  #- '{0,Plan,Plans,0,Sort Space Type}'
	);
2023-08-01 17:01:41.397 +07 client backend[296679] pg_regress/reloptions ERROR:  unrecognized parameter "not_existing_option"
2023-08-01 17:01:41.397 +07 client backend[296679] pg_regress/reloptions STATEMENT:  CREATE TABLE reloptions_test2 (i int) WITH (toast.not_existing_option = 42);
2023-08-01 17:01:41.401 +07 client backend[296679] pg_regress/reloptions ERROR:  unrecognized parameter "not_existing_option"
2023-08-01 17:01:41.401 +07 client backend[296679] pg_regress/reloptions STATEMENT:  CREATE INDEX reloptions_test_idx ON reloptions_test (s)
		WITH (not_existing_option=2);
2023-08-01 17:01:41.401 +07 client backend[296679] pg_regress/reloptions ERROR:  unrecognized parameter namespace "not_existing_ns"
2023-08-01 17:01:41.401 +07 client backend[296679] pg_regress/reloptions STATEMENT:  CREATE INDEX reloptions_test_idx ON reloptions_test (s)
		WITH (not_existing_ns.fillfactor=2);
2023-08-01 17:01:41.401 +07 client backend[296679] pg_regress/reloptions ERROR:  value 1 out of bounds for option "fillfactor"
2023-08-01 17:01:41.401 +07 client backend[296679] pg_regress/reloptions DETAIL:  Valid values are between "10" and "100".
2023-08-01 17:01:41.401 +07 client backend[296679] pg_regress/reloptions STATEMENT:  CREATE INDEX reloptions_test_idx2 ON reloptions_test (s) WITH (fillfactor=1);
2023-08-01 17:01:41.401 +07 client backend[296679] pg_regress/reloptions ERROR:  value 130 out of bounds for option "fillfactor"
2023-08-01 17:01:41.401 +07 client backend[296679] pg_regress/reloptions DETAIL:  Valid values are between "10" and "100".
2023-08-01 17:01:41.401 +07 client backend[296679] pg_regress/reloptions STATEMENT:  CREATE INDEX reloptions_test_idx2 ON reloptions_test (s) WITH (fillfactor=130);
2023-08-01 17:01:41.419 +07 client backend[296684] pg_regress/indexing ERROR:  "idxpart_c" is not a partitioned table
2023-08-01 17:01:41.419 +07 client backend[296684] pg_regress/indexing STATEMENT:  alter table idxpart_c attach partition idxpart1_c for values from (10) to (20);
2023-08-01 17:01:41.420 +07 client backend[296684] pg_regress/indexing ERROR:  "idxpart_c" is not a table
2023-08-01 17:01:41.420 +07 client backend[296684] pg_regress/indexing STATEMENT:  alter table idxpart_c detach partition idxpart1_c;
2023-08-01 17:01:41.428 +07 client backend[296684] pg_regress/indexing ERROR:  cannot drop index idxpart1_a_idx because index idxpart_a_idx requires it
2023-08-01 17:01:41.428 +07 client backend[296684] pg_regress/indexing HINT:  You can drop index idxpart_a_idx instead.
2023-08-01 17:01:41.428 +07 client backend[296684] pg_regress/indexing STATEMENT:  drop index idxpart1_a_idx;
2023-08-01 17:01:41.428 +07 client backend[296684] pg_regress/indexing ERROR:  cannot drop partitioned index "idxpart_a_idx" concurrently
2023-08-01 17:01:41.428 +07 client backend[296684] pg_regress/indexing STATEMENT:  drop index concurrently idxpart_a_idx;
2023-08-01 17:01:41.432 +07 client backend[296684] pg_regress/indexing ERROR:  cannot drop index idxpart1_temp_a_idx because index idxpart_temp_a_idx requires it
2023-08-01 17:01:41.432 +07 client backend[296684] pg_regress/indexing HINT:  You can drop index idxpart_temp_a_idx instead.
2023-08-01 17:01:41.432 +07 client backend[296684] pg_regress/indexing STATEMENT:  drop index idxpart1_temp_a_idx;
2023-08-01 17:01:41.436 +07 client backend[296684] pg_regress/indexing ERROR:  "idxpart" is not an index
2023-08-01 17:01:41.436 +07 client backend[296684] pg_regress/indexing STATEMENT:  alter index idxpart attach partition idxpart1;
2023-08-01 17:01:41.436 +07 client backend[296684] pg_regress/indexing ERROR:  "idxpart1" is not an index
2023-08-01 17:01:41.436 +07 client backend[296684] pg_regress/indexing STATEMENT:  alter index idxpart_a_b_idx attach partition idxpart1;
2023-08-01 17:01:41.436 +07 client backend[296684] pg_regress/indexing ERROR:  cannot attach index "idxpart_a_b_idx" as a partition of index "idxpart_a_b_idx"
2023-08-01 17:01:41.436 +07 client backend[296684] pg_regress/indexing DETAIL:  Index "idxpart_a_b_idx" is not an index on any partition of table "idxpart".
2023-08-01 17:01:41.436 +07 client backend[296684] pg_regress/indexing STATEMENT:  alter index idxpart_a_b_idx attach partition idxpart_a_b_idx;
2023-08-01 17:01:41.436 +07 client backend[296684] pg_regress/indexing ERROR:  relation "idxpart1_b_idx" does not exist
2023-08-01 17:01:41.436 +07 client backend[296684] pg_regress/indexing STATEMENT:  alter index idxpart_a_b_idx attach partition idxpart1_b_idx;
2023-08-01 17:01:41.437 +07 client backend[296684] pg_regress/indexing ERROR:  cannot attach index "idxpart1_tst1" as a partition of index "idxpart_a_b_idx"
2023-08-01 17:01:41.437 +07 client backend[296684] pg_regress/indexing DETAIL:  The index definitions do not match.
2023-08-01 17:01:41.437 +07 client backend[296684] pg_regress/indexing STATEMENT:  alter index idxpart_a_b_idx attach partition idxpart1_tst1;
2023-08-01 17:01:41.437 +07 client backend[296684] pg_regress/indexing ERROR:  cannot attach index "idxpart1_tst2" as a partition of index "idxpart_a_b_idx"
2023-08-01 17:01:41.437 +07 client backend[296684] pg_regress/indexing DETAIL:  The index definitions do not match.
2023-08-01 17:01:41.437 +07 client backend[296684] pg_regress/indexing STATEMENT:  alter index idxpart_a_b_idx attach partition idxpart1_tst2;
2023-08-01 17:01:41.437 +07 client backend[296684] pg_regress/indexing ERROR:  cannot attach index "idxpart1_tst3" as a partition of index "idxpart_a_b_idx"
2023-08-01 17:01:41.437 +07 client backend[296684] pg_regress/indexing DETAIL:  The index definitions do not match.
2023-08-01 17:01:41.437 +07 client backend[296684] pg_regress/indexing STATEMENT:  alter index idxpart_a_b_idx attach partition idxpart1_tst3;
2023-08-01 17:01:41.438 +07 client backend[296684] pg_regress/indexing ERROR:  cannot attach index "idxpart1_2_a_b" as a partition of index "idxpart_a_b_idx"
2023-08-01 17:01:41.438 +07 client backend[296684] pg_regress/indexing DETAIL:  Another index is already attached for partition "idxpart1".
2023-08-01 17:01:41.438 +07 client backend[296684] pg_regress/indexing STATEMENT:  alter index idxpart_a_b_idx attach partition idxpart1_2_a_b;
2023-08-01 17:01:41.455 +07 client backend[296677] pg_regress/partition_prune ERROR:  table "part_rev" contains column "c" not found in parent "part"
2023-08-01 17:01:41.455 +07 client backend[296677] pg_regress/partition_prune DETAIL:  The new partition may contain only the columns present in parent.
2023-08-01 17:01:41.455 +07 client backend[296677] pg_regress/partition_prune STATEMENT:  ALTER TABLE part ATTACH PARTITION part_rev FOR VALUES IN (3);
2023-08-01 17:01:41.539 +07 client backend[296684] pg_regress/indexing ERROR:  cannot attach index "idxpart2_a_idx" as a partition of index "idxpart_a_idx"
2023-08-01 17:01:41.539 +07 client backend[296684] pg_regress/indexing DETAIL:  The index definitions do not match.
2023-08-01 17:01:41.539 +07 client backend[296684] pg_regress/indexing STATEMENT:  alter index idxpart_a_idx attach partition idxpart2_a_idx;
2023-08-01 17:01:41.545 +07 client backend[296684] pg_regress/indexing ERROR:  cannot attach index "idxpart1_1b_idx" as a partition of index "idxpart_1_idx"
2023-08-01 17:01:41.545 +07 client backend[296684] pg_regress/indexing DETAIL:  The index definitions do not match.
2023-08-01 17:01:41.545 +07 client backend[296684] pg_regress/indexing STATEMENT:  alter index idxpart_1_idx attach partition idxpart1_1b_idx;
2023-08-01 17:01:41.546 +07 client backend[296684] pg_regress/indexing ERROR:  cannot attach index "idxpart1_2b_idx" as a partition of index "idxpart_2_idx"
2023-08-01 17:01:41.546 +07 client backend[296684] pg_regress/indexing DETAIL:  The index definitions do not match.
2023-08-01 17:01:41.546 +07 client backend[296684] pg_regress/indexing STATEMENT:  alter index idxpart_2_idx attach partition idxpart1_2b_idx;
2023-08-01 17:01:41.546 +07 client backend[296684] pg_regress/indexing ERROR:  cannot attach index "idxpart1_2c_idx" as a partition of index "idxpart_2_idx"
2023-08-01 17:01:41.546 +07 client backend[296684] pg_regress/indexing DETAIL:  The index definitions do not match.
2023-08-01 17:01:41.546 +07 client backend[296684] pg_regress/indexing STATEMENT:  alter index idxpart_2_idx attach partition idxpart1_2c_idx;
2023-08-01 17:01:41.626 +07 client backend[296684] pg_regress/indexing ERROR:  multiple primary keys for table "failpart" are not allowed
2023-08-01 17:01:41.626 +07 client backend[296684] pg_regress/indexing STATEMENT:  create table failpart partition of idxpart (b primary key) for values from (0) to (100);
2023-08-01 17:01:41.634 +07 client backend[296684] pg_regress/indexing ERROR:  unique constraint on partitioned table must include all partitioning columns
2023-08-01 17:01:41.634 +07 client backend[296684] pg_regress/indexing DETAIL:  UNIQUE constraint on table "idxpart" lacks column "b" which is part of the partition key.
2023-08-01 17:01:41.634 +07 client backend[296684] pg_regress/indexing STATEMENT:  create table idxpart (a int unique, b int) partition by range (a, b);
2023-08-01 17:01:41.634 +07 client backend[296684] pg_regress/indexing ERROR:  unique constraint on partitioned table must include all partitioning columns
2023-08-01 17:01:41.634 +07 client backend[296684] pg_regress/indexing DETAIL:  UNIQUE constraint on table "idxpart" lacks column "a" which is part of the partition key.
2023-08-01 17:01:41.634 +07 client backend[296684] pg_regress/indexing STATEMENT:  create table idxpart (a int, b int unique) partition by range (a, b);
2023-08-01 17:01:41.635 +07 client backend[296684] pg_regress/indexing ERROR:  unique constraint on partitioned table must include all partitioning columns
2023-08-01 17:01:41.635 +07 client backend[296684] pg_regress/indexing DETAIL:  PRIMARY KEY constraint on table "idxpart" lacks column "b" which is part of the partition key.
2023-08-01 17:01:41.635 +07 client backend[296684] pg_regress/indexing STATEMENT:  create table idxpart (a int primary key, b int) partition by range (b, a);
2023-08-01 17:01:41.635 +07 client backend[296684] pg_regress/indexing ERROR:  unique constraint on partitioned table must include all partitioning columns
2023-08-01 17:01:41.635 +07 client backend[296684] pg_regress/indexing DETAIL:  PRIMARY KEY constraint on table "idxpart" lacks column "a" which is part of the partition key.
2023-08-01 17:01:41.635 +07 client backend[296684] pg_regress/indexing STATEMENT:  create table idxpart (a int, b int primary key) partition by range (b, a);
2023-08-01 17:01:41.637 +07 client backend[296684] pg_regress/indexing ERROR:  exclusion constraints are not supported on partitioned tables at character 30
2023-08-01 17:01:41.637 +07 client backend[296684] pg_regress/indexing STATEMENT:  create table idxpart (a int, exclude (a with = )) partition by range (a);
2023-08-01 17:01:41.637 +07 client backend[296684] pg_regress/indexing ERROR:  unsupported PRIMARY KEY constraint with partition key definition
2023-08-01 17:01:41.637 +07 client backend[296684] pg_regress/indexing DETAIL:  PRIMARY KEY constraints cannot be used when partition keys include expressions.
2023-08-01 17:01:41.637 +07 client backend[296684] pg_regress/indexing STATEMENT:  create table idxpart (a int primary key, b int) partition by range ((b + a));
2023-08-01 17:01:41.638 +07 client backend[296684] pg_regress/indexing ERROR:  unsupported UNIQUE constraint with partition key definition
2023-08-01 17:01:41.638 +07 client backend[296684] pg_regress/indexing DETAIL:  UNIQUE constraints cannot be used when partition keys include expressions.
2023-08-01 17:01:41.638 +07 client backend[296684] pg_regress/indexing STATEMENT:  create table idxpart (a int unique, b int) partition by range ((b + a));
2023-08-01 17:01:41.639 +07 client backend[296684] pg_regress/indexing ERROR:  unique constraint on partitioned table must include all partitioning columns
2023-08-01 17:01:41.639 +07 client backend[296684] pg_regress/indexing DETAIL:  PRIMARY KEY constraint on table "idxpart" lacks column "b" which is part of the partition key.
2023-08-01 17:01:41.639 +07 client backend[296684] pg_regress/indexing STATEMENT:  alter table idxpart add primary key (a);
2023-08-01 17:01:41.650 +07 client backend[296684] pg_regress/indexing ERROR:  unique constraint on partitioned table must include all partitioning columns
2023-08-01 17:01:41.650 +07 client backend[296684] pg_regress/indexing DETAIL:  UNIQUE constraint on table "idxpart" lacks column "b" which is part of the partition key.
2023-08-01 17:01:41.650 +07 client backend[296684] pg_regress/indexing STATEMENT:  alter table idxpart add unique (a);
2023-08-01 17:01:41.655 +07 client backend[296684] pg_regress/indexing ERROR:  exclusion constraints are not supported on partitioned tables at character 25
2023-08-01 17:01:41.655 +07 client backend[296684] pg_regress/indexing STATEMENT:  alter table idxpart add exclude (a with =);
2023-08-01 17:01:41.666 +07 client backend[296684] pg_regress/indexing ERROR:  unique constraint on partitioned table must include all partitioning columns
2023-08-01 17:01:41.666 +07 client backend[296684] pg_regress/indexing DETAIL:  PRIMARY KEY constraint on table "idxpart2" lacks column "b" which is part of the partition key.
2023-08-01 17:01:41.666 +07 client backend[296684] pg_regress/indexing STATEMENT:  create table idxpart2 partition of idxpart
	for values from (0) to (1000) partition by range (b);
2023-08-01 17:01:41.668 +07 client backend[296684] pg_regress/indexing ERROR:  unique constraint on partitioned table must include all partitioning columns
2023-08-01 17:01:41.668 +07 client backend[296684] pg_regress/indexing DETAIL:  UNIQUE constraint on table "idxpart1" lacks column "b" which is part of the partition key.
2023-08-01 17:01:41.668 +07 client backend[296684] pg_regress/indexing STATEMENT:  alter table idxpart attach partition idxpart1 for values from (1) to (1000);
2023-08-01 17:01:41.677 +07 client backend[296684] pg_regress/indexing ERROR:  cannot drop index idxpart0_pkey because index idxpart_pkey requires it
2023-08-01 17:01:41.677 +07 client backend[296684] pg_regress/indexing HINT:  You can drop index idxpart_pkey instead.
2023-08-01 17:01:41.677 +07 client backend[296684] pg_regress/indexing STATEMENT:  drop index idxpart0_pkey;
2023-08-01 17:01:41.678 +07 client backend[296684] pg_regress/indexing ERROR:  cannot drop index idxpart1_pkey because index idxpart_pkey requires it
2023-08-01 17:01:41.678 +07 client backend[296684] pg_regress/indexing HINT:  You can drop index idxpart_pkey instead.
2023-08-01 17:01:41.678 +07 client backend[296684] pg_regress/indexing STATEMENT:  drop index idxpart1_pkey;
2023-08-01 17:01:41.678 +07 client backend[296684] pg_regress/indexing ERROR:  cannot drop inherited constraint "idxpart0_pkey" of relation "idxpart0"
2023-08-01 17:01:41.678 +07 client backend[296684] pg_regress/indexing STATEMENT:  alter table idxpart0 drop constraint idxpart0_pkey;
2023-08-01 17:01:41.678 +07 client backend[296684] pg_regress/indexing ERROR:  cannot drop inherited constraint "idxpart1_pkey" of relation "idxpart1"
2023-08-01 17:01:41.678 +07 client backend[296684] pg_regress/indexing STATEMENT:  alter table idxpart1 drop constraint idxpart1_pkey;
2023-08-01 17:01:41.682 +07 client backend[296684] pg_regress/indexing ERROR:  multiple primary keys for table "idxpart1" are not allowed
2023-08-01 17:01:41.682 +07 client backend[296684] pg_regress/indexing STATEMENT:  ALTER TABLE idxpart ATTACH PARTITION idxpart1 FOR VALUES FROM (100) TO (200);
2023-08-01 17:01:41.686 +07 client backend[296684] pg_regress/indexing ERROR:  multiple primary keys for table "idxpart11" are not allowed
2023-08-01 17:01:41.686 +07 client backend[296684] pg_regress/indexing STATEMENT:  alter table idxpart attach partition idxpart1 for values from (0) to (10000);
2023-08-01 17:01:41.694 +07 client backend[296684] pg_regress/indexing ERROR:  constraint must be added to child tables too
2023-08-01 17:01:41.694 +07 client backend[296684] pg_regress/indexing DETAIL:  Column "a" of relation "idxpart0" is not already NOT NULL.
2023-08-01 17:01:41.694 +07 client backend[296684] pg_regress/indexing HINT:  Do not specify the ONLY keyword.
2023-08-01 17:01:41.694 +07 client backend[296684] pg_regress/indexing STATEMENT:  alter table only idxpart add primary key (a);
2023-08-01 17:01:41.694 +07 client backend[296684] pg_regress/indexing ERROR:  column "a" is marked NOT NULL in parent table
2023-08-01 17:01:41.694 +07 client backend[296684] pg_regress/indexing STATEMENT:  alter table idxpart0 alter column a drop not null;
2023-08-01 17:01:41.705 +07 client backend[296684] pg_regress/indexing ERROR:  cannot attach index "idxpart1_a_idx" as a partition of index "idxpart_pkey"
2023-08-01 17:01:41.705 +07 client backend[296684] pg_regress/indexing DETAIL:  The index "idxpart_pkey" belongs to a constraint in table "idxpart" but no constraint exists for index "idxpart1_a_idx".
2023-08-01 17:01:41.705 +07 client backend[296684] pg_regress/indexing STATEMENT:  alter index idxpart_pkey attach partition idxpart1_a_idx;
2023-08-01 17:01:41.710 +07 client backend[296684] pg_regress/indexing ERROR:  duplicate key value violates unique constraint "idxpart1_a_idx"
2023-08-01 17:01:41.710 +07 client backend[296684] pg_regress/indexing DETAIL:  Key (a)=(65536) already exists.
2023-08-01 17:01:41.710 +07 client backend[296684] pg_regress/indexing STATEMENT:  insert into idxpart select 2^g, format('two to power of %s', g) from generate_series(15, 17) g;
2023-08-01 17:01:41.711 +07 client backend[296684] pg_regress/indexing ERROR:  duplicate key value violates unique constraint "idxpart2_a_idx"
2023-08-01 17:01:41.711 +07 client backend[296684] pg_regress/indexing DETAIL:  Key (a)=(285714) already exists.
2023-08-01 17:01:41.711 +07 client backend[296684] pg_regress/indexing STATEMENT:  insert into idxpart select a * 2, b || b from idxpart where a between 2^16 and 2^19;
2023-08-01 17:01:41.712 +07 client backend[296684] pg_regress/indexing ERROR:  duplicate key value violates unique constraint "idxpart2_a_idx"
2023-08-01 17:01:41.712 +07 client backend[296684] pg_regress/indexing DETAIL:  Key (a)=(572814) already exists.
2023-08-01 17:01:41.712 +07 client backend[296684] pg_regress/indexing STATEMENT:  insert into idxpart values (572814, 'five');
2023-08-01 17:01:41.730 +07 client backend[296684] pg_regress/indexing ERROR:  duplicate key value violates unique constraint "covidxpart1_a_b_idx"
2023-08-01 17:01:41.730 +07 client backend[296684] pg_regress/indexing DETAIL:  Key (a)=(1) already exists.
2023-08-01 17:01:41.730 +07 client backend[296684] pg_regress/indexing STATEMENT:  insert into covidxpart values (1, 1);
2023-08-01 17:01:41.732 +07 client backend[296684] pg_regress/indexing ERROR:  duplicate key value violates unique constraint "covidxpart3_a_b_idx"
2023-08-01 17:01:41.732 +07 client backend[296684] pg_regress/indexing DETAIL:  Key (a)=(3) already exists.
2023-08-01 17:01:41.732 +07 client backend[296684] pg_regress/indexing STATEMENT:  insert into covidxpart values (3, 1);
2023-08-01 17:01:41.733 +07 client backend[296684] pg_regress/indexing ERROR:  duplicate key value violates unique constraint "covidxpart4_a_b_idx"
2023-08-01 17:01:41.733 +07 client backend[296684] pg_regress/indexing DETAIL:  Key (a)=(4) already exists.
2023-08-01 17:01:41.733 +07 client backend[296684] pg_regress/indexing STATEMENT:  insert into covidxpart values (4, 1);
2023-08-01 17:01:41.733 +07 client backend[296684] pg_regress/indexing ERROR:  unique constraint on partitioned table must include all partitioning columns
2023-08-01 17:01:41.733 +07 client backend[296684] pg_regress/indexing DETAIL:  UNIQUE constraint on table "covidxpart" lacks column "a" which is part of the partition key.
2023-08-01 17:01:41.733 +07 client backend[296684] pg_regress/indexing STATEMENT:  create unique index on covidxpart (b) include (a);
2023-08-01 17:01:41.735 +07 client backend[296684] pg_regress/indexing ERROR:  cannot drop inherited constraint "parted_pk_detach_test1_pkey" of relation "parted_pk_detach_test1"
2023-08-01 17:01:41.735 +07 client backend[296684] pg_regress/indexing STATEMENT:  alter table parted_pk_detach_test1 drop constraint parted_pk_detach_test1_pkey;
2023-08-01 17:01:41.737 +07 client backend[296684] pg_regress/indexing ERROR:  cannot drop inherited constraint "parted_uniq_detach_test1_a_key" of relation "parted_uniq_detach_test1"
2023-08-01 17:01:41.737 +07 client backend[296684] pg_regress/indexing STATEMENT:  alter table parted_uniq_detach_test1 drop constraint parted_uniq_detach_test1_a_key;
2023-08-01 17:01:41.826 +07 client backend[296683] pg_regress/tuplesort LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp296683.0", size 630784
2023-08-01 17:01:41.826 +07 client backend[296683] pg_regress/tuplesort STATEMENT:  COMMIT;
2023-08-01 17:01:41.941 +07 client backend[296683] pg_regress/tuplesort LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp296683.6", size 270336
2023-08-01 17:01:41.941 +07 client backend[296683] pg_regress/tuplesort STATEMENT:  SELECT
	    (array_agg(id ORDER BY id DESC NULLS FIRST))[0:5],
	    (array_agg(abort_increasing ORDER BY abort_increasing DESC NULLS LAST))[0:5],
	    (array_agg(id::text ORDER BY id::text DESC NULLS LAST))[0:5],
	    percentile_disc(0.99) WITHIN GROUP (ORDER BY id),
	    percentile_disc(0.01) WITHIN GROUP (ORDER BY id),
	    percentile_disc(0.8) WITHIN GROUP (ORDER BY abort_increasing),
	    percentile_disc(0.2) WITHIN GROUP (ORDER BY id::text),
	    rank('00000000-0000-0000-0000-000000000000', '2', '2') WITHIN GROUP (ORDER BY noabort_increasing, id, id::text)
	FROM (
	    SELECT * FROM abbrev_abort_uuids
	    UNION ALL
	    SELECT NULL, NULL, NULL, NULL, NULL) s;
2023-08-01 17:01:41.946 +07 client backend[296683] pg_regress/tuplesort LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp296683.2", size 425984
2023-08-01 17:01:41.946 +07 client backend[296683] pg_regress/tuplesort STATEMENT:  SELECT
	    (array_agg(id ORDER BY id DESC NULLS FIRST))[0:5],
	    (array_agg(abort_increasing ORDER BY abort_increasing DESC NULLS LAST))[0:5],
	    (array_agg(id::text ORDER BY id::text DESC NULLS LAST))[0:5],
	    percentile_disc(0.99) WITHIN GROUP (ORDER BY id),
	    percentile_disc(0.01) WITHIN GROUP (ORDER BY id),
	    percentile_disc(0.8) WITHIN GROUP (ORDER BY abort_increasing),
	    percentile_disc(0.2) WITHIN GROUP (ORDER BY id::text),
	    rank('00000000-0000-0000-0000-000000000000', '2', '2') WITHIN GROUP (ORDER BY noabort_increasing, id, id::text)
	FROM (
	    SELECT * FROM abbrev_abort_uuids
	    UNION ALL
	    SELECT NULL, NULL, NULL, NULL, NULL) s;
2023-08-01 17:01:41.963 +07 client backend[296683] pg_regress/tuplesort LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp296683.4", size 278528
2023-08-01 17:01:41.963 +07 client backend[296683] pg_regress/tuplesort STATEMENT:  SELECT
	    (array_agg(id ORDER BY id DESC NULLS FIRST))[0:5],
	    (array_agg(abort_increasing ORDER BY abort_increasing DESC NULLS LAST))[0:5],
	    (array_agg(id::text ORDER BY id::text DESC NULLS LAST))[0:5],
	    percentile_disc(0.99) WITHIN GROUP (ORDER BY id),
	    percentile_disc(0.01) WITHIN GROUP (ORDER BY id),
	    percentile_disc(0.8) WITHIN GROUP (ORDER BY abort_increasing),
	    percentile_disc(0.2) WITHIN GROUP (ORDER BY id::text),
	    rank('00000000-0000-0000-0000-000000000000', '2', '2') WITHIN GROUP (ORDER BY noabort_increasing, id, id::text)
	FROM (
	    SELECT * FROM abbrev_abort_uuids
	    UNION ALL
	    SELECT NULL, NULL, NULL, NULL, NULL) s;
2023-08-01 17:01:41.984 +07 client backend[296683] pg_regress/tuplesort LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp296683.1", size 860160
2023-08-01 17:01:41.984 +07 client backend[296683] pg_regress/tuplesort STATEMENT:  SELECT
	    (array_agg(id ORDER BY id DESC NULLS FIRST))[0:5],
	    (array_agg(abort_increasing ORDER BY abort_increasing DESC NULLS LAST))[0:5],
	    (array_agg(id::text ORDER BY id::text DESC NULLS LAST))[0:5],
	    percentile_disc(0.99) WITHIN GROUP (ORDER BY id),
	    percentile_disc(0.01) WITHIN GROUP (ORDER BY id),
	    percentile_disc(0.8) WITHIN GROUP (ORDER BY abort_increasing),
	    percentile_disc(0.2) WITHIN GROUP (ORDER BY id::text),
	    rank('00000000-0000-0000-0000-000000000000', '2', '2') WITHIN GROUP (ORDER BY noabort_increasing, id, id::text)
	FROM (
	    SELECT * FROM abbrev_abort_uuids
	    UNION ALL
	    SELECT NULL, NULL, NULL, NULL, NULL) s;
2023-08-01 17:01:41.984 +07 client backend[296683] pg_regress/tuplesort LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp296683.5", size 278528
2023-08-01 17:01:41.984 +07 client backend[296683] pg_regress/tuplesort STATEMENT:  SELECT
	    (array_agg(id ORDER BY id DESC NULLS FIRST))[0:5],
	    (array_agg(abort_increasing ORDER BY abort_increasing DESC NULLS LAST))[0:5],
	    (array_agg(id::text ORDER BY id::text DESC NULLS LAST))[0:5],
	    percentile_disc(0.99) WITHIN GROUP (ORDER BY id),
	    percentile_disc(0.01) WITHIN GROUP (ORDER BY id),
	    percentile_disc(0.8) WITHIN GROUP (ORDER BY abort_increasing),
	    percentile_disc(0.2) WITHIN GROUP (ORDER BY id::text),
	    rank('00000000-0000-0000-0000-000000000000', '2', '2') WITHIN GROUP (ORDER BY noabort_increasing, id, id::text)
	FROM (
	    SELECT * FROM abbrev_abort_uuids
	    UNION ALL
	    SELECT NULL, NULL, NULL, NULL, NULL) s;
2023-08-01 17:01:41.984 +07 client backend[296683] pg_regress/tuplesort LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp296683.3", size 425984
2023-08-01 17:01:41.984 +07 client backend[296683] pg_regress/tuplesort STATEMENT:  SELECT
	    (array_agg(id ORDER BY id DESC NULLS FIRST))[0:5],
	    (array_agg(abort_increasing ORDER BY abort_increasing DESC NULLS LAST))[0:5],
	    (array_agg(id::text ORDER BY id::text DESC NULLS LAST))[0:5],
	    percentile_disc(0.99) WITHIN GROUP (ORDER BY id),
	    percentile_disc(0.01) WITHIN GROUP (ORDER BY id),
	    percentile_disc(0.8) WITHIN GROUP (ORDER BY abort_increasing),
	    percentile_disc(0.2) WITHIN GROUP (ORDER BY id::text),
	    rank('00000000-0000-0000-0000-000000000000', '2', '2') WITHIN GROUP (ORDER BY noabort_increasing, id, id::text)
	FROM (
	    SELECT * FROM abbrev_abort_uuids
	    UNION ALL
	    SELECT NULL, NULL, NULL, NULL, NULL) s;
2023-08-01 17:01:41.984 +07 client backend[296683] pg_regress/tuplesort LOG:  temporary file: path "base/pgsql_tmp/pgsql_tmp296683.7", size 344064
2023-08-01 17:01:41.984 +07 client backend[296683] pg_regress/tuplesort STATEMENT:  SELECT
	    (array_agg(id ORDER BY id DESC NULLS FIRST))[0:5],
	    (array_agg(abort_increasing ORDER BY abort_increasing DESC NULLS LAST))[0:5],
	    (array_agg(id::text ORDER BY id::text DESC NULLS LAST))[0:5],
	    percentile_disc(0.99) WITHIN GROUP (ORDER BY id),
	    percentile_disc(0.01) WITHIN GROUP (ORDER BY id),
	    percentile_disc(0.8) WITHIN GROUP (ORDER BY abort_increasing),
	    percentile_disc(0.2) WITHIN GROUP (ORDER BY id::text),
	    rank('00000000-0000-0000-0000-000000000000', '2', '2') WITHIN GROUP (ORDER BY noabort_increasing, id, id::text)
	FROM (
	    SELECT * FROM abbrev_abort_uuids
	    UNION ALL
	    SELECT NULL, NULL, NULL, NULL, NULL) s;
2023-08-01 17:01:42.011 +07 client backend[296752] pg_regress/event_trigger ERROR:  function pg_backend_pid must return type event_trigger
2023-08-01 17:01:42.011 +07 client backend[296752] pg_regress/event_trigger STATEMENT:  create event trigger regress_event_trigger
	   on ddl_command_start
	   execute procedure pg_backend_pid();
2023-08-01 17:01:42.012 +07 client backend[296752] pg_regress/event_trigger ERROR:  trigger functions can only be called as triggers
2023-08-01 17:01:42.012 +07 client backend[296752] pg_regress/event_trigger CONTEXT:  compilation of PL/pgSQL function "test_event_trigger" near line 1
2023-08-01 17:01:42.012 +07 client backend[296752] pg_regress/event_trigger STATEMENT:  SELECT test_event_trigger();
2023-08-01 17:01:42.012 +07 client backend[296752] pg_regress/event_trigger ERROR:  event trigger functions cannot have declared arguments
2023-08-01 17:01:42.012 +07 client backend[296752] pg_regress/event_trigger CONTEXT:  compilation of PL/pgSQL function "test_event_trigger_arg" near line 1
2023-08-01 17:01:42.012 +07 client backend[296752] pg_regress/event_trigger STATEMENT:  create function test_event_trigger_arg(name text)
	returns event_trigger as $$ BEGIN RETURN 1; END $$ language plpgsql;
2023-08-01 17:01:42.012 +07 client backend[296752] pg_regress/event_trigger ERROR:  SQL functions cannot return type event_trigger
2023-08-01 17:01:42.012 +07 client backend[296752] pg_regress/event_trigger STATEMENT:  create function test_event_trigger_sql() returns event_trigger as $$
	SELECT 1 $$ language sql;
2023-08-01 17:01:42.012 +07 client backend[296752] pg_regress/event_trigger ERROR:  unrecognized event name "elephant_bootstrap"
2023-08-01 17:01:42.012 +07 client backend[296752] pg_regress/event_trigger STATEMENT:  create event trigger regress_event_trigger on elephant_bootstrap
	   execute procedure test_event_trigger();
2023-08-01 17:01:42.012 +07 client backend[296752] pg_regress/event_trigger ERROR:  unrecognized filter variable "food"
2023-08-01 17:01:42.012 +07 client backend[296752] pg_regress/event_trigger STATEMENT:  create event trigger regress_event_trigger2 on ddl_command_start
	   when food in ('sandwich')
	   execute procedure test_event_trigger();
2023-08-01 17:01:42.012 +07 client backend[296752] pg_regress/event_trigger ERROR:  filter value "sandwich" not recognized for filter variable "tag"
2023-08-01 17:01:42.012 +07 client backend[296752] pg_regress/event_trigger STATEMENT:  create event trigger regress_event_trigger2 on ddl_command_start
	   when tag in ('sandwich')
	   execute procedure test_event_trigger();
2023-08-01 17:01:42.012 +07 client backend[296752] pg_regress/event_trigger ERROR:  filter value "create skunkcabbage" not recognized for filter variable "tag"
2023-08-01 17:01:42.012 +07 client backend[296752] pg_regress/event_trigger STATEMENT:  create event trigger regress_event_trigger2 on ddl_command_start
	   when tag in ('create table', 'create skunkcabbage')
	   execute procedure test_event_trigger();
2023-08-01 17:01:42.012 +07 client backend[296752] pg_regress/event_trigger ERROR:  event triggers are not supported for DROP EVENT TRIGGER
2023-08-01 17:01:42.012 +07 client backend[296752] pg_regress/event_trigger STATEMENT:  create event trigger regress_event_trigger2 on ddl_command_start
	   when tag in ('DROP EVENT TRIGGER')
	   execute procedure test_event_trigger();
2023-08-01 17:01:42.012 +07 client backend[296752] pg_regress/event_trigger ERROR:  event triggers are not supported for CREATE ROLE
2023-08-01 17:01:42.012 +07 client backend[296752] pg_regress/event_trigger STATEMENT:  create event trigger regress_event_trigger2 on ddl_command_start
	   when tag in ('CREATE ROLE')
	   execute procedure test_event_trigger();
2023-08-01 17:01:42.012 +07 client backend[296752] pg_regress/event_trigger ERROR:  event triggers are not supported for CREATE DATABASE
2023-08-01 17:01:42.012 +07 client backend[296752] pg_regress/event_trigger STATEMENT:  create event trigger regress_event_trigger2 on ddl_command_start
	   when tag in ('CREATE DATABASE')
	   execute procedure test_event_trigger();
2023-08-01 17:01:42.012 +07 client backend[296752] pg_regress/event_trigger ERROR:  event triggers are not supported for CREATE TABLESPACE
2023-08-01 17:01:42.012 +07 client backend[296752] pg_regress/event_trigger STATEMENT:  create event trigger regress_event_trigger2 on ddl_command_start
	   when tag in ('CREATE TABLESPACE')
	   execute procedure test_event_trigger();
2023-08-01 17:01:42.013 +07 client backend[296752] pg_regress/event_trigger ERROR:  filter variable "tag" specified more than once
2023-08-01 17:01:42.013 +07 client backend[296752] pg_regress/event_trigger STATEMENT:  create event trigger regress_event_trigger2 on ddl_command_start
	   when tag in ('create table') and tag in ('CREATE FUNCTION')
	   execute procedure test_event_trigger();
2023-08-01 17:01:42.013 +07 client backend[296752] pg_regress/event_trigger ERROR:  syntax error at or near "'argument not allowed'" at character 106
2023-08-01 17:01:42.013 +07 client backend[296752] pg_regress/event_trigger STATEMENT:  create event trigger regress_event_trigger2 on ddl_command_start
	   execute procedure test_event_trigger('argument not allowed');
2023-08-01 17:01:42.013 +07 client backend[296752] pg_regress/event_trigger ERROR:  permission denied to create event trigger "regress_event_trigger_noperms"
2023-08-01 17:01:42.013 +07 client backend[296752] pg_regress/event_trigger HINT:  Must be superuser to create an event trigger.
2023-08-01 17:01:42.013 +07 client backend[296752] pg_regress/event_trigger STATEMENT:  create event trigger regress_event_trigger_noperms on ddl_command_start
	   execute procedure test_event_trigger();
2023-08-01 17:01:42.018 +07 client backend[296752] pg_regress/event_trigger ERROR:  permission denied to change owner of event trigger "regress_event_trigger"
2023-08-01 17:01:42.018 +07 client backend[296752] pg_regress/event_trigger HINT:  The owner of an event trigger must be a superuser.
2023-08-01 17:01:42.018 +07 client backend[296752] pg_regress/event_trigger STATEMENT:  alter event trigger regress_event_trigger owner to regress_evt_user;
2023-08-01 17:01:42.019 +07 client backend[296752] pg_regress/event_trigger ERROR:  event trigger "regress_event_trigger2" already exists
2023-08-01 17:01:42.019 +07 client backend[296752] pg_regress/event_trigger STATEMENT:  alter event trigger regress_event_trigger rename to regress_event_trigger2;
2023-08-01 17:01:42.019 +07 client backend[296752] pg_regress/event_trigger ERROR:  event trigger "regress_event_trigger" does not exist
2023-08-01 17:01:42.019 +07 client backend[296752] pg_regress/event_trigger STATEMENT:  drop event trigger regress_event_trigger;
2023-08-01 17:01:42.019 +07 client backend[296752] pg_regress/event_trigger ERROR:  role "regress_evt_user" cannot be dropped because some objects depend on it
2023-08-01 17:01:42.019 +07 client backend[296752] pg_regress/event_trigger DETAIL:  owner of event trigger regress_event_trigger3
	owner of user mapping for regress_evt_user on server useless_server
	owner of default privileges on new relations belonging to role regress_evt_user
2023-08-01 17:01:42.019 +07 client backend[296752] pg_regress/event_trigger STATEMENT:  drop role regress_evt_user;
2023-08-01 17:01:42.028 +07 client backend[296752] pg_regress/event_trigger ERROR:  object audit_tbls.schema_two_table_three of type table cannot be dropped
2023-08-01 17:01:42.028 +07 client backend[296752] pg_regress/event_trigger CONTEXT:  PL/pgSQL function undroppable() line 14 at RAISE
	SQL statement "DROP TABLE IF EXISTS audit_tbls.schema_two_table_three"
	PL/pgSQL function test_evtrig_dropped_objects() line 8 at EXECUTE
2023-08-01 17:01:42.028 +07 client backend[296752] pg_regress/event_trigger STATEMENT:  DROP SCHEMA schema_one, schema_two CASCADE;
2023-08-01 17:01:42.030 +07 client backend[296752] pg_regress/event_trigger ERROR:  object schema_one.table_three of type table cannot be dropped
2023-08-01 17:01:42.030 +07 client backend[296752] pg_regress/event_trigger CONTEXT:  PL/pgSQL function undroppable() line 14 at RAISE
2023-08-01 17:01:42.030 +07 client backend[296752] pg_regress/event_trigger STATEMENT:  DROP SCHEMA schema_one, schema_two CASCADE;
2023-08-01 17:01:42.043 +07 client backend[296752] pg_regress/event_trigger ERROR:  pg_event_trigger_table_rewrite_oid() can only be called in a table_rewrite event trigger function
2023-08-01 17:01:42.043 +07 client backend[296752] pg_regress/event_trigger STATEMENT:  select pg_event_trigger_table_rewrite_oid();
2023-08-01 17:01:42.046 +07 client backend[296752] pg_regress/event_trigger ERROR:  rewrites not allowed
2023-08-01 17:01:42.046 +07 client backend[296752] pg_regress/event_trigger CONTEXT:  PL/pgSQL function test_evtrig_no_rewrite() line 3 at RAISE
2023-08-01 17:01:42.046 +07 client backend[296752] pg_regress/event_trigger STATEMENT:  alter table rewriteme alter column foo type numeric;
2023-08-01 17:01:42.055 +07 client backend[296752] pg_regress/event_trigger ERROR:  cannot alter type "rewritetype" because column "rewritemetoo3.a" uses it
2023-08-01 17:01:42.055 +07 client backend[296752] pg_regress/event_trigger STATEMENT:  alter type rewritetype alter attribute a type varchar cascade;
2023-08-01 17:01:42.675 +07 client backend[296761] pg_regress/stats LOG:  wait_for_stats delayed 0.518232 seconds
2023-08-01 17:01:42.675 +07 client backend[296761] pg_regress/stats CONTEXT:  PL/pgSQL function wait_for_stats() line 48 at RAISE
2023-08-01 17:01:42.675 +07 client backend[296761] pg_regress/stats STATEMENT:  SELECT wait_for_stats();
2023-08-01 17:01:42.691 +07 postmaster[295405] LOG:  received fast shutdown request
2023-08-01 17:01:42.691 +07 postmaster[295405] LOG:  aborting any active transactions
2023-08-01 17:01:42.692 +07 postmaster[295405] LOG:  background worker "logical replication launcher" (PID 295414) exited with exit code 1
2023-08-01 17:01:42.693 +07 checkpointer[295409] LOG:  shutting down
2023-08-01 17:01:42.693 +07 checkpointer[295409] LOG:  checkpoint starting: shutdown immediate
2023-08-01 17:01:42.791 +07 checkpointer[295409] LOG:  checkpoint complete: wrote 11020 buffers (67.3%); 0 WAL file(s) added, 0 removed, 13 recycled; write=0.062 s, sync=0.001 s, total=0.099 s; sync files=0, longest=0.000 s, average=0.000 s; distance=219611 kB, estimate=219611 kB
2023-08-01 17:01:42.806 +07 postmaster[295405] LOG:  database system is shut down
